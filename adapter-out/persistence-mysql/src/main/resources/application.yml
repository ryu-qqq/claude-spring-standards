# ===============================================
# Persistence MySQL Adapter Configuration
# ===============================================
# MySQL + JPA + QueryDSL + HikariCP 설정
# 애플리케이션 런타임 설정은 bootstrap/bootstrap-web-api/application.yml 참조
#
# @author windsurf
# @since 1.0.0
# ===============================================

# ===============================================
# DataSource Configuration (MySQL + HikariCP)
# ===============================================
spring:
  datasource:
    # JDBC URL
    # 로컬: localhost:3306
    # 개발/운영: 환경변수 또는 외부 설정으로 주입
    url: jdbc:mysql://localhost:3306/spring_standards?useSSL=false&serverTimezone=Asia/Seoul&characterEncoding=UTF-8&allowPublicKeyRetrieval=true
    
    # 드라이버 클래스
    driver-class-name: com.mysql.cj.jdbc.Driver
    
    # 인증 정보 (환경변수 또는 외부 설정 권장)
    username: ${DB_USERNAME:root}
    password: ${DB_PASSWORD:password}
    
    # HikariCP 커넥션 풀 설정
    hikari:
      # 풀 이름 (로깅/모니터링용)
      pool-name: SpringStandardsHikariPool
      
      # 커넥션 풀 크기
      # minimum-idle: 최소 유휴 커넥션 수 (기본값: maximum-pool-size와 동일)
      # maximum-pool-size: 최대 커넥션 수 (기본값: 10)
      # 권장: CPU 코어 수 * 2 ~ 4
      minimum-idle: 10
      maximum-pool-size: 20
      
      # 커넥션 타임아웃
      # connection-timeout: 풀에서 커넥션을 얻기 위한 최대 대기 시간 (밀리초)
      connection-timeout: 30000  # 30초
      
      # 커넥션 유휴 타임아웃
      # idle-timeout: 유휴 커넥션이 풀에서 제거되기까지의 시간 (밀리초)
      # minimum-idle보다 많은 커넥션이 있을 때만 적용
      idle-timeout: 600000  # 10분
      
      # 커넥션 최대 수명
      # max-lifetime: 커넥션의 최대 수명 (밀리초)
      # 데이터베이스의 wait_timeout보다 짧게 설정 권장
      max-lifetime: 1800000  # 30분
      
      # 커넥션 검증 쿼리
      # connection-test-query: 커넥션 유효성 검증 쿼리 (JDBC4 드라이버는 불필요)
      # MySQL: SELECT 1
      # PostgreSQL: SELECT 1
      # connection-test-query: SELECT 1
      
      # 커넥션 유효성 검증 타임아웃
      validation-timeout: 5000  # 5초
      
      # Leak Detection (커넥션 누수 감지)
      # leak-detection-threshold: 커넥션이 누수로 간주되는 시간 (밀리초)
      # 0이면 비활성화, 개발 환경에서는 활성화 권장
      leak-detection-threshold: 60000  # 60초
      
      # 커넥션 초기화 SQL
      # connection-init-sql: 커넥션 생성 시 실행할 SQL
      # 예: SET NAMES utf8mb4
      # connection-init-sql: SET NAMES utf8mb4
      
      # Auto Commit
      auto-commit: true
      
      # Read Only (읽기 전용 커넥션 풀 분리 시 사용)
      read-only: false
      
      # 커넥션 풀 JMX 모니터링
      register-mbeans: true
      
      # 데이터 소스 속성 (MySQL 최적화)
      data-source-properties:
        # 캐시 설정
        cachePrepStmts: true
        prepStmtCacheSize: 250
        prepStmtCacheSqlLimit: 2048
        useServerPrepStmts: true
        
        # 성능 최적화
        useLocalSessionState: true
        rewriteBatchedStatements: true
        cacheResultSetMetadata: true
        cacheServerConfiguration: true
        elideSetAutoCommits: true
        maintainTimeStats: false

  # ===============================================
  # JPA Configuration
  # ===============================================
  jpa:
    # 데이터베이스 플랫폼
    database-platform: org.hibernate.dialect.MySQLDialect
    
    # Hibernate 설정
    hibernate:
      # DDL 자동 생성 전략
      # none: 아무것도 하지 않음 (프로덕션)
      # validate: 스키마 검증만 수행
      # update: 스키마 자동 업데이트 (개발 환경)
      # create: 시작 시 스키마 삭제 후 생성 (테스트)
      # create-drop: 종료 시 스키마 삭제 (테스트)
      ddl-auto: validate
      
      # Naming Strategy
      # physical-strategy: 물리적 테이블/컬럼명 전략
      # SpringPhysicalNamingStrategy: camelCase → snake_case 변환
      naming:
        physical-strategy: org.hibernate.boot.model.naming.CamelCaseToUnderscoresNamingStrategy
        implicit-strategy: org.springframework.boot.orm.jpa.hibernate.SpringImplicitNamingStrategy
    
    # JPA 속성
    properties:
      hibernate:
        # SQL 포맷팅 (개발 환경)
        format_sql: true
        use_sql_comments: true
        
        # JDBC 배치 처리
        jdbc:
          batch_size: 50
          fetch_size: 100
        
        # 배치 처리 최적화
        order_inserts: true
        order_updates: true
        batch_versioned_data: true
        
        # 쿼리 플랜 캐시
        query:
          plan_cache_max_size: 2048
          plan_parameter_metadata_max_size: 128
        
        # 2차 캐시 (필요 시 활성화)
        # cache:
        #   use_second_level_cache: true
        #   use_query_cache: true
        #   region:
        #     factory_class: org.hibernate.cache.jcache.JCacheRegionFactory
        
        # 통계 수집 (개발/모니터링)
        generate_statistics: false
        
        # Connection Provider
        connection:
          provider_disables_autocommit: false

    # Entity Scan
    # @Entity 클래스 스캔 경로 (기본: @SpringBootApplication 패키지)
    # 명시적 지정 시 사용
    # scan-packages: com.ryuqq.adapter.out.persistence.example.entity
    
    # Open In View (OSIV)
    # false 권장: 트랜잭션 범위를 명확히 제한
    open-in-view: false
    
    # Show SQL (개발 환경)
    show-sql: false  # Hibernate logging으로 대체

# ===============================================
# Flyway Migration
# ===============================================
flyway:
  # Flyway 활성화
  enabled: true

  # Migration 스크립트 위치
  locations: classpath:db/migration

  # 베이스라인 설정
  # baseline-on-migrate: 기존 DB에 Flyway 적용 시 사용
  baseline-on-migrate: true
  baseline-version: 0

  # 인코딩
  encoding: UTF-8

  # SQL Migration 접두사/접미사
  sql-migration-prefix: V
  sql-migration-separator: __
  sql-migration-suffixes: .sql

  # Placeholder 설정
  # Migration SQL 내 ${...} 변수 치환
  placeholder-replacement: true
  placeholders:
    charset: utf8mb4
    collation: utf8mb4_unicode_ci

  # 검증 설정
  # validate-on-migrate: Migration 실행 전 검증
  validate-on-migrate: true

  # Out of Order 허용 여부 (기본: false)
  # true: 버전 순서와 관계없이 Migration 허용
  out-of-order: false

  # Clean 비활성화 (프로덕션 필수)
  # clean: 모든 객체 삭제 후 재생성 (위험!)
  clean-disabled: true

  # Group 설정 (All or Nothing)
  # true: 모든 pending migration을 단일 트랜잭션으로 실행
  group: false

  # Mixed Migration 허용 (SQL + Java)
  mixed: false

  # Repeatable Migration 허용
  # R__로 시작하는 스크립트 (변경 시 재실행)
  repeatable-sql-migration-prefix: R

  # Schema 설정 (기본: connection의 기본 schema)
  # default-schema: spring_standards

  # Table 설정 (Flyway 이력 관리 테이블)
  table: flyway_schema_history

  # Flyway 팀 에디션 기능 (오픈소스에서는 비활성화)
  # oracle-sqlplus: false
  # license-key: ''
