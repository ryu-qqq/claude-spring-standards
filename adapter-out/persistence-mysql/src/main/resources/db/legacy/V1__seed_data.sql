
/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8mb4 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

LOCK TABLES `tech_stack` WRITE;
/*!40000 ALTER TABLE `tech_stack` DISABLE KEYS */;
INSERT INTO `tech_stack` (`id`, `name`, `status`, `language_type`, `language_version`, `language_features`, `framework_type`, `framework_version`, `framework_modules`, `platform_type`, `runtime_environment`, `build_tool_type`, `build_config_file`, `created_at`, `updated_at`, `deleted_at`) VALUES (1,'java21-springboot35-backend','ACTIVE','JAVA','21','[\"VIRTUAL_THREAD\", \"RECORD\", \"SEALED_CLASS\", \"PATTERN_MATCHING\", \"SEQUENCED_COLLECTION\"]','SPRING_BOOT','3.5.x','[\"WEB\", \"JPA\", \"VALIDATION\", \"SECURITY\", \"ACTUATOR\"]','BACKEND','JVM','GRADLE','build.gradle.kts','2026-01-16 02:24:43','2026-01-16 02:24:43',NULL);
/*!40000 ALTER TABLE `tech_stack` ENABLE KEYS */;
UNLOCK TABLES;

LOCK TABLES `architecture` WRITE;
/*!40000 ALTER TABLE `architecture` DISABLE KEYS */;
INSERT INTO `architecture` (`id`, `tech_stack_id`, `name`, `pattern_type`, `pattern_description`, `pattern_principles`, `created_at`, `updated_at`, `deleted_at`) VALUES (1,1,'hexagonal-multimodule','HEXAGONAL','포트와 어댑터 패턴 기반 멀티모듈 아키텍처. Domain 중심 설계로 외부 의존성을 격리하고, CQRS 패턴을 적용하여 Command/Query를 분리합니다.','[\"DIP\", \"SRP\", \"OCP\", \"ISP\", \"CQRS\", \"DDD\"]','2026-01-16 02:24:44','2026-01-16 02:24:44',NULL);
/*!40000 ALTER TABLE `architecture` ENABLE KEYS */;
UNLOCK TABLES;

LOCK TABLES `module` WRITE;
/*!40000 ALTER TABLE `module` DISABLE KEYS */;
INSERT INTO `module` (`id`, `architecture_id`, `parent_module_id`, `name`, `module_type`, `description`, `gradle_path`, `created_at`, `updated_at`, `deleted_at`) VALUES (1,1,NULL,'domain','DOMAIN','순수 비즈니스 로직을 담당하는 핵심 모듈. 외부 프레임워크 의존성 없이 Plain Java로 구현.',':domain','2026-01-16 02:24:45','2026-01-16 02:24:45',NULL),(2,1,NULL,'application','APPLICATION','UseCase, Port, Service를 정의하는 애플리케이션 계층. Domain을 조합하여 비즈니스 흐름을 제어.',':application','2026-01-16 02:24:45','2026-01-16 02:24:45',NULL),(3,1,NULL,'adapter-in','ADAPTER_IN','외부 요청을 받아들이는 인바운드 어댑터 상위 모듈.',':adapter-in','2026-01-16 02:24:45','2026-01-16 02:24:45',NULL),(4,1,3,'rest-api','ADAPTER_IN','REST API 엔드포인트를 제공하는 인바운드 어댑터. Thin Controller 패턴 적용.',':adapter-in:rest-api','2026-01-16 02:24:45','2026-01-16 02:24:46',NULL),(5,1,NULL,'adapter-out','ADAPTER_OUT','외부 시스템과 통신하는 아웃바운드 어댑터 상위 모듈.',':adapter-out','2026-01-16 02:24:45','2026-01-16 02:24:45',NULL),(6,1,5,'persistence-mysql','ADAPTER_OUT_PERSISTENCE','MySQL 데이터베이스 영속성 어댑터. JPA/QueryDSL 기반 구현.',':adapter-out:persistence-mysql','2026-01-16 02:24:45','2026-01-16 02:24:46',NULL);
/*!40000 ALTER TABLE `module` ENABLE KEYS */;
UNLOCK TABLES;

LOCK TABLES `convention` WRITE;
/*!40000 ALTER TABLE `convention` DISABLE KEYS */;
INSERT INTO `convention` (`id`, `architecture_id`, `layer`, `version`, `description`, `is_active`, `created_at`, `updated_at`, `deleted_at`) VALUES (1,1,'REST_API','1.0.0','REST API Layer 코딩 컨벤션. Thin Controller 패턴, Bean Validation, CQRS 분리, RFC 7807 에러 처리 등 HTTP Adapter 설계 표준을 정의합니다.',1,'2026-01-16 02:24:53','2026-01-16 02:24:53',NULL),(2,1,'SCHEDULER','1.0.0','Thin Scheduler 아키텍처 컨벤션. @Scheduled로 주기적 실행을 트리거하고, Application Layer의 Scheduler UseCase를 호출합니다. 분산락, 배치 처리, 상태 관리 등 모든 비즈니스 로직은 Application Layer에서 처리합니다.',1,'2026-01-16 02:26:21','2026-01-16 02:26:21',NULL),(3,1,'DOMAIN','1.0.0','Domain Layer 코딩 컨벤션. DDD Aggregate/Value Object 설계, 순수 자바 원칙 (Lombok/JPA/Spring 금지), Instant 시간 처리, 2-Tier Exception 시스템, Domain Event 발행 패턴을 정의합니다.',1,'2026-01-16 02:26:32','2026-01-16 02:26:32',NULL),(4,1,'APPLICATION','1.0.0','Application Layer 코딩 컨벤션. CQRS 기반 Command/Query 분리, Port-In(UseCase)/Port-Out(Port) 인터페이스 설계, Manager(@Transactional 경계)/Facade(RDB Manager 조합) 트랜잭션 관리, Factory(입력변환)/Assembler(출력변환) 변환기, EventListener(외부호출전용)+Scheduler(Fallback) 이벤트 처리 패턴을 정의합니다.',1,'2026-01-16 02:27:03','2026-01-16 02:27:03',NULL),(5,1,'PERSISTENCE','1.0.0','Persistence Layer 코딩 컨벤션. CQRS Repository 분리(JpaRepository Command / QueryDslRepository Query), Long FK 전략, Merge 기반 업데이트, persist() Port 통합, @Transactional 금지(Application Layer 책임) 등 영속성 어댑터 설계 표준을 정의합니다.',1,'2026-01-16 06:51:44','2026-01-16 06:51:44',NULL);
/*!40000 ALTER TABLE `convention` ENABLE KEYS */;
UNLOCK TABLES;

LOCK TABLES `package_purpose` WRITE;
/*!40000 ALTER TABLE `package_purpose` DISABLE KEYS */;
INSERT INTO `package_purpose` (`id`, `module_type`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (1,'ADAPTER_IN','CONTROLLER_COMMAND','Command Controller','POST, PUT, PATCH, DELETE 요청을 처리하는 컨트롤러. Thin Controller 패턴 적용.','[\"REST_CONTROLLER\"]','^[A-Z][a-zA-Z]*CommandController$','CommandController','2026-01-16 02:24:47','2026-01-16 02:24:47',NULL),(2,'ADAPTER_IN','CONTROLLER_QUERY','Query Controller','GET 요청을 처리하는 컨트롤러. 조회 전용.','[\"REST_CONTROLLER\"]','^[A-Z][a-zA-Z]*QueryController$','QueryController','2026-01-16 02:24:47','2026-01-16 02:24:47',NULL),(3,'ADAPTER_IN','DTO_COMMAND','Command Request DTO','Create, Update 등 Command 요청의 Request Body DTO. Record 사용 권장.','[\"RECORD\", \"CLASS\"]','^(Create|Update|Delete|Register|Modify)[A-Z][a-zA-Z]*ApiRequest$','ApiRequest','2026-01-16 02:24:47','2026-01-16 02:24:47',NULL),(4,'ADAPTER_IN','DTO_QUERY','Query Request DTO','GET 요청의 Query Parameter DTO. 검색 조건, 페이징 등.','[\"RECORD\", \"CLASS\"]','^(Get|Search|Find|List)[A-Z][a-zA-Z]*ApiRequest$','ApiRequest','2026-01-16 02:24:47','2026-01-16 02:24:47',NULL),(5,'ADAPTER_IN','DTO_RESPONSE','Response DTO','API 응답 DTO. Record 사용 권장.','[\"RECORD\", \"CLASS\"]','^[A-Z][a-zA-Z]*ApiResponse$','ApiResponse','2026-01-16 02:24:47','2026-01-16 02:24:47',NULL),(6,'ADAPTER_IN','ERROR','Error Handler','Bounded Context 전용 예외 핸들러 및 에러 코드.','[\"CLASS\", \"ENUM\"]','^[A-Z][a-zA-Z]*(ErrorCode|ExceptionHandler)$',NULL,'2026-01-16 02:24:47','2026-01-16 02:24:47',NULL),(7,'ADAPTER_IN','MAPPER_COMMAND','Command API Mapper','Request DTO → Application Command 변환 매퍼.','[\"INTERFACE\", \"CLASS\"]','^[A-Z][a-zA-Z]*CommandApiMapper$','CommandApiMapper','2026-01-16 02:24:47','2026-01-16 02:24:47',NULL),(8,'ADAPTER_IN','MAPPER_QUERY','Query API Mapper','Request DTO → Application Query, Domain → Response 변환 매퍼.','[\"INTERFACE\", \"CLASS\"]','^[A-Z][a-zA-Z]*QueryApiMapper$','QueryApiMapper','2026-01-16 02:24:47','2026-01-16 02:24:47',NULL),(9,'ADAPTER_IN','COMMON_CONTROLLER','Common Controller','API 문서 서빙, RFC 7807 전역 예외 핸들러(@RestControllerAdvice) 등 BC 독립적 컨트롤러 계층.','[\"CONTROLLER\", \"REST_CONTROLLER_ADVICE\"]','^[A-Z][a-zA-Z]*(Controller|Handler)$',NULL,'2026-01-16 02:24:47','2026-01-16 02:24:47',NULL),(10,'ADAPTER_IN','COMMON_DTO','Common DTO','표준 API 응답 래퍼. ApiResponse<T>(성공 응답, timestamp, requestId), PageApiResponse(페이지네이션), SliceApiResponse(무한스크롤).','[\"RECORD\", \"GENERIC_CLASS\"]','^[A-Z][a-zA-Z]*(Response)$','Response','2026-01-16 02:24:47','2026-01-16 02:24:47',NULL),(11,'ADAPTER_IN','COMMON_ERROR','Error Mapper Registry','ErrorMapper 레지스트리. OCP 준수를 위해 도메인별 ErrorMapper 구현체를 관리하고 적절한 매퍼를 선택.','[\"CLASS\"]','^[A-Z][a-zA-Z]*(Registry|Resolver)$',NULL,'2026-01-16 02:24:48','2026-01-16 02:24:48',NULL),(12,'ADAPTER_IN','COMMON_MAPPER','Error Mapper Interface','DomainException → HTTP 응답 변환 인터페이스. supports/map 메서드로 도메인별 커스텀 매핑 지원.','[\"INTERFACE\"]','^[A-Z][a-zA-Z]*Mapper$','Mapper','2026-01-16 02:24:48','2026-01-16 02:24:48',NULL),(13,'ADAPTER_IN','COMMON_UTIL','Utility','날짜/시간 포맷 유틸리티. ISO 8601 변환, KST 타임존 처리 등 static 메서드 제공.','[\"CLASS\"]','^[A-Z][a-zA-Z]*(Utils?|Helper)$',NULL,'2026-01-16 02:24:48','2026-01-16 02:24:48',NULL),(14,'ADAPTER_IN','CONTROLLER','Controller (Aggregate)','Command/Query 컨트롤러 통합. Thin Controller 패턴, ResponseEntity<ApiResponse<T>> 래핑, @Valid 검증 등 컨트롤러 공통 규칙 적용.','[\"REST_CONTROLLER\"]','^[A-Z][a-zA-Z]*(Command|Query)?Controller$','Controller','2026-01-16 02:25:49','2026-01-16 02:25:49',NULL),(15,'ADAPTER_IN','DTO','DTO (Aggregate)','Command/Query/Response DTO 통합. Java 21 Record 필수, Bean Validation, Lombok/Jackson 금지 등 DTO 공통 규칙 적용.','[\"RECORD\"]','^[A-Z][a-zA-Z]*Api(Request|Response)$',NULL,'2026-01-16 02:25:49','2026-01-16 02:25:49',NULL),(16,'ADAPTER_IN','MAPPER','Mapper (Aggregate)','Command/Query 매퍼 통합. @Component 필수, 필드 매핑만 수행, 비즈니스 로직 금지 등 매퍼 공통 규칙 적용.','[\"CLASS\"]','^[A-Z][a-zA-Z]*(Command|Query)?ApiMapper$','ApiMapper','2026-01-16 02:25:49','2026-01-16 02:25:49',NULL),(17,'ADAPTER_IN','REST_DOCS_TEST','REST Docs Test','Controller REST Docs 테스트. @WebMvcTest + RestDocsTestSupport 상속, @MockitoBean 의존성 Mock, document() 문서화 필수.','[\"CLASS\"]','^[A-Z][a-zA-Z]*(Command|Query)?Controller(Docs)?Test$','DocsTest','2026-01-16 02:26:05','2026-01-16 02:26:05',NULL),(18,'ADAPTER_IN','TEST_SUPPORT','Test Support','테스트 지원 추상 클래스 및 유틸리티. RestDocsTestSupport, TestFixture, TestHelper 등.','[\"ABSTRACT_CLASS\", \"CLASS\"]','^[A-Z][a-zA-Z]*(TestSupport|TestHelper|TestFixture)$',NULL,'2026-01-16 02:26:05','2026-01-16 02:26:05',NULL),(19,'ADAPTER_IN','CONFIG','Configuration','스프링 설정 클래스. OpenApiConfig, JacksonConfig, WebMvcConfig 등. @Configuration 필수.','[\"CLASS\"]','^[A-Z][a-zA-Z]*Config$','Config','2026-01-16 02:26:05','2026-01-16 02:26:05',NULL),(20,'ADAPTER_IN','ARCH_TEST','Architecture Test','ArchUnit 아키텍처 테스트. 패키지 의존성, 네이밍 규칙, 어노테이션 검증 등.','[\"CLASS\"]','^[A-Z][a-zA-Z]*ArchTest$','ArchTest','2026-01-16 02:26:06','2026-01-16 02:26:06',NULL),(21,'ADAPTER_IN','SCHEDULER','Scheduler','Thin Scheduler 패키지. @Scheduled 어노테이션으로 주기적 실행을 트리거하고, Application Layer의 UseCase를 호출합니다. 비즈니스 로직 없이 단순 호출만 담당합니다.','[\"CLASS\"]','^[A-Z][a-zA-Z]*Scheduler$','Scheduler','2026-01-16 02:26:20','2026-01-16 02:26:20',NULL),(22,'DOMAIN','COMMON_EVENT','Domain Event Interface','DomainEvent 마커 인터페이스. 모든 도메인 이벤트가 구현해야 하는 공통 인터페이스. occurredAt() 메서드 필수.','[\"INTERFACE\"]','^DomainEvent$',NULL,'2026-01-16 02:26:29','2026-01-16 02:26:29',NULL),(23,'DOMAIN','COMMON_EXCEPTION','Domain Exception Base','ErrorCode 인터페이스와 DomainException 베이스 클래스. 모든 도메인 예외의 상위 타입. int httpStatus 사용 (Spring HttpStatus 금지).','[\"INTERFACE\", \"CLASS\"]','^(ErrorCode|DomainException)$',NULL,'2026-01-16 02:26:29','2026-01-16 02:26:29',NULL),(24,'DOMAIN','COMMON_VO','Common Value Object','DateRange, PageRequest, CursorPageRequest, QueryContext, PageMeta, SliceMeta, LockKey 등 여러 BC에서 공유하는 공통 VO.','[\"RECORD\", \"INTERFACE\"]','^[A-Z][a-zA-Z]+$',NULL,'2026-01-16 02:26:29','2026-01-16 02:26:29',NULL),(25,'DOMAIN','COMMON_UTIL','Domain Utility','DomainAssertions 등 도메인 로직에서 사용하는 순수 자바 유틸리티. Spring/JPA 의존 금지.','[\"CLASS\"]','^[A-Z][a-zA-Z]*(Assertions?|Utils?)$',NULL,'2026-01-16 02:26:29','2026-01-16 02:26:29',NULL),(26,'DOMAIN','AGGREGATE','Aggregate Root','DDD Aggregate Root 클래스. forNew()/reconstitute() 팩토리, isNew() 상태, Clock 주입. Lombok/JPA/Spring 금지.','[\"CLASS\"]','^[A-Z][a-zA-Z]+$',NULL,'2026-01-16 02:26:29','2026-01-16 02:26:29',NULL),(27,'DOMAIN','ID','ID Value Object','Aggregate/Entity 식별자 VO. Long ID는 forNew()/isNew() 필수 (Auto Increment). String ID는 of()만 사용 (UUID/UUIDv7/Snowflake).','[\"RECORD\"]','^[A-Z][a-zA-Z]+Id$','Id','2026-01-16 02:26:29','2026-01-16 02:26:29',NULL),(28,'DOMAIN','VALUE_OBJECT','Value Object','불변 값 객체. Record 타입 필수, of() 팩토리 메서드, equals/hashCode 자동. Lombok 금지.','[\"RECORD\"]','^[A-Z][a-zA-Z]+$',NULL,'2026-01-16 02:26:29','2026-01-16 02:26:29',NULL),(29,'DOMAIN','DOMAIN_EVENT','Domain Event','BC별 도메인 이벤트 구현체. Record 타입, DomainEvent 구현, occurredAt(Instant), from() 팩토리. 과거형 네이밍 필수.','[\"RECORD\"]','^[A-Z][a-zA-Z]*(ed|ent|aid|ade|one|ept|ilt|elt|ought|aught|old|eld|own|ven|ken|ten|ung|ost|eft)Event$','Event','2026-01-16 02:26:29','2026-01-16 02:26:29',NULL),(30,'DOMAIN','DOMAIN_EXCEPTION','Domain Exception','BC별 ErrorCode Enum과 DomainException 구현체. ErrorCode는 int httpStatus, getCode(), getMessage() 필수.','[\"ENUM\", \"CLASS\"]','^[A-Z][a-zA-Z]+(ErrorCode|Exception)$',NULL,'2026-01-16 02:26:29','2026-01-16 02:26:29',NULL),(31,'DOMAIN','QUERY_CRITERIA','Query Criteria','BC별 조회 조건 VO. SearchCriteria 등. QueryContext 필드 필수 (ArchUnit 강제).','[\"RECORD\"]','^[A-Z][a-zA-Z]+Criteria$','Criteria','2026-01-16 02:26:29','2026-01-16 02:26:29',NULL),(32,'APPLICATION','COMMON_DTO','Common DTO','CommonSearchParams 등 여러 BC에서 공유하는 공통 DTO. REST-API에서 전달받은 정렬/페이징 정보를 Application Layer로 전달.','[\"RECORD\"]','^Common[A-Z][a-zA-Z]+$',NULL,'2026-01-16 02:26:57','2026-01-16 02:26:57',NULL),(33,'APPLICATION','COMMON_FACTORY','Common Factory','CommonVoFactory 등 공통 변환기. CommonSearchParams → Domain QueryContext 변환 담당.','[\"CLASS\"]','^Common[A-Z][a-zA-Z]+Factory$','Factory','2026-01-16 02:26:57','2026-01-16 02:26:57',NULL),(34,'APPLICATION','COMMON_EVENT','Transaction Event Registry','ApplicationEventPublisher 래퍼. 트랜잭션 유무에 따라 즉시 또는 커밋 후 이벤트 발행. ApplicationEventPublisher 직접 사용 금지.','[\"CLASS\"]','^TransactionEventRegistry$',NULL,'2026-01-16 02:26:57','2026-01-16 02:26:57',NULL),(35,'APPLICATION','COMMON_PORT','Common Port Interface','TimeProvider, IdGeneratorPort 등 인프라 추상화 인터페이스. Instant.now(), UUID 직접 사용 금지.','[\"INTERFACE\"]','^(TimeProvider|IdGeneratorPort|[A-Z][a-zA-Z]+Provider)$',NULL,'2026-01-16 02:26:57','2026-01-16 02:26:57',NULL),(36,'APPLICATION','SERVICE_COMMAND','Command Service','UseCase(Port-In) 구현체. 생성/수정/삭제 비즈니스 흐름 제어. @Service 어노테이션. @Transactional 금지 (Manager/Facade 책임).','[\"SERVICE\"]','^(Create|Update|Delete|Change|Register|Modify)[A-Z][a-zA-Z]+Service$','Service','2026-01-16 02:26:57','2026-01-16 02:26:57',NULL),(37,'APPLICATION','SERVICE_QUERY','Query Service','UseCase(Port-In) 구현체. 조회 비즈니스 흐름 제어. @Service 어노테이션. @Transactional 금지.','[\"SERVICE\"]','^(Get|Search|Find|List|Count)[A-Z][a-zA-Z]+Service$','Service','2026-01-16 02:26:57','2026-01-16 02:26:57',NULL),(38,'APPLICATION','MANAGER_PERSISTENCE','Persistence Manager','단일 CommandPort 래퍼. @Transactional 메서드 단위 필수. persist() 메서드명. ID 반환. 클래스 단위 @Transactional 금지.','[\"COMPONENT\"]','^[A-Z][a-zA-Z]+PersistenceManager$','PersistenceManager','2026-01-16 02:26:57','2026-01-16 02:26:57',NULL),(39,'APPLICATION','MANAGER_READ','Read Manager','단일 QueryPort 래퍼. @Transactional(readOnly=true) 메서드 단위 필수. findBy/get/existsBy 메서드명. Domain 반환.','[\"COMPONENT\"]','^[A-Z][a-zA-Z]+ReadManager$','ReadManager','2026-01-16 02:26:57','2026-01-16 02:26:57',NULL),(40,'APPLICATION','FACADE_COMMAND','Command Facade','2개 이상 PersistenceManager 조합. RDB Persistence Manager만 의존 허용 (외부API/캐시 금지). @Transactional 메서드 단위 허용. persist*() 메서드명.','[\"COMPONENT\"]','^[A-Z][a-zA-Z]+CommandFacade$','CommandFacade','2026-01-16 02:26:57','2026-01-16 02:26:57',NULL),(41,'APPLICATION','FACADE_QUERY','Query Facade','2개 이상 ReadManager 조합. 복합 조회용. @Transactional(readOnly=true) 메서드 단위 허용. fetch*() 메서드명.','[\"COMPONENT\"]','^[A-Z][a-zA-Z]+QueryFacade$','QueryFacade','2026-01-16 02:26:57','2026-01-16 02:26:57',NULL),(42,'APPLICATION','FACTORY_COMMAND','Command Factory','Command DTO → Domain/UpdateData/Bundle 변환. TimeProvider, IdGeneratorPort 의존. updatedAt 주입 책임. 응답 객체 생성 금지.','[\"COMPONENT\"]','^[A-Z][a-zA-Z]+CommandFactory$','CommandFactory','2026-01-16 02:26:57','2026-01-16 02:26:57',NULL),(43,'APPLICATION','FACTORY_QUERY','Query Factory','Query DTO → Domain Criteria 변환. CommonVoFactory 의존. to{Domain}Criteria() 메서드명.','[\"COMPONENT\"]','^[A-Z][a-zA-Z]+QueryFactory$','QueryFactory','2026-01-16 02:26:57','2026-01-16 02:26:57',NULL),(44,'APPLICATION','ASSEMBLER','Assembler','Domain → Response DTO 변환 전담. toResponse(), toResponseList(), toPageResponse(), toSliceResponse() 메서드. 비즈니스 로직 금지.','[\"COMPONENT\"]','^[A-Z][a-zA-Z]+Assembler$','Assembler','2026-01-16 02:26:57','2026-01-16 02:26:57',NULL),(45,'APPLICATION','PORT_IN_COMMAND','Command UseCase','생성/수정/삭제 UseCase 인터페이스. execute(Command) 단일 메서드. 내부 클래스 금지. 단일 책임.','[\"INTERFACE\"]','^(Create|Update|Delete|Change|Register|Modify)[A-Z][a-zA-Z]+UseCase$','UseCase','2026-01-16 02:26:58','2026-01-16 02:26:58',NULL),(46,'APPLICATION','PORT_IN_QUERY','Query UseCase','조회 UseCase 인터페이스. execute(Query) 단일 메서드. 내부 클래스 금지. 단일 책임.','[\"INTERFACE\"]','^(Get|Search|Find|List|Count)[A-Z][a-zA-Z]+UseCase$','UseCase','2026-01-16 02:26:58','2026-01-16 02:26:58',NULL),(47,'APPLICATION','PORT_OUT_COMMAND','Command Port','저장용 Port 인터페이스. persist(Domain) 단일 메서드만 제공. ID 반환. Entity/DTO 전달 금지.','[\"INTERFACE\"]','^[A-Z][a-zA-Z]+CommandPort$','CommandPort','2026-01-16 02:26:58','2026-01-16 02:26:58',NULL),(48,'APPLICATION','PORT_OUT_QUERY','Query Port','조회용 Port 인터페이스. 표준 4개 메서드 필수 (findById, existsById, findByCriteria, countByCriteria). Unique 필드 조회 허용. Domain 반환.','[\"INTERFACE\"]','^[A-Z][a-zA-Z]+QueryPort$','QueryPort','2026-01-16 02:26:58','2026-01-16 02:26:58',NULL),(49,'APPLICATION','PORT_OUT_CLIENT','Client Port','외부 시스템 연동 Port 인터페이스. HTTP, gRPC, 메시징 등. 도메인 언어 사용 (외부 용어 노출 금지). 실패 처리 명시.','[\"INTERFACE\"]','^[A-Z][a-zA-Z]+ClientPort$','ClientPort','2026-01-16 02:26:58','2026-01-16 02:26:58',NULL),(50,'APPLICATION','DTO_COMMAND','Command DTO','Command 입력 DTO. Record 필수. Create/Update/Change 네이밍. Update는 전체 필드 포함. Validation/Domain 의존 금지.','[\"RECORD\"]','^(Create|Update|Delete|Change|Register|Modify)[A-Z][a-zA-Z]+Command$','Command','2026-01-16 02:26:58','2026-01-16 02:26:58',NULL),(51,'APPLICATION','DTO_QUERY','Query DTO','Query 입력 DTO. Record 필수. Get(단건)/Search(목록) 네이밍. CommonSearchParams 포함. Domain 의존 금지.','[\"RECORD\"]','^(Get|Search|Find|List|Count)[A-Z][a-zA-Z]+Query$','Query','2026-01-16 02:26:58','2026-01-16 02:26:58',NULL),(52,'APPLICATION','DTO_RESPONSE','Response DTO','Query 응답 DTO. Record 필수. Response/SummaryResponse/PageResponse/SliceResponse/IdResponse 네이밍. createdAt+updatedAt 필수. Domain 의존 금지.','[\"RECORD\"]','^[A-Z][a-zA-Z]+(Response|SummaryResponse|PageResponse|SliceResponse|IdResponse)$','Response','2026-01-16 02:26:58','2026-01-16 02:26:58',NULL),(53,'APPLICATION','DTO_BUNDLE','Bundle','복합 객체 묶음. PersistBundle은 Class (with 패턴, ID Getter 위임). QueryBundle은 Record. Domain 객체 직접 포함.','[\"CLASS\", \"RECORD\"]','^[A-Z][a-zA-Z]+(PersistBundle|QueryBundle)$','Bundle','2026-01-16 02:26:58','2026-01-16 02:26:58',NULL),(54,'APPLICATION','EVENT_LISTENER','SCHEDULER_SERVICE','Scheduler Service 패키지. Scheduler UseCase 구현체. 분산락 획득/해제, Outbox 조회, 외부 호출, 상태 업데이트 등 비즈니스 로직을 포함합니다.','[\"COMPONENT\"]','^[A-Z][a-zA-Z]+EventListener$','EventListener','2026-01-16 02:26:58','2026-01-16 02:31:31',NULL),(55,'APPLICATION','SCHEDULER','Scheduler','EventListener 실패 시 Outbox 재처리. @Component + @Scheduled. 분산락 필수. PENDING 조회 → 멱등키로 외부 호출 → 상태 업데이트. 건별 독립 트랜잭션.','[\"COMPONENT\"]','^[A-Z][a-zA-Z]+(OutboxScheduler|Scheduler)$','Scheduler','2026-01-16 02:26:58','2026-01-16 02:26:58',NULL),(56,'APPLICATION','COMPONENT_VALIDATOR','Validator','비즈니스 검증 컴포넌트. ReadManager 의존. 중복/존재/상태 검증. validateXxx()/checkXxx() 메서드. void 반환 또는 DomainException.','[\"COMPONENT\"]','^[A-Z][a-zA-Z]+Validator$','Validator','2026-01-16 02:26:58','2026-01-16 02:26:58',NULL),(57,'APPLICATION','COMPONENT_PROCESSOR','Processor','데이터 처리 컴포넌트. Service에서 분리된 특정 처리 로직. Manager 의존 가능.','[\"COMPONENT\"]','^[A-Z][a-zA-Z]+Processor$','Processor','2026-01-16 02:26:58','2026-01-16 02:26:58',NULL),(58,'APPLICATION','COMPONENT_CALCULATOR','Calculator','계산 로직 컴포넌트. 복잡한 계산을 Service에서 분리. 순수 계산 로직.','[\"COMPONENT\"]','^[A-Z][a-zA-Z]+Calculator$','Calculator','2026-01-16 02:26:59','2026-01-16 02:26:59',NULL),(59,'APPLICATION','COMPONENT_RESOLVER','Resolver','결정/해결 로직 컴포넌트. 조건에 따른 전략 결정 등. Manager 의존 가능.','[\"COMPONENT\"]','^[A-Z][a-zA-Z]+Resolver$','Resolver','2026-01-16 02:26:59','2026-01-16 02:26:59',NULL),(60,'APPLICATION','SCHEDULER_USECASE','Scheduler UseCase','Scheduler UseCase 인터페이스 패키지. port/in/scheduler에 위치. execute() 단일 메서드. adapter-in/scheduler에서 호출합니다.',NULL,NULL,NULL,'2026-01-16 02:31:32','2026-01-16 02:31:32',NULL),(61,'ADAPTER_OUT_PERSISTENCE','COMMON_ENTITY','Common Entity','BaseAuditEntity(생성/수정 시간), SoftDeletableEntity(논리삭제) 등 공통 상속 Entity.','[\"ABSTRACT_CLASS\"]','^(Base|Abstract)[A-Z][a-zA-Z]*(Entity|Auditable)$',NULL,'2026-01-16 06:51:43','2026-01-16 06:51:43',NULL),(62,'ADAPTER_OUT_PERSISTENCE','COMMON_CONFIG','Common Config','JPA 설정(EntityManagerFactory, Transaction), QueryDSL 설정(JPAQueryFactory Bean) 등.','[\"CLASS\"]','^[A-Z][a-zA-Z]*(Config|Configuration)$','Config','2026-01-16 06:51:43','2026-01-16 06:51:43',NULL),(63,'ADAPTER_OUT_PERSISTENCE','ENTITY','JPA Entity','BC별 JPA Entity. BaseAuditEntity 상속, Long FK 전략 적용, JPA 관계 어노테이션 금지.','[\"CLASS\"]','^[A-Z][a-zA-Z]*JpaEntity$','JpaEntity','2026-01-16 06:51:43','2026-01-16 06:51:43',NULL),(64,'ADAPTER_OUT_PERSISTENCE','JPA_REPOSITORY','JPA Repository','Command 전용 JPA Repository. save/delete만 허용, Query Method 금지, CQRS Command 담당.','[\"INTERFACE\"]','^[A-Z][a-zA-Z]*JpaRepository$','JpaRepository','2026-01-16 06:51:43','2026-01-16 06:51:43',NULL),(65,'ADAPTER_OUT_PERSISTENCE','QUERYDSL_REPOSITORY','QueryDSL Repository','Query 전용 QueryDSL Repository. JPAQueryFactory 사용, Join 금지, Entity 반환.','[\"CLASS\"]','^[A-Z][a-zA-Z]*QueryDslRepository$','QueryDslRepository','2026-01-16 06:51:43','2026-01-16 06:51:43',NULL),(66,'ADAPTER_OUT_PERSISTENCE','COMMAND_ADAPTER','Command Adapter','Application Command Port 구현. persist(aggregate)만 제공, @Transactional 금지.','[\"CLASS\"]','^[A-Z][a-zA-Z]*CommandAdapter$','CommandAdapter','2026-01-16 06:51:43','2026-01-16 06:51:43',NULL),(67,'ADAPTER_OUT_PERSISTENCE','QUERY_ADAPTER','Query Adapter','Application Query Port 구현. QueryDslRepository 위임 + Mapper로 Domain 반환. @Transactional 금지.','[\"CLASS\"]','^[A-Z][a-zA-Z]*QueryAdapter$','QueryAdapter','2026-01-16 06:51:43','2026-01-16 06:51:43',NULL),(68,'ADAPTER_OUT_PERSISTENCE','ENTITY_MAPPER','Entity Mapper','Entity ↔ Domain 변환. @Component, Pure Java(Lombok/MapStruct 금지), 시간 필드 생성 금지.','[\"CLASS\"]','^[A-Z][a-zA-Z]*JpaEntityMapper$','JpaEntityMapper','2026-01-16 06:51:43','2026-01-16 06:51:43',NULL);
/*!40000 ALTER TABLE `package_purpose` ENABLE KEYS */;
UNLOCK TABLES;

LOCK TABLES `package_structure` WRITE;
/*!40000 ALTER TABLE `package_structure` DISABLE KEYS */;
INSERT INTO `package_structure` (`id`, `module_id`, `purpose_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (1,4,1,'{base}.{bc}.controller.command','[\"REST_CONTROLLER\"]','^[A-Z][a-zA-Z]*CommandController$','CommandController','BC별 Command 컨트롤러. POST/PUT/PATCH/DELETE 처리.','2026-01-16 02:24:49','2026-01-16 02:24:49',NULL),(2,4,2,'{base}.{bc}.controller.query','[\"REST_CONTROLLER\"]','^[A-Z][a-zA-Z]*QueryController$','QueryController','BC별 Query 컨트롤러. GET 처리.','2026-01-16 02:24:49','2026-01-16 02:24:49',NULL),(3,4,3,'{base}.{bc}.dto.command','[\"RECORD\", \"CLASS\"]','^(Create|Update|Delete|Register|Modify)[A-Z][a-zA-Z]*ApiRequest$','ApiRequest','BC별 Command Request DTO. Create/Update 요청 본문.','2026-01-16 02:24:49','2026-01-16 02:24:49',NULL),(4,4,4,'{base}.{bc}.dto.query','[\"RECORD\", \"CLASS\"]','^(Get|Search|Find|List)[A-Z][a-zA-Z]*ApiRequest$','ApiRequest','BC별 Query Request DTO. 검색 조건, 페이징 파라미터.','2026-01-16 02:24:49','2026-01-16 02:24:49',NULL),(5,4,5,'{base}.{bc}.dto.response','[\"RECORD\", \"CLASS\"]','^[A-Z][a-zA-Z]*ApiResponse$','ApiResponse','BC별 Response DTO. API 응답 본문.','2026-01-16 02:24:49','2026-01-16 02:24:49',NULL),(6,4,6,'{base}.{bc}.error','[\"CLASS\", \"ENUM\"]','^[A-Z][a-zA-Z]*(ErrorMapper|ErrorCode|ExceptionHandler)$',NULL,'BC별 에러 코드 및 예외 핸들러.','2026-01-16 02:24:49','2026-01-16 02:25:56',NULL),(7,4,7,'{base}.{bc}.mapper.command','[\"INTERFACE\", \"CLASS\"]','^[A-Z][a-zA-Z]*CommandApiMapper$','CommandApiMapper','BC별 Command 매퍼. Request → Application Command 변환.','2026-01-16 02:24:49','2026-01-16 02:24:49',NULL),(8,4,8,'{base}.{bc}.mapper.query','[\"INTERFACE\", \"CLASS\"]','^[A-Z][a-zA-Z]*QueryApiMapper$','QueryApiMapper','BC별 Query 매퍼. Request → Query, Domain → Response 변환.','2026-01-16 02:24:49','2026-01-16 02:24:49',NULL),(9,4,9,'{base}.common.controller','[\"CONTROLLER\", \"REST_CONTROLLER_ADVICE\"]','^[A-Z][a-zA-Z]*(Controller|Handler)$',NULL,'API 문서 서빙(ApiDocsController), RFC 7807 전역 예외 핸들러(GlobalExceptionHandler) 등 공통 컨트롤러 계층.','2026-01-16 02:24:49','2026-01-16 02:24:49',NULL),(10,4,10,'{base}.common.dto','[\"RECORD\", \"GENERIC_CLASS\"]','^[A-Z][a-zA-Z]*(Response)$','Response','표준 API 응답 래퍼. ApiResponse<T>(성공 응답, timestamp, requestId), PageApiResponse(페이지네이션), SliceApiResponse(무한스크롤).','2026-01-16 02:24:50','2026-01-16 02:24:50',NULL),(11,4,11,'{base}.common.error','[\"CLASS\"]','^[A-Z][a-zA-Z]*(Registry|Resolver)$',NULL,'ErrorMapper 레지스트리. OCP 준수를 위해 도메인별 ErrorMapper 구현체를 관리하고 적절한 매퍼를 선택.','2026-01-16 02:24:50','2026-01-16 02:24:50',NULL),(12,4,12,'{base}.common.mapper','[\"INTERFACE\"]','^[A-Z][a-zA-Z]*Mapper$','Mapper','DomainException → HTTP 응답 변환 인터페이스(ErrorMapper). supports/map 메서드로 도메인별 커스텀 매핑 지원.','2026-01-16 02:24:50','2026-01-16 02:24:50',NULL),(13,4,13,'{base}.common.util','[\"CLASS\"]','^[A-Z][a-zA-Z]*(Utils?|Helper)$',NULL,'날짜/시간 포맷 유틸리티(DateTimeFormatUtils). ISO 8601 변환, KST 타임존 처리 등 static 메서드 제공.','2026-01-16 02:24:50','2026-01-16 02:24:50',NULL),(14,4,14,'{base}.{bc}.controller','[\"REST_CONTROLLER\"]','^[A-Z][a-zA-Z]*(Command|Query)?Controller$','Controller','BC별 컨트롤러 패키지. command/, query/ 하위 포함. CTR-* 규칙 적용.','2026-01-16 02:25:49','2026-01-16 02:25:49',NULL),(15,4,15,'{base}.{bc}.dto','[\"RECORD\"]','^[A-Z][a-zA-Z]*Api(Request|Response)$',NULL,'BC별 DTO 패키지. command/, query/, response/ 하위 포함. DTO-* 규칙 적용.','2026-01-16 02:25:50','2026-01-16 02:25:50',NULL),(16,4,16,'{base}.{bc}.mapper','[\"CLASS\"]','^[A-Z][a-zA-Z]*(Command|Query)?ApiMapper$','ApiMapper','BC별 매퍼 패키지. command/, query/ 하위 포함. MAP-* 규칙 적용.','2026-01-16 02:25:50','2026-01-16 02:25:50',NULL),(17,4,17,'{base}.{bc}.controller.test','[\"CLASS\"]','^[A-Z][a-zA-Z]*(Command|Query)?ControllerDocsTest$','DocsTest','src/test/java 하위 BC별 Controller 테스트 패키지. command/, query/ 하위 구조. TEST-* 규칙 적용.','2026-01-16 02:26:06','2026-01-16 02:26:06',NULL),(18,4,18,'{base}.common.test','[\"ABSTRACT_CLASS\", \"CLASS\"]','^[A-Z][a-zA-Z]*(TestSupport|TestHelper|Fixture)$',NULL,'src/test/java 하위 공통 테스트 지원 클래스. RestDocsTestSupport, TestFixture 등.','2026-01-16 02:26:06','2026-01-16 02:26:06',NULL),(19,4,19,'{base}.config','[\"CLASS\"]','^[A-Z][a-zA-Z]*Config$','Config','src/main/java 하위 설정 클래스 패키지. OpenApiConfig, JacksonConfig, WebMvcConfig 등. CFG-* 규칙 적용.','2026-01-16 02:26:06','2026-01-16 02:26:06',NULL),(20,4,20,'{base}.architecture','[\"CLASS\"]','^[A-Z][a-zA-Z]*ArchTest$','ArchTest','src/test/java 하위 ArchUnit 테스트 패키지. 계층별 의존성 검증, 네이밍 규칙 검증.','2026-01-16 02:26:06','2026-01-16 02:26:06',NULL),(22,1,22,'{base}.common.event','[\"INTERFACE\"]','^DomainEvent$',NULL,'DomainEvent 마커 인터페이스. occurredAt() 메서드 정의.','2026-01-16 02:26:30','2026-01-16 02:26:30',NULL),(23,1,23,'{base}.common.exception','[\"INTERFACE\", \"CLASS\"]','^(ErrorCode|DomainException)$',NULL,'ErrorCode 인터페이스, DomainException 베이스 클래스. Spring HttpStatus 사용 금지 (int httpStatus).','2026-01-16 02:26:30','2026-01-16 02:26:30',NULL),(24,1,24,'{base}.common.vo','[\"RECORD\", \"INTERFACE\"]','^[A-Z][a-zA-Z]+$',NULL,'DateRange, PageRequest, QueryContext, PageMeta, SliceMeta, LockKey 등 공통 VO.','2026-01-16 02:26:31','2026-01-16 02:26:31',NULL),(25,1,25,'{base}.common.util','[\"CLASS\"]','^[A-Z][a-zA-Z]*(Assertions?|Utils?)$',NULL,'DomainAssertions 등 순수 자바 유틸리티. Spring/JPA 의존 금지.','2026-01-16 02:26:31','2026-01-16 02:26:31',NULL),(26,1,26,'{base}.{bc}.aggregate','[\"CLASS\"]','^[A-Z][a-zA-Z]+$',NULL,'Aggregate Root 클래스. 접미사 없음. forNew()/reconstitute() 팩토리, Lombok/JPA/Spring 금지.','2026-01-16 02:26:31','2026-01-16 02:26:31',NULL),(27,1,27,'{base}.{bc}.id','[\"RECORD\"]','^[A-Z][a-zA-Z]+Id$','Id','ID VO. Long ID는 forNew()/isNew() 필수, String ID는 of()만 사용.','2026-01-16 02:26:31','2026-01-16 02:26:31',NULL),(28,1,28,'{base}.{bc}.vo','[\"RECORD\"]','^[A-Z][a-zA-Z]+$',NULL,'일반 Value Object. Record 타입 필수, of() 팩토리 메서드.','2026-01-16 02:26:31','2026-01-16 02:26:31',NULL),(29,1,29,'{base}.{bc}.event','[\"RECORD\"]','^[A-Z][a-zA-Z]*(ed|ent|aid|ade|one|ept|ilt|elt|ought|aught|old|eld|own|ven|ken|ten|ung|ost|eft)Event$','Event','Domain Event 구현체. 과거형 네이밍 필수 (Created, Sent, Paid, Made, Done 등).','2026-01-16 02:26:31','2026-01-16 02:26:31',NULL),(30,1,30,'{base}.{bc}.exception','[\"ENUM\", \"CLASS\"]','^[A-Z][a-zA-Z]+(ErrorCode|Exception)$',NULL,'BC별 ErrorCode Enum과 Exception 클래스. DomainException 상속.','2026-01-16 02:26:31','2026-01-16 02:26:31',NULL),(31,1,31,'{base}.{bc}.query','[\"RECORD\"]','^[A-Z][a-zA-Z]+Criteria$','Criteria','조회 조건 VO. QueryContext 필드 필수.','2026-01-16 02:26:31','2026-01-16 02:26:31',NULL),(32,2,31,'{base}.common.dto','[\"RECORD\"]','^Common[A-Z][a-zA-Z]+$',NULL,'CommonSearchParams 등 공통 DTO. 정렬/페이징 정보 전달.','2026-01-16 02:27:00','2026-01-16 02:27:00',NULL),(33,2,32,'{base}.common.factory','[\"CLASS\"]','^Common[A-Z][a-zA-Z]+Factory$','Factory','CommonVoFactory 등 공통 변환기. CommonSearchParams → QueryContext.','2026-01-16 02:27:00','2026-01-16 02:27:00',NULL),(34,2,33,'{base}.common.event','[\"CLASS\"]','^TransactionEventRegistry$',NULL,'TransactionEventRegistry. 트랜잭션 유무 따라 이벤트 발행 시점 결정.','2026-01-16 02:27:00','2026-01-16 02:27:00',NULL),(35,2,34,'{base}.common.port','[\"INTERFACE\"]','^(TimeProvider|IdGeneratorPort|[A-Z][a-zA-Z]+Provider)$',NULL,'TimeProvider, IdGeneratorPort 등 인프라 추상화.','2026-01-16 02:27:00','2026-01-16 02:27:00',NULL),(36,2,35,'{base}.{bc}.service.command','[\"SERVICE\"]','^(Create|Update|Delete|Change|Register|Modify)[A-Z][a-zA-Z]+Service$','Service','CommandService. UseCase 구현체. @Transactional 금지.','2026-01-16 02:27:00','2026-01-16 02:27:00',NULL),(37,2,36,'{base}.{bc}.service.query','[\"SERVICE\"]','^(Get|Search|Find|List|Count)[A-Z][a-zA-Z]+Service$','Service','QueryService. UseCase 구현체. @Transactional 금지.','2026-01-16 02:27:00','2026-01-16 02:27:00',NULL),(38,2,37,'{base}.{bc}.manager.command','[\"COMPONENT\"]','^[A-Z][a-zA-Z]+PersistenceManager$','PersistenceManager','PersistenceManager. @Transactional 메서드 단위. persist() 메서드.','2026-01-16 02:27:00','2026-01-16 02:27:00',NULL),(39,2,38,'{base}.{bc}.manager.query','[\"COMPONENT\"]','^[A-Z][a-zA-Z]+ReadManager$','ReadManager','ReadManager. @Transactional(readOnly=true) 메서드 단위. findBy/get/existsBy.','2026-01-16 02:27:00','2026-01-16 02:27:00',NULL),(40,2,39,'{base}.{bc}.facade.command','[\"COMPONENT\"]','^[A-Z][a-zA-Z]+CommandFacade$','CommandFacade','CommandFacade. 2+ PersistenceManager 조합. RDB Manager만 의존.','2026-01-16 02:27:01','2026-01-16 02:27:01',NULL),(41,2,40,'{base}.{bc}.facade.query','[\"COMPONENT\"]','^[A-Z][a-zA-Z]+QueryFacade$','QueryFacade','QueryFacade. 2+ ReadManager 조합. fetch*() 메서드.','2026-01-16 02:27:01','2026-01-16 02:27:01',NULL),(42,2,41,'{base}.{bc}.factory.command','[\"COMPONENT\"]','^[A-Z][a-zA-Z]+CommandFactory$','CommandFactory','CommandFactory. Command → Domain/UpdateData/Bundle. TimeProvider 의존.','2026-01-16 02:27:01','2026-01-16 02:27:01',NULL),(43,2,42,'{base}.{bc}.factory.query','[\"COMPONENT\"]','^[A-Z][a-zA-Z]+QueryFactory$','QueryFactory','QueryFactory. Query → Criteria. CommonVoFactory 의존.','2026-01-16 02:27:01','2026-01-16 02:27:01',NULL),(44,2,43,'{base}.{bc}.assembler','[\"COMPONENT\"]','^[A-Z][a-zA-Z]+Assembler$','Assembler','Assembler. Domain → Response. toResponse()/toPageResponse()/toSliceResponse().','2026-01-16 02:27:01','2026-01-16 02:27:01',NULL),(45,2,44,'{base}.{bc}.port.in.command','[\"INTERFACE\"]','^(Create|Update|Delete|Change|Register|Modify)[A-Z][a-zA-Z]+UseCase$','UseCase','Command UseCase 인터페이스. execute(Command) 단일 메서드.','2026-01-16 02:27:01','2026-01-16 02:27:01',NULL),(46,2,45,'{base}.{bc}.port.in.query','[\"INTERFACE\"]','^(Get|Search|Find|List|Count)[A-Z][a-zA-Z]+UseCase$','UseCase','Query UseCase 인터페이스. execute(Query) 단일 메서드.','2026-01-16 02:27:01','2026-01-16 02:27:01',NULL),(47,2,46,'{base}.{bc}.port.out.command','[\"INTERFACE\"]','^[A-Z][a-zA-Z]+CommandPort$','CommandPort','CommandPort. persist(Domain) 메서드. ID 반환.','2026-01-16 02:27:01','2026-01-16 02:27:01',NULL),(48,2,47,'{base}.{bc}.port.out.query','[\"INTERFACE\"]','^[A-Z][a-zA-Z]+QueryPort$','QueryPort','QueryPort. 표준 4개 메서드 + Unique 필드 조회 허용.','2026-01-16 02:27:01','2026-01-16 02:27:01',NULL),(49,2,48,'{base}.{bc}.port.out.client','[\"INTERFACE\"]','^[A-Z][a-zA-Z]+ClientPort$','ClientPort','ClientPort. 외부 시스템 연동. 도메인 언어 사용.','2026-01-16 02:27:01','2026-01-16 02:27:01',NULL),(50,2,49,'{base}.{bc}.dto.command','[\"RECORD\"]','^(Create|Update|Delete|Change|Register|Modify)[A-Z][a-zA-Z]+Command$','Command','Command DTO. Record 필수. Update는 전체 필드.','2026-01-16 02:27:01','2026-01-16 02:27:01',NULL),(51,2,50,'{base}.{bc}.dto.query','[\"RECORD\"]','^(Get|Search|Find|List|Count)[A-Z][a-zA-Z]+Query$','Query','Query DTO. Record 필수. CommonSearchParams 포함.','2026-01-16 02:27:01','2026-01-16 02:27:01',NULL),(52,2,51,'{base}.{bc}.dto.response','[\"RECORD\"]','^[A-Z][a-zA-Z]+(Response|SummaryResponse|PageResponse|SliceResponse|IdResponse)$','Response','Response DTO. Record 필수. createdAt+updatedAt 필수.','2026-01-16 02:27:02','2026-01-16 02:27:02',NULL),(53,2,52,'{base}.{bc}.dto.bundle','[\"CLASS\", \"RECORD\"]','^[A-Z][a-zA-Z]+(PersistBundle|QueryBundle)$','Bundle','Bundle. PersistBundle=Class (with패턴), QueryBundle=Record.','2026-01-16 02:27:02','2026-01-16 02:27:02',NULL),(54,2,53,'{base}.{bc}.listener','[\"COMPONENT\"]','^[A-Z][a-zA-Z]+EventListener$','EventListener','EventListener. 외부 호출 전용. @Async + @EventListener. 멱등키 필수.','2026-01-16 02:27:02','2026-01-16 02:27:02',NULL),(55,2,54,'{base}.{bc}.service.scheduler','[\"COMPONENT\"]','^(Process|Retry|Cleanup)[A-Z][a-zA-Z]+Service$','Service','Scheduler Service. Scheduler UseCase 구현체. 분산락, 배치 처리, 상태 관리 로직 포함. Manager 의존 (Port 직접 주입 금지).','2026-01-16 02:27:02','2026-01-16 02:31:31',NULL),(56,2,55,'{base}.{bc}.component.validator','[\"COMPONENT\"]','^[A-Z][a-zA-Z]+Validator$','Validator','Validator. 비즈니스 검증. ReadManager 의존.','2026-01-16 02:27:02','2026-01-16 02:27:02',NULL),(57,2,56,'{base}.{bc}.component.processor','[\"COMPONENT\"]','^[A-Z][a-zA-Z]+Processor$','Processor','Processor. 데이터 처리 로직.','2026-01-16 02:27:02','2026-01-16 02:27:02',NULL),(58,2,57,'{base}.{bc}.component.calculator','[\"COMPONENT\"]','^[A-Z][a-zA-Z]+Calculator$','Calculator','Calculator. 계산 로직.','2026-01-16 02:27:02','2026-01-16 02:27:02',NULL),(59,2,58,'{base}.{bc}.component.resolver','[\"COMPONENT\"]','^[A-Z][a-zA-Z]+Resolver$','Resolver','Resolver. 결정/해결 로직.','2026-01-16 02:27:02','2026-01-16 02:27:02',NULL),(60,2,60,'{base}.{bc}.port.in.scheduler','[\"INTERFACE\"]','^(Process|Retry|Cleanup)[A-Z][a-zA-Z]+UseCase$','UseCase','Scheduler UseCase 인터페이스. port/in/command, port/in/query와 별도로 관리. execute() 단일 메서드.','2026-01-16 02:31:32','2026-01-16 02:31:32',NULL),(61,6,24,'{base}.common.entity','[\"ABSTRACT_CLASS\"]','^(Base|Abstract)[A-Z][a-zA-Z]*(Entity|Auditable)$',NULL,'공통 Entity 상위 클래스. BaseAuditEntity(createdAt, updatedAt), SoftDeletableEntity(deletedAt) 제공.','2026-01-16 06:51:43','2026-01-16 06:51:43',NULL),(62,6,25,'{base}.common.config','[\"CLASS\"]','^[A-Z][a-zA-Z]*(Config|Configuration)$','Config','JPA/QueryDSL 설정 클래스. JPAQueryFactory Bean 등록, AuditorAware 설정 등.','2026-01-16 06:51:44','2026-01-16 06:51:44',NULL),(63,6,26,'{base}.{bc}.entity','[\"CLASS\"]','^[A-Z][a-zA-Z]*JpaEntity$','JpaEntity','BC별 JPA Entity. BaseAuditEntity 상속, Long FK 전략, JPA 관계 어노테이션 금지.','2026-01-16 06:51:44','2026-01-16 06:51:44',NULL),(64,6,27,'{base}.{bc}.repository.jpa','[\"INTERFACE\"]','^[A-Z][a-zA-Z]*JpaRepository$','JpaRepository','BC별 JPA Repository. Command 전용 (save/delete), Query Method/@Query 금지.','2026-01-16 06:51:44','2026-01-16 06:51:44',NULL),(65,6,28,'{base}.{bc}.repository.querydsl','[\"CLASS\"]','^[A-Z][a-zA-Z]*QueryDslRepository$','QueryDslRepository','BC별 QueryDSL Repository. Query 전용, JPAQueryFactory 사용, Join/findAll 금지.','2026-01-16 06:51:44','2026-01-16 06:51:44',NULL),(66,6,29,'{base}.{bc}.adapter.command','[\"CLASS\"]','^[A-Z][a-zA-Z]*CommandAdapter$','CommandAdapter','BC별 Command Port 구현. persist(aggregate) 메서드만 제공, @Transactional 금지.','2026-01-16 06:51:44','2026-01-16 06:51:44',NULL),(67,6,30,'{base}.{bc}.adapter.query','[\"CLASS\"]','^[A-Z][a-zA-Z]*QueryAdapter$','QueryAdapter','BC별 Query Port 구현. QueryDslRepository 위임 + Mapper로 Domain 반환. @Transactional 금지.','2026-01-16 06:51:44','2026-01-16 06:51:44',NULL),(68,6,31,'{base}.{bc}.mapper','[\"CLASS\"]','^[A-Z][a-zA-Z]*JpaEntityMapper$','JpaEntityMapper','BC별 Entity ↔ Domain 변환 Mapper. @Component, Pure Java, 시간 필드 생성 금지.','2026-01-16 06:51:44','2026-01-16 06:51:44',NULL);
/*!40000 ALTER TABLE `package_structure` ENABLE KEYS */;
UNLOCK TABLES;

LOCK TABLES `layer_dependency_rule` WRITE;
/*!40000 ALTER TABLE `layer_dependency_rule` DISABLE KEYS */;
INSERT INTO `layer_dependency_rule` (`id`, `architecture_id`, `from_layer`, `to_layer`, `dependency_type`, `condition_description`, `created_at`, `updated_at`, `deleted_at`) VALUES (1,1,'DOMAIN','APPLICATION','FORBIDDEN','Domain은 Application에 의존할 수 없음. Domain은 순수 비즈니스 로직만 포함.','2026-01-16 02:24:51','2026-01-16 02:24:51',NULL),(2,1,'DOMAIN','ADAPTER_IN','FORBIDDEN','Domain은 Adapter-In에 의존할 수 없음. 외부 프레임워크 의존 금지.','2026-01-16 02:24:51','2026-01-16 02:24:51',NULL),(3,1,'DOMAIN','ADAPTER_OUT','FORBIDDEN','Domain은 Adapter-Out에 의존할 수 없음. 인프라 의존 금지.','2026-01-16 02:24:51','2026-01-16 02:24:51',NULL),(4,1,'APPLICATION','DOMAIN','ALLOWED','Application은 Domain에 의존 가능. UseCase에서 Domain 객체 사용.','2026-01-16 02:24:51','2026-01-16 02:24:51',NULL),(5,1,'APPLICATION','ADAPTER_IN','FORBIDDEN','Application은 Adapter-In에 의존할 수 없음. Port-In 인터페이스로 역전.','2026-01-16 02:24:52','2026-01-16 02:24:52',NULL),(6,1,'APPLICATION','ADAPTER_OUT','FORBIDDEN','Application은 Adapter-Out에 의존할 수 없음. Port-Out 인터페이스로 역전.','2026-01-16 02:24:52','2026-01-16 02:24:52',NULL),(7,1,'ADAPTER_IN','APPLICATION','ALLOWED','Adapter-In은 Application에 의존 가능. UseCase(Port-In) 호출.','2026-01-16 02:24:52','2026-01-16 02:24:52',NULL),(8,1,'ADAPTER_IN','DOMAIN','CONDITIONAL','Adapter-In은 Domain DTO/VO 참조만 허용. Domain 로직 직접 호출 금지.','2026-01-16 02:24:52','2026-01-16 02:24:52',NULL),(9,1,'ADAPTER_IN','ADAPTER_OUT','FORBIDDEN','Adapter-In은 Adapter-Out에 직접 의존할 수 없음. Application을 통해서만 접근.','2026-01-16 02:24:52','2026-01-16 02:24:52',NULL),(10,1,'ADAPTER_OUT','APPLICATION','ALLOWED','Adapter-Out은 Application에 의존 가능. Port-Out 인터페이스 구현.','2026-01-16 02:24:52','2026-01-16 02:24:52',NULL),(11,1,'ADAPTER_OUT','DOMAIN','ALLOWED','Adapter-Out은 Domain에 의존 가능. Entity ↔ Domain 변환.','2026-01-16 02:24:52','2026-01-16 02:24:52',NULL),(12,1,'ADAPTER_OUT','ADAPTER_IN','FORBIDDEN','Adapter-Out은 Adapter-In에 의존할 수 없음.','2026-01-16 02:24:52','2026-01-16 02:24:52',NULL);
/*!40000 ALTER TABLE `layer_dependency_rule` ENABLE KEYS */;
UNLOCK TABLES;

LOCK TABLES `coding_rule` WRITE;
/*!40000 ALTER TABLE `coding_rule` DISABLE KEYS */;
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `is_zero_tolerance`, `applies_to`, `created_at`, `updated_at`, `structure_id`, `sdk_artifact`, `sdk_min_version`, `sdk_max_version`, `deleted_at`) VALUES (1,1,'CTR-001','Thin Controller 패턴 적용','BLOCKER','BEHAVIOR','Controller는 HTTP 요청을 UseCase로 전달하고, 결과를 HTTP 응답으로 반환하는 역할만 수행합니다. 비즈니스 로직, Domain 객체 직접 생성/조작, 예외 처리(try-catch) 등을 Controller에 포함하면 안 됩니다.','Controller의 단일 책임 원칙(SRP) 준수. 비즈니스 로직은 UseCase에, 예외 처리는 GlobalExceptionHandler에 위임하여 계층 분리를 명확히 합니다.',0,1,'[\"CLASS\", \"METHOD\"]','2026-01-16 02:25:41','2026-01-16 02:25:51',14,NULL,NULL,NULL,NULL),(2,1,'CTR-002','ResponseEntity<ApiResponse<T>> 래핑 필수','BLOCKER','STRUCTURE','모든 Controller 응답은 ResponseEntity<ApiResponse<T>> 형식으로 반환해야 합니다. ApiResponse만 반환하면 HTTP 상태 코드 제어가 불가하고, ResponseEntity만 반환하면 표준 응답 형식을 준수하지 못합니다.','HTTP 상태 코드 제어와 표준 API 응답 형식을 동시에 만족하기 위함입니다. 클라이언트는 일관된 응답 형식을 기대할 수 있습니다.',1,1,'[\"METHOD\"]','2026-01-16 02:25:41','2026-01-16 02:25:51',14,NULL,NULL,NULL,NULL),(3,1,'CTR-003','@Valid 검증 필수','CRITICAL','ANNOTATION','모든 Request DTO(@RequestBody, @ModelAttribute)에 @Valid 어노테이션을 사용하여 Bean Validation을 수행합니다. PathVariable, RequestParam 검증 시 클래스 레벨에 @Validated가 필요합니다.','Bean Validation을 통해 입력 값 검증을 선언적으로 처리하고, 검증 실패 시 GlobalExceptionHandler가 일관된 에러 응답을 생성합니다.',1,0,'[\"PARAMETER\"]','2026-01-16 02:25:42','2026-01-16 02:25:51',14,NULL,NULL,NULL,NULL),(4,1,'CTR-004','DELETE 메서드 금지 (소프트 삭제는 PATCH)','BLOCKER','BEHAVIOR','DELETE 엔드포인트는 지원하지 않습니다. 소프트 삭제는 PATCH /{id}/delete 형태로 상태를 DELETED로 변경합니다. @DeleteMapping 어노테이션 사용이 금지됩니다.','실제 DB 삭제는 위험하며 복구 불가합니다. 소프트 삭제는 상태 변경이므로 PATCH가 적합하고, 감사 추적(Audit Trail) 유지가 가능합니다.',0,1,'[\"METHOD\"]','2026-01-16 02:25:42','2026-01-16 02:25:51',14,NULL,NULL,NULL,NULL),(5,1,'CTR-005','Controller에서 @Transactional 사용 금지','BLOCKER','ANNOTATION','Controller에서 @Transactional 어노테이션을 사용하면 안 됩니다. 트랜잭션 관리는 UseCase(Service) 계층의 책임입니다.','트랜잭션 경계는 비즈니스 로직을 처리하는 UseCase 계층에서 관리해야 합니다. Controller는 HTTP 어댑터 역할만 수행합니다.',1,1,'[\"CLASS\", \"METHOD\"]','2026-01-16 02:25:42','2026-01-16 02:25:51',14,NULL,NULL,NULL,NULL),(6,1,'CTR-006','Controller에서 try-catch 예외 처리 금지','CRITICAL','BEHAVIOR','Controller 메서드에서 try-catch로 직접 예외를 처리하면 안 됩니다. 모든 예외 처리는 GlobalExceptionHandler(@RestControllerAdvice)에 위임합니다.','예외 처리 로직을 중앙화하여 일관된 에러 응답 형식을 보장합니다. RFC 7807 표준 에러 응답을 생성할 수 있습니다.',0,0,'[\"METHOD\"]','2026-01-16 02:25:42','2026-01-16 02:25:51',14,NULL,NULL,NULL,NULL),(7,1,'CTR-007','Controller에 비즈니스 로직 포함 금지','BLOCKER','BEHAVIOR','Controller에 if/switch를 사용한 비즈니스 규칙, 계산 로직, 상태 변경 로직 등을 포함하면 안 됩니다. Controller는 Mapper 변환과 UseCase 호출만 수행합니다.','Thin Controller 패턴의 핵심. 비즈니스 로직은 Domain과 UseCase에서 처리하여 테스트 용이성과 재사용성을 높입니다.',0,1,'[\"METHOD\"]','2026-01-16 02:25:42','2026-01-16 02:25:51',14,NULL,NULL,NULL,NULL),(8,1,'CTR-008','Controller에서 Domain 객체 직접 생성/조작 금지','BLOCKER','DEPENDENCY','Controller에서 Domain Entity, Aggregate, Value Object를 직접 생성하거나 조작하면 안 됩니다. Domain 변환은 Application Layer의 Assembler 책임입니다.','계층 간 의존성 격리. REST API Layer는 Application Layer의 DTO만 사용하고, Domain은 Application Layer를 통해서만 접근합니다.',0,1,'[\"METHOD\"]','2026-01-16 02:25:42','2026-01-16 02:25:51',14,NULL,NULL,NULL,NULL),(9,1,'CTR-009','Controller에서 Lombok 사용 금지','BLOCKER','ANNOTATION','@Data, @Builder, @Getter, @Setter, @RequiredArgsConstructor 등 모든 Lombok 어노테이션 사용이 금지됩니다. 생성자 주입은 명시적으로 작성합니다.','Pure Java 원칙. 컴파일 타임에 코드가 명확히 보이고, IDE 지원이 확실하며, 바이트코드 조작으로 인한 예측 불가능한 동작을 방지합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:25:42','2026-01-16 02:25:51',14,NULL,NULL,NULL,NULL),(10,1,'CTR-010','UseCase 직접 의존 및 Mapper DI','MAJOR','DEPENDENCY','Controller는 UseCase(Port-In 인터페이스)와 Mapper를 생성자 주입으로 의존합니다. UseCase 5-10개 의존은 정상이며, Service 클래스 직접 주입은 권장하지 않습니다.','CQRS 패턴 적용 시 Command UseCase와 Query UseCase를 분리하여 의존성을 명확히 합니다. Mapper DI를 통해 변환 로직을 테스트 가능하게 합니다.',0,0,'[\"FIELD\", \"CONSTRUCTOR\"]','2026-01-16 02:25:42','2026-01-16 02:25:51',14,NULL,NULL,NULL,NULL),(11,1,'CTR-011','CQRS Controller 분리 (권장)','INFO','STRUCTURE','Command Controller(POST, PUT, PATCH)와 Query Controller(GET)를 분리하는 것을 권장합니다. *CommandController, *QueryController 네이밍을 사용합니다. 소규모 BC는 통합 Controller 사용 가능합니다.','Command와 Query 의존성을 분리하여 관심사 분리를 명확히 하고, 각 Controller의 책임을 단순화합니다.',0,0,'[\"CLASS\"]','2026-01-16 02:25:42','2026-01-16 02:25:51',14,NULL,NULL,NULL,NULL),(12,1,'CTR-012','RESTful URI 설계','MAJOR','STRUCTURE','URI는 리소스 기반 명사 복수형(/orders)을 사용하고, 행위는 HTTP 메서드로 표현합니다. RPC 스타일(/createOrder, /getOrders) 금지. 상태 변경 동사는 PATCH /{id}/cancel 형태로 허용됩니다.','REST API 설계 원칙 준수. URI는 리소스를 식별하고, HTTP 메서드가 행위를 나타내어 API 예측 가능성을 높입니다.',0,0,'[\"METHOD\"]','2026-01-16 02:25:42','2026-01-16 02:25:51',14,NULL,NULL,NULL,NULL),(13,1,'CTR-013','HTTP 상태 코드 올바른 사용','MAJOR','BEHAVIOR','POST → 201 Created, GET → 200 OK, PATCH/PUT → 200 OK를 사용합니다. 모든 성공 응답에 200을 사용하면 안 됩니다. ResponseEntity.status(HttpStatus.CREATED) 형태로 명시합니다.','HTTP 표준 준수. 클라이언트는 상태 코드를 통해 응답의 성격을 즉시 파악할 수 있습니다.',1,0,'[\"METHOD\"]','2026-01-16 02:25:42','2026-01-16 02:25:51',14,NULL,NULL,NULL,NULL),(14,1,'CTR-014','Endpoint Properties 중앙 관리','MINOR','STRUCTURE','@RequestMapping 경로는 하드코딩하지 않고 ${api.endpoints.base-v1} 형태로 Properties를 참조합니다. ApiEndpointProperties 클래스로 중앙 관리합니다.','Endpoint 경로 변경 시 한 곳에서 관리할 수 있고, 환경별로 다른 경로 설정이 가능합니다.',1,0,'[\"CLASS\"]','2026-01-16 02:25:42','2026-01-16 02:25:51',14,NULL,NULL,NULL,NULL),(15,1,'DTO-001','Request/Response DTO는 Java 21 Record 사용 필수','BLOCKER','STRUCTURE','모든 Request DTO와 Response DTO는 public record 키워드로 정의합니다. Class로 정의하면 안 됩니다. Nested DTO도 record로 정의합니다.','Record는 불변성, equals/hashCode/toString 자동 생성, Compact Constructor를 제공합니다. DTO의 본질인 데이터 전송 객체에 최적화되어 있습니다.',0,1,'[\"CLASS\"]','2026-01-16 02:25:44','2026-01-16 02:25:51',15,NULL,NULL,NULL,NULL),(16,1,'DTO-002','Request DTO @NotNull 필수 (Nullable 금지)','BLOCKER','ANNOTATION','Command/Query Request DTO의 모든 필드에 @NotNull (또는 @NotBlank, @NotEmpty)이 필수입니다. Nullable 필드는 허용하지 않습니다. 변경 여부는 서버에서 기존 값과 비교하여 판단합니다. Optional 필드가 필요한 경우에도 클라이언트가 현재 값을 그대로 보내도록 합니다.','Null 허용 시 의도적 null과 누락을 구분할 수 없습니다. 모든 필드를 필수로 받고, 변경 여부는 서버에서 판단하는 것이 명확합니다. 이로써 클라이언트 실수로 인한 데이터 손실을 방지합니다.',1,1,'[\"FIELD\"]','2026-01-16 02:25:44','2026-01-16 02:26:15',15,NULL,NULL,NULL,NULL),(17,1,'DTO-003','Request DTO는 *ApiRequest 네이밍 규칙','MAJOR','STRUCTURE','Command DTO: Create*, Update*, Delete*, Cancel* + ApiRequest (예: CreateOrderApiRequest). Query DTO: Get*, Search*, Find*, List* + ApiRequest (예: SearchOrderApiRequest).','이름만으로 DTO의 용도와 HTTP 메서드를 즉시 파악할 수 있습니다. 유비쿼터스 언어를 적용하여 도메인 전문가와 소통이 원활합니다.',1,0,'[\"CLASS\"]','2026-01-16 02:25:44','2026-01-16 02:25:51',15,NULL,NULL,NULL,NULL),(18,1,'DTO-004','Response DTO는 *ApiResponse 네이밍 규칙','MAJOR','STRUCTURE','Response DTO는 *ApiResponse 접미사를 사용합니다 (예: OrderApiResponse, OrderDetailApiResponse, OrderSummaryApiResponse). 목적에 맞는 접두사/접미사를 추가합니다.','API Layer의 DTO임을 명확히 하고, Application Layer DTO와 구분합니다.',1,0,'[\"CLASS\"]','2026-01-16 02:25:44','2026-01-16 02:25:51',15,NULL,NULL,NULL,NULL),(19,1,'DTO-005','DTO에서 Lombok 사용 금지','BLOCKER','ANNOTATION','@Data, @Builder, @Getter, @Setter, @NoArgsConstructor, @AllArgsConstructor 등 모든 Lombok 어노테이션 사용이 금지됩니다. Java 21 Record 기능으로 대체합니다.','Pure Java 원칙. Record는 Lombok의 기능을 언어 레벨에서 제공하므로 Lombok이 불필요합니다. 바이트코드 조작 없이 명확한 코드를 유지합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:25:44','2026-01-16 02:25:51',15,NULL,NULL,NULL,NULL),(20,1,'DTO-006','DTO에서 Jackson 어노테이션 금지','CRITICAL','ANNOTATION','@JsonFormat, @JsonProperty, @JsonIgnore, @JsonInclude 등 Jackson 어노테이션 사용이 금지됩니다. 필드명은 camelCase를 사용하고, 전역 ObjectMapper 설정으로 처리합니다.','DTO가 특정 직렬화 라이브러리에 종속되는 것을 방지합니다. 직렬화 설정은 인프라 설정에서 중앙 관리합니다.',0,1,'[\"FIELD\"]','2026-01-16 02:25:44','2026-01-16 02:25:51',15,NULL,NULL,NULL,NULL),(21,1,'DTO-007','DTO에 Domain 변환 메서드 금지','BLOCKER','BEHAVIOR','DTO에 toDomain(), toEntity(), toAggregate() 등 Domain 객체 변환 메서드를 포함하면 안 됩니다. API DTO → Application DTO 변환은 Mapper, Application DTO → Domain 변환은 Assembler 책임입니다.','계층 간 책임 분리. DTO는 데이터 전송만 담당하고, 변환 로직은 전용 컴포넌트에서 처리하여 단일 책임 원칙을 준수합니다.',0,1,'[\"METHOD\"]','2026-01-16 02:25:44','2026-01-16 02:25:51',15,NULL,NULL,NULL,NULL),(22,1,'DTO-008','DTO에 비즈니스 로직 메서드 금지','BLOCKER','BEHAVIOR','DTO에 isVip(), calculateTotal(), validate() 등 비즈니스 로직 메서드를 포함하면 안 됩니다. DTO는 데이터 전송 객체로서 데이터만 담습니다.','비즈니스 로직은 Domain Layer의 책임입니다. DTO는 레이어 간 데이터 전송만 담당하여 관심사를 명확히 분리합니다.',0,1,'[\"METHOD\"]','2026-01-16 02:25:44','2026-01-16 02:25:51',15,NULL,NULL,NULL,NULL),(23,1,'DTO-009','Compact Constructor 활용','INFO','STRUCTURE','DTO 필드에 Optional<T> 타입을 사용할 수 없습니다. 모든 필드는 @NotNull로 필수화하고, Optional이 필요한 상황 자체를 허용하지 않습니다. 클라이언트는 변경하지 않을 필드도 현재 값을 그대로 전송합니다.','Optional은 반환 타입용으로 설계되었고, 필드로 사용 시 직렬화 문제가 발생합니다. 또한 Nullable 허용 정책과 충돌하므로 근본적으로 사용하지 않습니다.',0,0,'[\"CONSTRUCTOR\"]','2026-01-16 02:25:44','2026-01-16 02:26:16',15,NULL,NULL,NULL,NULL),(24,1,'DTO-010','복잡한 구조는 Nested Record로 표현','INFO','STRUCTURE','복잡한 요청/응답 구조는 Nested Record로 표현합니다. 외부 클래스 내부에 관련 Record를 정의하여 응집도를 높입니다 (예: CreateOrderApiRequest.OrderItemRequest).','관련 DTO를 논리적으로 그룹화하여 가독성과 유지보수성을 높입니다. 패키지 구조도 단순해집니다.',0,0,'[\"CLASS\"]','2026-01-16 02:25:44','2026-01-16 02:25:51',15,NULL,NULL,NULL,NULL),(25,1,'DTO-011','DTO에 Setter 메서드 금지','BLOCKER','STRUCTURE','DTO는 불변 객체여야 합니다. Setter 메서드를 정의하면 안 됩니다. Record는 기본적으로 불변이므로 Setter가 없습니다.','불변성 보장. DTO가 여러 계층을 거쳐도 상태가 변하지 않아 예측 가능하고 Thread-Safe합니다.',0,1,'[\"METHOD\"]','2026-01-16 02:25:44','2026-01-16 02:25:51',15,NULL,NULL,NULL,NULL),(26,1,'DTO-012','DTO에 Spring 어노테이션 금지','CRITICAL','ANNOTATION','@Component, @Service, @Repository, @Controller 등 Spring 어노테이션을 DTO에 사용하면 안 됩니다. DTO는 순수 데이터 객체입니다.','DTO는 프레임워크에 독립적인 POJO여야 합니다. Spring 컨테이너 관리 대상이 아닙니다.',0,1,'[\"CLASS\"]','2026-01-16 02:25:45','2026-01-16 02:25:51',15,NULL,NULL,NULL,NULL),(27,1,'DTO-013','DTO는 올바른 패키지에 위치','MAJOR','STRUCTURE','Command DTO: {bc}.dto.command/ (예: order/dto/command/CreateOrderApiRequest.java). Query DTO: {bc}.dto.query/. Response DTO: {bc}.dto.response/.','CQRS 패턴에 따라 Command와 Query DTO를 분리하여 의존성과 변경 이유를 명확히 합니다.',1,0,'[\"CLASS\"]','2026-01-16 02:25:45','2026-01-16 02:25:51',15,NULL,NULL,NULL,NULL),(28,1,'MAP-001','Mapper는 @Component Bean 등록 필수','BLOCKER','ANNOTATION','Mapper 클래스는 @Component 어노테이션으로 Spring Bean 등록합니다. Static 메서드로 구현하면 안 됩니다. 생성자 주입으로 Controller에 DI합니다.','의존성 주입을 통해 MessageSource, ObjectMapper 등 다른 빈을 주입받을 수 있습니다. 테스트 시 Mock 교체가 용이합니다.',1,1,'[\"CLASS\"]','2026-01-16 02:25:46','2026-01-16 02:25:51',16,NULL,NULL,NULL,NULL),(29,1,'MAP-002','Mapper에서 Static 메서드 금지','BLOCKER','STRUCTURE','Mapper의 변환 메서드를 static으로 정의하면 안 됩니다. 인스턴스 메서드로 구현하여 DI가 가능하게 합니다. MapperUtil 등 Static 클래스 금지.','Static 메서드는 의존성 주입이 불가능하고, 테스트 시 Mock 교체가 어렵습니다. Bean으로 등록하면 Spring 생태계의 이점을 활용할 수 있습니다.',0,1,'[\"METHOD\"]','2026-01-16 02:25:46','2026-01-16 02:25:51',16,NULL,NULL,NULL,NULL),(30,1,'MAP-003','Mapper는 *ApiMapper 네이밍 규칙','MAJOR','STRUCTURE','Mapper 클래스명은 *ApiMapper 접미사를 사용합니다 (예: OrderApiMapper, ProductApiMapper). BC별로 하나의 Mapper를 사용하고, 필요시 Command/Query로 분리할 수 있습니다.','API Layer의 Mapper임을 명확히 하고, Application Layer의 Assembler/Factory와 구분합니다.',1,0,'[\"CLASS\"]','2026-01-16 02:25:46','2026-01-16 02:25:51',16,NULL,NULL,NULL,NULL),(31,1,'MAP-004','Mapper는 필드 매핑만 수행','BLOCKER','BEHAVIOR','Mapper는 API DTO ↔ Application DTO 간 필드 매핑만 수행합니다. 비즈니스 로직, 검증 로직, 기본값 설정, 계산 로직 등을 포함하면 안 됩니다.','Mapper의 단일 책임. 변환 로직 외의 책임은 적절한 계층(Controller, UseCase, Domain)에서 처리합니다.',0,1,'[\"METHOD\"]','2026-01-16 02:25:46','2026-01-16 02:25:51',16,NULL,NULL,NULL,NULL),(32,1,'MAP-005','Mapper에 비즈니스 로직 금지','BLOCKER','BEHAVIOR','if/switch를 사용한 조건부 로직, 계산(tax, discount), 상태 변환(enum → label), 기본값 설정 등을 Mapper에 포함하면 안 됩니다. 단순 필드 복사만 수행합니다.','비즈니스 로직은 Domain Layer 또는 Application Layer UseCase에서 처리합니다. Mapper는 순수 변환기입니다.',0,1,'[\"METHOD\"]','2026-01-16 02:25:46','2026-01-16 02:25:51',16,NULL,NULL,NULL,NULL),(33,1,'MAP-006','Mapper에서 Domain 객체 직접 사용 금지','BLOCKER','DEPENDENCY','Mapper에서 Domain Entity, Aggregate, Value Object를 직접 import하거나 사용하면 안 됩니다. API DTO ↔ Application DTO 변환만 담당합니다.','계층 분리 원칙. REST API Layer는 Domain Layer를 직접 알지 못하고, Application Layer의 DTO를 통해서만 통신합니다.',0,1,'[\"CLASS\", \"METHOD\"]','2026-01-16 02:25:46','2026-01-16 02:25:51',16,NULL,NULL,NULL,NULL),(34,1,'MAP-007','Mapper에서 Lombok 사용 금지','BLOCKER','ANNOTATION','@Data, @Builder, @RequiredArgsConstructor 등 모든 Lombok 어노테이션 사용이 금지됩니다. 생성자와 의존성 필드는 명시적으로 작성합니다.','Pure Java 원칙. 컴파일 타임에 코드가 명확히 보이고, IDE 지원이 확실합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:25:46','2026-01-16 02:25:51',16,NULL,NULL,NULL,NULL),(35,1,'MAP-008','Mapper에 Repository/UseCase 주입 금지','BLOCKER','DEPENDENCY','Mapper에 Repository, UseCase, Service 등 다른 계층의 컴포넌트를 주입하면 안 됩니다. 허용되는 의존성: MessageSource, ObjectMapper 등 인프라 유틸리티만 가능합니다.','Mapper는 순수 변환기입니다. 데이터 조회나 비즈니스 로직 실행이 필요하면 Controller나 UseCase에서 처리 후 Mapper에 전달합니다.',0,1,'[\"FIELD\", \"CONSTRUCTOR\"]','2026-01-16 02:25:46','2026-01-16 02:25:51',16,NULL,NULL,NULL,NULL),(36,1,'MAP-009','Mapper는 올바른 패키지에 위치','MAJOR','STRUCTURE','Mapper는 {bc}.mapper/ 패키지에 위치합니다 (예: order/mapper/OrderApiMapper.java). Command/Query로 분리 시 같은 패키지 내에 OrderCommandApiMapper, OrderQueryApiMapper로 네이밍합니다.','BC별로 관련 Mapper를 그룹화하여 응집도를 높입니다.',1,0,'[\"CLASS\"]','2026-01-16 02:25:46','2026-01-16 02:25:51',16,NULL,NULL,NULL,NULL),(37,1,'MAP-010','toCommand/toQuery/toApiResponse 메서드 패턴','INFO','STRUCTURE','API Request → Command: toCommand() 또는 to{Action}Command(). API Request → Query: toQuery() 또는 to{Action}Query(). Application Response → API Response: toApiResponse() 또는 to{Type}ApiResponse().','일관된 메서드 네이밍으로 변환 방향을 명확히 합니다. 코드 가독성과 예측 가능성이 높아집니다.',0,0,'[\"METHOD\"]','2026-01-16 02:25:46','2026-01-16 02:25:51',16,NULL,NULL,NULL,NULL),(38,1,'MAP-011','Mapper에 검증 로직 금지','CRITICAL','BEHAVIOR','Mapper에서 if (request.getAmount() < 0) throw ... 형태의 검증 로직을 포함하면 안 됩니다. 검증은 Bean Validation(@Valid)으로 처리합니다.','검증 책임을 DTO의 Bean Validation에 위임하여 Mapper의 단일 책임을 유지합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:25:46','2026-01-16 02:25:51',16,NULL,NULL,NULL,NULL),(39,1,'MAP-012','Mapper에 기본값 설정 금지','MAJOR','BEHAVIOR','request.getSortBy() != null ? request.getSortBy() : \"createdAt\" 형태의 기본값 설정을 Mapper에서 하면 안 됩니다. 기본값은 Controller 또는 DTO Compact Constructor에서 처리합니다.','기본값 설정 책임을 명확히 하여 Mapper는 순수 변환만 수행합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:25:47','2026-01-16 02:25:51',16,NULL,NULL,NULL,NULL),(40,1,'TEST-001','@WebMvcTest + RestDocsTestSupport 상속 필수','BLOCKER','STRUCTURE','REST Docs 테스트는 @WebMvcTest(TargetController.class)와 RestDocsTestSupport 상속이 필수입니다. @SpringBootTest는 사용하지 않습니다. RestDocsTestSupport는 MockMvc, ObjectMapper, REST Docs 설정을 제공합니다.','Slice Test로 빠른 테스트 실행과 REST Docs 문서 자동 생성을 위함입니다. @SpringBootTest는 전체 컨텍스트 로딩으로 느리고 불필요합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:03','2026-01-16 02:26:03',NULL,NULL,NULL,NULL,NULL),(41,1,'TEST-002','@MockitoBean UseCase/Mapper Mock 필수','BLOCKER','DEPENDENCY','Controller가 의존하는 UseCase, Mapper, 필터 의존성은 @MockitoBean으로 Mock 처리합니다. 실제 구현체 대신 Mock을 사용하여 Controller 레이어만 격리 테스트합니다.','Slice Test 원칙. Controller 테스트는 HTTP 요청/응답 변환 로직만 검증합니다. 비즈니스 로직은 UseCase 테스트에서 검증합니다.',0,1,'[\"FIELD\"]','2026-01-16 02:26:03','2026-01-16 02:26:03',NULL,NULL,NULL,NULL,NULL),(42,1,'TEST-003','REST Docs document() 문서화 필수','BLOCKER','BEHAVIOR','모든 REST Docs 테스트는 .andDo(document(\"identifier\", ...))로 문서를 생성해야 합니다. identifier는 kebab-case로 작성합니다 (예: order-create, order-update).','REST Docs를 통한 API 문서 자동 생성. 테스트가 통과해야만 문서가 생성되어 문서와 실제 API의 동기화를 보장합니다.',0,1,'[\"METHOD\"]','2026-01-16 02:26:03','2026-01-16 02:26:03',NULL,NULL,NULL,NULL,NULL),(43,1,'TEST-004','requestFields/responseFields 필드 문서화 필수','CRITICAL','BEHAVIOR','Request Body가 있는 API는 requestFields()로, Response Body가 있는 API는 responseFields()로 모든 필드를 문서화합니다. 선택 필드는 .optional() 표시 필수입니다.','필드 문서화는 API 사용자를 위한 필수 정보입니다. 필드가 누락되면 테스트가 실패하여 문서 완전성을 보장합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:26:03','2026-01-16 02:26:03',NULL,NULL,NULL,NULL,NULL),(44,1,'TEST-005','@Tag(\"restdocs\") 클래스 태그 필수','MAJOR','ANNOTATION','REST Docs 테스트 클래스에는 @Tag(\"restdocs\")를 필수로 적용합니다. Gradle에서 특정 태그의 테스트만 실행하여 문서 생성을 제어할 수 있습니다.','CI/CD에서 문서 생성 테스트만 선택적으로 실행하기 위함입니다. --tests 필터링보다 태그 기반 필터링이 유연합니다.',1,0,'[\"CLASS\"]','2026-01-16 02:26:03','2026-01-16 02:26:03',NULL,NULL,NULL,NULL,NULL),(45,1,'TEST-006','@DisplayName 한글 설명 필수','MAJOR','ANNOTATION','테스트 클래스와 메서드에 @DisplayName으로 한글 설명을 작성합니다. 클래스: \"{Controller명} REST Docs\", 메서드: \"{HTTP메서드} {URI} - {설명}\" 형식을 권장합니다.','테스트 결과 리포트에서 어떤 API를 테스트하는지 명확히 파악할 수 있습니다. 개발자 간 커뮤니케이션과 유지보수에 도움됩니다.',0,0,'[\"CLASS\", \"METHOD\"]','2026-01-16 02:26:03','2026-01-16 02:26:03',NULL,NULL,NULL,NULL,NULL),(46,1,'TEST-007','@AutoConfigureMockMvc(addFilters = false) 설정','CRITICAL','ANNOTATION','REST Docs 테스트에서 Security Filter 등을 비활성화하려면 @AutoConfigureMockMvc(addFilters = false)를 사용합니다. Filter 의존성은 @MockitoBean으로 Mock 처리합니다.','Controller 로직만 격리 테스트하기 위함입니다. Security 통합 테스트는 별도 Integration Test에서 수행합니다.',1,0,'[\"CLASS\"]','2026-01-16 02:26:03','2026-01-16 02:26:03',NULL,NULL,NULL,NULL,NULL),(47,1,'TEST-008','Given-When-Then 패턴 준수','INFO','STRUCTURE','테스트 메서드는 Given(Mock 설정, 데이터 준비), When & Then(mockMvc.perform + 검증 + 문서화) 구조로 작성합니다. 주석으로 각 단계를 구분합니다.','BDD 스타일로 테스트 의도를 명확히 합니다. 코드 리뷰와 유지보수가 용이해집니다.',0,0,'[\"METHOD\"]','2026-01-16 02:26:03','2026-01-16 02:26:03',NULL,NULL,NULL,NULL,NULL),(48,1,'TEST-009','Path/Query Parameters 문서화','CRITICAL','BEHAVIOR','Path Variable이 있는 API는 pathParameters()로, Query Parameter가 있는 API는 queryParameters()로 문서화합니다. parameterWithName()으로 설명을 추가합니다.','REST Docs가 Path/Query Parameter를 자동 인식하지 않으므로 명시적 문서화가 필요합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:26:04','2026-01-16 02:26:04',NULL,NULL,NULL,NULL,NULL),(49,1,'TEST-010','*DocsTest 네이밍 규칙','MAJOR','STRUCTURE','REST Docs 테스트 클래스명은 {Controller명}DocsTest 형식을 사용합니다 (예: OrderCommandControllerDocsTest). 패키지는 src/test/java 하위 동일 패키지 구조를 따릅니다.','Controller와 테스트 클래스의 1:1 매핑으로 테스트 위치를 쉽게 찾을 수 있습니다.',1,0,'[\"CLASS\"]','2026-01-16 02:26:04','2026-01-16 02:26:04',NULL,NULL,NULL,NULL,NULL),(50,1,'OAS-001','@Schema DTO 필드 문서화','CRITICAL','ANNOTATION','DTO의 모든 필드에 @Schema(description = \"설명\", example = \"예시값\")을 적용합니다. Record 레벨에도 @Schema(description = \"DTO 설명\")을 추가합니다.','Swagger UI에서 API 문서를 자동 생성합니다. example은 실제 사용 가능한 값을 제공하여 API 테스트를 용이하게 합니다.',1,0,'[\"FIELD\", \"CLASS\"]','2026-01-16 02:26:04','2026-01-16 02:26:06',1,NULL,NULL,NULL,NULL),(51,1,'OAS-002','@Operation Controller 메서드 문서화','CRITICAL','ANNOTATION','Controller의 모든 public 메서드에 @Operation(summary = \"요약\", description = \"상세설명\")을 적용합니다. summary는 간결하게, description은 상세하게 작성합니다.','Swagger UI에서 API 목록과 상세 정보를 제공합니다. summary는 목록에, description은 상세 페이지에 표시됩니다.',1,0,'[\"METHOD\"]','2026-01-16 02:26:04','2026-01-16 02:26:06',1,NULL,NULL,NULL,NULL),(52,1,'OAS-003','@ApiResponses 응답 코드 문서화','MAJOR','ANNOTATION','@ApiResponses에 예상되는 모든 HTTP 상태 코드(200, 201, 400, 404 등)와 설명을 작성합니다. @ApiResponse(responseCode = \"201\", description = \"생성 성공\") 형태입니다.','API 사용자가 예상할 수 있는 응답 코드와 상황을 명확히 문서화합니다.',1,0,'[\"METHOD\"]','2026-01-16 02:26:04','2026-01-16 02:26:06',1,NULL,NULL,NULL,NULL),(53,1,'OAS-004','@Tag Controller 그룹화','MAJOR','ANNOTATION','Controller 클래스에 @Tag(name = \"그룹명\", description = \"설명\")을 적용하여 API를 논리적으로 그룹화합니다 (예: @Tag(name = \"Order Command\", description = \"주문 생성/수정 API\")).','Swagger UI에서 API를 도메인별로 그룹화하여 탐색이 용이합니다.',1,0,'[\"CLASS\"]','2026-01-16 02:26:04','2026-01-16 02:26:06',1,NULL,NULL,NULL,NULL),(54,1,'CFG-001','OpenApiConfig 중앙 설정 필수','BLOCKER','STRUCTURE','OpenAPI 설정은 config/OpenApiConfig.java에서 중앙 관리합니다. API 정보(title, version, description), Security Scheme(Bearer Token), 공통 스키마(ApiResponse, ProblemDetail)를 정의합니다.','Swagger UI 일관성과 보안 설정 중앙 관리를 위함입니다. 각 Controller에서 개별 설정하면 일관성이 깨집니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:04','2026-01-16 02:26:06',19,NULL,NULL,NULL,NULL),(55,1,'CFG-002','JacksonConfig 중앙 설정 필수','BLOCKER','STRUCTURE','Jackson ObjectMapper 설정은 config/JacksonConfig.java에서 중앙 관리합니다. PropertyNamingStrategy, JavaTimeModule, Date 형식, Null 처리 등을 전역 설정합니다.','JSON 직렬화/역직렬화 일관성을 위함입니다. DTO에 @JsonFormat 등 개별 설정하면 안 됩니다 (DTO-006 참조).',0,1,'[\"CLASS\"]','2026-01-16 02:26:04','2026-01-16 02:26:06',19,NULL,NULL,NULL,NULL),(56,1,'CFG-003','@Configuration 클래스 *Config 네이밍','MAJOR','STRUCTURE','설정 클래스는 *Config 접미사를 사용합니다 (예: OpenApiConfig, JacksonConfig, WebMvcConfig). config/ 패키지에 위치합니다.','설정 클래스임을 명확히 하고, 패키지 구조로 설정 파일을 쉽게 찾을 수 있습니다.',1,0,'[\"CLASS\"]','2026-01-16 02:26:04','2026-01-16 02:26:06',19,NULL,NULL,NULL,NULL),(57,1,'CFG-004','@Bean 메서드 Javadoc 필수','INFO','DOCUMENTATION','@Bean 메서드에는 해당 Bean의 역할과 설정 내용을 Javadoc으로 문서화합니다. 복잡한 설정은 왜 그렇게 설정했는지 이유를 명시합니다.','설정 의도를 명확히 하여 유지보수 시 실수를 방지합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:26:04','2026-01-16 02:26:06',19,NULL,NULL,NULL,NULL),(61,1,'DTO-014','ApiResponse 원시타입 래핑 금지','BLOCKER','STRUCTURE','ApiResponse<T>의 제네릭 타입으로 원시타입(String, Long, Boolean 등)을 직접 사용할 수 없습니다. 단순한 응답이라도 반드시 *ApiResponse 형태의 Response DTO를 생성하여 래핑합니다. 예: ApiResponse<String> ❌ → ApiResponse<OrderIdApiResponse> ✅','원시타입 래핑 시 API 확장이 어렵고, OpenAPI 문서화가 불명확해집니다. 전용 Response DTO를 사용하면 필드 추가가 용이하고 API 스펙이 명확해집니다.',0,1,'[\"METHOD\"]','2026-01-16 02:26:15','2026-01-16 02:26:15',14,NULL,NULL,NULL,NULL),(66,2,'TSCH-001','Thin Scheduler는 @Component + @Scheduled 어노테이션 사용','MAJOR','ANNOTATION','Thin Scheduler 클래스는 @Component 어노테이션으로 빈 등록하고, 실행 메서드에 @Scheduled를 사용합니다. fixedDelay 권장 (작업 완료 후 지연). cron은 복잡한 스케줄 필요 시에만 사용합니다.','Spring 통합. Spring의 스케줄링 기능을 활용하여 주기적 실행을 트리거합니다.',1,0,'[\"CLASS\", \"METHOD\"]','2026-01-16 02:26:22','2026-01-16 02:26:22',NULL,NULL,NULL,NULL,NULL),(67,2,'TSCH-002','Thin Scheduler는 UseCase 인터페이스만 의존','BLOCKER','DEPENDENCY','Thin Scheduler는 Application Layer의 Scheduler UseCase 인터페이스만 주입받습니다. Manager, Port, Repository 등 다른 컴포넌트를 직접 주입받으면 안 됩니다. 모든 비즈니스 로직은 UseCase 구현체에 위임합니다.','Thin Layer 원칙. Controller처럼 Scheduler도 호출만 담당하고 로직을 포함하지 않습니다.',0,1,'[\"FIELD\", \"CONSTRUCTOR\"]','2026-01-16 02:26:22','2026-01-16 02:26:22',NULL,NULL,NULL,NULL,NULL),(68,2,'TSCH-003','Thin Scheduler의 @Scheduled 메서드는 UseCase.execute() 단일 호출','BLOCKER','BEHAVIOR','@Scheduled 메서드는 useCase.execute() 한 줄만 포함합니다. 조건 분기, 예외 처리, 로깅 외 로직을 추가하면 안 됩니다. 분산락 획득, 배치 처리, 상태 업데이트는 모두 UseCase 구현체에서 처리합니다.','Thin Layer 원칙. 스케줄러는 트리거 역할만 수행하고, 모든 로직은 Application Layer에 위임합니다.',0,1,'[\"METHOD\"]','2026-01-16 02:26:22','2026-01-16 02:26:22',NULL,NULL,NULL,NULL,NULL),(69,2,'TSCH-004','Thin Scheduler에 비즈니스 로직 금지','BLOCKER','BEHAVIOR','Thin Scheduler에 분산락 획득/해제, Outbox 조회, 상태 업데이트, 외부 API 호출 로직을 구현하지 않습니다. 이 모든 로직은 Application Layer의 Scheduler Service에서 처리합니다.','관심사 분리. 스케줄링 인프라와 비즈니스 로직을 명확히 분리합니다.',0,1,'[\"METHOD\"]','2026-01-16 02:26:22','2026-01-16 02:26:22',NULL,NULL,NULL,NULL,NULL),(70,2,'TSCH-005','@Scheduled는 fixedDelay 권장 (작업 중복 방지)','MAJOR','ANNOTATION','Outbox 처리 등 배치 작업에는 fixedDelay를 권장합니다. fixedDelay는 이전 작업 완료 후 지연을 적용하여 작업이 중첩되지 않습니다. fixedRate는 작업 시간이 길어지면 중첩될 수 있어 주의가 필요합니다.','작업 안전성. 처리 시간이 가변적인 배치 작업에서 중첩 실행을 방지합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:26:22','2026-01-16 02:26:22',NULL,NULL,NULL,NULL,NULL),(71,2,'TSCH-006','Thin Scheduler는 {Domain}Scheduler 또는 {Domain}OutboxScheduler 네이밍','MAJOR','NAMING','Thin Scheduler 클래스는 {Domain}Scheduler 또는 {Domain}OutboxScheduler로 네이밍합니다. 예: OrderOutboxScheduler, PaymentRetryScheduler, NotificationScheduler. 담당 도메인과 역할을 명확히 표현합니다.','네이밍 일관성. 클래스명만으로 스케줄러의 담당 영역을 파악할 수 있습니다.',0,0,'[\"CLASS\"]','2026-01-16 02:26:22','2026-01-16 02:26:22',NULL,NULL,NULL,NULL,NULL),(72,2,'TSCH-007','@Scheduled 메서드는 void 반환','MAJOR','STRUCTURE','@Scheduled 어노테이션이 적용된 메서드는 void를 반환합니다. 반환값이 있어도 Spring이 무시하므로 의미가 없습니다. 실행 결과는 UseCase 내부에서 로깅하거나 상태를 업데이트합니다.','Spring 스펙 준수. @Scheduled 메서드의 반환값은 사용되지 않습니다.',1,0,'[\"METHOD\"]','2026-01-16 02:26:22','2026-01-16 02:26:22',NULL,NULL,NULL,NULL,NULL),(73,2,'TSCH-008','Thin Scheduler는 예외 처리를 UseCase에 위임','MAJOR','BEHAVIOR','Thin Scheduler의 @Scheduled 메서드에서 try-catch를 사용하지 않습니다. 모든 예외 처리는 UseCase 구현체 내부에서 처리합니다. 필요시 최상위 예외 로깅만 허용합니다.','책임 분리. 예외 처리 로직도 비즈니스 로직의 일부이므로 Application Layer에서 처리합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:26:23','2026-01-16 02:26:23',NULL,NULL,NULL,NULL,NULL),(74,3,'AGG-001','Aggregate Lombok 어노테이션 금지','BLOCKER','ANNOTATION','Aggregate 클래스에서 @Getter, @Setter, @Data, @Builder, @NoArgsConstructor, @AllArgsConstructor 등 모든 Lombok 어노테이션 사용을 금지합니다. 순수 자바 코드로 작성해야 합니다.','Domain Layer의 순수성 유지. Lombok은 컴파일 타임 코드 생성으로 디버깅이 어렵고, Domain 로직의 명시성을 해칩니다. 모든 접근자와 생성자는 명시적으로 작성합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:33','2026-01-16 02:26:33',26,NULL,NULL,NULL,NULL),(75,3,'AGG-002','Aggregate JPA 어노테이션 금지','BLOCKER','ANNOTATION','Aggregate 클래스에서 @Entity, @Table, @Column, @Id, @ManyToOne, @OneToMany 등 모든 JPA 어노테이션 사용을 금지합니다. 영속화 관심사는 Persistence Layer의 Entity에서 처리합니다.','Domain Layer는 인프라스트럭처에 의존하면 안 됩니다. JPA는 Persistence Layer의 관심사이며, Aggregate는 순수 비즈니스 로직만 담당합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:33','2026-01-16 02:26:33',26,NULL,NULL,NULL,NULL),(76,3,'AGG-003','Aggregate Spring 어노테이션 금지','BLOCKER','ANNOTATION','Aggregate 클래스에서 @Component, @Service, @Repository, @Autowired, @Transactional 등 모든 Spring 어노테이션 사용을 금지합니다.','Domain Layer는 프레임워크에 의존하면 안 됩니다. Spring은 Application/Adapter Layer의 관심사이며, Aggregate는 POJO로 유지해야 합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:33','2026-01-16 02:26:33',26,NULL,NULL,NULL,NULL),(77,3,'AGG-004','forNew() 팩토리 메서드 필수','BLOCKER','STRUCTURE','Aggregate는 새로운 인스턴스 생성을 위한 static forNew(..., Instant now) 팩토리 메서드가 필수입니다. ID는 null(Long ID) 또는 외부 주입(String ID)하고, createdAt/updatedAt은 파라미터로 받은 Instant로 초기화합니다.','생성자를 직접 노출하지 않고 팩토리 메서드를 통해 생성 의도를 명확히 합니다. forNew는 \"새로 생성\"임을 명시하고, 시간은 외부에서 주입받아 테스트 가능성을 확보합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:34','2026-01-16 02:26:34',26,NULL,NULL,NULL,NULL),(78,3,'AGG-005','reconstitute() 팩토리 메서드 필수','BLOCKER','STRUCTURE','Aggregate는 DB에서 조회한 데이터로 복원하기 위한 static reconstitute(...) 팩토리 메서드가 필수입니다. 모든 필드를 파라미터로 받아 복원합니다. 비즈니스 검증은 수행하지 않습니다.','forNew()와 reconstitute()를 분리하여 생성과 복원의 의도를 명확히 합니다. DB 데이터는 이미 검증된 것으로 간주하여 복원 시에는 검증을 생략합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:34','2026-01-16 02:26:34',26,NULL,NULL,NULL,NULL),(79,3,'AGG-006','protected 기본 생성자','CRITICAL','STRUCTURE','Aggregate의 기본 생성자(no-args constructor)는 protected 접근 제어자를 사용합니다. public 또는 private 기본 생성자는 금지됩니다.','외부에서 빈 생성자를 통한 잘못된 객체 생성을 방지합니다. protected는 같은 패키지와 하위 클래스에서만 접근 가능하며, 팩토리 메서드 사용을 강제합니다.',1,0,'[\"CONSTRUCTOR\"]','2026-01-16 02:26:34','2026-01-16 02:26:34',26,NULL,NULL,NULL,NULL),(80,3,'AGG-007','Aggregate ID는 ID VO 사용','BLOCKER','STRUCTURE','Aggregate의 ID 필드는 원시 타입(Long) 대신 전용 ID VO(예: OrderId)를 사용해야 합니다. ID VO는 domain/{bc}/id 패키지에 위치합니다.','Primitive Obsession 안티패턴 방지. ID VO를 사용하면 타입 안전성이 보장되고, 실수로 다른 ID를 전달하는 것을 컴파일 타임에 방지합니다.',0,1,'[\"FIELD\"]','2026-01-16 02:26:34','2026-01-16 02:26:34',26,NULL,NULL,NULL,NULL),(81,3,'AGG-008','isNew() 메서드 필수','BLOCKER','STRUCTURE','Aggregate는 새로 생성된 객체인지 판단하는 isNew() 메서드가 필수입니다. Long ID의 경우 id.value() == null 또는 id.isNew()로 판단합니다.','JPA의 merge/persist 결정, Outbox 이벤트 생성 여부 등에서 신규 생성 여부 판단이 필요합니다. ID가 null이면 아직 영속화되지 않은 새 객체입니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:34','2026-01-16 02:26:34',26,NULL,NULL,NULL,NULL),(82,3,'AGG-009','Aggregate 시간 필드는 Instant 타입','BLOCKER','STRUCTURE','Aggregate의 모든 시간 필드(createdAt, updatedAt, expiredAt 등)는 java.time.Instant 타입을 사용합니다. LocalDateTime, LocalDate, Date 등은 금지됩니다.','Instant는 타임존 독립적인 시점을 나타냅니다. LocalDateTime은 타임존 정보가 없어 글로벌 서비스에서 혼란을 야기합니다. UTC 기준 저장 후 표현 계층에서 타임존 변환합니다.',0,1,'[\"FIELD\"]','2026-01-16 02:26:34','2026-01-16 02:26:34',26,NULL,NULL,NULL,NULL),(83,3,'AGG-010','Instant 파라미터 주입 (Instant.now() 금지)','BLOCKER','BEHAVIOR','Aggregate 내부에서 Instant.now() 또는 System.currentTimeMillis() 직접 호출을 금지합니다. 시간이 필요한 메서드(forNew, 상태 변경 등)는 Instant 파라미터로 받습니다. 예: forNew(..., Instant now), cancel(Instant now).','테스트 가능성 확보. Instant.now()는 테스트에서 시간을 고정할 수 없습니다. Instant 파라미터로 받으면 테스트에서 특정 시점을 주입할 수 있습니다. Application Layer에서 Instant.now()를 호출하여 전달합니다.',0,1,'[\"METHOD\"]','2026-01-16 02:26:34','2026-01-16 02:26:34',26,NULL,NULL,NULL,NULL),(84,3,'AGG-011','상태 변경 시 updatedAt 갱신','CRITICAL','BEHAVIOR','Aggregate의 상태를 변경하는 메서드(command method)는 반드시 updatedAt 필드를 갱신해야 합니다. Instant 파라미터를 통해 시간을 받습니다. 예: public void cancel(Instant now) { this.updatedAt = now; ... }','변경 이력 추적 및 낙관적 잠금에 활용됩니다. updatedAt은 마지막 수정 시점을 나타내며, 감사(Audit) 목적으로도 사용됩니다.',0,0,'[\"METHOD\"]','2026-01-16 02:26:34','2026-01-16 02:26:34',26,NULL,NULL,NULL,NULL),(85,3,'AGG-012','Aggregate Setter 메서드 금지','BLOCKER','STRUCTURE','Aggregate에서 setXxx() 형태의 Setter 메서드를 정의할 수 없습니다. 상태 변경은 비즈니스 의도를 드러내는 명시적 메서드(cancel, confirm, updatePrice 등)로 수행합니다.','Setter는 의미 없는 상태 변경을 허용합니다. 비즈니스 메서드는 변경의 의도를 명확히 하고, 불변식을 보장하며, 도메인 이벤트를 발행할 수 있습니다.',0,1,'[\"METHOD\"]','2026-01-16 02:26:34','2026-01-16 02:26:34',26,NULL,NULL,NULL,NULL),(86,3,'AGG-013','Aggregate Getter 최소화','MAJOR','STRUCTURE','Aggregate의 Getter는 외부에서 정말 필요한 경우에만 제공합니다. 내부 컬렉션은 불변 래퍼(List.copyOf, Collections.unmodifiableList)로 반환합니다.','Tell, Don\'t Ask 원칙. Getter를 통해 상태를 조회하고 외부에서 판단하는 대신, Aggregate에게 행동을 요청합니다. 내부 상태 노출을 최소화합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:26:34','2026-01-16 02:26:34',26,NULL,NULL,NULL,NULL),(87,3,'AGG-014','Law of Demeter (Getter 체이닝 금지)','BLOCKER','BEHAVIOR','order.getCustomer().getAddress().getCity()와 같은 Getter 체이닝을 금지합니다. 필요한 정보는 Aggregate 메서드를 통해 직접 반환하거나, 위임 메서드를 제공합니다.','Law of Demeter(디미터 법칙). 객체 간 결합도를 낮추고 캡슐화를 강화합니다. 체이닝은 내부 구조 변경 시 호출부 전체 수정이 필요합니다.',0,1,'[\"METHOD\"]','2026-01-16 02:26:34','2026-01-16 02:26:34',26,NULL,NULL,NULL,NULL),(88,3,'AGG-015','Tell, Don\'t Ask 원칙','CRITICAL','BEHAVIOR','상태를 조회(Getter)해서 외부에서 판단하고 다시 설정하는 대신, Aggregate에게 직접 행동을 요청합니다. if (order.getStatus() == PENDING) order.confirm() ❌ → order.confirmIfPending() ✅','비즈니스 로직이 Aggregate 외부로 유출되는 것을 방지합니다. 조건부 로직도 Aggregate 내부에서 처리하여 응집도를 높입니다.',0,0,'[\"METHOD\"]','2026-01-16 02:26:34','2026-01-16 02:26:34',26,NULL,NULL,NULL,NULL),(89,3,'AGG-016','복잡한 비즈니스 규칙은 VO로 위임','CRITICAL','BEHAVIOR','복잡한 비즈니스 규칙(할인 계산, 유효성 검증 로직 등)은 Aggregate에 직접 구현하지 않고 전용 VO(Value Object)로 추출합니다. VO가 자체적으로 판단 로직을 갖습니다. 예: Money.add(), DiscountPolicy.calculate(), Email.isValid().','단일 책임 원칙(SRP). Aggregate는 상태 관리와 불변식 보장에 집중하고, 비즈니스 규칙은 VO에 캡슐화합니다. VO는 불변이므로 테스트하기 쉽고 재사용 가능합니다.',0,0,'[\"CLASS\", \"METHOD\"]','2026-01-16 02:26:34','2026-01-16 02:26:34',26,NULL,NULL,NULL,NULL),(90,3,'AGG-017','상태 변경 시 도메인 이벤트 발행','CRITICAL','BEHAVIOR','중요한 상태 변경(생성, 취소, 완료 등)이 발생하면 해당하는 도메인 이벤트를 registerEvent()로 등록합니다. 이벤트는 Aggregate 내부 리스트에 저장됩니다.','이벤트 기반 아키텍처 지원. 도메인 이벤트를 통해 다른 바운디드 컨텍스트에 변경 사항을 전파하고, 감사 로그 생성, Outbox 패턴 구현 등에 활용합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:26:34','2026-01-16 02:26:34',26,NULL,NULL,NULL,NULL),(91,3,'AGG-018','registerEvent() protected 메서드','CRITICAL','STRUCTURE','Aggregate는 protected void registerEvent(DomainEvent event) 메서드를 가지며, 내부에서 이벤트 리스트에 추가합니다. 외부에서 직접 이벤트를 등록할 수 없습니다.','이벤트 등록은 Aggregate의 상태 변경과 함께 이루어져야 합니다. 외부에서 임의로 이벤트를 등록하면 상태와 이벤트 불일치가 발생할 수 있습니다.',0,0,'[\"METHOD\"]','2026-01-16 02:26:35','2026-01-16 02:26:35',26,NULL,NULL,NULL,NULL),(92,3,'AGG-019','pollEvents() 메서드 (이벤트 수확)','CRITICAL','STRUCTURE','Aggregate는 public List<DomainEvent> pollEvents() 메서드를 제공하여 등록된 이벤트를 반환하고 내부 리스트를 비웁니다. 호출할 때마다 새 리스트를 반환합니다.','이벤트 중복 발행 방지. poll 방식으로 이벤트를 가져가면 내부 리스트가 비워져 같은 이벤트가 두 번 처리되지 않습니다.',0,0,'[\"METHOD\"]','2026-01-16 02:26:35','2026-01-16 02:26:35',26,NULL,NULL,NULL,NULL),(93,3,'AGG-020','Command 메서드는 동사로 시작','MAJOR','NAMING','상태를 변경하는 Command 메서드는 동사로 시작합니다. 예: cancel(), confirm(), updatePrice(), addItem(). void 반환 또는 this 반환(fluent)이 가능합니다.','메서드 이름만으로 부수효과가 있는 Command인지 명확히 알 수 있습니다. 도메인 전문가도 이해할 수 있는 유비쿼터스 언어를 사용합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:26:35','2026-01-16 02:26:35',26,NULL,NULL,NULL,NULL),(94,3,'AGG-021','Query 메서드는 get/is/has/can으로 시작','MAJOR','NAMING','상태를 조회하는 Query 메서드는 getXxx(), isXxx(), hasXxx(), canXxx() 형태로 네이밍합니다. 이 메서드들은 상태를 변경하면 안 됩니다 (부수효과 없음).','CQS(Command Query Separation) 원칙. Query 메서드는 상태를 변경하지 않으므로 여러 번 호출해도 동일한 결과를 반환합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:26:35','2026-01-16 02:26:35',26,NULL,NULL,NULL,NULL),(95,3,'AGG-022','판단 메서드는 boolean 반환','MAJOR','BEHAVIOR','is*, can*, has* 형태의 판단 메서드는 boolean을 반환합니다. 복잡한 조건도 Aggregate 내부에서 판단하여 외부에 단순한 boolean으로 제공합니다.','비즈니스 로직 캡슐화. 외부에서 여러 상태를 조합하여 판단하는 대신, Aggregate가 캡슐화된 판단을 제공합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:26:35','2026-01-16 02:26:35',26,NULL,NULL,NULL,NULL),(96,3,'AGG-023','Aggregate 외부 레이어 의존 금지','BLOCKER','DEPENDENCY','Aggregate는 application, adapter 패키지에 의존할 수 없습니다. domain 패키지와 java 표준 라이브러리만 import 가능합니다.','헥사고날 아키텍처 원칙. Domain Layer는 가장 안쪽 계층으로 외부에 의존하면 안 됩니다. 의존성 역전을 통해 순수성을 유지합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:35','2026-01-16 02:26:35',26,NULL,NULL,NULL,NULL),(97,3,'AGG-024','Aggregate에서 Repository 참조 금지','BLOCKER','DEPENDENCY','Aggregate 내부에서 Repository를 호출하여 다른 Aggregate를 조회할 수 없습니다. 필요한 경우 Application Layer에서 조회하여 파라미터로 전달합니다.','Aggregate는 영속화 관심사를 모르는 순수 도메인 객체입니다. 다른 Aggregate 참조가 필요하면 ID로만 참조하거나, Application Layer에서 조합합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:35','2026-01-16 02:26:35',26,NULL,NULL,NULL,NULL),(98,3,'AGG-025','불변식(Invariant) 검증','CRITICAL','BEHAVIOR','Aggregate의 상태 변경 메서드는 불변식을 위반하는 경우 DomainException을 발생시킵니다. 잘못된 상태 전이를 방지합니다. 예: 취소된 주문은 다시 취소할 수 없음.','Aggregate는 항상 유효한 상태를 유지해야 합니다. 불변식 위반 시 명확한 도메인 예외를 발생시켜 호출자에게 알립니다.',0,0,'[\"METHOD\"]','2026-01-16 02:26:35','2026-01-16 02:26:35',26,NULL,NULL,NULL,NULL),(99,3,'AGG-026','equals/hashCode는 ID 기반','MAJOR','STRUCTURE','Aggregate의 equals()와 hashCode()를 정의할 경우 ID 필드만 사용합니다. 다른 필드를 포함하면 상태 변경 시 해시값이 변경되어 컬렉션 사용에 문제가 발생합니다.','Aggregate는 ID로 식별됩니다. 같은 ID를 가진 두 객체는 상태가 달라도 동일한 엔티티입니다. 새 객체(ID가 null)는 equals 비교에 주의가 필요합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:26:35','2026-01-16 02:26:35',26,NULL,NULL,NULL,NULL),(100,3,'AGG-027','불변 필드는 final 선언','MINOR','STRUCTURE','생성 후 변경되지 않는 필드(ID, createdAt 등)는 final로 선언합니다. 단, JPA 매핑을 위해 Persistence Layer Entity에서는 final을 사용하지 않을 수 있습니다.','불변성을 컴파일러 수준에서 보장합니다. final 필드는 생성자에서만 할당 가능하므로 실수로 변경하는 것을 방지합니다.',0,0,'[\"FIELD\"]','2026-01-16 02:26:35','2026-01-16 02:26:35',26,NULL,NULL,NULL,NULL),(101,3,'ID-001','*Id 네이밍 필수','BLOCKER','NAMING','ID Value Object는 *Id 네이밍 규칙 필수 (예: OrderId, UserId, ProductId). 식별자임을 명확히 표현합니다.','Primitive Obsession 방지. 타입 이름만으로 ID VO임을 명확히 알 수 있어 실수로 다른 타입의 ID를 전달하는 것을 컴파일 타임에 방지합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:36','2026-01-16 02:26:36',27,NULL,NULL,NULL,NULL),(102,3,'ID-002','Record 타입 필수','BLOCKER','STRUCTURE','ID Value Object는 Java Record 타입으로 정의해야 합니다. 예: public record OrderId(Long value) {}','Record는 equals/hashCode/toString을 자동 생성하고 불변성을 보장합니다. ID는 값 객체이므로 Record가 가장 적합합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:36','2026-01-16 02:26:36',27,NULL,NULL,NULL,NULL),(103,3,'ID-003','of() 정적 팩토리 메서드 필수','BLOCKER','STRUCTURE','ID Value Object는 public static XxxId of(Long/String value) 정적 팩토리 메서드가 필수입니다. 기존 ID 값을 복원할 때 사용합니다.','생성 의도를 명확히 하고, 검증 로직을 포함할 수 있습니다. of()는 기존에 영속화된 ID를 복원하는 용도로 사용됩니다.',0,1,'[\"METHOD\"]','2026-01-16 02:26:36','2026-01-16 02:26:36',27,NULL,NULL,NULL,NULL),(104,3,'ID-004','Long ID forNew() 필수','BLOCKER','STRUCTURE','Long 기반 ID VO는 public static XxxId forNew() 메서드가 필수입니다. 신규 Aggregate 생성 시 사용하며, Auto Increment를 위해 null을 반환합니다.','forNew()는 \"새로 생성\"의 의도를 명확히 합니다. DB Auto Increment 전략에서는 ID가 null인 상태로 persist해야 합니다.',0,1,'[\"METHOD\"]','2026-01-16 02:26:37','2026-01-16 02:26:37',27,NULL,NULL,NULL,NULL),(105,3,'ID-005','Long ID forNew()는 null 반환','BLOCKER','BEHAVIOR','Long ID의 forNew()는 new XxxId(null)을 반환해야 합니다. JPA Auto Increment가 persist 시점에 실제 ID를 할당합니다.','JPA의 Auto Increment 전략 호환. ID가 null이면 insert, 값이 있으면 update로 판단합니다.',0,1,'[\"METHOD\"]','2026-01-16 02:26:37','2026-01-16 02:26:37',27,NULL,NULL,NULL,NULL),(106,3,'ID-006','Long ID isNew() 필수','BLOCKER','STRUCTURE','Long 기반 ID VO는 public boolean isNew() 메서드가 필수입니다. value == null 또는 value.equals(null)을 체크하여 신규 생성 여부를 반환합니다.','Aggregate.isNew() 구현에 활용됩니다. JPA merge/persist 결정, Outbox 이벤트 생성 여부 판단 등에 사용됩니다.',0,1,'[\"METHOD\"]','2026-01-16 02:26:37','2026-01-16 02:26:37',27,NULL,NULL,NULL,NULL),(107,3,'ID-007','String ID isNew() 금지','BLOCKER','BEHAVIOR','String 기반 ID VO는 isNew() 메서드를 가지면 안 됩니다. UUID/UUIDv7/Snowflake 등 String ID는 생성 시점에 이미 값이 존재하므로 신규 여부를 ID로 판단할 수 없습니다.','String ID는 생성 시점에 값이 할당되므로 null 체크로 신규 여부를 판단할 수 없습니다. 필요 시 Aggregate에 별도 플래그를 사용하세요.',0,1,'[\"CLASS\"]','2026-01-16 02:26:37','2026-01-16 02:26:37',27,NULL,NULL,NULL,NULL),(108,3,'ID-008','String ID는 외부에서 주입','BLOCKER','BEHAVIOR','String 기반 ID VO는 내부에서 UUID를 생성하지 않습니다. forNew(String value) 형태로 외부에서 String 값을 주입받습니다. Application Layer의 ID Generator가 UUIDv7, Snowflake 등을 생성하여 전달합니다.','ID 생성 전략(UUID, UUIDv7, Snowflake 등)을 Domain Layer에서 결정하면 유연성이 떨어집니다. Application/Infrastructure Layer에서 ID를 생성하여 Domain에 주입하면 전략 변경이 용이합니다.',0,1,'[\"METHOD\"]','2026-01-16 02:26:37','2026-01-16 02:26:37',27,NULL,NULL,NULL,NULL),(109,3,'ID-009','ID VO Lombok 금지','BLOCKER','ANNOTATION','ID Value Object에서 @Getter, @Setter, @Data, @Builder, @Value, @RequiredArgsConstructor 등 모든 Lombok 어노테이션 사용을 금지합니다.','Domain Layer 순수 자바 원칙. Record 타입은 이미 접근자와 equals/hashCode를 제공하므로 Lombok이 불필요합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:37','2026-01-16 02:26:37',27,NULL,NULL,NULL,NULL),(110,3,'ID-010','ID VO JPA/Spring 금지','BLOCKER','ANNOTATION','ID Value Object에서 @Entity, @Table, @Id, @Column, @Embeddable, @Component, @Service, @Repository 등 JPA/Spring 어노테이션 사용을 금지합니다.','Domain Layer는 인프라스트럭처/프레임워크에 의존하면 안 됩니다. JPA 매핑은 Persistence Layer Entity에서 처리합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:37','2026-01-16 02:26:37',27,NULL,NULL,NULL,NULL),(111,3,'VO-001','Record 타입 필수','BLOCKER','STRUCTURE','Value Object는 Java Record 타입으로 정의해야 합니다 (Enum/Interface 제외). 예: public record Email(String value) {}','Record는 equals/hashCode/toString을 자동 생성하고 불변성을 보장합니다. VO는 값으로 비교되므로 Record가 가장 적합합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:38','2026-01-16 02:26:38',28,NULL,NULL,NULL,NULL),(112,3,'VO-002','of() 정적 팩토리 메서드 필수','BLOCKER','STRUCTURE','Value Object는 public static XxxVo of(...) 정적 팩토리 메서드가 필수입니다. 생성 시 검증 로직을 포함합니다.','생성 의도를 명확히 하고, 검증 로직을 포함하여 유효한 객체만 생성되도록 보장합니다.',0,1,'[\"METHOD\"]','2026-01-16 02:26:38','2026-01-16 02:26:38',28,NULL,NULL,NULL,NULL),(113,3,'VO-003','Compact Constructor 검증 필수','BLOCKER','BEHAVIOR','Record의 Compact Constructor에서 필드 검증이 필수입니다 (null 체크, 빈값 체크, 형식 검증 등). 예: public Email { if (value == null || value.isBlank()) throw ... }','VO는 항상 유효한 상태로만 존재해야 합니다. 생성자에서 검증하면 불변식(Invariant)을 보장할 수 있습니다.',0,1,'[\"CONSTRUCTOR\"]','2026-01-16 02:26:38','2026-01-16 02:26:38',28,NULL,NULL,NULL,NULL),(114,3,'VO-004','Enum VO displayName() 필수','CRITICAL','STRUCTURE','Enum Value Object는 public String displayName() 메서드가 필수입니다. 사용자에게 표시되는 한글/영문 이름을 반환합니다.','Enum의 name()은 코드용이고 displayName()은 사용자 표시용입니다. UI에서 직접 Enum을 사용할 때 필요합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:26:39','2026-01-16 02:26:39',28,NULL,NULL,NULL,NULL),(115,3,'VO-005','LockKey 인터페이스 구현 (선택적)','CRITICAL','STRUCTURE','[Lock 기능 사용 시 적용] *LockKey VO는 LockKey 인터페이스를 구현하고 value() 메서드가 필수입니다. 분산 락 키 생성에 사용됩니다. 예: public record OrderLockKey(Long orderId) implements LockKey { @Override public String value() { return \"order:\" + orderId; } }','LockKey 인터페이스를 통해 락 키 생성 방식을 표준화합니다. Domain Layer에서 락 키의 형식과 네이밍을 제어할 수 있습니다.',0,0,'[\"CLASS\"]','2026-01-16 02:26:39','2026-01-16 02:26:39',28,NULL,NULL,NULL,NULL),(116,3,'VO-006','CacheKey 인터페이스 구현 (선택적)','CRITICAL','STRUCTURE','[Cache 기능 사용 시 적용] *CacheKey VO는 CacheKey 인터페이스를 구현하고 value() 메서드가 필수입니다. 캐시 키 생성에 사용됩니다. 예: public record OrderCacheKey(Long orderId) implements CacheKey { @Override public String value() { return \"order:cache:\" + orderId; } }','CacheKey 인터페이스를 통해 캐시 키 생성 방식을 표준화합니다. 키 형식의 일관성과 네이밍 충돌 방지를 보장합니다.',0,0,'[\"CLASS\"]','2026-01-16 02:26:39','2026-01-16 02:26:39',28,NULL,NULL,NULL,NULL),(117,3,'VO-007','VO Lombok 금지','BLOCKER','ANNOTATION','Value Object에서 @Getter, @Setter, @Data, @Builder, @Value, @RequiredArgsConstructor, @AllArgsConstructor 등 모든 Lombok 어노테이션 사용을 금지합니다.','Domain Layer 순수 자바 원칙. Record 타입은 이미 접근자와 equals/hashCode를 제공하므로 Lombok이 불필요합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:39','2026-01-16 02:26:39',28,NULL,NULL,NULL,NULL),(118,3,'VO-008','VO JPA 금지','BLOCKER','ANNOTATION','Value Object에서 @Entity, @Table, @Id, @Column, @Embeddable, @Embedded 등 JPA 어노테이션 사용을 금지합니다.','Domain Layer는 인프라스트럭처에 의존하면 안 됩니다. JPA 매핑은 Persistence Layer Entity에서 처리합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:39','2026-01-16 02:26:39',28,NULL,NULL,NULL,NULL),(119,3,'VO-009','VO Spring 금지','BLOCKER','ANNOTATION','Value Object에서 @Component, @Service, @Repository, @Transactional, @Autowired 등 Spring 어노테이션 사용을 금지합니다.','Domain Layer는 Spring Framework에 의존하면 안 됩니다. VO는 순수 자바 객체로 유지해야 합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:39','2026-01-16 02:26:39',28,NULL,NULL,NULL,NULL),(120,4,'EVT-001','DomainEvent 인터페이스 구현 필수','BLOCKER','STRUCTURE','Domain Event는 DomainEvent 인터페이스를 구현해야 합니다. 예: public record OrderCreatedEvent(...) implements DomainEvent {}','DomainEvent 인터페이스를 통해 이벤트 타입을 식별하고, 공통 메서드(occurredAt 등)를 강제합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:40','2026-01-16 06:50:28',29,NULL,NULL,NULL,NULL),(121,4,'EVT-002','Record 타입 필수','BLOCKER','STRUCTURE','Domain Event는 Java Record 타입으로 정의해야 합니다. 불변성을 보장합니다. 예: public record OrderCreatedEvent(OrderId orderId, Instant occurredAt) implements DomainEvent {}','Event는 발생한 사실을 나타내므로 불변이어야 합니다. Record는 불변성과 값 비교를 자동으로 보장합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:40','2026-01-16 06:50:28',29,NULL,NULL,NULL,NULL),(122,4,'EVT-003','occurredAt (Instant) 필드 필수','BLOCKER','STRUCTURE','Domain Event는 Instant occurredAt 필드가 필수입니다. 이벤트 발생 시점을 기록합니다.','이벤트 발생 시점은 이벤트 소싱, 감사 로그, 순서 정렬 등에 필수입니다. Instant 타입으로 타임존 독립적 시간을 저장합니다.',0,1,'[\"FIELD\"]','2026-01-16 02:26:40','2026-01-16 06:50:28',29,NULL,NULL,NULL,NULL),(123,4,'EVT-004','from(Aggregate, Instant) 정적 팩토리 메서드 필수','BLOCKER','STRUCTURE','Domain Event는 public static XxxEvent from(Aggregate, Instant now) 정적 팩토리 메서드가 필수입니다. Aggregate에서 필요한 정보를 추출하여 Event를 생성합니다.','Aggregate의 내부 상태를 캡슐화하면서 필요한 정보만 Event로 전달합니다. Instant 파라미터로 테스트 가능성을 확보합니다.',0,1,'[\"METHOD\"]','2026-01-16 02:26:40','2026-01-16 06:50:28',29,NULL,NULL,NULL,NULL),(124,4,'EVT-005','과거형 네이밍 필수 (*Event)','BLOCKER','NAMING','Domain Event는 과거형 네이밍이 필수입니다. OrderCreatedEvent(✅), OrderCancelledEvent(✅), OrderPaidEvent(✅). 현재/미래형 금지: OrderCreateEvent(❌), OrderCancelEvent(❌).','Event는 \"이미 발생한 사실\"을 나타내므로 과거형이어야 합니다. 현재형/명령형은 Command와 혼동될 수 있습니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:40','2026-01-16 06:50:28',29,NULL,NULL,NULL,NULL),(125,4,'EVT-006','domain.[bc].event 패키지 위치','BLOCKER','LOCATION','Domain Event는 domain.[bc].event 패키지에 위치해야 합니다. 예: domain.order.event.OrderCreatedEvent.','도메인 이벤트는 도메인 레이어에 속하며, Bounded Context별로 이벤트를 그룹화하여 관리합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:40','2026-01-16 06:50:28',29,NULL,NULL,NULL,NULL),(126,4,'EVT-007','Event Lombok 금지','BLOCKER','ANNOTATION','Domain Event에서 @Getter, @Setter, @Data, @Builder, @Value, @RequiredArgsConstructor, @AllArgsConstructor 등 모든 Lombok 어노테이션 사용을 금지합니다.','Domain Layer 순수 자바 원칙. Record 타입은 이미 접근자와 equals/hashCode를 제공하므로 Lombok이 불필요합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:41','2026-01-16 06:50:28',29,NULL,NULL,NULL,NULL),(127,4,'EVT-008','Event JPA 금지','BLOCKER','ANNOTATION','Domain Event에서 @Entity, @Table, @Id, @Column, @Embeddable, @Embedded 등 JPA 어노테이션 사용을 금지합니다.','Domain Layer는 인프라스트럭처에 의존하면 안 됩니다. Event 영속화는 Outbox 패턴 등 별도 메커니즘으로 처리합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:41','2026-01-16 06:50:28',29,NULL,NULL,NULL,NULL),(128,4,'EVT-009','Event Spring 금지','BLOCKER','ANNOTATION','Domain Event에서 @Component, @Service, @Repository, @Transactional, @Autowired, @EventListener 등 Spring 어노테이션 사용을 금지합니다.','Domain Layer는 Spring Framework에 의존하면 안 됩니다. Event Listener는 Application/Adapter Layer에서 구현합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:41','2026-01-16 06:50:28',29,NULL,NULL,NULL,NULL),(129,4,'EVT-010','Event org.springframework.* 의존 금지','BLOCKER','DEPENDENCY','Domain Event에서 org.springframework.* 패키지 import를 금지합니다.','Domain Layer는 프레임워크에 독립적이어야 합니다. 순수 자바로 유지하여 테스트 용이성과 이식성을 확보합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:41','2026-01-16 06:50:28',29,NULL,NULL,NULL,NULL),(130,4,'EVT-011','Event 외부 레이어 의존 금지','BLOCKER','DEPENDENCY','Domain Event에서 Application Layer, Adapter Layer, Bootstrap Layer 의존을 금지합니다. import *.application.*, *.adapter.*, *.bootstrap.* 금지.','헥사고날 아키텍처의 의존성 역전 원칙. Domain Layer는 가장 안쪽에 위치하며 외부 레이어에 의존하면 안 됩니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:41','2026-01-16 06:50:28',29,NULL,NULL,NULL,NULL),(131,3,'EXC-001','ErrorCode 인터페이스 구현 필수','BLOCKER','STRUCTURE','ErrorCode Enum은 ErrorCode 인터페이스를 구현해야 합니다. 예: public enum OrderErrorCode implements ErrorCode { ... }','ErrorCode 인터페이스를 통해 공통 메서드(getCode, getHttpStatus, getMessage)를 강제하고 일관성을 보장합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:42','2026-01-16 02:26:42',30,NULL,NULL,NULL,NULL),(132,3,'EXC-002','ErrorCode domain.[bc].exception 패키지','BLOCKER','LOCATION','ErrorCode Enum은 domain.[bc].exception 패키지에 위치해야 합니다. 예: domain.order.exception.OrderErrorCode.','Bounded Context별로 ErrorCode를 그룹화하여 관리합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:42','2026-01-16 02:26:42',30,NULL,NULL,NULL,NULL),(133,3,'EXC-003','ErrorCode Lombok 금지','BLOCKER','ANNOTATION','ErrorCode Enum에서 @Getter, @Setter, @Data, @RequiredArgsConstructor 등 Lombok 어노테이션 사용을 금지합니다.','Domain Layer 순수 자바 원칙. Enum은 간단하므로 Lombok이 불필요합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:42','2026-01-16 02:26:42',30,NULL,NULL,NULL,NULL),(134,3,'EXC-004','ErrorCode public 접근 제어자','BLOCKER','STRUCTURE','ErrorCode Enum은 public 접근 제어자가 필수입니다. 예: public enum OrderErrorCode implements ErrorCode { ... }','Application Layer, Adapter Layer에서 ErrorCode를 사용하기 위해 public이어야 합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:42','2026-01-16 02:26:42',30,NULL,NULL,NULL,NULL),(135,3,'EXC-005','getCode() 메서드 필수','BLOCKER','STRUCTURE','ErrorCode Enum은 String getCode() 메서드가 필수입니다. API 응답에서 사용되는 고유 에러 코드를 반환합니다.','에러 코드는 클라이언트가 에러를 식별하고 처리하는 데 사용됩니다. 예: \"ORDER_NOT_FOUND\", \"PAYMENT_FAILED\".',0,1,'[\"METHOD\"]','2026-01-16 02:26:42','2026-01-16 02:26:42',30,NULL,NULL,NULL,NULL),(136,3,'EXC-006','getHttpStatus() int 타입 반환','BLOCKER','STRUCTURE','ErrorCode Enum은 int getHttpStatus() 메서드가 필수입니다. Spring HttpStatus가 아닌 int 타입으로 반환합니다. 예: return 404;','Domain Layer가 Spring에 의존하지 않도록 int 타입을 사용합니다. Adapter Layer에서 HttpStatus로 변환합니다.',0,1,'[\"METHOD\"]','2026-01-16 02:26:42','2026-01-16 02:26:42',30,NULL,NULL,NULL,NULL),(137,3,'EXC-007','getMessage() 메서드 필수','BLOCKER','STRUCTURE','ErrorCode Enum은 String getMessage() 메서드가 필수입니다. 사용자에게 표시되는 에러 메시지를 반환합니다.','에러 메시지는 사용자가 에러 원인을 이해하는 데 도움을 줍니다.',0,1,'[\"METHOD\"]','2026-01-16 02:26:42','2026-01-16 02:26:42',30,NULL,NULL,NULL,NULL),(138,3,'EXC-008','Spring HttpStatus 사용 금지','BLOCKER','DEPENDENCY','ErrorCode Enum에서 org.springframework.http.HttpStatus 사용을 금지합니다. int 타입으로 HTTP 상태 코드를 저장합니다.','Domain Layer는 Spring Framework에 의존하면 안 됩니다. int 타입(400, 404, 500 등)으로 표현합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:43','2026-01-16 02:26:43',30,NULL,NULL,NULL,NULL),(139,3,'EXC-009','DomainException 상속 필수','BLOCKER','STRUCTURE','Concrete Exception은 DomainException을 상속해야 합니다. 예: public class OrderNotFoundException extends DomainException { ... }','DomainException 공통 기능(ErrorCode 연동 등)을 상속받아 일관된 예외 처리를 보장합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:43','2026-01-16 02:26:43',30,NULL,NULL,NULL,NULL),(140,3,'EXC-010','Exception domain.[bc].exception 패키지','BLOCKER','LOCATION','Concrete Exception은 domain.[bc].exception 패키지에 위치해야 합니다. 예: domain.order.exception.OrderNotFoundException.','Bounded Context별로 Exception을 그룹화하여 관리합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:43','2026-01-16 02:26:43',30,NULL,NULL,NULL,NULL),(141,3,'EXC-011','Exception Lombok 금지','BLOCKER','ANNOTATION','Exception에서 @Getter, @Setter, @Data, @Builder, @RequiredArgsConstructor 등 Lombok 어노테이션 사용을 금지합니다.','Domain Layer 순수 자바 원칙. Exception은 간단하므로 Lombok이 불필요합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:43','2026-01-16 02:26:43',30,NULL,NULL,NULL,NULL),(142,3,'EXC-012','Exception JPA 금지','BLOCKER','ANNOTATION','Exception에서 @Entity, @Table, @Id, @Column 등 JPA 어노테이션 사용을 금지합니다.','Domain Layer는 인프라스트럭처에 의존하면 안 됩니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:43','2026-01-16 02:26:43',30,NULL,NULL,NULL,NULL),(143,3,'EXC-013','Exception Spring 금지','BLOCKER','ANNOTATION','Exception에서 @Component, @Service, @Repository, @Transactional 등 Spring 어노테이션 사용을 금지합니다.','Domain Layer는 Spring Framework에 의존하면 안 됩니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:43','2026-01-16 02:26:43',30,NULL,NULL,NULL,NULL),(144,3,'EXC-014','Exception public 클래스','BLOCKER','STRUCTURE','Exception은 public 클래스가 필수입니다. 예: public class OrderNotFoundException extends DomainException { ... }','Application Layer, Adapter Layer에서 Exception을 catch하기 위해 public이어야 합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:43','2026-01-16 02:26:43',30,NULL,NULL,NULL,NULL),(145,3,'EXC-015','RuntimeException 계층 (Unchecked)','BLOCKER','STRUCTURE','Exception은 RuntimeException 계층이어야 합니다 (Unchecked Exception). DomainException은 RuntimeException을 상속합니다.','Unchecked Exception으로 메서드 시그니처를 깨끗하게 유지하고, 글로벌 예외 처리기에서 일괄 처리합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:43','2026-01-16 02:26:43',30,NULL,NULL,NULL,NULL),(146,3,'EXC-016','Exception 외부 레이어 의존 금지','BLOCKER','DEPENDENCY','Exception에서 Application Layer, Adapter Layer, Bootstrap Layer 의존을 금지합니다.','헥사고날 아키텍처의 의존성 역전 원칙. Domain Layer는 외부 레이어에 의존하면 안 됩니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:43','2026-01-16 02:26:43',30,NULL,NULL,NULL,NULL),(147,3,'EXC-017','Exception Spring Framework 의존 금지','BLOCKER','DEPENDENCY','Exception에서 org.springframework.* 패키지 import를 금지합니다.','Domain Layer는 프레임워크에 독립적이어야 합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:43','2026-01-16 02:26:43',30,NULL,NULL,NULL,NULL),(148,3,'EXC-018','명확한 비즈니스 네이밍','CRITICAL','NAMING','Exception은 명확한 비즈니스 의미를 담은 네이밍을 사용합니다. 권장 패턴: NotFound, Invalid, AlreadyExists, Cannot, Failed, Duplicate, Conflict, Forbidden, Unauthorized, Expired 등.','Exception 이름만으로 에러 원인을 파악할 수 있어야 합니다. 예: OrderNotFoundException, PaymentFailedException.',0,0,'[\"CLASS\"]','2026-01-16 02:26:43','2026-01-16 02:26:43',30,NULL,NULL,NULL,NULL),(149,3,'EXC-019','DomainException common 패키지','BLOCKER','LOCATION','DomainException 기본 클래스는 domain.common.exception 패키지에 위치해야 합니다.','공통 Exception은 common 패키지에서 관리하여 모든 Bounded Context에서 재사용합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:43','2026-01-16 02:26:43',30,NULL,NULL,NULL,NULL),(150,3,'EXC-020','ErrorCode 인터페이스 common 패키지','BLOCKER','LOCATION','ErrorCode 인터페이스는 domain.common.exception 패키지에 위치해야 합니다.','공통 인터페이스는 common 패키지에서 관리하여 모든 Bounded Context에서 구현합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:43','2026-01-16 02:26:43',30,NULL,NULL,NULL,NULL),(151,3,'CRI-001','domain.[bc].query 패키지','BLOCKER','LOCATION','Criteria는 domain.[bc].query 패키지에 위치해야 합니다. 예: domain.order.query.OrderSearchCriteria.','Query 관련 객체를 query 하위 패키지로 분리하여 CQRS 패턴을 명확히 합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:45','2026-01-16 02:26:45',31,NULL,NULL,NULL,NULL),(152,3,'CRI-002','*Criteria 네이밍 규칙','BLOCKER','NAMING','Criteria는 *Criteria 또는 *SearchCriteria 네이밍 규칙이 필수입니다. 예: OrderCriteria, OrderSearchCriteria.','네이밍만으로 조회 조건 객체임을 명확히 알 수 있어야 합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:45','2026-01-16 02:26:45',31,NULL,NULL,NULL,NULL),(153,3,'CRI-003','Criteria public 접근 제어자','BLOCKER','STRUCTURE','Criteria는 public 클래스가 필수입니다. 예: public record OrderSearchCriteria(...) {}','Application Layer, Adapter Layer에서 Criteria를 사용하기 위해 public이어야 합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:45','2026-01-16 02:26:45',31,NULL,NULL,NULL,NULL),(154,3,'CRI-004','Record 타입 필수','BLOCKER','STRUCTURE','Criteria는 Java Record 타입으로 정의해야 합니다. 불변성을 보장합니다. 예: public record OrderSearchCriteria(OrderStatus status, DateRange dateRange, PageRequest page) {}','Record는 불변성과 값 비교를 자동으로 보장합니다. Criteria는 조회 조건을 담는 값 객체이므로 불변이어야 합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:45','2026-01-16 02:26:45',31,NULL,NULL,NULL,NULL),(155,3,'CRI-005','of() 정적 팩토리 메서드 필수','BLOCKER','STRUCTURE','Criteria는 public static XxxCriteria of(...) 정적 팩토리 메서드가 필수입니다. 기본값 적용 및 검증 로직을 포함합니다.','of() 메서드에서 기본값(default page size 등)을 적용하고, 필수 조건 검증을 수행합니다.',0,1,'[\"METHOD\"]','2026-01-16 02:26:45','2026-01-16 02:26:45',31,NULL,NULL,NULL,NULL),(156,3,'CRI-006','Criteria Lombok 금지','BLOCKER','ANNOTATION','Criteria에서 @Getter, @Setter, @Data, @Builder, @Value, @RequiredArgsConstructor, @AllArgsConstructor 등 모든 Lombok 어노테이션 사용을 금지합니다.','Domain Layer 순수 자바 원칙. Record 타입은 이미 접근자와 equals/hashCode를 제공하므로 Lombok이 불필요합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:45','2026-01-16 02:26:45',31,NULL,NULL,NULL,NULL),(157,3,'CRI-007','Criteria JPA 금지','BLOCKER','ANNOTATION','Criteria에서 @Entity, @Table, @Id, @Column, @Embeddable, @Embedded 등 JPA 어노테이션 사용을 금지합니다.','Domain Layer는 인프라스트럭처에 의존하면 안 됩니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:45','2026-01-16 02:26:45',31,NULL,NULL,NULL,NULL),(158,3,'CRI-008','Criteria Spring 금지','BLOCKER','ANNOTATION','Criteria에서 @Component, @Service, @Repository, @Transactional, @Autowired 등 Spring 어노테이션 사용을 금지합니다.','Domain Layer는 Spring Framework에 의존하면 안 됩니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:45','2026-01-16 02:26:45',31,NULL,NULL,NULL,NULL),(159,3,'CRI-009','Criteria 외부 레이어 의존 금지','BLOCKER','DEPENDENCY','Criteria에서 Application Layer, Adapter Layer, Bootstrap Layer 의존을 금지합니다.','헥사고날 아키텍처의 의존성 역전 원칙. Domain Layer는 외부 레이어에 의존하면 안 됩니다.',0,1,'[\"CLASS\"]','2026-01-16 02:26:45','2026-01-16 02:26:45',31,NULL,NULL,NULL,NULL),(160,3,'CRI-010','공통 VO 사용 권장','MINOR','BEHAVIOR','Criteria는 DateRange, SortDirection, PageRequest, CursorPageRequest, SortKey, QueryContext 등 공통 VO 사용을 권장합니다.','공통 VO를 사용하면 조회 조건의 일관성을 유지하고, 반복적인 코드를 줄일 수 있습니다.',0,0,'[\"CLASS\"]','2026-01-16 02:26:45','2026-01-16 02:26:45',31,NULL,NULL,NULL,NULL),(161,4,'C-001','Lombok 사용 금지','BLOCKER','ANNOTATION','@Data, @Builder, @Getter, @Setter, @RequiredArgsConstructor 등 모든 Lombok 어노테이션 사용이 금지됩니다. 생성자 주입은 명시적으로 작성하고, Record는 Lombok 없이 사용합니다.','Pure Java 원칙. 컴파일 타임에 코드가 명확히 보이고, IDE 지원이 확실하며, 바이트코드 조작으로 인한 예측 불가능한 동작을 방지합니다.',0,1,'[\"CLASS\", \"RECORD\"]','2026-01-16 02:27:04','2026-01-16 06:50:28',NULL,NULL,NULL,NULL,NULL),(162,4,'C-002','변환기에서 null 체크 금지','BLOCKER','BEHAVIOR','Factory, Assembler 등 변환기 클래스에서 입력값 null 체크를 하면 안 됩니다. null 검증은 REST-API Layer의 Mapper에서 이미 처리되었으므로, Application Layer에서 중복 검증은 불필요합니다.','Fail-fast 원칙. REST-API Mapper에서 null이 유효한 값인지 검증 후 전달합니다. null이 넘어오면 시스템 오류이므로 NullPointerException이 발생해야 합니다.',0,1,'[\"METHOD\"]','2026-01-16 02:27:04','2026-01-16 06:50:28',NULL,NULL,NULL,NULL,NULL),(163,4,'C-003','변환기에서 기본값 할당 금지','BLOCKER','BEHAVIOR','Factory, Assembler 등 변환기에서 null을 기본값으로 대체하면 안 됩니다. (예: name != null ? name : \"Unknown\" 금지) null은 null 그대로 전달하고, 기본값 결정은 Domain 영역의 책임입니다.','단일 책임 원칙. 변환기는 \"형태 변환\"만 담당하고, 비즈니스 규칙(기본값 정책)은 Domain에서 처리해야 합니다.',0,1,'[\"METHOD\"]','2026-01-16 02:27:04','2026-01-16 06:50:28',NULL,NULL,NULL,NULL,NULL),(164,4,'C-004','@Transactional은 Manager/Facade에서만 메서드 단위로','BLOCKER','ANNOTATION','@Transactional 어노테이션은 오직 Manager(PersistenceManager, ReadManager)와 Facade(RDB Manager만 의존 시)에서만 사용합니다. Service, Factory, Assembler 등에서는 절대 금지입니다. 클래스 단위가 아닌 메서드 단위로만 사용합니다.','트랜잭션 경계 명확화. 트랜잭션을 짧게 유지하여 외부 호출이 트랜잭션에 묶이는 것을 방지합니다. Spring 프록시 제약(private, final, 내부 호출 불가)도 고려합니다.',0,1,'[\"CLASS\", \"METHOD\"]','2026-01-16 02:27:04','2026-01-16 06:50:28',NULL,NULL,NULL,NULL,NULL),(165,4,'C-005','Port(Out) 직접 주입 금지','BLOCKER','DEPENDENCY','Service, Factory, Assembler 등에서 CommandPort, QueryPort를 직접 주입받으면 안 됩니다. 반드시 Manager(PersistenceManager, ReadManager)를 통해 래핑하여 사용해야 합니다.','트랜잭션 경계 일관성. Port를 직접 사용하면 트랜잭션 없이 DB 접근이 발생할 수 있습니다. Manager로 래핑하여 모든 영속성 접근에 트랜잭션을 보장합니다.',0,1,'[\"FIELD\", \"CONSTRUCTOR\"]','2026-01-16 02:27:05','2026-01-16 06:50:28',NULL,NULL,NULL,NULL,NULL),(166,4,'C-006','시간/ID 생성은 Factory에서만','BLOCKER','BEHAVIOR','Instant.now(), LocalDateTime.now(), UUID.randomUUID() 등 시간이나 ID 생성 로직은 Factory에서만 허용됩니다. Service, Assembler 등 다른 컴포넌트에서는 금지됩니다.','단일 책임 원칙. 시간/ID 생성을 Factory에 집중하여 테스트 용이성을 확보하고, TimeProvider/IdGeneratorPort를 통한 추상화가 가능합니다.',0,1,'[\"METHOD\"]','2026-01-16 02:27:05','2026-01-16 06:50:28',NULL,NULL,NULL,NULL,NULL),(167,4,'C-007','이벤트 객체 생성은 Domain에서','BLOCKER','BEHAVIOR','DomainEvent 객체를 new OrderCreatedEvent(...) 형태로 Service, Factory에서 직접 생성하면 안 됩니다. Domain Aggregate 내부에서 이벤트 객체를 생성하고, Application Layer는 이를 발행만 담당합니다.','DDD 원칙. 도메인 이벤트는 도메인 상태 변경의 결과물이므로, Aggregate가 자신의 상태 변경 시 이벤트를 생성하는 것이 자연스럽습니다.',0,1,'[\"METHOD\"]','2026-01-16 02:27:05','2026-01-16 06:50:28',NULL,NULL,NULL,NULL,NULL),(168,4,'C-008','Tell, Don\'t Ask 원칙 준수','CRITICAL','BEHAVIOR','Service에서 Domain의 상태를 조회(get)하여 판단 후 행동하는 패턴을 금지합니다. (예: if(order.getStatus() == PAID) { order.ship(); } 금지) 대신 order.processShipment() 형태로 Domain에 행동을 위임합니다.','캡슐화 강화. 상태 판단 로직을 Domain 내부에 두어 비즈니스 규칙이 Domain에 집중되고, Service는 흐름 제어만 담당합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:27:05','2026-01-16 06:50:28',NULL,NULL,NULL,NULL,NULL),(169,4,'C-009','ApplicationEventPublisher 직접 사용 금지','BLOCKER','DEPENDENCY','Spring의 ApplicationEventPublisher를 직접 주입받아 사용하면 안 됩니다. 반드시 TransactionEventRegistry를 통해 이벤트를 발행해야 합니다.','트랜잭션 안전성. TransactionEventRegistry는 트랜잭션 유무에 따라 발행 시점을 자동 결정합니다. 트랜잭션이 있으면 커밋 후 발행, 없으면 즉시 발행합니다.',1,1,'[\"FIELD\", \"CONSTRUCTOR\"]','2026-01-16 02:27:05','2026-01-16 06:50:28',NULL,NULL,NULL,NULL,NULL),(170,4,'C-010','시간 조회는 TimeProvider 사용','BLOCKER','BEHAVIOR','Instant.now(), LocalDateTime.now(), System.currentTimeMillis() 등 시간 조회를 직접 호출하면 안 됩니다. TimeProvider 인터페이스를 주입받아 timeProvider.now()를 사용해야 합니다.','테스트 용이성. TimeProvider를 Mock으로 교체하여 시간 의존 로직을 테스트할 수 있습니다. 또한 시스템 시간 정책(UTC vs KST)을 중앙에서 관리할 수 있습니다.',1,1,'[\"METHOD\"]','2026-01-16 02:27:05','2026-01-16 06:50:28',NULL,NULL,NULL,NULL,NULL),(171,4,'C-011','ID 생성은 IdGeneratorPort 사용','BLOCKER','BEHAVIOR','UUID.randomUUID(), ULID, Snowflake 등 ID 생성 로직을 직접 호출하면 안 됩니다. IdGeneratorPort 인터페이스를 주입받아 idGenerator.generate()를 사용해야 합니다.','추상화 및 테스트 용이성. ID 생성 전략(UUID v4, v7, ULID, Snowflake 등)을 런타임에 교체할 수 있고, 테스트에서 예측 가능한 ID를 생성할 수 있습니다.',1,1,'[\"METHOD\"]','2026-01-16 02:27:05','2026-01-16 06:50:28',NULL,NULL,NULL,NULL,NULL),(172,4,'SVC-001','@Service 어노테이션 필수','MAJOR','ANNOTATION','Service 클래스는 @Service 어노테이션을 사용해야 합니다. @Component는 사용하지 않습니다. Service는 UseCase(Port-In 인터페이스) 구현체임을 명시합니다.','Spring 컴포넌트 스캔 및 역할 명확화. @Service는 비즈니스 로직 계층임을 의미론적으로 표현합니다.',1,0,'[\"CLASS\"]','2026-01-16 02:27:06','2026-01-16 06:50:28',NULL,NULL,NULL,NULL,NULL),(173,4,'SVC-002','UseCase(Port-In) 인터페이스 구현 필수','BLOCKER','STRUCTURE','Service 클래스는 반드시 해당 UseCase 인터페이스를 구현해야 합니다. (예: CreateOrderService implements CreateOrderUseCase) UseCase 인터페이스 없이 Service만 존재하면 안 됩니다.','헥사고날 아키텍처 원칙. Port-In을 통해 Application Layer 진입점을 추상화하고, Controller는 구체 클래스가 아닌 인터페이스에 의존합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:27:06','2026-01-16 06:50:28',NULL,NULL,NULL,NULL,NULL),(174,4,'SVC-003','Domain 객체 직접 생성 금지','BLOCKER','BEHAVIOR','Service에서 new Order(), Order.forNew() 등 Domain 객체를 직접 생성하면 안 됩니다. 모든 Domain/UpdateData/Bundle 생성은 Factory에 위임해야 합니다.','단일 책임 원칙. Domain 생성 로직(시간, ID 주입 등)을 Factory에 집중하여 Service는 흐름 제어만 담당합니다.',0,1,'[\"METHOD\"]','2026-01-16 02:27:06','2026-01-16 06:50:28',NULL,NULL,NULL,NULL,NULL),(175,4,'SVC-004','UseCase 간 직접 호출 금지','CRITICAL','DEPENDENCY','Service에서 다른 UseCase(Service)를 직접 주입받아 호출하면 안 됩니다. 순환 의존성이 발생할 수 있고, 트랜잭션 경계가 모호해집니다. Admin 조회 등 복합 조회가 필요한 경우 별도 Facade나 ReadManager 조합을 사용합니다.','순환 의존성 방지 및 트랜잭션 경계 명확화. UseCase는 독립적인 비즈니스 액션을 나타내므로 서로 호출하지 않아야 합니다.',0,0,'[\"FIELD\", \"CONSTRUCTOR\"]','2026-01-16 02:27:06','2026-01-16 06:50:28',NULL,NULL,NULL,NULL,NULL),(176,4,'SVC-005','Domain 객체 직접 반환 금지','BLOCKER','BEHAVIOR','Service의 execute() 메서드에서 Domain 객체(Aggregate, Entity, VO)를 직접 반환하면 안 됩니다. 반드시 Assembler를 통해 Response DTO로 변환하여 반환해야 합니다.','계층 분리. Domain 객체가 Controller까지 노출되면 캡슐화가 깨지고, JPA Entity인 경우 LazyLoading 문제도 발생합니다.',0,1,'[\"METHOD\"]','2026-01-16 02:27:07','2026-01-16 06:50:28',NULL,NULL,NULL,NULL,NULL),(177,4,'SVC-006','Service에서 @Transactional 절대 금지','BLOCKER','ANNOTATION','Service 클래스와 메서드에 @Transactional을 사용하면 안 됩니다. 트랜잭션 관리는 Manager/Facade의 책임입니다. Service는 비즈니스 흐름 조율만 담당합니다.','트랜잭션 경계 명확화. 트랜잭션을 짧게 유지하여 외부 호출이 트랜잭션에 묶이는 것을 방지합니다.',1,1,'[\"CLASS\", \"METHOD\"]','2026-01-16 02:27:07','2026-01-16 06:50:28',NULL,NULL,NULL,NULL,NULL),(178,4,'SVC-007','Service에 비즈니스 로직 금지','BLOCKER','BEHAVIOR','Service에서 if/switch를 사용한 비즈니스 규칙, 계산 로직, 상태 판단 로직을 포함하면 안 됩니다. (예: if(order.isPaymentCompleted()) 금지) 모든 비즈니스 로직은 Domain에 위임합니다.','Tell, Don\'t Ask 원칙. Domain의 캡슐화를 유지하고, 비즈니스 규칙이 Domain에 집중되어 재사용성과 테스트 용이성이 향상됩니다.',0,1,'[\"METHOD\"]','2026-01-16 02:27:07','2026-01-16 06:50:28',NULL,NULL,NULL,NULL,NULL),(179,4,'SVC-008','Service에서 Port(Out) 직접 주입 금지','BLOCKER','DEPENDENCY','Service에서 CommandPort, QueryPort를 직접 주입받으면 안 됩니다. 반드시 PersistenceManager, ReadManager를 통해 접근해야 합니다.','트랜잭션 일관성. Port를 직접 사용하면 트랜잭션 없이 DB 접근이 발생할 수 있습니다. Manager로 래핑하여 트랜잭션을 보장합니다.',0,1,'[\"FIELD\", \"CONSTRUCTOR\"]','2026-01-16 02:27:07','2026-01-16 06:50:28',NULL,NULL,NULL,NULL,NULL),(180,4,'SVC-009','Service에서 시간/ID 생성 금지','BLOCKER','BEHAVIOR','Service에서 Instant.now(), UUID.randomUUID() 등 시간이나 ID 생성 로직을 직접 호출하면 안 됩니다. 시간/ID 생성은 Factory의 책임입니다.','단일 책임 원칙. 시간/ID 생성을 Factory에 집중하여 TimeProvider/IdGeneratorPort를 통한 테스트 용이성을 확보합니다.',0,1,'[\"METHOD\"]','2026-01-16 02:27:07','2026-01-16 06:50:28',NULL,NULL,NULL,NULL,NULL),(181,4,'SVC-010','Service에서 이벤트 객체 생성 금지','BLOCKER','BEHAVIOR','Service에서 new OrderCreatedEvent(...) 형태로 이벤트 객체를 직접 생성하면 안 됩니다. 이벤트는 Domain 내부에서 생성되고, Service는 TransactionEventRegistry로 발행만 담당합니다.','DDD 원칙. 도메인 이벤트는 Aggregate 상태 변경의 결과물이므로 Domain에서 생성해야 합니다.',0,1,'[\"METHOD\"]','2026-01-16 02:27:07','2026-01-16 06:50:28',NULL,NULL,NULL,NULL,NULL),(182,3,'CSVC-001','CommandService는 CommandFactory 의존 필수','MAJOR','DEPENDENCY','CommandService는 반드시 해당 도메인의 CommandFactory를 주입받아야 합니다. (예: CreateOrderService → OrderCommandFactory) Factory를 통해 Command → Domain/Bundle 변환을 수행합니다.','Domain 생성 로직 분리. CommandFactory가 시간, ID 주입 및 Domain 생성 규칙을 담당하여 Service는 흐름 제어에 집중합니다.',0,0,'[\"FIELD\", \"CONSTRUCTOR\"]','2026-01-16 02:27:07','2026-01-16 02:27:07',35,NULL,NULL,NULL,NULL),(183,3,'CSVC-002','CommandService는 Manager 또는 Facade 사용','MAJOR','DEPENDENCY','단일 Aggregate 저장은 PersistenceManager를 사용하고, 복합 저장(2개 이상 Aggregate)은 CommandFacade를 사용합니다. Port 직접 사용은 금지됩니다.','복잡도별 적절한 추상화. 단순 저장은 Manager로, 트랜잭션 묶음이 필요한 복합 저장은 Facade로 처리합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:27:07','2026-01-16 02:27:07',35,NULL,NULL,NULL,NULL),(184,3,'CSVC-003','CommandService는 응답 반환 시 Assembler 사용','MAJOR','BEHAVIOR','CommandService가 ID 응답 등을 반환할 때 Assembler를 사용해야 합니다. 생성 응답은 {Domain}IdResponse 형태로 Assembler.toIdResponse()를 통해 변환합니다.','응답 변환 로직 분리. Assembler가 Domain → Response 변환을 담당하여 일관된 응답 형식을 보장합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:27:07','2026-01-16 02:27:07',35,NULL,NULL,NULL,NULL),(185,3,'CSVC-004','CommandService는 필요시 Validator 사용','MINOR','DEPENDENCY','중복 검증, 존재 검증 등 DB 조회가 필요한 비즈니스 검증은 Validator를 사용합니다. Service에서 직접 조회 후 예외를 던지면 안 됩니다.','검증 로직 분리. Validator가 비즈니스 검증을 담당하여 Service는 흐름 제어에 집중합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:27:07','2026-01-16 02:27:07',35,NULL,NULL,NULL,NULL),(186,3,'QSVC-001','QueryService는 QueryFactory 의존 필수','MAJOR','DEPENDENCY','QueryService는 반드시 해당 도메인의 QueryFactory를 주입받아야 합니다. (예: SearchOrdersService → OrderQueryFactory) Factory를 통해 Query → Criteria 변환을 수행합니다.','Query 변환 로직 분리. QueryFactory가 Query DTO를 Domain Criteria로 변환하고, CommonVoFactory를 통해 QueryContext를 생성합니다.',0,0,'[\"FIELD\", \"CONSTRUCTOR\"]','2026-01-16 02:27:07','2026-01-16 02:27:07',36,NULL,NULL,NULL,NULL),(187,3,'QSVC-002','QueryService는 ReadManager 또는 QueryFacade 사용','MAJOR','DEPENDENCY','단일 조회는 ReadManager를 사용하고, 복합 조회(2개 이상 Manager 조합)는 QueryFacade를 사용합니다. QueryPort 직접 사용은 금지됩니다.','복잡도별 적절한 추상화. 단순 조회는 ReadManager로, 복합 조회는 Facade로 처리합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:27:07','2026-01-16 02:27:07',36,NULL,NULL,NULL,NULL),(188,3,'QSVC-003','QueryService는 응답 반환 시 Assembler 사용 필수','MAJOR','BEHAVIOR','QueryService가 응답을 반환할 때 반드시 Assembler를 사용해야 합니다. 단건은 toResponse(), 목록은 toPageResponse() 또는 toSliceResponse()를 사용합니다.','응답 변환 로직 분리. Assembler가 Domain → Response 변환을 담당하여 일관된 응답 형식과 페이징 메타 정보를 보장합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:27:07','2026-01-16 02:27:07',36,NULL,NULL,NULL,NULL),(189,3,'PMGR-001','PersistenceManager는 @Component 어노테이션 사용','MAJOR','ANNOTATION','PersistenceManager 클래스는 @Component 어노테이션을 사용합니다. @Service가 아닙니다. Manager는 UseCase 구현체가 아닌 내부 컴포넌트입니다.','@Service는 UseCase 구현체에만 사용합니다. Manager는 트랜잭션 래퍼 역할의 내부 컴포넌트이므로 @Component가 적합합니다.',1,0,'[\"CLASS\"]','2026-01-16 02:27:09','2026-01-16 02:27:09',37,NULL,NULL,NULL,NULL),(190,3,'PMGR-002','PersistenceManager는 단일 CommandPort만 의존','BLOCKER','DEPENDENCY','PersistenceManager는 1개의 CommandPort만 주입받아야 합니다. (예: OrderPersistenceManager → OrderCommandPort) 여러 Port를 의존하면 Facade로 분리해야 합니다.','단일 책임 원칙. 1:1 매핑으로 트랜잭션 경계가 명확해지고, 복합 저장은 Facade에서 처리합니다.',0,1,'[\"FIELD\", \"CONSTRUCTOR\"]','2026-01-16 02:27:09','2026-01-16 02:27:09',37,NULL,NULL,NULL,NULL),(191,3,'PMGR-003','PersistenceManager는 @Transactional 메서드 단위 필수','BLOCKER','ANNOTATION','모든 public 메서드에 @Transactional을 명시합니다. 클래스 단위 @Transactional은 금지됩니다. 트랜잭션을 짧게 유지하기 위해 메서드별로 명시적으로 선언합니다.','트랜잭션 경계 명확화. 메서드 단위 선언으로 각 메서드의 트랜잭션 특성(readOnly 등)을 명확히 하고, Spring 프록시 제약을 고려합니다.',0,1,'[\"METHOD\"]','2026-01-16 02:27:09','2026-01-16 02:27:09',37,NULL,NULL,NULL,NULL),(192,3,'PMGR-004','PersistenceManager 메서드는 persist 접두어 사용','MAJOR','NAMING','PersistenceManager의 저장 메서드는 persist(), persistAll() 형태를 사용합니다. save(), insert(), create() 등 다른 네이밍은 사용하지 않습니다.','네이밍 일관성. persist는 영속화를 명확히 표현하고, JPA의 persist와 의미가 일치합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:27:09','2026-01-16 02:27:09',37,NULL,NULL,NULL,NULL),(193,3,'PMGR-005','PersistenceManager의 persist는 ID 반환 필수','MAJOR','BEHAVIOR','persist() 메서드는 저장 후 생성된 ID를 반환해야 합니다. (예: OrderId persist(Order order)) void 반환은 금지됩니다.','후속 작업 지원. Facade에서 ID Enrichment 패턴을 사용하여 Outbox에 Domain ID를 세팅하려면 persist 결과로 ID가 필요합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:27:09','2026-01-16 02:27:09',37,NULL,NULL,NULL,NULL),(194,3,'RMGR-001','ReadManager는 @Component 어노테이션 사용','MAJOR','ANNOTATION','ReadManager 클래스는 @Component 어노테이션을 사용합니다. @Service가 아닙니다. Manager는 UseCase 구현체가 아닌 내부 컴포넌트입니다.','@Service는 UseCase 구현체에만 사용합니다. Manager는 트랜잭션 래퍼 역할의 내부 컴포넌트이므로 @Component가 적합합니다.',1,0,'[\"CLASS\"]','2026-01-16 02:27:09','2026-01-16 02:27:09',38,NULL,NULL,NULL,NULL),(195,3,'RMGR-002','ReadManager는 단일 QueryPort만 의존','BLOCKER','DEPENDENCY','ReadManager는 1개의 QueryPort만 주입받아야 합니다. (예: OrderReadManager → OrderQueryPort) 여러 Port를 의존하면 QueryFacade로 분리해야 합니다.','단일 책임 원칙. 1:1 매핑으로 조회 책임이 명확해지고, 복합 조회는 QueryFacade에서 처리합니다.',0,1,'[\"FIELD\", \"CONSTRUCTOR\"]','2026-01-16 02:27:10','2026-01-16 02:27:10',38,NULL,NULL,NULL,NULL),(196,3,'RMGR-003','ReadManager는 @Transactional(readOnly=true) 메서드 단위 필수','BLOCKER','ANNOTATION','모든 public 메서드에 @Transactional(readOnly = true)를 명시합니다. 클래스 단위 @Transactional은 금지됩니다. readOnly 옵션으로 읽기 전용 최적화를 적용합니다.','읽기 전용 최적화. readOnly=true는 Hibernate 더티 체킹 비활성화, JDBC 드라이버 최적화, Replica DB 라우팅 등 성능 이점을 제공합니다.',0,1,'[\"METHOD\"]','2026-01-16 02:27:10','2026-01-16 02:27:10',38,NULL,NULL,NULL,NULL),(197,3,'RMGR-004','ReadManager 메서드는 findBy/get/existsBy 접두어 사용','MAJOR','NAMING','ReadManager의 조회 메서드는 findBy{조건}(), get{대상}(), existsBy{조건}() 형태를 사용합니다. select, search, fetch 등 다른 네이밍은 사용하지 않습니다.','네이밍 일관성. findBy는 Optional 반환, get은 단건 필수 반환(없으면 예외), existsBy는 boolean 반환을 의미합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:27:10','2026-01-16 02:27:10',38,NULL,NULL,NULL,NULL),(198,3,'RMGR-005','ReadManager는 Domain 반환 (Entity 직접 반환 금지)','BLOCKER','BEHAVIOR','ReadManager의 조회 메서드는 Domain 객체(Aggregate, Entity(Domain), VO)를 반환해야 합니다. JPA Entity나 DTO를 직접 반환하면 안 됩니다.','계층 분리. Application Layer는 Domain만 다루고, JPA Entity는 Persistence Layer 내부에 캡슐화됩니다. EntityMapper가 변환을 담당합니다.',0,1,'[\"METHOD\"]','2026-01-16 02:27:10','2026-01-16 02:27:10',38,NULL,NULL,NULL,NULL),(199,4,'FAC-001','Facade는 @Component 어노테이션 사용','MAJOR','ANNOTATION','Facade 클래스는 @Component 어노테이션을 사용합니다. @Service가 아닙니다. Facade는 UseCase 구현체가 아닌 Manager 조합을 위한 내부 컴포넌트입니다.','@Service는 UseCase 구현체에만 사용합니다. Facade는 여러 Manager를 조합하는 내부 컴포넌트이므로 @Component가 적합합니다.',1,0,'[\"CLASS\"]','2026-01-16 02:27:11','2026-01-16 06:50:28',NULL,NULL,NULL,NULL,NULL),(200,4,'FAC-002','CommandFacade와 QueryFacade 분리','MAJOR','STRUCTURE','Facade는 Command용(쓰기)과 Query용(읽기)으로 분리해야 합니다. OrderCommandFacade, OrderQueryFacade 형태로 네이밍합니다. 하나의 Facade에 읽기/쓰기 메서드를 혼합하면 안 됩니다.','CQRS 원칙. Command와 Query를 분리하여 관심사를 명확히 하고, 각 Facade의 책임을 단순화합니다.',0,0,'[\"CLASS\"]','2026-01-16 02:27:11','2026-01-16 06:50:28',NULL,NULL,NULL,NULL,NULL),(201,4,'FAC-003','Facade는 2개 이상 Manager 조합할 때만 사용','BLOCKER','STRUCTURE','Facade는 2개 이상의 Manager를 조합할 때만 생성합니다. 단일 Manager 호출만 필요하면 Service에서 Manager를 직접 사용해야 합니다. 불필요한 Facade는 복잡도만 증가시킵니다.','적절한 추상화 수준. Facade의 존재 이유는 여러 Manager의 조합이므로, 단일 Manager 호출은 Facade 없이 처리합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:27:11','2026-01-16 06:50:28',NULL,NULL,NULL,NULL,NULL),(202,4,'FAC-004','Facade는 RDB Persistence Manager만 의존','BLOCKER','DEPENDENCY','CommandFacade는 RDB PersistenceManager만 의존해야 합니다. 외부 API Manager(ClientPort 래퍼), Cache Manager, Messaging Manager 등은 Facade에서 호출하면 안 됩니다. 외부 호출이 필요하면 Service 레벨에서 처리합니다.','트랜잭션 경계 명확화. RDB Manager만 의존하면 하나의 DB 트랜잭션으로 묶을 수 있습니다. 외부 호출이 트랜잭션에 묶이면 롤백 불가, 타임아웃 증가 등 문제가 발생합니다.',0,1,'[\"FIELD\", \"CONSTRUCTOR\"]','2026-01-16 02:27:11','2026-01-16 06:50:28',NULL,NULL,NULL,NULL,NULL),(203,4,'FAC-005','Facade는 @Transactional 메서드 단위 허용','MAJOR','ANNOTATION','Facade는 RDB Manager만 의존하므로 @Transactional을 메서드 단위로 사용할 수 있습니다. 클래스 단위 @Transactional은 금지됩니다. CommandFacade는 @Transactional, QueryFacade는 @Transactional(readOnly=true)를 사용합니다.','RDB 전용 Facade이므로 트랜잭션 허용. 여러 Manager 호출이 하나의 트랜잭션으로 묶여 일부만 커밋되는 문제를 방지합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:27:11','2026-01-16 06:50:28',NULL,NULL,NULL,NULL,NULL),(204,4,'FAC-006','Facade에 비즈니스 로직 금지','BLOCKER','BEHAVIOR','Facade에서 if/switch를 사용한 비즈니스 규칙, 계산 로직, 상태 판단 로직을 포함하면 안 됩니다. Facade는 여러 Manager 호출을 조합하는 역할만 수행하고, 비즈니스 로직은 Domain에 위임합니다.','단일 책임 원칙. Facade는 \"조합\"만 담당하고 비즈니스 규칙은 Domain에서 처리하여 관심사를 분리합니다.',0,1,'[\"METHOD\"]','2026-01-16 02:27:11','2026-01-16 06:50:28',NULL,NULL,NULL,NULL,NULL),(205,3,'CFAC-001','CommandFacade 메서드는 persist 접두어 사용','MAJOR','NAMING','CommandFacade의 저장 메서드는 persist{Domain}Bundle(), persistOrderWithOutbox() 형태를 사용합니다. save, create, insert 등 다른 네이밍은 사용하지 않습니다.','네이밍 일관성. PersistenceManager와 동일하게 persist를 사용하여 영속화를 명확히 표현합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:27:11','2026-01-16 02:27:11',39,NULL,NULL,NULL,NULL),(206,3,'CFAC-002','CommandFacade는 Bundle 파라미터 사용 권장','MINOR','STRUCTURE','여러 객체를 함께 저장할 때는 개별 파라미터 대신 PersistBundle을 사용하는 것을 권장합니다. (예: persistOrderBundle(OrderPersistBundle bundle)) Bundle은 ID Enrichment 패턴을 지원합니다.','파라미터 응집도. Bundle로 묶으면 파라미터 수가 줄고, with 패턴으로 ID 설정이 용이합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:27:12','2026-01-16 02:27:12',39,NULL,NULL,NULL,NULL),(207,3,'CFAC-003','CommandFacade는 ID Enrichment 패턴 구현','MAJOR','BEHAVIOR','Domain 저장 후 획득한 ID를 Bundle에 세팅하는 ID Enrichment 패턴을 구현합니다. (예: OrderId 획득 → bundle.withOrderId(orderId) → Outbox 저장) 이를 통해 Outbox에 Domain ID, Event에 멱등키를 설정합니다.','Outbox 패턴 지원. Outbox는 원본 Domain ID가 필요하고, Event는 멱등키로 orderId+outboxId 조합을 사용합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:27:12','2026-01-16 02:27:12',39,NULL,NULL,NULL,NULL),(208,3,'QFAC-001','QueryFacade 메서드는 fetch 접두어 사용','MAJOR','NAMING','QueryFacade의 조회 메서드는 fetch{Domain}WithDetails(), fetchOrderWithMember() 형태를 사용합니다. find, get, search 등 다른 네이밍은 사용하지 않습니다.','네이밍 일관성. ReadManager의 findBy/get과 구분하여, Facade에서 복합 조회 시 fetch를 사용합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:27:12','2026-01-16 02:27:12',40,NULL,NULL,NULL,NULL),(209,3,'QFAC-002','QueryFacade는 QueryBundle 반환 권장','MINOR','STRUCTURE','여러 Domain 객체를 함께 조회할 때는 개별 반환 대신 QueryBundle을 사용하는 것을 권장합니다. (예: OrderQueryBundle fetch(OrderId orderId)) QueryBundle은 Record로 정의합니다.','반환 타입 응집도. 여러 Domain을 Bundle로 묶으면 Service에서 처리가 용이하고, Assembler에서 일괄 변환할 수 있습니다.',0,0,'[\"METHOD\"]','2026-01-16 02:27:12','2026-01-16 02:27:12',40,NULL,NULL,NULL,NULL),(210,3,'CFACTORY-001','CommandFactory는 @Component 어노테이션 사용','MAJOR','ANNOTATION','CommandFactory 클래스는 @Component 어노테이션을 사용합니다. Factory는 Bean으로 등록되어 TimeProvider, IdGeneratorPort를 주입받습니다.','의존성 주입 활용. Factory가 Bean이면 시간/ID 생성을 위한 Port를 주입받아 테스트 용이성을 확보할 수 있습니다.',1,0,'[\"CLASS\"]','2026-01-16 02:27:13','2026-01-16 02:27:13',41,NULL,NULL,NULL,NULL),(211,3,'CFACTORY-002','CommandFactory는 create{Domain}() 메서드 제공','MAJOR','BEHAVIOR','Command → Domain 변환 시 create{Domain}() 메서드를 사용합니다. (예: createOrder(CreateOrderCommand cmd)) 내부에서 Domain.forNew() 또는 Domain.of()를 호출하여 Domain을 생성합니다.','도메인 생성 책임 집중. Factory가 시간, ID 주입을 담당하고, Domain의 정적 팩토리 메서드를 호출합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:27:13','2026-01-16 02:27:13',41,NULL,NULL,NULL,NULL),(212,3,'CFACTORY-003','CommandFactory는 create{Domain}UpdateData() 메서드 제공','MAJOR','BEHAVIOR','Update Command → UpdateData 변환 시 create{Domain}UpdateData() 메서드를 사용합니다. UpdateData는 수정할 필드만 포함하며, null이면 수정하지 않음을 의미합니다.','Partial Update 지원. UpdateData 패턴으로 선택적 필드 수정을 지원하고, updatedAt은 Factory에서 주입합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:27:13','2026-01-16 02:27:13',41,NULL,NULL,NULL,NULL),(213,3,'CFACTORY-004','CommandFactory는 create{Domain}Bundle() 메서드 제공','MAJOR','BEHAVIOR','복합 저장 시 create{Domain}Bundle() 메서드를 사용합니다. (예: createOrderBundle(CreateOrderCommand cmd) → OrderPersistBundle) Bundle에는 Domain, Outbox, Event 등이 포함됩니다.','복합 객체 생성 집중. Outbox 패턴 사용 시 Domain과 Outbox를 함께 생성하여 일관성을 보장합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:27:13','2026-01-16 02:27:13',41,NULL,NULL,NULL,NULL),(214,3,'CFACTORY-005','CommandFactory는 TimeProvider 의존 필수','BLOCKER','DEPENDENCY','CommandFactory는 TimeProvider를 주입받아 시간을 생성해야 합니다. Instant.now(), LocalDateTime.now() 직접 호출은 금지됩니다.','테스트 용이성. TimeProvider를 Mock으로 교체하여 시간 의존 로직을 테스트할 수 있습니다.',0,1,'[\"FIELD\", \"CONSTRUCTOR\"]','2026-01-16 02:27:13','2026-01-16 02:27:13',41,NULL,NULL,NULL,NULL),(215,3,'CFACTORY-006','CommandFactory는 ID 생성 시 IdGeneratorPort 사용','BLOCKER','DEPENDENCY','Application Layer에서 ID를 생성해야 하는 경우(UUID 선채번 등) IdGeneratorPort를 주입받아 사용합니다. UUID.randomUUID() 직접 호출은 금지됩니다.','추상화 및 테스트 용이성. ID 생성 전략(UUID v4, v7, ULID 등)을 런타임에 교체하고 테스트에서 예측 가능한 ID를 사용할 수 있습니다.',0,1,'[\"FIELD\", \"CONSTRUCTOR\"]','2026-01-16 02:27:13','2026-01-16 02:27:13',41,NULL,NULL,NULL,NULL),(216,3,'CFACTORY-007','CommandFactory에서 null 체크 금지','BLOCKER','BEHAVIOR','CommandFactory에서 입력값 null 체크를 하면 안 됩니다. (예: if(cmd.name() != null) 금지) null 검증은 REST-API Layer의 Mapper에서 처리됩니다.','Fail-fast 원칙. REST-API에서 검증 후 전달되므로 Application Layer에서 중복 검증은 불필요합니다.',0,1,'[\"METHOD\"]','2026-01-16 02:27:13','2026-01-16 02:27:13',41,NULL,NULL,NULL,NULL),(217,3,'CFACTORY-008','CommandFactory에서 기본값 할당 금지','BLOCKER','BEHAVIOR','CommandFactory에서 null을 기본값으로 대체하면 안 됩니다. (예: name != null ? name : \"Unknown\" 금지) 기본값 결정은 Domain의 책임입니다.','단일 책임 원칙. Factory는 형태 변환만 담당하고, 비즈니스 규칙(기본값 정책)은 Domain에서 처리합니다.',0,1,'[\"METHOD\"]','2026-01-16 02:27:13','2026-01-16 02:27:13',41,NULL,NULL,NULL,NULL),(218,3,'CFACTORY-009','CommandFactory는 UpdateData에 updatedAt 주입','MAJOR','BEHAVIOR','UpdateData 생성 시 updatedAt 필드에 TimeProvider.now() 결과를 주입합니다. Domain.update() 호출 시 자동으로 수정 시각이 설정됩니다.','수정 시각 일관성. Factory에서 시간을 주입하여 모든 수정 작업에 일관된 수정 시각을 보장합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:27:14','2026-01-16 02:27:14',41,NULL,NULL,NULL,NULL),(219,3,'CFACTORY-010','CommandFactory에서 Response 객체 생성 금지','BLOCKER','BEHAVIOR','CommandFactory에서 Response DTO를 생성하면 안 됩니다. Response 변환은 Assembler의 책임입니다. Factory는 입력(Command) → 도메인 방향 변환만 담당합니다.','단방향 변환 원칙. Factory는 입력 변환, Assembler는 출력 변환으로 책임을 분리합니다.',0,1,'[\"METHOD\"]','2026-01-16 02:27:14','2026-01-16 02:27:14',41,NULL,NULL,NULL,NULL),(220,3,'QFACTORY-001','QueryFactory는 @Component 어노테이션 사용','MAJOR','ANNOTATION','QueryFactory 클래스는 @Component 어노테이션을 사용합니다. Factory는 Bean으로 등록되어 CommonVoFactory를 주입받습니다.','의존성 주입 활용. CommonVoFactory를 주입받아 QueryContext 생성을 위임합니다.',1,0,'[\"CLASS\"]','2026-01-16 02:27:14','2026-01-16 02:27:14',42,NULL,NULL,NULL,NULL),(221,3,'QFACTORY-002','QueryFactory는 to{Domain}Criteria() 메서드 제공','MAJOR','BEHAVIOR','Query → Criteria 변환 시 to{Domain}Criteria() 메서드를 사용합니다. (예: toOrderCriteria(SearchOrdersQuery query)) Criteria는 Domain의 검색 조건 VO입니다.','Query 변환 집중. Query DTO의 primitive 값을 Domain VO로 변환하고, QueryContext를 생성합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:27:14','2026-01-16 02:27:14',42,NULL,NULL,NULL,NULL),(222,3,'QFACTORY-003','QueryFactory는 CommonVoFactory 의존 필수','MAJOR','DEPENDENCY','QueryFactory는 CommonVoFactory를 주입받아 QueryContext를 생성합니다. CommonSearchParams → QueryContext 변환은 CommonVoFactory.createQueryContext()를 사용합니다.','공통 변환 재사용. 정렬, 페이징, includeDeleted 등 공통 조회 조건 변환을 중앙화합니다.',0,0,'[\"FIELD\", \"CONSTRUCTOR\"]','2026-01-16 02:27:14','2026-01-16 02:27:14',42,NULL,NULL,NULL,NULL),(223,3,'QFACTORY-004','QueryFactory에서 null 체크 금지','BLOCKER','BEHAVIOR','QueryFactory에서 입력값 null 체크를 하면 안 됩니다. Query DTO의 필드가 null이면 해당 조건을 사용하지 않음을 의미하며, Criteria VO도 null을 허용합니다.','Fail-fast 원칙. REST-API에서 검증 후 전달되므로 Application Layer에서 중복 검증은 불필요합니다.',0,1,'[\"METHOD\"]','2026-01-16 02:27:14','2026-01-16 02:27:14',42,NULL,NULL,NULL,NULL),(224,4,'ASM-001','Assembler는 @Component 어노테이션 사용','MAJOR','ANNOTATION','Assembler 클래스는 @Component 어노테이션을 사용합니다. Assembler는 Bean으로 등록되어 Service에서 주입받아 사용합니다.','의존성 주입 활용. Bean으로 등록하면 테스트에서 Mock 교체가 용이하고, 다른 Assembler를 조합할 수 있습니다.',1,0,'[\"CLASS\"]','2026-01-16 02:27:15','2026-01-16 06:50:28',43,NULL,NULL,NULL,NULL),(225,4,'ASM-002','Assembler는 Domain → Response 변환만 담당','BLOCKER','BEHAVIOR','Assembler는 Domain 객체를 Response DTO로 변환하는 역할만 수행합니다. Domain 생성, 수정, Command → Domain 변환은 Factory의 책임입니다.','단방향 변환 원칙. Factory는 입력 변환(Command → Domain), Assembler는 출력 변환(Domain → Response)으로 책임을 분리합니다.',0,1,'[\"METHOD\"]','2026-01-16 02:27:15','2026-01-16 06:50:28',43,NULL,NULL,NULL,NULL),(226,4,'ASM-003','Assembler 단건 변환은 toResponse() 메서드명 사용','MAJOR','NAMING','단건 Domain → Response 변환 시 toResponse(), toResponseSummary() 형태를 사용합니다. convert, transform, map 등 다른 네이밍은 사용하지 않습니다.','네이밍 일관성. to 접두어로 변환 방향(→ Response)을 명확히 하고, 프로젝트 전체에서 일관된 메서드명을 사용합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:27:15','2026-01-16 06:50:28',43,NULL,NULL,NULL,NULL),(227,4,'ASM-004','Assembler 목록 변환은 toResponseList() 메서드명 사용','MAJOR','NAMING','목록 Domain → Response 변환 시 toResponseList(), toResponseSummaryList() 형태를 사용합니다. 내부적으로 stream().map(this::toResponse).toList()를 사용합니다.','네이밍 일관성. List 접미어로 컬렉션 변환임을 명확히 합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:27:15','2026-01-16 06:50:28',43,NULL,NULL,NULL,NULL),(228,4,'ASM-005','Assembler 페이지 변환은 toPageResponse() 메서드명 사용','MAJOR','NAMING','페이지 응답 생성 시 toPageResponse(List<Domain>, int page, int size, long totalCount) 형태를 사용합니다. PageMeta를 함께 생성하여 {Domain}PageResponse를 반환합니다.','페이징 응답 일관성. PageMeta(page, size, totalElements, totalPages)를 포함한 표준 페이지 응답을 생성합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:27:15','2026-01-16 06:50:28',43,NULL,NULL,NULL,NULL),(229,4,'ASM-006','Assembler 슬라이스 변환은 toSliceResponse() 메서드명 사용','MAJOR','NAMING','슬라이스 응답 생성 시 toSliceResponse(List<Domain>, int size, boolean hasNext, String cursor) 형태를 사용합니다. SliceMeta를 함께 생성하여 {Domain}SliceResponse를 반환합니다.','슬라이스 응답 일관성. SliceMeta(size, hasNext, cursor, count)를 포함한 표준 슬라이스 응답을 생성합니다. 무한 스크롤, 더보기 UI에 적합합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:27:15','2026-01-16 06:50:28',43,NULL,NULL,NULL,NULL),(230,4,'ASM-007','Assembler는 Domain의 PageMeta/SliceMeta 사용','MAJOR','DEPENDENCY','페이징 메타 정보는 Domain Layer에 정의된 PageMeta, SliceMeta VO를 사용합니다. Application Layer에서 별도 페이징 객체를 정의하면 안 됩니다.','중복 정의 방지. Domain Layer의 공통 VO를 재사용하여 페이징 응답 형식을 표준화합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:27:15','2026-01-16 06:50:28',43,NULL,NULL,NULL,NULL),(231,4,'ASM-008','Assembler에 비즈니스 로직 금지','BLOCKER','BEHAVIOR','Assembler에서 if/switch를 사용한 비즈니스 규칙, 계산 로직, 상태 판단 로직을 포함하면 안 됩니다. Assembler는 단순 형태 변환(필드 매핑)만 수행합니다.','단일 책임 원칙. Assembler는 \"형태 변환\"만 담당하고 비즈니스 규칙은 Domain에서 처리합니다.',0,1,'[\"METHOD\"]','2026-01-16 02:27:16','2026-01-16 06:50:28',43,NULL,NULL,NULL,NULL),(232,3,'COMP-001','Component 패키지 클래스는 @Component 어노테이션 사용','MAJOR','ANNOTATION','component 패키지 하위의 모든 클래스(Validator, Processor, Calculator, Resolver 등)는 @Component 어노테이션을 사용합니다. @Service는 UseCase 구현체에만 사용합니다.','역할 명확화. @Service는 비즈니스 로직 진입점, @Component는 내부 유틸리티성 컴포넌트를 의미합니다.',1,0,'[\"CLASS\"]','2026-01-16 02:27:17','2026-01-16 02:27:17',NULL,NULL,NULL,NULL,NULL),(233,3,'COMP-002','Component는 {Domain}{Type} 네이밍 규칙 사용','MAJOR','NAMING','component 클래스는 {Domain}{Type} 형태로 네이밍합니다. 예: OrderValidator, PaymentProcessor, PriceCalculator, ShippingResolver. 타입명이 역할을 명확히 표현해야 합니다.','일관된 네이밍. 클래스명만 보고도 역할과 담당 도메인을 파악할 수 있습니다.',0,0,'[\"CLASS\"]','2026-01-16 02:27:17','2026-01-16 02:27:17',NULL,NULL,NULL,NULL,NULL),(234,3,'COMP-003','Component는 단일 책임 원칙 준수','MAJOR','STRUCTURE','component 클래스는 하나의 역할만 수행합니다. Validator는 검증만, Calculator는 계산만, Processor는 처리만 담당합니다. 여러 역할이 필요하면 별도 component로 분리합니다.','단일 책임 원칙(SRP). 역할이 명확하면 테스트가 쉽고 재사용성이 높아집니다.',0,0,'[\"CLASS\"]','2026-01-16 02:27:17','2026-01-16 02:27:17',NULL,NULL,NULL,NULL,NULL),(235,3,'COMP-004','Component는 Manager 의존 가능, Port 직접 의존 금지','BLOCKER','DEPENDENCY','component에서 DB 조회가 필요하면 ReadManager를 의존합니다. CommandPort, QueryPort를 직접 의존하면 안 됩니다. Manager로 래핑하여 트랜잭션 일관성을 보장합니다.','트랜잭션 일관성. Port를 직접 사용하면 트랜잭션 없이 DB 접근이 발생할 수 있습니다.',0,1,'[\"FIELD\", \"CONSTRUCTOR\"]','2026-01-16 02:27:17','2026-01-16 02:27:17',NULL,NULL,NULL,NULL,NULL),(236,3,'VAL-001','Validator는 @Component 어노테이션 사용','MAJOR','ANNOTATION','Validator 클래스는 @Component 어노테이션을 사용합니다. Service에서 주입받아 비즈니스 검증을 수행합니다.','의존성 주입 활용. Bean으로 등록하여 테스트에서 Mock 교체가 용이합니다.',1,0,'[\"CLASS\"]','2026-01-16 02:27:18','2026-01-16 02:27:18',55,NULL,NULL,NULL,NULL),(237,3,'VAL-002','Validator는 {Domain}Validator 네이밍 사용','MAJOR','NAMING','Validator 클래스는 {Domain}Validator 형태로 네이밍합니다. 예: OrderValidator, MemberValidator. 도메인별로 검증 로직을 분리합니다.','일관된 네이밍. 클래스명만 보고도 담당 도메인을 파악할 수 있습니다.',0,0,'[\"CLASS\"]','2026-01-16 02:27:18','2026-01-16 02:27:18',55,NULL,NULL,NULL,NULL),(238,3,'VAL-003','Validator는 ReadManager만 의존','BLOCKER','DEPENDENCY','Validator는 검증을 위해 ReadManager(조회용)만 의존합니다. PersistenceManager(쓰기용)나 CommandPort/QueryPort를 직접 의존하면 안 됩니다.','읽기 전용 검증. Validator는 상태 조회만 필요하고, 데이터 변경은 Service→Manager에서 처리합니다.',0,1,'[\"FIELD\", \"CONSTRUCTOR\"]','2026-01-16 02:27:18','2026-01-16 02:27:18',55,NULL,NULL,NULL,NULL),(239,3,'VAL-004','Validator는 void 반환, 실패 시 DomainException','MAJOR','BEHAVIOR','Validator 메서드는 void를 반환하고, 검증 실패 시 DomainException(DuplicateException, NotFoundException, InvalidStateException 등)을 발생시킵니다. boolean 반환은 금지됩니다.','Fail-fast 원칙. 검증 실패 시 즉시 예외를 발생시켜 후속 로직 실행을 방지합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:27:18','2026-01-16 02:27:18',55,NULL,NULL,NULL,NULL),(240,3,'VAL-005','Validator 메서드는 validateXxx() 또는 checkXxx() 사용','MAJOR','NAMING','Validator의 검증 메서드는 validateXxx() 또는 checkXxx() 형태를 사용합니다. 예: validateEmailDuplication(), checkOrderExists(). verify, assert 등 다른 네이밍은 사용하지 않습니다.','네이밍 일관성. validate/check 접두어로 검증 메서드임을 명확히 합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:27:18','2026-01-16 02:27:18',55,NULL,NULL,NULL,NULL),(241,3,'UC-001','UseCase는 반드시 interface로 정의','BLOCKER','STRUCTURE','UseCase(Port-In)는 반드시 interface로 정의합니다. class나 abstract class는 금지됩니다. Service가 이 인터페이스를 구현합니다.','헥사고날 아키텍처 원칙. Port-In을 통해 Application Layer 진입점을 추상화하고, Controller는 구체 클래스가 아닌 인터페이스에 의존합니다.',0,1,'[\"INTERFACE\"]','2026-01-16 02:27:19','2026-01-16 02:27:19',NULL,NULL,NULL,NULL,NULL),(242,3,'UC-002','UseCase는 execute() 단일 메서드 제공','BLOCKER','STRUCTURE','UseCase 인터페이스는 execute(Command) 또는 execute(Query) 단일 메서드만 정의합니다. 여러 메서드를 정의하면 안 됩니다. (예: execute(CreateOrderCommand): OrderIdResponse)','단일 책임 원칙. 하나의 UseCase = 하나의 비즈니스 액션. 메서드가 여러 개 필요하면 별도 UseCase로 분리합니다.',0,1,'[\"INTERFACE\"]','2026-01-16 02:27:19','2026-01-16 02:27:19',NULL,NULL,NULL,NULL,NULL),(243,3,'UC-003','UseCase interface 내 inner class/interface 금지','MAJOR','STRUCTURE','UseCase 인터페이스 내부에 nested class나 nested interface를 정의하면 안 됩니다. Command/Query DTO는 dto 패키지에 별도 파일로 정의합니다.','코드 조직화. DTO와 인터페이스를 분리하여 각각의 역할을 명확히 합니다.',0,0,'[\"INTERFACE\"]','2026-01-16 02:27:19','2026-01-16 02:27:19',NULL,NULL,NULL,NULL,NULL),(244,3,'UC-004','Command UseCase와 Query UseCase 분리','MAJOR','STRUCTURE','Command UseCase(생성/수정/삭제)와 Query UseCase(조회)는 별도 인터페이스로 분리합니다. port.in.command와 port.in.query 패키지로 구분합니다.','CQRS 원칙. 쓰기와 읽기를 분리하여 각각의 최적화와 확장이 가능합니다.',0,0,'[\"INTERFACE\"]','2026-01-16 02:27:20','2026-01-16 02:27:20',NULL,NULL,NULL,NULL,NULL),(245,3,'UC-005','UseCase는 하나의 비즈니스 액션만 담당','MAJOR','BEHAVIOR','하나의 UseCase = 하나의 비즈니스 액션입니다. (예: CreateOrderUseCase, UpdateOrderUseCase, GetOrderUseCase) 여러 액션을 하나의 UseCase에 묶으면 안 됩니다.','단일 책임 원칙. 역할이 명확하면 테스트가 쉽고, 변경 시 영향 범위가 최소화됩니다.',0,0,'[\"INTERFACE\"]','2026-01-16 02:27:20','2026-01-16 02:27:20',NULL,NULL,NULL,NULL,NULL),(246,3,'UC-006','Command UseCase는 동사 접두어 + UseCase 네이밍','MAJOR','NAMING','Command UseCase는 Create/Update/Delete/Change/Register/Modify 접두어를 사용합니다. 예: CreateOrderUseCase, UpdateOrderUseCase, ChangeOrderStatusUseCase.','네이밍 일관성. 접두어로 액션 유형을 명확히 표현합니다.',0,0,'[\"INTERFACE\"]','2026-01-16 02:27:20','2026-01-16 02:27:20',44,NULL,NULL,NULL,NULL),(247,3,'UC-007','Query UseCase는 조회 접두어 + UseCase 네이밍','MAJOR','NAMING','Query UseCase는 Get/Search/Find/List/Count 접두어를 사용합니다. 예: GetOrderUseCase(단건), SearchOrdersUseCase(목록), CountOrdersUseCase(카운트).','네이밍 일관성. 접두어로 조회 유형을 명확히 표현합니다.',0,0,'[\"INTERFACE\"]','2026-01-16 02:27:20','2026-01-16 02:27:20',45,NULL,NULL,NULL,NULL),(248,3,'CPRT-001','CommandPort는 반드시 interface로 정의','BLOCKER','STRUCTURE','CommandPort(Port-Out)는 반드시 interface로 정의합니다. class나 abstract class는 금지됩니다. Persistence Layer의 CommandAdapter가 이 인터페이스를 구현합니다.','헥사고날 아키텍처 원칙. Port-Out을 통해 외부 의존성을 추상화하고, Application Layer는 구체 구현에 의존하지 않습니다.',0,1,'[\"INTERFACE\"]','2026-01-16 02:27:21','2026-01-16 02:27:21',46,NULL,NULL,NULL,NULL),(249,3,'CPRT-002','CommandPort는 persist(Domain) 메서드만 제공','BLOCKER','STRUCTURE','CommandPort는 persist(Domain domain): {Id} 단일 메서드만 정의합니다. save, insert, create, update, delete 등 다른 네이밍은 금지됩니다. 삭제는 Domain의 soft-delete 상태 변경 후 persist로 처리합니다.','단순화 및 일관성. persist는 JPA의 persist와 의미가 일치하며, INSERT/UPDATE를 추상화합니다.',0,1,'[\"INTERFACE\"]','2026-01-16 02:27:21','2026-01-16 02:27:21',46,NULL,NULL,NULL,NULL),(250,3,'CPRT-003','CommandPort는 Domain 객체를 파라미터로 받음','BLOCKER','BEHAVIOR','persist() 메서드는 Domain 객체(Aggregate)를 파라미터로 받습니다. JPA Entity나 DTO를 직접 전달하면 안 됩니다. Entity 변환은 Adapter 내부(EntityMapper)에서 처리합니다.','계층 분리. Application Layer는 Domain만 다루고, Entity는 Persistence Layer 내부에 캡슐화됩니다.',0,1,'[\"METHOD\"]','2026-01-16 02:27:21','2026-01-16 02:27:21',46,NULL,NULL,NULL,NULL),(251,3,'CPRT-004','CommandPort의 persist는 ID를 반환','MAJOR','BEHAVIOR','persist(Domain domain) 메서드는 저장 후 생성된 ID를 반환해야 합니다. (예: OrderId persist(Order order)) void 반환은 금지됩니다. ID Enrichment 패턴에서 필요합니다.','후속 작업 지원. Facade에서 ID Enrichment 패턴을 사용하여 Outbox에 Domain ID를 세팅하려면 persist 결과로 ID가 필요합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:27:21','2026-01-16 02:27:21',46,NULL,NULL,NULL,NULL),(252,3,'QPRT-001','QueryPort는 반드시 interface로 정의','BLOCKER','STRUCTURE','QueryPort(Port-Out)는 반드시 interface로 정의합니다. class나 abstract class는 금지됩니다. Persistence Layer의 QueryAdapter가 이 인터페이스를 구현합니다.','헥사고날 아키텍처 원칙. Port-Out을 통해 외부 의존성을 추상화하고, Application Layer는 구체 구현에 의존하지 않습니다.',0,1,'[\"INTERFACE\"]','2026-01-16 02:27:22','2026-01-16 02:27:22',47,NULL,NULL,NULL,NULL),(253,3,'QPRT-002','QueryPort는 표준 4개 메서드 필수','MAJOR','STRUCTURE','QueryPort는 다음 4개 표준 메서드를 필수로 정의합니다: findById(Id): Optional<Domain>, existsById(Id): boolean, findByCriteria(Criteria): List<Domain>, countByCriteria(Criteria): long. 이 4개 메서드로 대부분의 조회 요구사항을 충족합니다.','인터페이스 일관성. 모든 QueryPort가 동일한 표준 메서드를 제공하여 예측 가능한 API를 보장합니다.',0,0,'[\"INTERFACE\"]','2026-01-16 02:27:22','2026-01-16 02:27:22',47,NULL,NULL,NULL,NULL),(254,3,'QPRT-003','QueryPort는 Unique 필드 조회 조건부 허용','MINOR','STRUCTURE','DB에 Unique 제약조건이 있는 필드에 대해 findBy{UniqueField}(): Optional<Domain>, existsBy{UniqueField}(): boolean 메서드를 추가할 수 있습니다. 예: findByEmail(Email), existsBySlug(Slug). 일반 필드 조회는 Criteria를 사용합니다.','성능 최적화. Unique 인덱스를 직접 조회하면 Criteria보다 효율적입니다. 중복 검증 등에 유용합니다.',0,0,'[\"INTERFACE\"]','2026-01-16 02:27:22','2026-01-16 02:27:22',47,NULL,NULL,NULL,NULL),(255,3,'QPRT-004','QueryPort는 Domain 객체 반환 (Entity/DTO 금지)','BLOCKER','BEHAVIOR','QueryPort의 조회 메서드는 Domain 객체(Aggregate, Entity(Domain), VO)를 반환해야 합니다. JPA Entity나 DTO를 직접 반환하면 안 됩니다. Entity→Domain 변환은 Adapter 내부에서 처리합니다.','계층 분리. Application Layer는 Domain만 다루고, JPA Entity는 Persistence Layer 내부에 캡슐화됩니다.',0,1,'[\"METHOD\"]','2026-01-16 02:27:22','2026-01-16 02:27:22',47,NULL,NULL,NULL,NULL),(256,3,'QPRT-005','QueryPort의 복합 조건 조회는 Criteria 사용','BLOCKER','STRUCTURE','findByXxxAndYyy(), findByStatusAndDate() 형태의 복합 조건 메서드는 금지됩니다. 복합 조건은 Criteria VO를 사용하여 findByCriteria(Criteria)로 처리합니다. Criteria는 Domain Layer에 정의됩니다.','인터페이스 폭발 방지. 조건 조합마다 메서드를 추가하면 메서드 수가 폭발합니다. Criteria로 동적 조회를 지원합니다.',0,1,'[\"INTERFACE\"]','2026-01-16 02:27:22','2026-01-16 02:27:22',47,NULL,NULL,NULL,NULL),(257,3,'CLPRT-001','ClientPort는 반드시 interface로 정의','BLOCKER','STRUCTURE','ClientPort(Port-Out)는 반드시 interface로 정의합니다. class나 abstract class는 금지됩니다. External Adapter가 이 인터페이스를 구현합니다.','헥사고날 아키텍처 원칙. Port-Out을 통해 외부 시스템 의존성을 추상화하고, Application Layer는 구체 구현에 의존하지 않습니다.',0,1,'[\"INTERFACE\"]','2026-01-16 02:27:24','2026-01-16 02:27:24',48,NULL,NULL,NULL,NULL),(258,3,'CLPRT-002','ClientPort는 외부 시스템 연동 전용','MAJOR','BEHAVIOR','ClientPort는 HTTP API, gRPC, 메시징 시스템 등 외부 시스템과의 연동을 위해 사용합니다. 내부 DB 접근은 CommandPort/QueryPort를 사용합니다. 예: PaymentClientPort, NotificationClientPort.','역할 분리. DB 접근과 외부 API 호출을 명확히 구분하여 장애 격리와 모니터링을 용이하게 합니다.',0,0,'[\"INTERFACE\"]','2026-01-16 02:27:24','2026-01-16 02:27:24',48,NULL,NULL,NULL,NULL),(259,3,'CLPRT-003','ClientPort는 도메인 언어로 메서드 정의','MAJOR','NAMING','ClientPort 메서드는 외부 시스템 용어가 아닌 도메인 언어를 사용합니다. (예: requestPayment() ✅, callPgApi() ❌) 외부 시스템 세부사항(URL, 프로토콜)은 Adapter에 캡슐화합니다.','도메인 중심 설계. Application Layer는 외부 시스템이 무엇인지 알 필요 없이 도메인 관점의 메서드만 호출합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:27:24','2026-01-16 02:27:24',48,NULL,NULL,NULL,NULL),(260,3,'CLPRT-004','ClientPort는 실패 처리를 반환 타입으로 명시','MAJOR','BEHAVIOR','외부 호출 실패 가능성을 반환 타입으로 명시합니다. 필수 성공: throws DomainException, 실패 허용: Optional<Result> 또는 Result with isSuccess(). 암묵적 예외 발생은 지양합니다.','명시적 실패 처리. 호출자가 실패 가능성을 인지하고 적절히 처리할 수 있도록 API 시그니처에 표현합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:27:24','2026-01-16 02:27:24',48,NULL,NULL,NULL,NULL),(261,4,'CDTO-001','Command DTO는 Record로 정의','BLOCKER','STRUCTURE','Command DTO는 반드시 Java Record로 정의합니다. class 사용을 금지합니다. Record는 불변성을 보장하고 equals/hashCode/toString을 자동 생성합니다.','불변성 보장. Command는 생성 후 변경되지 않아야 하며, Record가 이를 자연스럽게 강제합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:27:25','2026-01-16 06:50:28',49,NULL,NULL,NULL,NULL),(262,4,'CDTO-002','Command DTO 생성용은 Create{Domain}Command 네이밍','MAJOR','NAMING','생성 Command는 Create{Domain}Command 형태로 네이밍합니다. 예: CreateOrderCommand, CreateMemberCommand. Register, Add 등 다른 동사는 사용하지 않습니다.','네이밍 일관성. 생성 작업임을 명확히 표현하고 CRUD의 C를 직관적으로 나타냅니다.',0,0,'[\"CLASS\"]','2026-01-16 02:27:25','2026-01-16 06:50:28',49,NULL,NULL,NULL,NULL),(263,4,'CDTO-003','Command DTO 수정용은 Update{Domain}Command 네이밍','MAJOR','NAMING','수정 Command는 Update{Domain}Command 형태로 네이밍합니다. 예: UpdateOrderCommand, UpdateMemberCommand. Modify, Edit 등 다른 동사는 사용하지 않습니다.','네이밍 일관성. 수정 작업임을 명확히 표현하고 CRUD의 U를 직관적으로 나타냅니다.',0,0,'[\"CLASS\"]','2026-01-16 02:27:25','2026-01-16 06:50:28',49,NULL,NULL,NULL,NULL),(264,4,'CDTO-004','Update Command는 UpdateData 생성에 필요한 전체 필드 포함','MAJOR','STRUCTURE','Update Command는 UpdateData VO 생성에 필요한 모든 필드를 포함해야 합니다. 부분 업데이트가 필요하면 null 허용 필드로 정의합니다. Factory에서 UpdateData로 변환됩니다.','명시적 수정 범위. 어떤 필드가 수정 가능한지 Command 레벨에서 명확히 정의합니다.',0,0,'[\"CLASS\"]','2026-01-16 02:27:25','2026-01-16 06:50:28',49,NULL,NULL,NULL,NULL),(265,4,'CDTO-005','상태 변경 전용 Command는 Change{Domain}StatusCommand로 분리','MAJOR','STRUCTURE','상태만 변경하는 경우 Update Command와 분리하여 Change{Domain}StatusCommand를 사용합니다. 예: ChangeOrderStatusCommand, ChangeMemberStatusCommand. 상태 변경은 별도 비즈니스 의미를 가집니다.','단일 책임. 전체 수정과 상태 변경은 다른 비즈니스 의미를 가지므로 분리하여 관리합니다.',0,0,'[\"CLASS\"]','2026-01-16 02:27:25','2026-01-16 06:50:28',49,NULL,NULL,NULL,NULL),(266,4,'CDTO-006','Command DTO에 Validation 어노테이션 금지','BLOCKER','ANNOTATION','Command DTO에 @Valid, @NotNull, @Size 등 Bean Validation 어노테이션을 사용하지 않습니다. 입력 검증은 REST-API Layer의 ApiRequest DTO에서 처리되어야 합니다.','레이어 분리. 입력 검증은 Adapter-In 책임이며, Application Layer Command는 이미 검증된 데이터를 받습니다.',0,1,'[\"FIELD\"]','2026-01-16 02:27:25','2026-01-16 06:50:28',49,NULL,NULL,NULL,NULL),(267,4,'CDTO-007','Command DTO는 Domain 타입 의존 금지','BLOCKER','DEPENDENCY','Command DTO의 필드는 primitive 타입, String, 표준 Java 타입만 사용합니다. Domain의 VO나 ID 타입을 직접 사용하면 안 됩니다. (예: Long memberId ✅, MemberId memberId ❌)','레이어 분리. Command는 외부 입력을 표현하며, Domain 타입 변환은 Factory 책임입니다.',0,1,'[\"FIELD\"]','2026-01-16 02:27:25','2026-01-16 06:50:28',49,NULL,NULL,NULL,NULL),(268,4,'QDTO-001','Query DTO는 Record로 정의','BLOCKER','STRUCTURE','Query DTO는 반드시 Java Record로 정의합니다. class 사용을 금지합니다. Query는 조회 조건을 담는 불변 객체입니다.','불변성 보장. Query는 조회 요청을 표현하며, 생성 후 변경되지 않아야 합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:27:26','2026-01-16 06:50:28',50,NULL,NULL,NULL,NULL),(269,4,'QDTO-002','단건 조회 Query는 Get{Domain}Query 네이밍','MAJOR','NAMING','단건 조회 Query는 Get{Domain}Query 형태로 네이밍합니다. 예: GetOrderQuery, GetMemberQuery. ID로 단건 조회하는 경우 사용합니다.','네이밍 일관성. Get 접두어로 단건 조회임을 명확히 표현합니다.',0,0,'[\"CLASS\"]','2026-01-16 02:27:27','2026-01-16 06:50:28',50,NULL,NULL,NULL,NULL),(270,4,'QDTO-003','목록 조회 Query는 Search{Domain}sQuery 네이밍 (복수형)','MAJOR','NAMING','목록 조회 Query는 Search{Domain}sQuery 형태로 네이밍합니다. 예: SearchOrdersQuery, SearchMembersQuery. 복수형 도메인명을 사용하여 목록 조회임을 명확히 합니다.','네이밍 일관성. Search 접두어와 복수형으로 목록 조회임을 직관적으로 표현합니다.',0,0,'[\"CLASS\"]','2026-01-16 02:27:27','2026-01-16 06:50:28',50,NULL,NULL,NULL,NULL),(271,4,'QDTO-004','목록 조회 Query는 CommonSearchParams 포함 필수','MAJOR','STRUCTURE','목록 조회 Query(Search*Query)는 CommonSearchParams를 필드로 포함해야 합니다. CommonSearchParams는 정렬(sortKey, sortDirection), 페이징(page, size), 삭제 포함 여부(includeDeleted) 정보를 담습니다.','조회 표준화. 정렬과 페이징 정보를 일관된 방식으로 전달하여 QueryFactory에서 QueryContext로 변환합니다.',0,0,'[\"FIELD\"]','2026-01-16 02:27:27','2026-01-16 06:50:28',50,NULL,NULL,NULL,NULL),(272,4,'QDTO-005','Query DTO는 Domain 타입 의존 금지','BLOCKER','DEPENDENCY','Query DTO의 필드는 primitive 타입, String, 표준 Java 타입만 사용합니다. Domain의 VO나 ID 타입을 직접 사용하면 안 됩니다. Domain 타입 변환은 QueryFactory에서 Criteria 생성 시 처리합니다.','레이어 분리. Query는 외부 입력을 표현하며, Domain 타입 변환은 Factory 책임입니다.',0,1,'[\"FIELD\"]','2026-01-16 02:27:27','2026-01-16 06:50:28',50,NULL,NULL,NULL,NULL),(273,4,'RDTO-001','Response DTO는 Record로 정의','BLOCKER','STRUCTURE','Response DTO는 반드시 Java Record로 정의합니다. class 사용을 금지합니다. Response는 조회 결과를 담는 불변 객체입니다.','불변성 보장. Response는 외부로 전달되는 데이터이며, 생성 후 변경되지 않아야 합니다.',0,1,'[\"CLASS\"]','2026-01-16 02:27:28','2026-01-16 06:50:28',51,NULL,NULL,NULL,NULL),(274,4,'RDTO-002','단건 상세 응답은 {Domain}Response 네이밍','MAJOR','NAMING','단건 상세 조회 응답은 {Domain}Response 형태로 네이밍합니다. 예: OrderResponse, MemberResponse. 해당 Domain의 모든 상세 정보를 포함합니다.','네이밍 일관성. Response 접미어로 응답 객체임을 명확히 표현합니다.',0,0,'[\"CLASS\"]','2026-01-16 02:27:28','2026-01-16 06:50:28',51,NULL,NULL,NULL,NULL),(275,4,'RDTO-003','목록용 요약 응답은 {Domain}SummaryResponse 네이밍','MAJOR','NAMING','목록 조회 시 각 항목의 요약 정보는 {Domain}SummaryResponse로 네이밍합니다. 예: OrderSummaryResponse, MemberSummaryResponse. 상세 정보보다 적은 필드만 포함합니다.','성능 최적화. 목록 조회 시 필요한 최소 정보만 전달하여 네트워크와 처리 비용을 절감합니다.',0,0,'[\"CLASS\"]','2026-01-16 02:27:28','2026-01-16 06:50:28',51,NULL,NULL,NULL,NULL),(276,4,'RDTO-004','페이지 응답은 {Domain}PageResponse 네이밍 (PageMeta 포함)','MAJOR','NAMING','페이지 기반 목록 응답은 {Domain}PageResponse로 네이밍합니다. content(목록)와 PageMeta(page, size, totalElements, totalPages)를 포함합니다. 관리자 화면 등 전체 개수가 필요한 경우 사용합니다.','페이지네이션 표준화. PageMeta를 통해 일관된 페이지 정보를 제공합니다.',0,0,'[\"CLASS\"]','2026-01-16 02:27:28','2026-01-16 06:50:28',51,NULL,NULL,NULL,NULL),(277,4,'RDTO-005','슬라이스 응답은 {Domain}SliceResponse 네이밍 (SliceMeta 포함)','MAJOR','NAMING','슬라이스 기반 목록 응답은 {Domain}SliceResponse로 네이밍합니다. content(목록)와 SliceMeta(size, hasNext, cursor, count)를 포함합니다. 무한 스크롤, 더보기 UI에 적합하며 COUNT 쿼리가 불필요합니다.','성능 최적화. COUNT 쿼리 없이 다음 페이지 존재 여부만 확인하여 대용량 데이터에 효율적입니다.',0,0,'[\"CLASS\"]','2026-01-16 02:27:28','2026-01-16 06:50:28',51,NULL,NULL,NULL,NULL),(278,4,'RDTO-006','생성 결과 응답은 {Domain}IdResponse 네이밍','MAJOR','NAMING','생성(Create) 작업의 응답은 {Domain}IdResponse로 네이밍합니다. 예: OrderIdResponse, MemberIdResponse. 생성된 엔티티의 ID를 반환합니다.','명확한 응답. 생성 작업의 결과로 ID만 필요한 경우 경량 응답을 제공합니다.',0,0,'[\"CLASS\"]','2026-01-16 02:27:28','2026-01-16 06:50:28',51,NULL,NULL,NULL,NULL),(279,4,'RDTO-007','Response DTO는 createdAt, updatedAt 시간 필드 필수 포함','MAJOR','STRUCTURE','Response DTO({Domain}Response, {Domain}SummaryResponse)는 createdAt과 updatedAt 필드를 모두 포함해야 합니다. 단, IdResponse는 제외합니다.','감사 추적. 데이터의 생성 시점과 최종 수정 시점은 필수 정보입니다.',0,0,'[\"FIELD\"]','2026-01-16 02:27:28','2026-01-16 06:50:28',51,NULL,NULL,NULL,NULL),(280,4,'RDTO-008','Response DTO는 Domain 타입 의존 금지','BLOCKER','DEPENDENCY','Response DTO의 필드는 primitive 타입, String, 표준 Java 타입만 사용합니다. Domain의 VO나 ID 타입을 직접 노출하면 안 됩니다. Domain → Response 변환은 Assembler에서 값 추출하여 처리합니다.','레이어 분리. Response는 외부 API 계약이며, Domain 내부 타입이 노출되면 결합도가 높아집니다.',0,1,'[\"FIELD\"]','2026-01-16 02:27:28','2026-01-16 06:50:28',51,NULL,NULL,NULL,NULL),(281,4,'BDL-001','PersistBundle은 Class로 정의 (mutable)','MAJOR','STRUCTURE','PersistBundle은 ID Enrichment를 위해 Class로 정의합니다. Record가 아닌 Class를 사용하여 저장 후 ID를 세팅할 수 있어야 합니다. Domain 저장 → ID 획득 → Outbox에 ID 세팅 패턴에 필요합니다.','ID Enrichment 패턴. Facade에서 persist 후 획득한 ID를 Bundle 내 다른 객체에 전달해야 합니다.',0,0,'[\"CLASS\"]','2026-01-16 02:27:29','2026-01-16 06:50:28',52,NULL,NULL,NULL,NULL),(282,4,'BDL-002','QueryBundle은 Record로 정의 (immutable)','MAJOR','STRUCTURE','QueryBundle은 조회 결과의 단순 묶음이므로 Record로 정의합니다. 조회 결과는 변경될 필요가 없으므로 불변 객체가 적합합니다.','불변성 보장. 조회 결과 Bundle은 생성 후 변경되지 않아야 합니다.',0,0,'[\"CLASS\"]','2026-01-16 02:27:29','2026-01-16 06:50:28',52,NULL,NULL,NULL,NULL),(283,4,'BDL-003','PersistBundle은 {Domain}PersistBundle 네이밍','MAJOR','NAMING','저장용 Bundle은 {Domain}PersistBundle로 네이밍합니다. 예: OrderPersistBundle, PaymentPersistBundle. Domain + 관련 객체(Outbox 등)를 함께 묶어 저장합니다.','네이밍 일관성. PersistBundle 접미어로 저장용 복합 객체임을 명확히 합니다.',0,0,'[\"CLASS\"]','2026-01-16 02:27:29','2026-01-16 06:50:28',52,NULL,NULL,NULL,NULL),(284,4,'BDL-004','QueryBundle은 {Domain}QueryBundle 네이밍','MAJOR','NAMING','조회 결과 Bundle은 {Domain}QueryBundle로 네이밍합니다. 예: OrderQueryBundle, MemberQueryBundle. 여러 Domain의 조회 결과를 함께 묶어 전달합니다.','네이밍 일관성. QueryBundle 접미어로 조회 결과 복합 객체임을 명확히 합니다.',0,0,'[\"CLASS\"]','2026-01-16 02:27:29','2026-01-16 06:50:28',52,NULL,NULL,NULL,NULL),(285,4,'BDL-005','PersistBundle은 with{Id}() 패턴으로 ID 세팅','MAJOR','BEHAVIOR','PersistBundle은 ID 세팅을 위해 with{Domain}Id() 메서드를 제공합니다. 예: withOrderId(orderId). 내부적으로 Domain의 withId() 메서드를 호출하여 ID를 세팅합니다.','ID Enrichment 캡슐화. Bundle이 내부 객체의 ID 세팅 로직을 캡슐화합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:27:30','2026-01-16 06:50:28',52,NULL,NULL,NULL,NULL),(286,4,'BDL-006','Bundle은 ID Getter를 위임 메서드로 제공 (Law of Demeter)','MAJOR','BEHAVIOR','Bundle은 orderId(), outboxId() 같은 위임 메서드를 제공합니다. bundle.order().id() 대신 bundle.orderId()를 사용합니다. Law of Demeter를 준수하여 내부 구조를 캡슐화합니다.','Law of Demeter. 메서드 체이닝을 방지하고 Bundle의 내부 구조 변경에 대한 영향을 최소화합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:27:30','2026-01-16 06:50:28',52,NULL,NULL,NULL,NULL),(287,4,'BDL-007','Bundle은 Domain 객체를 직접 포함','MAJOR','STRUCTURE','Bundle은 Domain 객체(Aggregate, Entity, Outbox 등)를 필드로 직접 포함합니다. DTO나 primitive 타입으로 분해하지 않습니다. order(), outbox() 같은 getter로 Domain 객체에 접근합니다.','Domain 중심 설계. Bundle은 Application Layer 내부에서만 사용되며, Domain 객체를 그대로 전달합니다.',0,0,'[\"FIELD\"]','2026-01-16 02:27:30','2026-01-16 06:50:28',52,NULL,NULL,NULL,NULL),(297,4,'SCHS-001','Scheduler UseCase는 port/in/scheduler 패키지에 정의','MAJOR','STRUCTURE','Scheduler UseCase 인터페이스는 port/in/scheduler 패키지에 정의합니다. port/in/command, port/in/query와 분리하여 스케줄러 전용 UseCase임을 명확히 합니다. 예: ProcessOrderOutboxUseCase, RetryFailedPaymentUseCase.','관심사 분리. Command/Query와 별도로 Scheduler 전용 UseCase를 관리하여 역할을 명확히 합니다.',0,0,'[\"INTERFACE\"]','2026-01-16 02:28:58','2026-01-16 06:50:28',54,NULL,NULL,NULL,NULL),(298,4,'SCHS-002','Scheduler Service는 service/scheduler 패키지에 구현','MAJOR','STRUCTURE','Scheduler UseCase의 구현체는 service/scheduler 패키지에 위치합니다. @Component 어노테이션을 사용하며, UseCase 인터페이스를 구현합니다. 예: ProcessOrderOutboxService.','일관된 구조. service/command, service/query와 동일한 패턴으로 service/scheduler를 구성합니다.',0,0,'[\"CLASS\"]','2026-01-16 02:28:58','2026-01-16 06:50:28',54,NULL,NULL,NULL,NULL),(299,4,'SCHS-003','Application Layer에 @Scheduled 어노테이션 금지','BLOCKER','ANNOTATION','Application Layer의 Scheduler Service에는 @Scheduled 어노테이션을 사용하지 않습니다. @Scheduled는 adapter-in/scheduler에서만 사용합니다. Application Layer는 순수 비즈니스 로직만 포함합니다.','Thin Scheduler 패턴. 스케줄링 트리거는 adapter-in에서, 비즈니스 로직은 Application Layer에서 분리합니다.',0,1,'[\"CLASS\", \"METHOD\"]','2026-01-16 02:28:58','2026-01-16 06:50:28',54,NULL,NULL,NULL,NULL),(300,4,'SCHS-004','Scheduler Service는 분산락(LockManager) 사용 필수','BLOCKER','BEHAVIOR','Scheduler Service 실행 시작 시 LockManager를 통해 분산락을 획득해야 합니다. 다중 인스턴스 환경에서 동일 작업이 중복 실행되는 것을 방지합니다. 락 획득 실패 시 즉시 리턴합니다.','중복 방지. 여러 서버에서 동일 Scheduler가 동시에 실행되면 데이터 정합성 문제가 발생합니다.',0,1,'[\"METHOD\"]','2026-01-16 02:28:58','2026-01-16 06:50:28',54,NULL,NULL,NULL,NULL),(301,4,'SCHS-005','Scheduler Service는 Manager를 통해 Port 사용 (Port 직접 주입 금지)','BLOCKER','DEPENDENCY','Scheduler Service는 Port(ClientPort 등)를 직접 주입받지 않습니다. 반드시 Manager(ClientManager)를 통해 외부 호출을 수행합니다. 예: PaymentClientPort 대신 PaymentClientManager를 주입받습니다.','C-005 규칙 준수. Port 직접 주입은 금지되며, Manager가 Port를 캡슐화하여 일관된 호출 정책을 적용합니다.',0,1,'[\"FIELD\", \"CONSTRUCTOR\"]','2026-01-16 02:28:58','2026-01-16 06:50:28',54,NULL,NULL,NULL,NULL),(302,4,'SCHS-006','Scheduler Service는 ReadManager로 PENDING 상태 Outbox 조회','MAJOR','BEHAVIOR','Scheduler Service는 OutboxReadManager를 통해 PENDING 상태의 Outbox 목록을 조회합니다. EventListener 실패로 처리되지 않은 항목들을 배치로 처리합니다. 조회 시 batchSize를 제한합니다.','Fallback 역할. EventListener 실패 시 Scheduler가 재처리하여 최종 일관성을 보장합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:28:58','2026-01-16 06:50:28',54,NULL,NULL,NULL,NULL),(303,4,'SCHS-007','Scheduler Service 외부 호출 시 멱등키(outboxId) 필수 전달','BLOCKER','BEHAVIOR','Scheduler Service가 ClientManager를 통해 외부 API를 호출할 때 outboxId를 멱등키로 전달합니다. ClientManager가 실제 HTTP 헤더나 요청 파라미터로 멱등키를 설정합니다. EventListener에서 이미 성공했더라도 재호출이 안전합니다.','중복 안전. 멱등키 덕분에 EventListener와 Scheduler가 동일 항목을 처리해도 문제없습니다.',0,1,'[\"METHOD\"]','2026-01-16 02:28:59','2026-01-16 06:50:28',54,NULL,NULL,NULL,NULL),(304,4,'SCHS-008','Scheduler Service는 처리 결과에 따라 Outbox 상태 업데이트','MAJOR','BEHAVIOR','Scheduler Service는 외부 호출 성공 시 OutboxPersistenceManager를 통해 Outbox를 SUCCESS로, 실패 시 retryCount를 증가시킵니다. markSuccess(), incrementRetryCount() 메서드를 사용합니다.','상태 추적. Outbox 상태를 통해 처리 현황을 모니터링하고 문제를 추적할 수 있습니다.',0,0,'[\"METHOD\"]','2026-01-16 02:28:59','2026-01-16 06:50:28',54,NULL,NULL,NULL,NULL),(305,4,'SCHS-009','Scheduler Service는 maxRetryCount 초과 시 FAILED 처리','MAJOR','BEHAVIOR','Outbox의 retryCount가 maxRetryCount를 초과하면 FAILED 상태로 변경합니다. FAILED는 Dead Letter로 취급하여 수동 처리 또는 운영 알림이 필요합니다.','무한 재시도 방지. 복구 불가능한 오류에 대해 무한 재시도하지 않고 운영팀에 알립니다.',0,0,'[\"METHOD\"]','2026-01-16 02:28:59','2026-01-16 06:50:28',54,NULL,NULL,NULL,NULL),(306,4,'SCHS-010','Scheduler Service는 한 번에 batchSize 건씩 배치 처리','MAJOR','BEHAVIOR','Scheduler Service는 PENDING Outbox를 한 번에 전체 처리하지 않고 batchSize만큼씩 조회하여 처리합니다. 대량 미처리 건이 있어도 메모리와 시간을 제한하여 시스템 안정성을 유지합니다.','리소스 관리. 대량 데이터 처리 시 메모리 부족이나 타임아웃을 방지합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:28:59','2026-01-16 06:50:28',54,NULL,NULL,NULL,NULL),(307,4,'SCHS-011','Scheduler Service는 건별 독립 트랜잭션으로 처리','MAJOR','BEHAVIOR','Scheduler Service는 각 Outbox 항목을 독립적인 트랜잭션으로 처리합니다. 하나의 항목 처리 실패가 다른 항목에 영향을 주지 않습니다. for 루프 내에서 try-catch로 각 건을 격리합니다.','장애 격리. 한 건의 실패가 전체 배치를 롤백시키지 않아 나머지 항목이 정상 처리됩니다.',0,0,'[\"METHOD\"]','2026-01-16 02:28:59','2026-01-16 06:50:28',54,NULL,NULL,NULL,NULL),(308,4,'SCHS-012','Scheduler Service는 finally 블록에서 분산락 해제','BLOCKER','BEHAVIOR','분산락 획득 후에는 반드시 try-finally 패턴을 사용하여 finally에서 락을 해제합니다. 예외 발생 시에도 락이 해제되어야 다음 실행 주기에 정상 동작합니다.','데드락 방지. 예외로 인해 락이 해제되지 않으면 모든 인스턴스가 대기 상태가 됩니다.',0,1,'[\"METHOD\"]','2026-01-16 02:28:59','2026-01-16 06:50:28',54,NULL,NULL,NULL,NULL),(309,3,'TER-001','ApplicationEventPublisher 직접 사용 금지','BLOCKER','DEPENDENCY','Service에서 ApplicationEventPublisher를 직접 주입하여 사용하지 않습니다. 반드시 TransactionEventRegistry를 통해 이벤트를 발행해야 합니다. TransactionEventRegistry가 트랜잭션 상태에 따라 발행 시점을 결정합니다.','일관된 이벤트 처리. TransactionEventRegistry를 통해 이벤트 발행 정책을 중앙에서 관리합니다.',0,1,'[\"FIELD\", \"CONSTRUCTOR\"]','2026-01-16 02:29:00','2026-01-16 02:29:00',33,NULL,NULL,NULL,NULL),(310,3,'TER-002','TransactionEventRegistry는 Service에서 Facade 호출 후 사용','MAJOR','BEHAVIOR','TransactionEventRegistry.registerForPublish()는 Service에서 Facade를 통한 저장 완료 후 호출합니다. Facade 호출 전에 이벤트를 발행하면 데이터가 저장되지 않은 상태에서 이벤트가 발행될 수 있습니다.','데이터 정합성. Domain과 Outbox가 저장된 후에 이벤트를 발행하여 EventListener가 올바른 데이터를 참조합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:29:00','2026-01-16 02:29:00',33,NULL,NULL,NULL,NULL),(311,3,'TER-003','TransactionEventRegistry는 DomainEvent 인터페이스 구현 객체 발행','MAJOR','BEHAVIOR','TransactionEventRegistry.registerForPublish()에 전달하는 객체는 DomainEvent 인터페이스를 구현해야 합니다. 임의의 객체 대신 명확한 계약을 가진 DomainEvent를 사용합니다.','타입 안전성. DomainEvent 마커 인터페이스로 이벤트 객체를 식별하고 EventListener에서 타입 안전하게 처리합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:29:00','2026-01-16 02:29:00',33,NULL,NULL,NULL,NULL),(312,3,'TER-004','TransactionEventRegistry의 기본 메서드는 registerForPublish()','MAJOR','BEHAVIOR','단일 이벤트 발행은 registerForPublish(DomainEvent)를 사용합니다. 여러 이벤트는 registerAllForPublish(List<DomainEvent>)를 사용합니다. 현재 아키텍처에서는 트랜잭션이 이미 종료되어 즉시 발행됩니다.','API 일관성. 표준 메서드를 통해 이벤트 발행 방식을 통일합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:29:00','2026-01-16 02:29:00',33,NULL,NULL,NULL,NULL),(313,3,'TER-005','TransactionEventRegistry.publish()는 예비용 (향후 확장)','INFO','BEHAVIOR','publish(Object) 메서드는 즉시 발행이 필요한 특수 상황을 위해 예비로 제공됩니다. 일반적인 DomainEvent 발행에는 registerForPublish()를 사용하고, 향후 확장 시 활용됩니다.','확장성. 다양한 이벤트 발행 요구사항에 대응할 수 있도록 API를 확장 가능하게 설계합니다.',0,0,'[\"METHOD\"]','2026-01-16 02:29:01','2026-01-16 02:29:01',33,NULL,NULL,NULL,NULL),(314,5,'ENT-001','BaseAuditEntity 상속 필수','BLOCKER','STRUCTURE','모든 JPA Entity는 BaseAuditEntity를 상속해야 합니다. createdAt, updatedAt 필드가 자동으로 관리됩니다. 논리삭제가 필요한 Entity는 SoftDeletableEntity를 상속합니다.','감사 추적(Audit Trail) 일관성 보장. 모든 Entity에 생성/수정 시간이 자동 기록되어 데이터 변경 이력을 추적할 수 있습니다.',0,1,'[\"CLASS\"]','2026-01-16 06:52:03','2026-01-16 07:05:56',NULL,NULL,NULL,NULL,NULL),(315,5,'ENT-002','Long FK 전략 (JPA 관계 어노테이션 금지)','BLOCKER','STRUCTURE','@ManyToOne, @OneToMany, @OneToOne, @ManyToMany 등 JPA 관계 어노테이션 사용을 금지합니다. 외래키는 Long userId 형태로 직접 관리합니다.','Lazy Loading 문제, N+1 쿼리 문제, 복잡한 영속성 컨텍스트 관리 문제를 원천 차단합니다. Application Layer에서 필요 시 별도 조회로 해결합니다.',0,1,'[\"FIELD\"]','2026-01-16 06:52:03','2026-01-16 07:05:56',NULL,NULL,NULL,NULL,NULL),(316,5,'ENT-003','Entity에서 Lombok 금지','BLOCKER','ANNOTATION','@Data, @Builder, @Getter, @Setter, @NoArgsConstructor, @AllArgsConstructor 등 모든 Lombok 어노테이션 사용을 금지합니다. JPA proxy와의 충돌 및 바이트코드 조작 문제를 방지합니다.','JPA Entity의 특성상 프록시 객체가 생성되며, Lombok의 equals/hashCode가 예상치 못한 문제를 일으킬 수 있습니다. 명시적 코드로 동작을 명확히 합니다.',0,1,'[\"CLASS\"]','2026-01-16 06:52:03','2026-01-16 07:05:56',NULL,NULL,NULL,NULL,NULL),(317,5,'ENT-004','of() 정적 팩토리 메서드 필수','CRITICAL','STRUCTURE','Entity 생성은 public static of(...) 팩토리 메서드를 통해서만 가능해야 합니다. 생성자는 protected 또는 private으로 선언합니다.','Entity 생성 시점의 불변식(invariant)을 보장하고, 명확한 생성 의도를 표현합니다. Mapper에서 Entity.of(...)로 호출합니다.',0,0,'[\"METHOD\"]','2026-01-16 06:52:03','2026-01-16 07:05:56',NULL,NULL,NULL,NULL,NULL),(318,5,'ENT-005','Setter 메서드 금지','BLOCKER','BEHAVIOR','Entity에 Setter 메서드(set*)를 정의하면 안 됩니다. 상태 변경은 의미 있는 비즈니스 메서드(예: cancel(), complete())를 통해 수행합니다. 단, update 용도의 of() 재호출은 허용됩니다.','Entity의 일관성과 불변식 보장. 무분별한 상태 변경을 방지하고, 비즈니스 의도가 담긴 메서드로 상태 전이를 명확히 합니다.',0,1,'[\"METHOD\"]','2026-01-16 06:52:03','2026-01-16 07:05:56',NULL,NULL,NULL,NULL,NULL),(319,5,'ENT-006','protected/private 생성자 사용','MAJOR','STRUCTURE','Entity의 생성자는 protected 또는 private으로 선언합니다. JPA 프록시를 위해 기본 생성자(protected)가 필수이며, 외부에서 new 키워드로 직접 생성을 방지합니다.','Entity 생성을 of() 팩토리로 강제하여 불변식 보장 및 생성 로직 중앙화. JPA 명세상 기본 생성자 필수 요구사항 충족.',0,0,'[\"CONSTRUCTOR\"]','2026-01-16 06:52:03','2026-01-16 07:05:56',NULL,NULL,NULL,NULL,NULL),(320,5,'ENT-007','SoftDeletableEntity 적용 (논리삭제)','MAJOR','STRUCTURE','논리삭제가 필요한 Entity는 SoftDeletableEntity를 상속합니다. deletedAt 필드가 추가되며, @SQLRestriction(\"deleted_at IS NULL\")로 기본 조회에서 삭제된 데이터를 제외합니다.','물리삭제 대신 논리삭제로 데이터 복구 가능성 확보 및 감사 추적 유지. 삭제된 데이터는 조회되지 않지만 DB에 보존됩니다.',0,0,'[\"CLASS\"]','2026-01-16 06:52:03','2026-01-16 07:05:56',NULL,NULL,NULL,NULL,NULL),(321,5,'ENT-008','ID Auto Increment 전략','MAJOR','STRUCTURE','Entity ID는 @GeneratedValue(strategy = GenerationType.IDENTITY)를 사용합니다. INSERT 시 DB가 ID를 생성하며, persist() 후 생성된 ID를 반환합니다.','MySQL Auto Increment와 일치. save() 후 즉시 ID 접근 가능하며, 분산 환경에서는 UUIDv7/Snowflake 등 별도 전략 적용.',0,0,'[\"FIELD\"]','2026-01-16 06:52:03','2026-01-16 07:05:56',NULL,NULL,NULL,NULL,NULL),(322,5,'ENT-009','@Column nullable, length 명시','MINOR','ANNOTATION','@Column 어노테이션에 nullable, length 속성을 명시적으로 선언합니다. 특히 String 타입은 @Column(nullable = false, length = 100) 형태로 제약조건을 명확히 합니다.','DDL 자동 생성 시 명확한 스키마 정의. 코드 리뷰 시 필드 제약조건을 즉시 파악 가능하며, 문서화 효과가 있습니다.',1,0,'[\"FIELD\"]','2026-01-16 06:52:03','2026-01-16 07:05:56',NULL,NULL,NULL,NULL,NULL),(323,5,'ENT-010','@Table 테이블명 명시','MINOR','ANNOTATION','@Entity 클래스에 @Table(name = \"order\") 형태로 테이블명을 명시합니다. 클래스명과 테이블명이 다를 수 있으며, 네이밍 규칙 일관성을 보장합니다.','명시적 테이블명으로 DB 스키마와 Entity 매핑을 명확히 합니다. 복수형/단수형 혼란을 방지합니다.',1,0,'[\"CLASS\"]','2026-01-16 06:52:03','2026-01-16 07:05:56',NULL,NULL,NULL,NULL,NULL),(324,5,'REPO-001','Command 전용 (save/delete만)','BLOCKER','BEHAVIOR','JpaRepository는 Command(저장/삭제) 전용입니다. JpaRepository<Entity, Long>을 상속하면 save(), delete()만 사용합니다. 조회는 QueryDslRepository로 분리합니다.','CQRS 패턴 적용. Command와 Query의 책임을 분리하여 각 Repository의 역할을 명확히 하고, 성능 최적화 포인트를 분리합니다.',0,1,'[\"INTERFACE\"]','2026-01-16 06:52:03','2026-01-16 07:05:56',NULL,NULL,NULL,NULL,NULL),(325,5,'REPO-002','Query Method 금지','BLOCKER','BEHAVIOR','JpaRepository에 findByName(), findByEmailAndStatus() 등 Query Method를 정의하면 안 됩니다. 모든 조회 메서드는 QueryDslRepository에서 JPAQueryFactory로 구현합니다.','Query Method의 메서드명 길이 증가, 복잡한 조건 표현 한계, 타입 안전성 부족 문제를 QueryDSL로 해결합니다.',0,1,'[\"INTERFACE\"]','2026-01-16 06:52:03','2026-01-16 07:05:56',NULL,NULL,NULL,NULL,NULL),(326,5,'REPO-003','@Query 어노테이션 금지','BLOCKER','ANNOTATION','@Query 어노테이션을 사용한 JPQL/Native Query 정의를 금지합니다. 문자열 기반 쿼리는 컴파일 타임 오류 감지 불가하며, QueryDSL의 타입 안전 쿼리로 대체합니다.','JPQL 문자열은 런타임에만 오류 발견 가능. QueryDSL은 Java 코드로 쿼리를 작성하여 컴파일 타임에 오류를 감지합니다.',0,1,'[\"METHOD\"]','2026-01-16 06:52:03','2026-01-16 07:05:56',NULL,NULL,NULL,NULL,NULL),(327,5,'REPO-004','QuerydslPredicateExecutor 금지','BLOCKER','STRUCTURE','JpaRepository에서 QuerydslPredicateExecutor<Entity>를 상속하면 안 됩니다. JpaRepository는 순수 Command 전용으로 유지하고, 조회는 별도 QueryDslRepository 클래스에서 처리합니다.','CQRS 분리 원칙 준수. Repository 인터페이스를 단순하게 유지하고, 복잡한 쿼리 로직을 별도 클래스로 캡슐화합니다.',0,1,'[\"INTERFACE\"]','2026-01-16 06:52:03','2026-01-16 07:05:56',NULL,NULL,NULL,NULL,NULL),(328,5,'REPO-005','Repository에서 @Transactional 금지','BLOCKER','ANNOTATION','JpaRepository 인터페이스나 구현체에서 @Transactional 어노테이션을 사용하면 안 됩니다. 트랜잭션 경계는 Application Layer(UseCase/Service)에서 관리합니다.','트랜잭션 경계를 비즈니스 로직 계층에서 제어하여 일관된 트랜잭션 관리. Repository는 단순 데이터 접근 역할만 수행합니다.',1,1,'[\"INTERFACE\", \"METHOD\"]','2026-01-16 06:52:03','2026-01-16 07:05:56',NULL,NULL,NULL,NULL,NULL),(329,3,'QDR-001','Query 전용 (조회만)','BLOCKER','BEHAVIOR','QueryDslRepository는 Query(조회) 전용입니다. save(), delete(), update() 등 상태 변경 메서드를 포함하면 안 됩니다. 상태 변경은 JpaRepository를 통해 수행합니다.','CQRS 패턴 적용. Query와 Command의 책임을 분리하여 조회 최적화와 변경 트랜잭션을 독립적으로 관리합니다.',0,1,'[\"CLASS\"]','2026-01-16 06:52:04','2026-01-16 06:52:04',NULL,NULL,NULL,NULL,NULL),(330,3,'QDR-002','Join 절대 금지','BLOCKER','BEHAVIOR','QueryDslRepository에서 .join(), .leftJoin(), .rightJoin(), .innerJoin() 등 모든 Join 구문을 사용하면 안 됩니다. 연관 데이터는 Application Layer에서 별도 조회 후 조합합니다.','Join으로 인한 N+1 문제, 복잡한 영속성 관리, 성능 예측 어려움을 원천 차단. Long FK 전략과 일관성 유지.',0,1,'[\"METHOD\"]','2026-01-16 06:52:04','2026-01-16 06:52:04',NULL,NULL,NULL,NULL,NULL),(331,3,'QDR-003','findAll 금지 (OOM 방지)','BLOCKER','BEHAVIOR','findAll() 메서드 정의를 금지합니다. 조건 없이 전체 데이터를 조회하면 OutOfMemory 위험이 있습니다. 반드시 Criteria 기반 조회(findByCriteria)와 페이징을 사용합니다.','대량 데이터 로드로 인한 OOM 방지. 항상 조건과 페이징을 강제하여 안정적인 조회를 보장합니다.',0,1,'[\"METHOD\"]','2026-01-16 06:52:04','2026-01-16 06:52:04',NULL,NULL,NULL,NULL,NULL),(332,3,'QDR-004','findById 필수 메서드','MAJOR','STRUCTURE','QueryDslRepository는 Optional<Entity> findById(Long id) 메서드를 필수로 구현해야 합니다. 단건 조회의 기본 메서드입니다.','단건 조회는 가장 기본적인 Query 패턴. selectFrom(entity).where(entity.id.eq(id)).fetchOne()으로 구현합니다.',0,0,'[\"CLASS\"]','2026-01-16 06:52:04','2026-01-16 06:52:04',NULL,NULL,NULL,NULL,NULL),(333,3,'QDR-005','existsById 필수 메서드','MAJOR','STRUCTURE','QueryDslRepository는 boolean existsById(Long id) 메서드를 필수로 구현해야 합니다. 존재 여부만 확인할 때 전체 Entity를 로드하지 않습니다.','exists 쿼리는 COUNT(*)보다 효율적. 데이터 존재 여부만 확인하는 용도로 최적화된 쿼리를 제공합니다.',0,0,'[\"CLASS\"]','2026-01-16 06:52:04','2026-01-16 06:52:04',NULL,NULL,NULL,NULL,NULL),(334,3,'QDR-006','@Repository 클래스 어노테이션','MAJOR','ANNOTATION','QueryDslRepository는 @Repository 어노테이션을 사용한 구체 클래스로 정의합니다. 인터페이스가 아닌 클래스로 JPAQueryFactory를 직접 사용합니다.','Spring Data JPA와 달리 QueryDSL은 구체 클래스에서 JPAQueryFactory를 주입받아 사용. @Repository로 Bean 등록 및 예외 변환을 적용합니다.',1,0,'[\"CLASS\"]','2026-01-16 06:52:04','2026-01-16 06:52:04',NULL,NULL,NULL,NULL,NULL),(335,3,'QDR-007','JPAQueryFactory 생성자 주입','MAJOR','DEPENDENCY','QueryDslRepository는 생성자를 통해 JPAQueryFactory를 주입받습니다. 필드 주입(@Autowired) 대신 생성자 주입을 사용하여 불변성과 테스트 용이성을 확보합니다.','생성자 주입은 필수 의존성을 명확히 하고, 테스트 시 Mock 객체 주입이 용이합니다.',0,0,'[\"CONSTRUCTOR\"]','2026-01-16 06:52:04','2026-01-16 06:52:04',NULL,NULL,NULL,NULL,NULL),(336,3,'QDR-008','QueryDslRepository에서 @Transactional 금지','BLOCKER','ANNOTATION','QueryDslRepository 클래스 및 메서드에서 @Transactional 어노테이션을 사용하면 안 됩니다. 트랜잭션 경계는 Application Layer에서 관리합니다.','조회 전용 Repository도 트랜잭션 경계를 비즈니스 로직 계층에서 제어. @Transactional(readOnly = true)도 UseCase에서 선언합니다.',1,1,'[\"CLASS\", \"METHOD\"]','2026-01-16 06:52:04','2026-01-16 06:52:04',NULL,NULL,NULL,NULL,NULL),(337,3,'QDR-009','Entity 반환 (DTO 반환 금지)','CRITICAL','STRUCTURE','QueryDslRepository 메서드는 Entity를 반환해야 합니다. DTO Projection은 AdminQueryDslRepository(관리자 전용)에서만 허용됩니다. Adapter에서 Mapper를 통해 Domain으로 변환합니다.','Repository 계층의 책임 분리. DTO 변환은 Adapter 또는 Application Layer에서 수행하고, Repository는 Entity 영속화에 집중합니다.',0,0,'[\"METHOD\"]','2026-01-16 06:52:04','2026-01-16 06:52:04',NULL,NULL,NULL,NULL,NULL),(338,3,'QDR-010','메서드 네이밍 패턴','MINOR','NAMING','QueryDslRepository 메서드는 findBy*, existsBy*, search*, count* 패턴을 따릅니다. 예: findById, findByCriteria, existsByEmail, searchWithPaging, countByCriteria.','일관된 네이밍으로 메서드 역할을 즉시 파악 가능. Spring Data JPA의 네이밍 컨벤션과 유사성을 유지합니다.',1,0,'[\"METHOD\"]','2026-01-16 06:52:04','2026-01-16 06:52:04',NULL,NULL,NULL,NULL,NULL),(339,5,'CADP-001','persist() 메서드만 제공','BLOCKER','BEHAVIOR','CommandAdapter는 persist(Aggregate aggregate) 메서드만 제공합니다. save(), update(), delete() 등 별도 메서드를 정의하면 안 됩니다. Merge 방식으로 INSERT/UPDATE를 JPA가 판단합니다.','persist() Port 통합 원칙. Domain에서 isNew()로 신규 여부를 판단하고, Mapper가 Entity로 변환 후 JPA save()를 호출하면 자동으로 INSERT/UPDATE가 결정됩니다.',0,1,'[\"CLASS\"]','2026-01-16 06:52:04','2026-01-16 07:05:56',NULL,NULL,NULL,NULL,NULL),(340,5,'CADP-002','CommandAdapter에서 @Transactional 금지','BLOCKER','ANNOTATION','CommandAdapter 클래스 및 메서드에서 @Transactional 어노테이션을 사용하면 안 됩니다. 트랜잭션 경계는 Application Layer(UseCase/Service)에서 관리합니다.','트랜잭션 범위를 비즈니스 로직 계층에서 제어. 여러 Aggregate를 하나의 트랜잭션으로 묶거나, 트랜잭션 전파 정책을 Application에서 결정합니다.',1,1,'[\"CLASS\", \"METHOD\"]','2026-01-16 06:52:04','2026-01-16 07:05:56',NULL,NULL,NULL,NULL,NULL),(341,5,'CADP-003','@Component 어노테이션 사용','MAJOR','ANNOTATION','CommandAdapter는 @Component 어노테이션으로 Bean 등록합니다. @Repository나 @Service가 아닌 @Component를 사용하여 Adapter 역할을 명확히 합니다.','Hexagonal Architecture에서 Adapter는 @Component로 표시. @Repository는 Spring Data JPA 전용, @Service는 비즈니스 로직 계층 전용입니다.',1,0,'[\"CLASS\"]','2026-01-16 06:52:04','2026-01-16 07:05:56',NULL,NULL,NULL,NULL,NULL),(342,5,'CADP-004','Command Port 구현','MAJOR','STRUCTURE','CommandAdapter는 Application Layer에서 정의한 Command Port(예: OrderCommandPort) 인터페이스를 구현합니다. Port 인터페이스와 1:1 매핑됩니다.','Hexagonal Architecture의 Ports & Adapters 패턴. Application은 Port 인터페이스에만 의존하고, Adapter가 구체적인 영속화 로직을 구현합니다.',0,0,'[\"CLASS\"]','2026-01-16 06:52:04','2026-01-16 07:05:56',NULL,NULL,NULL,NULL,NULL),(343,5,'CADP-005','Mapper + Repository 의존','MAJOR','DEPENDENCY','CommandAdapter는 EntityMapper와 JpaRepository를 생성자 주입으로 의존합니다. Mapper로 Domain→Entity 변환 후 Repository로 저장합니다.','변환(Mapper)과 저장(Repository)의 책임 분리. 각 컴포넌트는 단일 책임을 가지며, 테스트와 유지보수가 용이합니다.',0,0,'[\"CONSTRUCTOR\"]','2026-01-16 06:52:04','2026-01-16 07:05:56',NULL,NULL,NULL,NULL,NULL),(344,5,'CADP-006','persist 후 ID 반환','CRITICAL','BEHAVIOR','persist() 메서드는 저장 후 생성된 ID(예: OrderId)를 반환합니다. Auto Increment로 생성된 ID를 Domain Value Object로 래핑하여 반환합니다.','Application Layer에서 생성된 ID로 후속 처리(이벤트 발행, 응답 생성)가 가능합니다. repository.save(entity).getId()로 즉시 ID를 얻습니다.',0,0,'[\"METHOD\"]','2026-01-16 06:52:04','2026-01-16 07:05:56',NULL,NULL,NULL,NULL,NULL),(345,5,'CADP-007','CommandAdapter에 비즈니스 로직 금지','BLOCKER','BEHAVIOR','CommandAdapter에 if/switch 조건 분기, 계산 로직, 상태 검증 등 비즈니스 로직을 포함하면 안 됩니다. 단순히 Domain→Entity 변환 후 저장만 수행합니다.','Adapter는 기술적 변환만 담당. 비즈니스 로직은 Domain과 Application Layer에서 처리하고, Adapter는 영속화 어댑터 역할에 집중합니다.',0,1,'[\"METHOD\"]','2026-01-16 06:52:04','2026-01-16 07:05:56',NULL,NULL,NULL,NULL,NULL),(346,5,'QADP-001','QueryDslRepository 위임만','BLOCKER','BEHAVIOR','QueryAdapter는 QueryDslRepository로 조회를 위임하고 Mapper로 변환하는 역할만 수행합니다. 직접 JPAQueryFactory를 사용하거나 쿼리 로직을 포함하면 안 됩니다.','책임 분리. Repository는 쿼리 실행, Mapper는 변환, Adapter는 조합만 담당합니다. 각 컴포넌트의 단일 책임을 유지합니다.',0,1,'[\"CLASS\"]','2026-01-16 06:52:05','2026-01-16 07:05:56',NULL,NULL,NULL,NULL,NULL),(347,5,'QADP-002','QueryAdapter에서 @Transactional 금지','BLOCKER','ANNOTATION','QueryAdapter 클래스 및 메서드에서 @Transactional 어노테이션을 사용하면 안 됩니다. 읽기 전용 트랜잭션도 Application Layer에서 @Transactional(readOnly = true)로 관리합니다.','트랜잭션 경계를 비즈니스 로직 계층에서 일관되게 제어. Adapter는 기술적 변환만 담당합니다.',1,1,'[\"CLASS\", \"METHOD\"]','2026-01-16 06:52:05','2026-01-16 07:05:56',NULL,NULL,NULL,NULL,NULL),(348,5,'QADP-003','@Component 어노테이션 사용','MAJOR','ANNOTATION','QueryAdapter는 @Component 어노테이션으로 Bean 등록합니다. @Repository가 아닌 @Component를 사용하여 Adapter 역할을 명확히 합니다.','Hexagonal Architecture에서 Adapter는 @Component로 표시. 기술적 역할(영속성 어댑터)을 명확히 구분합니다.',1,0,'[\"CLASS\"]','2026-01-16 06:52:05','2026-01-16 07:05:56',NULL,NULL,NULL,NULL,NULL),(349,5,'QADP-004','Query Port 구현','MAJOR','STRUCTURE','QueryAdapter는 Application Layer에서 정의한 Query Port(예: OrderQueryPort) 인터페이스를 구현합니다. Port 인터페이스와 1:1 매핑됩니다.','Ports & Adapters 패턴. Application은 Port 인터페이스에만 의존하고, Adapter가 구체적인 조회 로직을 구현합니다.',0,0,'[\"CLASS\"]','2026-01-16 06:52:05','2026-01-16 07:05:56',NULL,NULL,NULL,NULL,NULL),(350,5,'QADP-005','Mapper + QueryDslRepository 의존','MAJOR','DEPENDENCY','QueryAdapter는 EntityMapper와 QueryDslRepository를 생성자 주입으로 의존합니다. Repository로 Entity 조회 후 Mapper로 Domain 변환합니다.','조회(Repository)와 변환(Mapper)의 책임 분리. 각 컴포넌트는 단일 책임을 가지며, 테스트와 유지보수가 용이합니다.',0,0,'[\"CONSTRUCTOR\"]','2026-01-16 06:52:05','2026-01-16 07:05:56',NULL,NULL,NULL,NULL,NULL),(351,5,'QADP-006','Domain 반환 (DTO 반환 금지)','CRITICAL','STRUCTURE','QueryAdapter 메서드는 Domain 객체(Aggregate, Value Object)를 반환합니다. Entity나 DTO를 직접 반환하면 안 됩니다. Domain으로 변환하여 Application Layer에 전달합니다.','계층 간 의존성 격리. Application Layer는 Domain만 사용하고, Entity는 Persistence Layer 내부에 캡슐화됩니다.',0,0,'[\"METHOD\"]','2026-01-16 06:52:05','2026-01-16 07:05:56',NULL,NULL,NULL,NULL,NULL),(352,5,'QADP-007','Entity → Domain 변환 (Mapper 사용)','CRITICAL','BEHAVIOR','Entity를 Domain으로 변환할 때 반드시 EntityMapper.toDomain()을 사용합니다. Adapter 내부에서 직접 new Domain()이나 Domain.reconstitute()를 호출하면 안 됩니다.','변환 로직 중앙화. Mapper에서 변환 규칙을 관리하여 일관성을 보장하고, 변환 로직 변경 시 영향 범위를 최소화합니다.',0,0,'[\"METHOD\"]','2026-01-16 06:52:05','2026-01-16 07:05:56',NULL,NULL,NULL,NULL,NULL),(353,5,'QADP-008','QueryAdapter에 비즈니스 로직 금지','BLOCKER','BEHAVIOR','QueryAdapter에 if/switch 조건 분기, 필터링 로직, 정렬 로직 등 비즈니스 로직을 포함하면 안 됩니다. 단순히 Repository 호출 후 Mapper 변환만 수행합니다.','Adapter는 기술적 변환만 담당. 조회 조건과 정렬은 Repository에서, 비즈니스 필터링은 Application Layer에서 처리합니다.',0,1,'[\"METHOD\"]','2026-01-16 06:52:05','2026-01-16 07:05:56',NULL,NULL,NULL,NULL,NULL),(354,5,'QADP-009','4개 표준 메서드 패턴','MAJOR','STRUCTURE','QueryAdapter는 findById(Id), existsById(Id), findByCriteria(Criteria), countByCriteria(Criteria) 4개 메서드를 기본 패턴으로 제공합니다. 필요 시 추가 메서드를 정의할 수 있습니다.','일관된 조회 패턴 제공. 단건 조회, 존재 여부, 목록 조회, 개수 조회가 기본 Query 패턴입니다.',0,0,'[\"CLASS\"]','2026-01-16 06:52:05','2026-01-16 07:05:56',NULL,NULL,NULL,NULL,NULL),(355,3,'EMAP-001','@Component 어노테이션 사용','MAJOR','ANNOTATION','EntityMapper는 @Component 어노테이션으로 Bean 등록합니다. Adapter에서 생성자 주입으로 의존성을 주입받아 사용합니다.','DI를 통한 Mapper 사용. Mock 주입으로 단위 테스트가 용이하며, Mapper 교체가 유연합니다.',1,0,'[\"CLASS\"]','2026-01-16 06:52:05','2026-01-16 06:52:05',NULL,NULL,NULL,NULL,NULL),(356,3,'EMAP-002','Pure Java (Lombok/MapStruct 금지)','BLOCKER','ANNOTATION','EntityMapper는 순수 Java로 구현합니다. @Mapper(MapStruct), @Data, @Builder 등 모든 코드 생성 라이브러리 사용을 금지합니다.','변환 로직의 명시적 제어. 바이트코드 생성 도구의 예측 불가능한 동작을 방지하고, 디버깅과 유지보수가 용이합니다.',0,1,'[\"CLASS\"]','2026-01-16 06:52:05','2026-01-16 06:52:05',NULL,NULL,NULL,NULL,NULL),(357,3,'EMAP-003','시간 필드 생성 금지 (Instant.now() 금지)','BLOCKER','BEHAVIOR','Mapper에서 Instant.now(), LocalDateTime.now(), System.currentTimeMillis() 등 시간 필드를 직접 생성하면 안 됩니다. 시간은 Domain에서 주입받거나 JPA Auditing(@CreatedDate, @LastModifiedDate)으로 처리합니다.','테스트 가능성과 결정론적 동작 보장. 시간 의존성을 외부에서 주입받아 테스트 시 고정 시간 사용이 가능합니다.',0,1,'[\"METHOD\"]','2026-01-16 06:52:05','2026-01-16 06:52:05',NULL,NULL,NULL,NULL,NULL),(358,3,'EMAP-004','toEntity(Domain) 메서드 필수','CRITICAL','STRUCTURE','EntityMapper는 Entity toEntity(Domain domain) 메서드를 필수로 구현합니다. Domain → Entity 변환 로직을 캡슐화합니다.','Domain을 Entity로 변환하여 JPA 영속화에 사용. Entity.of()를 호출하여 Entity를 생성합니다.',0,0,'[\"CLASS\"]','2026-01-16 06:52:05','2026-01-16 06:52:05',NULL,NULL,NULL,NULL,NULL),(359,3,'EMAP-005','toDomain(Entity) 메서드 필수','CRITICAL','STRUCTURE','EntityMapper는 Domain toDomain(Entity entity) 메서드를 필수로 구현합니다. Entity → Domain 변환 로직을 캡슐화합니다.','Entity를 Domain으로 변환하여 Application Layer에 전달. Domain.reconstitute()를 호출하여 Domain을 복원합니다.',0,0,'[\"CLASS\"]','2026-01-16 06:52:05','2026-01-16 06:52:05',NULL,NULL,NULL,NULL,NULL),(360,3,'EMAP-006','Entity.of() 호출','MAJOR','BEHAVIOR','toEntity() 메서드에서 Entity 생성 시 Entity.of(...) 정적 팩토리 메서드를 호출합니다. new Entity() 직접 생성을 금지합니다.','Entity 생성 로직 중앙화. Entity의 불변식을 of() 메서드에서 보장하고, 생성자를 외부에 노출하지 않습니다.',0,0,'[\"METHOD\"]','2026-01-16 06:52:05','2026-01-16 06:52:05',NULL,NULL,NULL,NULL,NULL),(361,3,'EMAP-007','Domain.reconstitute() 호출','MAJOR','BEHAVIOR','toDomain() 메서드에서 Domain 복원 시 Domain.reconstitute(...) 정적 팩토리 메서드를 호출합니다. new Domain()이나 forNew()는 신규 생성 전용입니다.','Domain의 신규 생성(forNew)과 복원(reconstitute)을 명확히 구분. 영속화된 데이터로부터 Domain을 복원할 때는 reconstitute()를 사용합니다.',0,0,'[\"METHOD\"]','2026-01-16 06:52:05','2026-01-16 06:52:05',NULL,NULL,NULL,NULL,NULL),(362,3,'EMAP-008','Null 안전 처리','MAJOR','BEHAVIOR','Mapper 메서드에서 null 입력에 대한 안전한 처리를 구현합니다. null 입력 시 null 반환 또는 명시적 예외 발생. Optional 래핑된 입력도 처리합니다.','NPE 방지. Repository에서 Optional.empty()가 반환될 수 있으므로, Mapper도 null/empty 케이스를 안전하게 처리합니다.',0,0,'[\"METHOD\"]','2026-01-16 06:52:05','2026-01-16 06:52:05',NULL,NULL,NULL,NULL,NULL),(363,3,'EMAP-009','단방향 변환 (순환 변환 금지)','CRITICAL','BEHAVIOR','toEntity()와 toDomain()은 각각 단방향 변환만 수행합니다. toDomain() 내부에서 toEntity()를 호출하거나 그 반대의 순환 호출을 금지합니다.','무한 루프와 스택 오버플로우 방지. 각 변환 메서드는 독립적으로 동작하며, 서로를 호출하지 않습니다.',0,0,'[\"METHOD\"]','2026-01-16 06:52:05','2026-01-16 06:52:05',NULL,NULL,NULL,NULL,NULL),(414,3,'EXC-021','공통 예외 클래스 분리 금지','BLOCKER','STRUCTURE','공통 예외 클래스(EntityNotFoundException, DeletionConstraintException 등)를 별도로 생성하지 않습니다. 모든 도메인 예외는 DomainException 하나만 사용하고, ErrorCode로 구분합니다.','예외 클래스를 상황별로 분리하면 예외 처리가 복잡해지고, GlobalExceptionHandler에서 일관된 처리가 어려워집니다. DomainException + ErrorCode 조합으로 충분합니다.',0,1,'[\"CLASS\"]','2026-01-16 06:53:03','2026-01-16 06:53:03',NULL,NULL,NULL,NULL,NULL),(415,1,'CTR-015','Controller에서 계산/기본값 로직 금지','BLOCKER','BEHAVIOR','Controller에서 Math.max(), 삼항 연산자, 기본값 계산 등의 로직을 수행하면 안 됩니다. 이러한 로직은 Mapper나 Request DTO의 Compact Constructor에서 처리해야 합니다.','Controller는 Thin Controller 패턴을 따라야 하며, HTTP 요청을 UseCase로 전달하고 결과를 HTTP 응답으로 반환하는 역할만 수행해야 합니다. 계산이나 기본값 로직이 Controller에 있으면 테스트가 어렵고 관심사 분리가 깨집니다.',0,1,'[\"CLASS\", \"METHOD\"]','2026-01-16 06:53:03','2026-01-16 06:53:03',14,NULL,NULL,NULL,NULL),(416,1,'DTO-015','Request DTO Compact Constructor 기본값 설정 금지','BLOCKER','STRUCTURE','Request DTO의 Compact Constructor에서 필드에 기본값을 설정하면 안 됩니다. 기본값 로직은 Mapper에서 처리해야 합니다. DTO는 순수 데이터 전송 객체로만 사용합니다.','DTO의 Compact Constructor는 유효성 검증만 수행해야 합니다. 기본값 설정은 비즈니스 로직에 해당하며, 이를 DTO에 포함하면 DTO의 단일 책임 원칙이 깨지고 테스트가 어려워집니다.',0,1,'[\"CLASS\"]','2026-01-16 06:53:03','2026-01-16 06:53:03',NULL,NULL,NULL,NULL,NULL),(417,1,'DTO-016','Response DTO는 String 타입으로 날짜/시간 표현','BLOCKER','STRUCTURE','Response DTO에서 날짜/시간 필드는 LocalDateTime, Instant가 아닌 String 타입을 사용합니다. @JsonFormat 어노테이션 대신 DateTimeFormatUtils.toIso8601()을 사용하여 Mapper에서 변환합니다.','DTO에 @JsonFormat을 사용하면 JacksonConfig 중앙 설정과 충돌하고, DTO가 직렬화 로직에 의존하게 됩니다. String 타입으로 선언하고 Mapper에서 명시적으로 변환하면 일관성과 테스트 용이성이 높아집니다.',0,1,'[\"CLASS\"]','2026-01-16 06:53:03','2026-01-16 06:53:03',NULL,NULL,NULL,NULL,NULL),(418,1,'END-001','도메인별 Endpoints 클래스 분리','BLOCKER','STRUCTURE','공통 Endpoints 클래스(ApiPaths)를 사용하지 않고, 도메인별로 *ApiEndpoints 클래스를 분리합니다. 예: TechStackApiEndpoints, ConventionApiEndpoints','공통 Endpoints 클래스에 모든 도메인 경로를 넣으면 단일 책임 원칙이 깨지고, 변경 시 영향 범위가 넓어집니다. 도메인별로 분리하면 응집도가 높아지고 수정 영향이 해당 도메인으로 제한됩니다.',0,1,'[\"CLASS\"]','2026-01-16 06:53:03','2026-01-16 06:53:03',14,NULL,NULL,NULL,NULL),(419,1,'ERR-001','도메인별 ErrorMapper 필수','MAJOR','STRUCTURE','각 도메인별로 *ErrorMapper 클래스를 생성하여 ErrorCode → HTTP 응답 매핑을 처리합니다. ErrorMapperRegistry에 등록하여 GlobalExceptionHandler에서 사용합니다.','도메인 예외를 HTTP 응답으로 변환하는 책임을 명확히 분리합니다. 각 도메인의 ErrorCode별 HTTP 상태 코드와 메시지를 ErrorMapper에서 관리하면 일관된 에러 응답이 가능합니다.',0,0,'[\"CLASS\"]','2026-01-16 06:53:04','2026-01-16 06:53:04',11,NULL,NULL,NULL,NULL),(420,1,'CUR-001','커서 기반 조회 패턴 권장','MAJOR','BEHAVIOR','목록 조회 API는 오프셋 기반 페이지네이션 대신 커서 기반 페이지네이션을 사용합니다. CursorPageRequest를 사용하고, 응답에 nextCursor를 포함합니다.','오프셋 기반 페이지네이션은 대용량 데이터에서 성능이 저하됩니다(OFFSET이 클수록 느림). 커서 기반은 일관된 성능을 제공하고, 실시간 데이터 변경에도 안정적입니다.',0,0,'[\"METHOD\"]','2026-01-16 06:53:04','2026-01-16 06:53:04',14,NULL,NULL,NULL,NULL),(421,1,'MAP-013','Mapper CQRS 분리 권장','MAJOR','STRUCTURE','Mapper도 CQRS 패턴에 따라 Command용과 Query용을 분리합니다. 복잡한 도메인에서는 *CommandApiMapper와 *QueryApiMapper로 분리하여 관심사를 명확히 합니다.','Command와 Query의 매핑 로직이 다르므로 분리하면 각 Mapper의 책임이 명확해집니다. 단순한 도메인에서는 통합 Mapper도 허용하지만, 복잡해지면 분리를 권장합니다.',0,0,'[\"CLASS\"]','2026-01-16 06:53:04','2026-01-16 06:53:04',NULL,NULL,NULL,NULL,NULL),(422,4,'FAC-007','CommandFactory와 QueryFactory 분리','MAJOR','STRUCTURE','Factory도 CQRS 원칙에 따라 분리합니다. CommandFactory는 Command DTO → Domain 변환, VO 생성(ID, Name 등), TimeProvider를 통한 시간 처리를 담당합니다. QueryFactory는 Query DTO → Criteria 변환, SearchCriteria(Page 기반), SliceCriteria(커서 기반) 생성을 담당합니다.','단일 책임 원칙. Factory를 Command/Query로 분리하면 각 Factory의 책임이 명확해지고, 변경 영향 범위가 줄어듭니다. FAC-002(Facade CQRS 분리)와 동일한 원칙을 Factory에도 적용합니다.',0,0,'[\"CLASS\"]','2026-01-16 06:53:04','2026-01-16 06:53:04',NULL,NULL,NULL,NULL,NULL),(423,4,'QDTO-006','커서 기반 조회 Query는 CommonCursorParams 포함 필수','MAJOR','STRUCTURE','커서 기반 조회 Query(GetAll*, GetActive* 등 슬라이스 조회)는 CommonCursorParams를 필드로 포함해야 합니다. CommonCursorParams는 커서(cursor), 페이지 크기(size), 정렬 방향(direction) 정보를 담습니다. QDTO-004(CommonSearchParams)가 페이지 기반 조회용이라면, CommonCursorParams는 커서 기반 조회용입니다.','커서 기반 조회 표준화. 무한 스크롤, 대용량 데이터 조회 등에서 페이지 기반 조회보다 효율적인 커서 기반 조회를 일관된 방식으로 지원합니다. UseCase 인터페이스와 Service 구현체의 시그니처 통일에도 기여합니다.',0,0,'[\"CLASS\"]','2026-01-16 06:53:04','2026-01-16 06:53:04',NULL,NULL,NULL,NULL,NULL),(424,4,'QPRT-006','QueryPort는 SliceCriteria 기반 조회 메서드 제공 권장','MAJOR','STRUCTURE','커서 기반 조회가 필요한 QueryPort는 findBySliceCriteria(SliceCriteria): Slice<Domain> 메서드를 추가로 제공합니다. SliceCriteria는 커서(cursor), 페이지 크기(size), 정렬 방향을 포함합니다. QPRT-002의 표준 4개 메서드에 더해 선택적으로 제공하는 확장 메서드입니다.','커서 기반 조회 지원. 무한 스크롤, 대용량 데이터 조회 등에서 페이지 기반 조회(findByCriteria)보다 효율적입니다. ReadManager도 이 메서드를 래핑하여 제공해야 합니다.',0,0,'[\"INTERFACE\"]','2026-01-16 06:53:04','2026-01-16 06:53:04',49,NULL,NULL,NULL,NULL);
/*!40000 ALTER TABLE `coding_rule` ENABLE KEYS */;
UNLOCK TABLES;

LOCK TABLES `class_template` WRITE;
/*!40000 ALTER TABLE `class_template` DISABLE KEYS */;
INSERT INTO `class_template` (`id`, `convention_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `structure_id`, `deleted_at`) VALUES (1,1,'COMMAND_CONTROLLER','package com.ryuqq.adapter.in.rest.{bc}.controller.command;\n\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.PatchMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\nimport com.ryuqq.adapter.in.rest.common.dto.ApiResponse;\nimport com.ryuqq.adapter.in.rest.{bc}.dto.command.Create{Entity}ApiRequest;\nimport com.ryuqq.adapter.in.rest.{bc}.dto.command.Update{Entity}ApiRequest;\nimport com.ryuqq.adapter.in.rest.{bc}.dto.response.Create{Entity}ApiResponse;\nimport com.ryuqq.adapter.in.rest.{bc}.mapper.command.{Entity}CommandApiMapper;\nimport com.ryuqq.adapter.in.rest.{bc}.paths.ApiPaths;\nimport com.ryuqq.application.{bc}.port.in.command.Create{Entity}UseCase;\nimport com.ryuqq.application.{bc}.port.in.command.Update{Entity}UseCase;\nimport io.swagger.v3.oas.annotations.Operation;\nimport io.swagger.v3.oas.annotations.Parameter;\nimport io.swagger.v3.oas.annotations.responses.ApiResponses;\nimport io.swagger.v3.oas.annotations.tags.Tag;\nimport jakarta.validation.Valid;\n\n/**\n * {Entity}CommandController - {Entity} Command API\n *\n * <p>CQRS Command 처리를 담당합니다. POST/PATCH 요청만 처리합니다.\n *\n * <p><strong>Thin Controller 패턴:</strong>\n * <ul>\n *   <li>메서드당 최대 5줄</li>\n *   <li>비즈니스 로직 없음</li>\n *   <li>Mapper + UseCase 호출만</li>\n * </ul>\n *\n * @author ryu-qqq\n * @since {date}\n */\n@Tag(name = \"{Entity}\", description = \"{Entity} Command API\")\n@RestController\n@RequestMapping(ApiPaths.{Entity}.BASE)\npublic class {Entity}CommandController {\n\n    private final Create{Entity}UseCase create{Entity}UseCase;\n    private final Update{Entity}UseCase update{Entity}UseCase;\n    private final {Entity}CommandApiMapper mapper;\n\n    public {Entity}CommandController(\n            Create{Entity}UseCase create{Entity}UseCase,\n            Update{Entity}UseCase update{Entity}UseCase,\n            {Entity}CommandApiMapper mapper) {\n        this.create{Entity}UseCase = create{Entity}UseCase;\n        this.update{Entity}UseCase = update{Entity}UseCase;\n        this.mapper = mapper;\n    }\n\n    @Operation(summary = \"{Entity} 생성\", description = \"새로운 {Entity}를 생성합니다.\")\n    @ApiResponses({\n        @io.swagger.v3.oas.annotations.responses.ApiResponse(responseCode = \"201\", description = \"생성 성공\"),\n        @io.swagger.v3.oas.annotations.responses.ApiResponse(responseCode = \"400\", description = \"잘못된 요청\"),\n        @io.swagger.v3.oas.annotations.responses.ApiResponse(responseCode = \"409\", description = \"중복 리소스\")\n    })\n    @PostMapping\n    public ResponseEntity<ApiResponse<Create{Entity}ApiResponse>> create(\n            @Valid @RequestBody Create{Entity}ApiRequest request) {\n        Long id = create{Entity}UseCase.execute(mapper.toCommand(request));\n        return ResponseEntity.status(201).body(ApiResponse.success(mapper.toCreateResponse(id)));\n    }\n\n    @Operation(summary = \"{Entity} 수정\", description = \"기존 {Entity}를 수정합니다.\")\n    @ApiResponses({\n        @io.swagger.v3.oas.annotations.responses.ApiResponse(responseCode = \"200\", description = \"수정 성공\"),\n        @io.swagger.v3.oas.annotations.responses.ApiResponse(responseCode = \"400\", description = \"잘못된 요청\"),\n        @io.swagger.v3.oas.annotations.responses.ApiResponse(responseCode = \"404\", description = \"리소스 없음\")\n    })\n    @PatchMapping(ApiPaths.{Entity}.BY_ID)\n    public ResponseEntity<ApiResponse<Void>> update(\n            @Parameter(description = \"{Entity} ID\") @PathVariable Long id,\n            @Valid @RequestBody Update{Entity}ApiRequest request) {\n        update{Entity}UseCase.execute(mapper.toCommand(id, request));\n        return ResponseEntity.ok(ApiResponse.success(null));\n    }\n}','{Entity}CommandController',NULL,NULL,NULL,NULL,NULL,'CQRS Command Controller - POST/PATCH 처리. Thin Controller 패턴 (5줄 이내). OpenAPI 문서화 필수.','2026-01-16 02:25:57','2026-01-16 05:24:10',1,NULL),(2,1,'QUERY_CONTROLLER','package com.ryuqq.adapter.in.rest.{bc}.controller.query;\n\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.ModelAttribute;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\nimport com.ryuqq.adapter.in.rest.common.dto.ApiResponse;\nimport com.ryuqq.adapter.in.rest.common.dto.PageApiResponse;\nimport com.ryuqq.adapter.in.rest.{bc}.dto.query.Search{Entity}sApiRequest;\nimport com.ryuqq.adapter.in.rest.{bc}.dto.response.{Entity}ApiResponse;\nimport com.ryuqq.adapter.in.rest.{bc}.dto.response.{Entity}SummaryApiResponse;\nimport com.ryuqq.adapter.in.rest.{bc}.mapper.query.{Entity}QueryApiMapper;\nimport com.ryuqq.adapter.in.rest.{bc}.paths.ApiPaths;\nimport com.ryuqq.application.{bc}.port.in.query.Get{Entity}UseCase;\nimport com.ryuqq.application.{bc}.port.in.query.Search{Entity}sUseCase;\nimport io.swagger.v3.oas.annotations.Operation;\nimport io.swagger.v3.oas.annotations.Parameter;\nimport io.swagger.v3.oas.annotations.responses.ApiResponses;\nimport io.swagger.v3.oas.annotations.tags.Tag;\nimport jakarta.validation.Valid;\n\n/**\n * {Entity}QueryController - {Entity} Query API\n *\n * <p>CQRS Query 처리를 담당합니다. GET 요청만 처리합니다.\n *\n * <p><strong>조회 패턴:</strong>\n * <ul>\n *   <li>목록 조회: @ModelAttribute로 검색 조건 수신</li>\n *   <li>단건 조회: @PathVariable로 ID 수신</li>\n * </ul>\n *\n * @author ryu-qqq\n * @since {date}\n */\n@Tag(name = \"{Entity}\", description = \"{Entity} Query API\")\n@RestController\n@RequestMapping(ApiPaths.{Entity}.BASE)\npublic class {Entity}QueryController {\n\n    private final Search{Entity}sUseCase search{Entity}sUseCase;\n    private final Get{Entity}UseCase get{Entity}UseCase;\n    private final {Entity}QueryApiMapper mapper;\n\n    public {Entity}QueryController(\n            Search{Entity}sUseCase search{Entity}sUseCase,\n            Get{Entity}UseCase get{Entity}UseCase,\n            {Entity}QueryApiMapper mapper) {\n        this.search{Entity}sUseCase = search{Entity}sUseCase;\n        this.get{Entity}UseCase = get{Entity}UseCase;\n        this.mapper = mapper;\n    }\n\n    @Operation(summary = \"{Entity} 목록 조회\", description = \"검색 조건에 맞는 {Entity} 목록을 조회합니다.\")\n    @ApiResponses({\n        @io.swagger.v3.oas.annotations.responses.ApiResponse(responseCode = \"200\", description = \"조회 성공\"),\n        @io.swagger.v3.oas.annotations.responses.ApiResponse(responseCode = \"400\", description = \"잘못된 요청\")\n    })\n    @GetMapping\n    public ResponseEntity<ApiResponse<PageApiResponse<{Entity}SummaryApiResponse>>> search(\n            @Valid @ModelAttribute Search{Entity}sApiRequest request) {\n        return ResponseEntity.ok(ApiResponse.success(\n            mapper.toPageApiResponse(search{Entity}sUseCase.execute(mapper.toQuery(request)))));\n    }\n\n    @Operation(summary = \"{Entity} 단건 조회\", description = \"ID로 {Entity}를 조회합니다.\")\n    @ApiResponses({\n        @io.swagger.v3.oas.annotations.responses.ApiResponse(responseCode = \"200\", description = \"조회 성공\"),\n        @io.swagger.v3.oas.annotations.responses.ApiResponse(responseCode = \"404\", description = \"리소스 없음\")\n    })\n    @GetMapping(ApiPaths.{Entity}.BY_ID)\n    public ResponseEntity<ApiResponse<{Entity}ApiResponse>> getById(\n            @Parameter(description = \"{Entity} ID\") @PathVariable Long id) {\n        return ResponseEntity.ok(ApiResponse.success(\n            mapper.toApiResponse(get{Entity}UseCase.execute(mapper.toGetQuery(id)))));\n    }\n}','{Entity}QueryController',NULL,NULL,NULL,NULL,NULL,'CQRS Query Controller - GET 처리. 목록 조회(@ModelAttribute), 단건 조회(@PathVariable).','2026-01-16 02:25:57','2026-01-16 05:24:10',2,NULL),(3,1,'REQUEST_DTO','package com.ryuqq.adapter.in.rest.{bc}.dto.command;\n\nimport io.swagger.v3.oas.annotations.media.Schema;\nimport jakarta.annotation.Nullable;\nimport jakarta.validation.constraints.NotBlank;\nimport jakarta.validation.constraints.NotNull;\nimport jakarta.validation.constraints.Size;\n\n/**\n * Create{Entity}ApiRequest - {Entity} 생성 요청 DTO\n *\n * <p>{Entity} 생성에 필요한 데이터를 담습니다.\n *\n * @param name {Entity} 이름 (필수, 1-100자)\n * @param description 설명 (선택, 최대 500자)\n * @param status 상태 (필수)\n * @author ryu-qqq\n * @since {date}\n */\n@Schema(description = \"{Entity} 생성 요청\")\npublic record Create{Entity}ApiRequest(\n        @Schema(description = \"{Entity} 이름\", example = \"Sample Name\", requiredMode = Schema.RequiredMode.REQUIRED)\n        @NotBlank(message = \"이름은 필수입니다\")\n        @Size(min = 1, max = 100, message = \"이름은 1-100자 사이여야 합니다\")\n        String name,\n\n        @Schema(description = \"설명\", example = \"Sample description\")\n        @Nullable\n        @Size(max = 500, message = \"설명은 500자를 초과할 수 없습니다\")\n        String description,\n\n        @Schema(description = \"상태\", example = \"ACTIVE\", requiredMode = Schema.RequiredMode.REQUIRED)\n        @NotBlank(message = \"상태는 필수입니다\")\n        String status\n) {\n}','Create{Entity}ApiRequest',NULL,NULL,NULL,NULL,NULL,'Command Create Request DTO. Java Record, Bean Validation, OpenAPI Schema 필수.','2026-01-16 02:25:57','2026-01-16 05:24:10',3,NULL),(38,3,'DOMAIN_EVENT','package com.ryuqq.domain.{bc}.event;\n\nimport com.ryuqq.domain.{bc}.aggregate.{Entity};\nimport com.ryuqq.domain.{bc}.id.{Entity}Id;\nimport com.ryuqq.domain.common.event.DomainEvent;\n\nimport java.time.Instant;\n\n/**\n * {Entity} 생성 이벤트.\n *\n * <p>새로운 {Entity}가 생성되었을 때 발행됩니다.\n *\n * @param {entity}Id 생성된 {Entity} ID\n * @param name 이름\n * @param occurredAt 이벤트 발생 시점\n */\npublic record {Entity}CreatedEvent(\n    {Entity}Id {entity}Id,\n    String name,\n    Instant occurredAt\n) implements DomainEvent {\n\n    /**\n     * Aggregate로부터 이벤트 생성.\n     *\n     * @param entity 생성된 Aggregate\n     * @param now 현재 시점\n     * @return 생성 이벤트\n     */\n    public static {Entity}CreatedEvent from({Entity} entity, Instant now) {\n        return new {Entity}CreatedEvent(\n            entity.id(),\n            entity.name(),\n            now\n        );\n    }\n}','{Entity}CreatedEvent',NULL,NULL,NULL,NULL,NULL,'Domain Event 구체 클래스 템플릿. from(Aggregate, Instant) 팩토리 메서드 필수.','2026-01-16 02:26:51','2026-01-16 02:26:51',29,NULL),(44,3,'DOMAIN_CRITERIA','package com.ryuqq.domain.{bc}.query;\n\nimport com.ryuqq.domain.{bc}.id.{Entity}Id;\n\n/**\n * {Entity} 단건 조회 조건.\n *\n * @param {entity}Id 조회할 {Entity} ID\n */\npublic record {Entity}GetCriteria(\n    {Entity}Id {entity}Id\n) {\n\n    public {Entity}GetCriteria {\n        if ({entity}Id == null) {\n            throw new IllegalArgumentException(\"{entity}Id must not be null\");\n        }\n    }\n\n    /**\n     * 조회 조건 생성.\n     *\n     * @param {entity}Id {Entity} ID\n     * @return 조회 조건\n     */\n    public static {Entity}GetCriteria of({Entity}Id {entity}Id) {\n        return new {Entity}GetCriteria({entity}Id);\n    }\n}','{Entity}GetCriteria',NULL,NULL,NULL,NULL,NULL,'단건 조회 Criteria 템플릿. ID 기반 조회.','2026-01-16 02:26:52','2026-01-16 05:25:44',31,NULL),(50,1,'RESPONSE_DTO','package com.ryuqq.adapter.in.rest.{bc}.dto.response;\n\npublic record Create{Entity}ApiResponse(Long id) {}','Create{Entity}ApiResponse',NULL,NULL,NULL,NULL,NULL,'Command 생성 응답 DTO. 생성된 리소스 ID만 반환.','2026-01-16 06:11:59','2026-01-16 06:11:59',5,NULL),(53,1,'API_MAPPER','package com.ryuqq.adapter.in.rest.{bc}.mapper.command;\n\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class {Entity}CommandApiMapper {\n    // Request to Command conversion\n}','{Entity}CommandApiMapper',NULL,NULL,NULL,NULL,NULL,'Command API Mapper. Request → Command 변환.','2026-01-16 06:11:59','2026-01-16 06:11:59',7,NULL),(55,1,'ERROR_HANDLER','package com.ryuqq.adapter.in.rest.{bc}.error;\n\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class {Entity}ErrorMapper {\n    // Domain exception to RFC 7807 Problem Details\n}','{Entity}ErrorMapper',NULL,NULL,NULL,NULL,NULL,'BC별 ErrorMapper. RFC 7807 Problem Details 변환.','2026-01-16 06:11:59','2026-01-16 06:11:59',6,NULL),(56,3,'AGGREGATE','package com.ryuqq.domain.{bc}.aggregate;\n\npublic class {Entity} {\n    private final {Entity}Id id;\n\n    public static {Entity} forNew(String name, Instant now) { /* ... */ }\n    public static {Entity} reconstitute({Entity}Id id, String name, Instant createdAt) { /* ... */ }\n}','{Entity}',NULL,NULL,NULL,NULL,NULL,'Aggregate Root 템플릿. forNew()/reconstitute() 팩토리 메서드, 도메인 이벤트 관리.','2026-01-16 06:12:00','2026-01-16 06:12:00',26,NULL),(57,3,'VALUE_OBJECT','package com.ryuqq.domain.{bc}.aggregate;\n\npublic record {Entity}UpdateData(String name) {\n    public boolean hasName() { return name != null; }\n}','{Entity}UpdateData',NULL,NULL,NULL,NULL,NULL,'Aggregate 부분 업데이트를 위한 UpdateData Record. null이면 변경하지 않음.','2026-01-16 06:12:00','2026-01-16 06:12:00',26,NULL),(63,3,'COMMON_VO','package com.ryuqq.domain.common.vo;\n\nimport java.math.BigDecimal;\n\npublic record Money(BigDecimal amount) {\n    public Money add(Money other) { return new Money(this.amount.add(other.amount)); }\n}','Money',NULL,NULL,NULL,NULL,NULL,'Money Value Object 템플릿. 금액 계산 로직 포함.','2026-01-16 06:12:00','2026-01-16 06:12:00',28,NULL),(66,3,'DOMAIN_EXCEPTION','package com.ryuqq.domain.common.exception;\n\npublic interface ErrorCode {\n    String getCode();\n    int getHttpStatus();\n    String getMessage();\n}','ErrorCode',NULL,NULL,NULL,NULL,NULL,'ErrorCode 공통 인터페이스. 모든 ErrorCode Enum이 구현.','2026-01-16 06:12:00','2026-01-16 06:12:00',30,NULL),(72,1,'REQUEST_DTO','package com.ryuqq.adapter.in.rest.{bc}.dto.command;\n\npublic record Update{Entity}ApiRequest(\n    String name\n) {}','Update{Entity}ApiRequest',NULL,NULL,NULL,NULL,NULL,'Command Update Request DTO. 부분 수정 지원 (모든 필드 Nullable).','2026-01-16 06:17:23','2026-01-16 06:17:23',3,NULL),(73,1,'REQUEST_DTO','package com.ryuqq.adapter.in.rest.{bc}.dto.query;\n\nimport jakarta.validation.constraints.*;\n\npublic record Search{Entity}sApiRequest(\n    @NotNull Integer page,\n    @NotNull Integer size,\n    String name\n) {}','Search{Entity}sApiRequest',NULL,NULL,NULL,NULL,NULL,'Query Search Request DTO. 페이징/정렬 필수(@NotNull), 필터 선택(Nullable).','2026-01-16 06:17:23','2026-01-16 06:17:23',4,NULL),(74,1,'RESPONSE_DTO','package com.ryuqq.adapter.in.rest.{bc}.dto.response;\n\npublic record {Entity}ApiResponse(\n    Long id,\n    String name,\n    String createdAt\n) {}','{Entity}ApiResponse',NULL,NULL,NULL,NULL,NULL,'Query 상세 조회 응답 DTO. 모든 필드 포함.','2026-01-16 06:17:24','2026-01-16 06:17:24',5,NULL),(75,1,'RESPONSE_DTO','package com.ryuqq.adapter.in.rest.{bc}.dto.response;\n\npublic record {Entity}SummaryApiResponse(\n    Long id,\n    String name\n) {}','{Entity}SummaryApiResponse',NULL,NULL,NULL,NULL,NULL,'Query 목록 조회 응답 DTO. 요약 필드만 포함.','2026-01-16 06:17:24','2026-01-16 06:17:24',5,NULL),(76,1,'API_MAPPER','package com.ryuqq.adapter.in.rest.{bc}.mapper.query;\n\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class {Entity}QueryApiMapper {\n    // Request to Query, Response conversion\n}','{Entity}QueryApiMapper',NULL,NULL,NULL,NULL,NULL,'Query API Mapper. Request → Query 변환, Response 변환.','2026-01-16 06:17:24','2026-01-16 06:17:24',8,NULL),(78,3,'VALUE_OBJECT','package com.ryuqq.domain.{bc}.id;\n\npublic record {Entity}Id(Long value) {\n    public static {Entity}Id forNew() { return new {Entity}Id(null); }\n    public static {Entity}Id of(Long value) { return new {Entity}Id(value); }\n    public boolean isNew() { return value == null; }\n}','{Entity}Id',NULL,NULL,NULL,NULL,NULL,'Long 기반 ID Value Object. Auto Increment 대응.','2026-01-16 06:17:24','2026-01-16 06:17:24',27,NULL),(79,3,'VALUE_OBJECT','package com.ryuqq.domain.{bc}.id;\n\npublic record {Entity}Id(String value) {\n    public static {Entity}Id forNew(String value) { return new {Entity}Id(value); }\n}','{Entity}Id (String)',NULL,NULL,NULL,NULL,NULL,'String 기반 ID Value Object. UUIDv7/Snowflake 등 외부 생성 ID용.','2026-01-16 06:17:24','2026-01-16 06:17:24',27,NULL),(80,3,'VALUE_OBJECT','package com.ryuqq.domain.{bc}.vo;\n\npublic record {Name}(String value) {\n    public {Name} { if (value == null || value.isBlank()) throw new IllegalArgumentException(); }\n}','{Name}',NULL,NULL,NULL,NULL,NULL,'단일 값 Value Object 템플릿. Compact Constructor에서 검증.','2026-01-16 06:17:24','2026-01-16 06:17:24',28,NULL),(81,3,'VALUE_OBJECT','package com.ryuqq.domain.{bc}.vo;\n\npublic record {Name}(String field1, String field2) { }','{Name} (Composite)',NULL,NULL,NULL,NULL,NULL,'복합 값 Value Object 템플릿. 여러 필드를 가진 불변 객체.','2026-01-16 06:17:24','2026-01-16 06:17:24',28,NULL),(82,3,'VALUE_OBJECT','package com.ryuqq.domain.{bc}.vo;\n\npublic enum {Name}Status {\n    ACTIVE(\"활성\"), INACTIVE(\"비활성\");\n    private final String displayName;\n    {Name}Status(String displayName) { this.displayName = displayName; }\n    public String displayName() { return displayName; }\n}','{Name}Status',NULL,NULL,NULL,NULL,NULL,'Enum Value Object 템플릿. displayName() 메서드 필수.','2026-01-16 06:17:24','2026-01-16 06:17:24',28,NULL),(84,3,'DOMAIN_EXCEPTION','package com.ryuqq.domain.{bc}.exception;\n\npublic enum {Entity}ErrorCode implements ErrorCode {\n    NOT_FOUND(\"{ENTITY}_NOT_FOUND\", 404, \"{Entity}를 찾을 수 없습니다\");\n    /* ... */\n}','{Entity}ErrorCode',NULL,NULL,NULL,NULL,NULL,'Bounded Context별 ErrorCode Enum. int 타입 HTTP 상태 코드 사용.','2026-01-16 06:17:24','2026-01-16 06:17:24',30,NULL),(85,3,'DOMAIN_EXCEPTION','package com.ryuqq.domain.common.exception;\n\npublic class DomainException extends RuntimeException {\n    private final ErrorCode errorCode;\n    public DomainException(ErrorCode errorCode) { super(errorCode.getMessage()); this.errorCode = errorCode; }\n}','DomainException',NULL,NULL,NULL,NULL,NULL,'Domain Exception 기본 클래스. RuntimeException 상속.','2026-01-16 06:17:24','2026-01-16 06:17:24',30,NULL),(86,3,'DOMAIN_EXCEPTION','package com.ryuqq.domain.{bc}.exception;\n\npublic class {Entity}NotFoundException extends DomainException {\n    public {Entity}NotFoundException({Entity}Id id) { super({Entity}ErrorCode.NOT_FOUND); }\n}','{Entity}NotFoundException',NULL,NULL,NULL,NULL,NULL,'Concrete Exception 템플릿. DomainException 상속.','2026-01-16 06:17:24','2026-01-16 06:17:24',30,NULL),(88,3,'DOMAIN_EVENT','package com.ryuqq.domain.common.event;\n\nimport java.time.Instant;\n\npublic interface DomainEvent {\n    Instant occurredAt();\n}','DomainEvent',NULL,NULL,NULL,NULL,NULL,'Domain Event 공통 인터페이스. 모든 도메인 이벤트가 구현.','2026-01-16 06:18:07','2026-01-16 06:18:07',29,NULL),(89,3,'DOMAIN_CRITERIA','package com.ryuqq.domain.{bc}.query;\n\npublic record {Entity}SearchCriteria(String name, PageRequest page) {\n    public static {Entity}SearchCriteria of(String name, int page, int size) { /* ... */ }\n}','{Entity}SearchCriteria',NULL,NULL,NULL,NULL,NULL,'검색 조건 Criteria 템플릿. 페이징, 정렬, 필터 조건 포함.','2026-01-16 06:18:07','2026-01-16 06:18:07',31,NULL),(156,4,'COMMAND_SERVICE','package com.ryuqq.application.{bc}.service.command;\n\nimport org.springframework.stereotype.Service;\nimport com.ryuqq.application.{bc}.assembler.{Entity}Assembler;\nimport com.ryuqq.application.{bc}.dto.command.Create{Entity}Command;\nimport com.ryuqq.application.{bc}.dto.response.{Entity}IdResponse;\nimport com.ryuqq.application.{bc}.facade.command.{Entity}CommandFacade;\nimport com.ryuqq.application.{bc}.factory.command.{Entity}CommandFactory;\nimport com.ryuqq.application.{bc}.port.in.command.Create{Entity}UseCase;\nimport com.ryuqq.domain.{bc}.aggregate.{Entity};\n\n/**\n * Create{Entity}Service - {Entity} 생성 UseCase 구현체\n *\n * <p>@Transactional 사용 금지: 트랜잭션은 Facade/Manager에서 관리합니다.\n *\n * @author ryu-qqq\n */\n@Service\npublic class Create{Entity}Service implements Create{Entity}UseCase {\n\n    private final {Entity}CommandFactory factory;\n    private final {Entity}CommandFacade facade;\n    private final {Entity}Assembler assembler;\n\n    public Create{Entity}Service(\n            {Entity}CommandFactory factory,\n            {Entity}CommandFacade facade,\n            {Entity}Assembler assembler) {\n        this.factory = factory;\n        this.facade = facade;\n        this.assembler = assembler;\n    }\n\n    @Override\n    public {Entity}IdResponse execute(Create{Entity}Command command) {\n        {Entity} {entity} = factory.create(command);\n        Long id = facade.persist({entity});\n        return assembler.toIdResponse(id);\n    }\n}','Create{Entity}Service',NULL,NULL,NULL,NULL,NULL,'Command Service - UseCase 구현체. @Transactional 금지. Facade/Manager 호출만.','2026-01-16 06:58:54','2026-01-16 06:58:54',37,NULL),(157,4,'COMMAND_SERVICE','package com.ryuqq.application.{bc}.service.command;\n\nimport org.springframework.stereotype.Service;\nimport com.ryuqq.application.{bc}.dto.command.Update{Entity}Command;\nimport com.ryuqq.application.{bc}.facade.command.{Entity}CommandFacade;\nimport com.ryuqq.application.{bc}.port.in.command.Update{Entity}UseCase;\n\n@Service\npublic class Update{Entity}Service implements Update{Entity}UseCase {\n\n    private final {Entity}CommandFacade facade;\n\n    public Update{Entity}Service({Entity}CommandFacade facade) {\n        this.facade = facade;\n    }\n\n    @Override\n    public void execute(Update{Entity}Command command) {\n        facade.update(command.{entity}Id(), command.updateData());\n    }\n}','Update{Entity}Service',NULL,NULL,NULL,NULL,NULL,'Command Service - Update UseCase 구현체. 부분 업데이트 지원.','2026-01-16 06:58:54','2026-01-16 06:58:54',37,NULL),(158,4,'COMMAND_SERVICE','package com.ryuqq.application.{bc}.service.command;\n\nimport org.springframework.stereotype.Service;\nimport com.ryuqq.application.{bc}.dto.command.Delete{Entity}Command;\nimport com.ryuqq.application.{bc}.facade.command.{Entity}CommandFacade;\nimport com.ryuqq.application.{bc}.port.in.command.Delete{Entity}UseCase;\n\n@Service\npublic class Delete{Entity}Service implements Delete{Entity}UseCase {\n\n    private final {Entity}CommandFacade facade;\n\n    public Delete{Entity}Service({Entity}CommandFacade facade) {\n        this.facade = facade;\n    }\n\n    @Override\n    public void execute(Delete{Entity}Command command) {\n        facade.delete(command.{entity}Id());\n    }\n}','Delete{Entity}Service',NULL,NULL,NULL,NULL,NULL,'Command Service - Delete UseCase 구현체. 논리 삭제.','2026-01-16 06:58:54','2026-01-16 06:58:54',37,NULL),(159,4,'QUERY_SERVICE','package com.ryuqq.application.{bc}.service.query;\n\nimport org.springframework.stereotype.Service;\nimport com.ryuqq.application.{bc}.assembler.{Entity}Assembler;\nimport com.ryuqq.application.{bc}.dto.query.Get{Entity}Query;\nimport com.ryuqq.application.{bc}.dto.response.{Entity}Response;\nimport com.ryuqq.application.{bc}.manager.read.{Entity}ReadManager;\nimport com.ryuqq.application.{bc}.port.in.query.Get{Entity}UseCase;\nimport com.ryuqq.domain.{bc}.aggregate.{Entity};\n\n@Service\npublic class Get{Entity}Service implements Get{Entity}UseCase {\n\n    private final {Entity}ReadManager readManager;\n    private final {Entity}Assembler assembler;\n\n    public Get{Entity}Service(\n            {Entity}ReadManager readManager,\n            {Entity}Assembler assembler) {\n        this.readManager = readManager;\n        this.assembler = assembler;\n    }\n\n    @Override\n    public {Entity}Response execute(Get{Entity}Query query) {\n        {Entity} {entity} = readManager.getById(query.{entity}Id());\n        return assembler.toResponse({entity});\n    }\n}','Get{Entity}Service',NULL,NULL,NULL,NULL,NULL,'Query Service - 단건 조회 UseCase 구현체.','2026-01-16 06:58:54','2026-01-16 06:58:54',38,NULL),(160,4,'QUERY_SERVICE','package com.ryuqq.application.{bc}.service.query;\n\nimport org.springframework.stereotype.Service;\nimport com.ryuqq.application.{bc}.assembler.{Entity}Assembler;\nimport com.ryuqq.application.{bc}.dto.query.Search{Entity}sQuery;\nimport com.ryuqq.application.{bc}.dto.response.{Entity}SliceResponse;\nimport com.ryuqq.application.{bc}.manager.read.{Entity}ReadManager;\nimport com.ryuqq.application.{bc}.port.in.query.Search{Entity}sUseCase;\n\n@Service\npublic class Search{Entity}sService implements Search{Entity}sUseCase {\n\n    private final {Entity}ReadManager readManager;\n    private final {Entity}Assembler assembler;\n\n    public Search{Entity}sService(\n            {Entity}ReadManager readManager,\n            {Entity}Assembler assembler) {\n        this.readManager = readManager;\n        this.assembler = assembler;\n    }\n\n    @Override\n    public {Entity}SliceResponse execute(Search{Entity}sQuery query) {\n        var result = readManager.findByCriteria(query.toCriteria());\n        return assembler.toSliceResponse(result);\n    }\n}','Search{Entity}sService',NULL,NULL,NULL,NULL,NULL,'Query Service - 목록 조회 UseCase 구현체. Slice 기반 페이징.','2026-01-16 06:58:54','2026-01-16 06:58:54',38,NULL),(161,4,'SCHEDULER','package com.ryuqq.application.{bc}.service.scheduler;\n\nimport org.springframework.stereotype.Component;\nimport com.ryuqq.application.common.port.LockManager;\n\n@Component\npublic class Process{Entity}OutboxService {\n\n    private final LockManager lockManager;\n\n    public Process{Entity}OutboxService(LockManager lockManager) {\n        this.lockManager = lockManager;\n    }\n\n    public void execute() {\n        lockManager.executeWithLock(\"{entity}-outbox\", () -> {\n            // Outbox 처리 로직\n        });\n    }\n}','Process{Entity}OutboxService',NULL,NULL,NULL,NULL,NULL,'Scheduler Service - Outbox 처리. 분산락 필수.','2026-01-16 06:58:54','2026-01-16 06:58:54',56,NULL),(162,4,'FACADE','package com.ryuqq.application.{bc}.facade.command;\n\nimport org.springframework.stereotype.Component;\nimport org.springframework.transaction.annotation.Transactional;\n\n@Component\npublic class {Entity}CommandFacade {\n\n    @Transactional\n    public Long persist(Object entity) {\n        // Port 조합 로직\n        return null;\n    }\n}','{Entity}CommandFacade',NULL,NULL,NULL,NULL,NULL,'Command Facade - 다중 Port 조합. @Transactional 선언.','2026-01-16 06:58:54','2026-01-16 06:58:54',41,NULL),(163,4,'FACADE','package com.ryuqq.application.{bc}.facade.query;\n\nimport org.springframework.stereotype.Component;\nimport org.springframework.transaction.annotation.Transactional;\n\n@Component\n@Transactional(readOnly = true)\npublic class {Entity}QueryFacade {\n    // Query Port 조합 로직\n}','{Entity}QueryFacade',NULL,NULL,NULL,NULL,NULL,'Query Facade - 조회 Port 조합. @Transactional(readOnly=true).','2026-01-16 06:58:54','2026-01-16 06:58:54',42,NULL),(164,4,'MANAGER','package com.ryuqq.application.{bc}.manager.read;\n\nimport org.springframework.stereotype.Component;\nimport org.springframework.transaction.annotation.Transactional;\n\n@Component\n@Transactional(readOnly = true)\npublic class {Entity}ReadManager {\n\n    public Object getById(Long id) {\n        return null;\n    }\n}','{Entity}ReadManager',NULL,NULL,NULL,NULL,NULL,'Read Manager - 조회 Port 단일 호출. @Transactional(readOnly=true).','2026-01-16 06:58:55','2026-01-16 06:58:55',40,NULL),(165,4,'MANAGER','package com.ryuqq.application.{bc}.manager.command;\n\nimport org.springframework.stereotype.Component;\nimport org.springframework.transaction.annotation.Transactional;\n\n@Component\n@Transactional\npublic class {Entity}PersistenceManager {\n\n    public Long save(Object entity) {\n        return null;\n    }\n}','{Entity}PersistenceManager',NULL,NULL,NULL,NULL,NULL,'Persistence Manager - CUD Port 단일 호출. @Transactional.','2026-01-16 06:58:55','2026-01-16 06:58:55',39,NULL),(166,4,'MANAGER','package com.ryuqq.application.{bc}.manager.client;\n\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class {External}ClientManager {\n    // 외부 API 호출 로직 (트랜잭션 금지)\n}','{External}ClientManager',NULL,NULL,NULL,NULL,NULL,'Client Manager - 외부 API 호출. @Transactional 금지.','2026-01-16 06:58:55','2026-01-16 06:58:55',NULL,NULL),(167,4,'FACTORY','package com.ryuqq.application.{bc}.factory.command;\n\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class {Entity}CommandFactory {\n\n    public Object create(Object command) {\n        return null;\n    }\n}','{Entity}CommandFactory',NULL,NULL,NULL,NULL,NULL,'Command Factory - Command → Domain 변환.','2026-01-16 06:58:55','2026-01-16 06:58:55',43,NULL),(168,4,'FACTORY','package com.ryuqq.application.{bc}.factory.query;\n\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class {Entity}QueryFactory {\n\n    public Object toCriteria(Object query) {\n        return null;\n    }\n}','{Entity}QueryFactory',NULL,NULL,NULL,NULL,NULL,'Query Factory - Query → Criteria 변환.','2026-01-16 06:58:55','2026-01-16 06:58:55',44,NULL),(169,4,'ASSEMBLER','package com.ryuqq.application.{bc}.assembler;\n\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class {Entity}Assembler {\n\n    public Object toResponse(Object entity) {\n        return null;\n    }\n\n    public Object toIdResponse(Long id) {\n        return null;\n    }\n}','{Entity}Assembler',NULL,NULL,NULL,NULL,NULL,'Assembler - Domain → Response 변환.','2026-01-16 06:58:55','2026-01-16 06:58:55',45,NULL),(170,4,'PORT_IN','package com.ryuqq.application.{bc}.port.in.command;\n\npublic interface Create{Entity}UseCase {\n    Object execute(Object command);\n}','Create{Entity}UseCase',NULL,NULL,NULL,NULL,NULL,'Command UseCase 인터페이스 - 생성.','2026-01-16 06:58:55','2026-01-16 06:58:55',46,NULL),(171,4,'PORT_IN','package com.ryuqq.application.{bc}.port.in.query;\n\npublic interface Get{Entity}UseCase {\n    Object execute(Object query);\n}','Get{Entity}UseCase',NULL,NULL,NULL,NULL,NULL,'Query UseCase 인터페이스 - 단건 조회.','2026-01-16 06:58:55','2026-01-16 06:58:55',47,NULL),(172,4,'PORT_OUT','package com.ryuqq.application.{bc}.port.out.command;\n\npublic interface {Entity}CommandPort {\n    Long save(Object entity);\n    void update(Object entity);\n    void delete(Long id);\n}','{Entity}CommandPort',NULL,NULL,NULL,NULL,NULL,'Command Port 인터페이스 - CUD 영속화.','2026-01-16 06:58:55','2026-01-16 06:58:55',48,NULL),(173,4,'PORT_OUT','package com.ryuqq.application.{bc}.port.out.query;\n\nimport java.util.Optional;\n\npublic interface {Entity}QueryPort {\n    Optional<Object> findById(Long id);\n}','{Entity}QueryPort',NULL,NULL,NULL,NULL,NULL,'Query Port 인터페이스 - 조회.','2026-01-16 06:58:55','2026-01-16 06:58:55',49,NULL),(174,4,'PORT_OUT','package com.ryuqq.application.{bc}.port.out.client;\n\npublic interface {External}ClientPort {\n    Object call(Object request);\n}','{External}ClientPort',NULL,NULL,NULL,NULL,NULL,'Client Port 인터페이스 - 외부 API.','2026-01-16 06:58:55','2026-01-16 06:58:55',50,NULL),(175,4,'EVENT_LISTENER','package com.ryuqq.application.{bc}.event;\n\nimport org.springframework.context.event.EventListener;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class {Entity}EventListener {\n\n    @EventListener\n    public void handle(Object event) {\n        // 이벤트 처리 로직\n    }\n}','{Entity}EventListener',NULL,NULL,NULL,NULL,NULL,'Event Listener - Domain Event 처리.','2026-01-16 06:58:55','2026-01-16 06:58:55',55,NULL),(176,4,'USE_CASE','package com.ryuqq.application.{bc}.dto.command;\n\npublic record Create{Entity}Command(\n    String name\n) {}','Create{Entity}Command',NULL,NULL,NULL,NULL,NULL,'Command DTO - Record 타입. 생성 요청.','2026-01-16 06:58:56','2026-01-16 06:58:56',51,NULL),(177,4,'USE_CASE','package com.ryuqq.application.{bc}.dto.query;\n\npublic record Get{Entity}Query(Long id) {}','Get{Entity}Query',NULL,NULL,NULL,NULL,NULL,'Query DTO - Record 타입. 단건 조회.','2026-01-16 06:58:56','2026-01-16 06:58:56',52,NULL),(178,4,'USE_CASE','package com.ryuqq.application.{bc}.dto.response;\n\npublic record {Entity}Response(\n    Long id,\n    String name\n) {}','{Entity}Response',NULL,NULL,NULL,NULL,NULL,'Response DTO - Record 타입. 조회 응답.','2026-01-16 06:58:56','2026-01-16 06:58:56',53,NULL),(179,5,'ENTITY','package com.ryuqq.adapter.out.persistence.{bc}.entity;\n\nimport jakarta.persistence.*;\n\n@Entity\n@Table(name = \"{table_name}\")\npublic class {Entity}JpaEntity extends BaseAuditEntity {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    // Long FK 전략 - JPA 관계 어노테이션 금지\n    @Column(name = \"related_id\", nullable = false)\n    private Long relatedId;\n    \n    protected {Entity}JpaEntity() {}\n    \n    public static {Entity}JpaEntity of({Entity} domain) { /* ... */ }\n}','{Entity}JpaEntity',NULL,NULL,NULL,NULL,NULL,'JPA Entity - BaseAuditEntity 상속, Long FK 전략, Lombok 금지','2026-01-16 07:17:07','2026-01-16 07:17:07',NULL,NULL),(180,5,'JPA_REPOSITORY','package com.ryuqq.adapter.out.persistence.{bc}.repository;\n\nimport org.springframework.data.jpa.repository.JpaRepository;\n\npublic interface {Entity}JpaRepository extends JpaRepository<{Entity}JpaEntity, Long> {\n    // Query Method 금지 - QueryDSL 사용\n}','{Entity}JpaRepository',NULL,NULL,NULL,NULL,NULL,'JPA Repository - Command 전용, save/delete만, Query Method 금지','2026-01-16 07:17:07','2026-01-16 07:17:07',NULL,NULL),(181,5,'QUERYDSL_REPOSITORY','package com.ryuqq.adapter.out.persistence.{bc}.repository;\n\nimport com.querydsl.jpa.impl.JPAQueryFactory;\nimport org.springframework.stereotype.Repository;\n\n@Repository\npublic class {Entity}QueryDslRepository {\n    private final JPAQueryFactory queryFactory;\n    \n    public {Entity}QueryDslRepository(JPAQueryFactory queryFactory) {\n        this.queryFactory = queryFactory;\n    }\n}','{Entity}QueryDslRepository',NULL,NULL,NULL,NULL,NULL,'QueryDSL Repository - 조회 전용, DTO Projection','2026-01-16 07:17:07','2026-01-16 07:17:07',NULL,NULL),(182,5,'COMMAND_ADAPTER','package com.ryuqq.adapter.out.persistence.{bc}.adapter;\n\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class {Entity}CommandAdapter implements {Entity}CommandPort {\n    private final {Entity}JpaRepository repository;\n    private final {Entity}Mapper mapper;\n    \n    public Long persist({Entity} domain) {\n        return repository.save(mapper.toEntity(domain)).getId();\n    }\n}','{Entity}CommandAdapter',NULL,NULL,NULL,NULL,NULL,'Command Adapter - CommandPort 구현, @Transactional 금지','2026-01-16 07:17:07','2026-01-16 07:17:07',NULL,NULL),(183,5,'QUERY_ADAPTER','package com.ryuqq.adapter.out.persistence.{bc}.adapter;\n\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class {Entity}QueryAdapter implements {Entity}QueryPort {\n    private final {Entity}QueryDslRepository queryDslRepository;\n    private final {Entity}Mapper mapper;\n    \n    public Optional<{Entity}> findById(Long id) {\n        return queryDslRepository.findById(id).map(mapper::toDomain);\n    }\n}','{Entity}QueryAdapter',NULL,NULL,NULL,NULL,NULL,'Query Adapter - QueryPort 구현, Domain 반환','2026-01-16 07:17:07','2026-01-16 07:17:07',NULL,NULL),(184,5,'ENTITY_MAPPER','package com.ryuqq.adapter.out.persistence.{bc}.mapper;\n\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class {Entity}Mapper {\n    public {Entity}JpaEntity toEntity({Entity} domain) { /* ... */ }\n    public {Entity} toDomain({Entity}JpaEntity entity) { /* ... */ }\n}','{Entity}Mapper',NULL,NULL,NULL,NULL,NULL,'Entity Mapper - Entity ↔ Domain 양방향 변환','2026-01-16 07:17:07','2026-01-16 07:17:07',NULL,NULL);
/*!40000 ALTER TABLE `class_template` ENABLE KEYS */;
UNLOCK TABLES;

LOCK TABLES `archunit_test` WRITE;
/*!40000 ALTER TABLE `archunit_test` DISABLE KEYS */;
INSERT INTO `archunit_test` (`id`, `convention_id`, `structure_id`, `code`, `name`, `description`, `test_class_name`, `test_method_name`, `test_code`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (1,1,NULL,'ARCH-LAYER-001','REST-API는 Application Layer만 의존','adapter.in.rest 패키지는 application 패키지만 의존할 수 있습니다. domain, adapter.out 직접 의존을 금지합니다.','RestApiLayerArchTest','restApiShouldOnlyDependOnApplication','@ArchTest\nstatic final ArchRule restApiShouldOnlyDependOnApplication =\n    classes()\n        .that().resideInAPackage(\"..adapter.in.rest..\")\n        .should().onlyDependOnClassesThat()\n        .resideInAnyPackage(\n            \"..adapter.in.rest..\",\n            \"..application..\",\n            \"java..\",\n            \"jakarta..\",\n            \"org.springframework..\",\n            \"io.swagger..\",\n            \"com.fasterxml.jackson..\"\n        )\n        .because(\"REST API Layer는 Application Layer만 의존해야 합니다\");','BLOCKER','2026-01-16 02:26:17','2026-01-16 02:26:17',NULL),(2,1,NULL,'ARCH-LAYER-002','REST-API는 Domain 직접 의존 금지','adapter.in.rest 패키지에서 domain 패키지를 직접 import할 수 없습니다. Domain 객체는 Application Layer를 통해서만 접근합니다.','RestApiLayerArchTest','restApiShouldNotDependOnDomain','@ArchTest\nstatic final ArchRule restApiShouldNotDependOnDomain =\n    noClasses()\n        .that().resideInAPackage(\"..adapter.in.rest..\")\n        .should().dependOnClassesThat()\n        .resideInAPackage(\"..domain..\")\n        .because(\"REST API Layer는 Domain을 직접 의존할 수 없습니다. Application Layer를 통해 접근하세요\");','BLOCKER','2026-01-16 02:26:17','2026-01-16 02:26:17',NULL),(3,1,NULL,'ARCH-LAYER-003','패키지 간 순환 의존성 금지','adapter.in.rest 하위 패키지 간 순환 참조를 금지합니다. controller → dto → mapper 단방향 의존만 허용합니다.','RestApiLayerArchTest','noPackageCycles','@ArchTest\nstatic final ArchRule noPackageCycles =\n    slices()\n        .matching(\"..adapter.in.rest.(*)..\")\n        .should().beFreeOfCycles()\n        .because(\"패키지 간 순환 의존성은 허용되지 않습니다\");','BLOCKER','2026-01-16 02:26:17','2026-01-16 02:26:17',NULL),(4,1,14,'ARCH-CTR-001','Controller는 UseCase 인터페이스만 의존','Controller는 UseCase(Port-In) 인터페이스만 의존해야 합니다. Repository, Entity, Service 구현체 직접 의존을 금지합니다.','ControllerArchTest','controllersShouldOnlyDependOnUseCase','@ArchTest\nstatic final ArchRule controllersShouldOnlyDependOnUseCase =\n    classes()\n        .that().haveSimpleNameEndingWith(\"Controller\")\n        .should().onlyDependOnClassesThat()\n        .resideInAnyPackage(\n            \"..controller..\",\n            \"..dto..\",\n            \"..mapper..\",\n            \"..application..port.in..\",\n            \"..application..dto..\",\n            \"..common..\",\n            \"java..\",\n            \"jakarta..\",\n            \"org.springframework..\",\n            \"io.swagger..\"\n        )\n        .because(\"Controller는 UseCase 인터페이스만 의존해야 합니다 (Thin Controller)\");','BLOCKER','2026-01-16 02:26:17','2026-01-16 02:26:17',NULL),(5,1,14,'ARCH-CTR-002','Controller에 @RestController 필수','Controller 클래스에는 @RestController 어노테이션이 필수입니다. @Controller 단독 사용을 금지합니다.','ControllerArchTest','controllersShouldBeAnnotatedWithRestController','@ArchTest\nstatic final ArchRule controllersShouldBeAnnotatedWithRestController =\n    classes()\n        .that().haveSimpleNameEndingWith(\"Controller\")\n        .and().resideInAPackage(\"..controller..\")\n        .should().beAnnotatedWith(RestController.class)\n        .because(\"Controller는 @RestController 어노테이션이 필수입니다\");','BLOCKER','2026-01-16 02:26:17','2026-01-16 02:26:17',NULL),(6,1,14,'ARCH-CTR-003','Controller 패키지 위치 검증','Controller는 ..controller.command 또는 ..controller.query 패키지에 위치해야 합니다.','ControllerArchTest','controllersShouldResideInCorrectPackage','@ArchTest\nstatic final ArchRule controllersShouldResideInCorrectPackage =\n    classes()\n        .that().haveSimpleNameEndingWith(\"Controller\")\n        .should().resideInAnyPackage(\n            \"..controller.command..\",\n            \"..controller.query..\"\n        )\n        .because(\"Controller는 command 또는 query 패키지에 위치해야 합니다 (CQRS)\");','CRITICAL','2026-01-16 02:26:17','2026-01-16 02:26:17',NULL),(7,1,14,'ARCH-CTR-004','Controller 네이밍 규칙','Controller 클래스명은 *CommandController 또는 *QueryController 형식이어야 합니다.','ControllerArchTest','controllersShouldFollowNamingConvention','@ArchTest\nstatic final ArchRule controllersShouldFollowNamingConvention =\n    classes()\n        .that().resideInAPackage(\"..controller.command..\")\n        .should().haveSimpleNameEndingWith(\"CommandController\")\n        .orShould().haveSimpleNameEndingWith(\"Controller\")\n        .because(\"Command Controller는 *CommandController 네이밍을 따라야 합니다\");','MAJOR','2026-01-16 02:26:17','2026-01-16 02:26:17',NULL),(8,1,14,'ARCH-CTR-005','Controller에서 List 직접 반환 금지','Controller 메서드에서 List<T>를 직접 반환할 수 없습니다. PageApiResponse 또는 SliceApiResponse를 사용해야 합니다.','ControllerArchTest','controllersShouldNotReturnRawList','@ArchTest\nstatic final ArchRule controllersShouldNotReturnRawList =\n    methods()\n        .that().areDeclaredInClassesThat().haveSimpleNameEndingWith(\"Controller\")\n        .and().arePublic()\n        .should(new ArchCondition<JavaMethod>(\"not return raw List\") {\n            @Override\n            public void check(JavaMethod method, ConditionEvents events) {\n                String returnType = method.getRawReturnType().getName();\n                if (returnType.equals(\"java.util.List\") ||\n                    returnType.contains(\"List<\")) {\n                    events.add(SimpleConditionEvent.violated(method,\n                        String.format(\"Method %s returns raw List. Use PageApiResponse or SliceApiResponse instead\",\n                            method.getFullName())));\n                }\n            }\n        })\n        .because(\"List 직접 반환은 금지됩니다. PageApiResponse/SliceApiResponse를 사용하세요\");','BLOCKER','2026-01-16 02:26:18','2026-01-16 02:26:18',NULL),(9,1,14,'ARCH-CTR-006','Controller var 키워드 사용 금지 (가이드)','Controller에서 var 키워드 사용을 금지합니다. ArchUnit으로 직접 검증이 어려워 Checkstyle/SpotBugs로 보완 권장.','ControllerArchTest','varKeywordGuideline','// NOTE: var 키워드는 컴파일 후 실제 타입으로 변환되어 ArchUnit으로 직접 검증이 어렵습니다.\n// Checkstyle의 IllegalType 또는 커스텀 룰로 소스코드 레벨에서 검증하세요.\n//\n// Checkstyle 설정 예시:\n// <module name=\"IllegalType\">\n//     <property name=\"illegalClassNames\" value=\"var\"/>\n//     <property name=\"tokens\" value=\"VARIABLE_DEF\"/>\n// </module>\n//\n// 이 규칙은 코드 리뷰 가이드로 활용합니다.\n@ArchTest\nstatic final ArchRule varKeywordGuideline =\n    classes()\n        .that().haveSimpleNameEndingWith(\"Controller\")\n        .should().bePublic()\n        .because(\"Controller에서 var 키워드 사용을 금지합니다 (코드 리뷰로 검증)\");','MAJOR','2026-01-16 02:26:18','2026-01-16 02:26:18',NULL),(10,1,15,'ARCH-DTO-001','DTO는 Record 타입 필수','dto 패키지의 모든 클래스는 Java Record 타입이어야 합니다. 일반 class 사용을 금지합니다.','DtoArchTest','dtosShouldBeRecords','@ArchTest\nstatic final ArchRule dtosShouldBeRecords =\n    classes()\n        .that().resideInAPackage(\"..dto..\")\n        .and().haveSimpleNameEndingWith(\"Request\")\n        .or().haveSimpleNameEndingWith(\"Response\")\n        .should().beRecords()\n        .because(\"DTO는 Java Record 타입이어야 합니다\");','BLOCKER','2026-01-16 02:26:18','2026-01-16 02:26:18',NULL),(11,1,15,'ARCH-DTO-002','DTO 네이밍 규칙 (*ApiRequest, *ApiResponse)','DTO 클래스명은 *ApiRequest 또는 *ApiResponse 형식이어야 합니다.','DtoArchTest','dtosShouldFollowNamingConvention','@ArchTest\nstatic final ArchRule dtosShouldFollowNamingConvention =\n    classes()\n        .that().resideInAPackage(\"..dto..\")\n        .and().arePublic()\n        .and().areNotNestedClasses()\n        .should().haveSimpleNameEndingWith(\"ApiRequest\")\n        .orShould().haveSimpleNameEndingWith(\"ApiResponse\")\n        .orShould().haveSimpleNameEndingWith(\"SearchParams\")\n        .because(\"DTO는 *ApiRequest, *ApiResponse, *SearchParams 네이밍을 따라야 합니다\");','MAJOR','2026-01-16 02:26:18','2026-01-16 02:26:18',NULL),(12,1,15,'ARCH-DTO-003','DTO는 다른 레이어 의존 금지','DTO는 다른 레이어(domain, application, adapter.out)를 의존할 수 없습니다. 순수 데이터 객체로만 유지합니다.','DtoArchTest','dtosShouldNotDependOnOtherLayers','@ArchTest\nstatic final ArchRule dtosShouldNotDependOnOtherLayers =\n    classes()\n        .that().resideInAPackage(\"..dto..\")\n        .should().onlyDependOnClassesThat()\n        .resideInAnyPackage(\n            \"..dto..\",\n            \"java..\",\n            \"jakarta.validation..\",\n            \"io.swagger..\"\n        )\n        .because(\"DTO는 순수 데이터 객체로, 다른 레이어를 의존할 수 없습니다\");','BLOCKER','2026-01-16 02:26:18','2026-01-16 02:26:18',NULL),(13,1,15,'ARCH-DTO-004','DTO 패키지 위치 검증','Request DTO는 dto.command 또는 dto.query, Response DTO는 dto.response 패키지에 위치해야 합니다.','DtoArchTest','dtosShouldResideInCorrectPackage','@ArchTest\nstatic final ArchRule requestDtosShouldResideInCorrectPackage =\n    classes()\n        .that().haveSimpleNameEndingWith(\"ApiRequest\")\n        .should().resideInAnyPackage(\n            \"..dto.command..\",\n            \"..dto.query..\"\n        )\n        .because(\"Request DTO는 dto.command 또는 dto.query 패키지에 위치해야 합니다\");','CRITICAL','2026-01-16 02:26:18','2026-01-16 02:26:18',NULL),(14,1,15,'ARCH-DTO-005','Request DTO 메서드 금지','Request DTO(Record)에는 추가 메서드를 정의할 수 없습니다. Record의 자동 생성 메서드(getter, equals, hashCode, toString)만 허용됩니다.','DtoArchTest','requestDtosShouldNotHaveCustomMethods','@ArchTest\nstatic final ArchRule requestDtosShouldNotHaveCustomMethods =\n    classes()\n        .that().resideInAPackage(\"..dto..\")\n        .and().haveSimpleNameEndingWith(\"ApiRequest\")\n        .should(new ArchCondition<JavaClass>(\"not have custom methods\") {\n            @Override\n            public void check(JavaClass javaClass, ConditionEvents events) {\n                javaClass.getMethods().stream()\n                    .filter(method -> !isRecordGeneratedMethod(method))\n                    .filter(method -> !method.getName().equals(\"compact\"))\n                    .forEach(method -> events.add(SimpleConditionEvent.violated(javaClass,\n                        String.format(\"Request DTO %s has custom method: %s\",\n                            javaClass.getSimpleName(), method.getName()))));\n            }\n\n            private boolean isRecordGeneratedMethod(JavaMethod method) {\n                String name = method.getName();\n                return name.equals(\"equals\") || name.equals(\"hashCode\") ||\n                       name.equals(\"toString\") || method.getRawReturnType() != null;\n            }\n        })\n        .because(\"Request DTO에는 추가 메서드를 정의할 수 없습니다\");','BLOCKER','2026-01-16 02:26:18','2026-01-16 02:26:18',NULL),(15,1,15,'ARCH-DTO-006','Response DTO 메서드 금지','Response DTO(Record)는 순수 데이터 객체입니다. 추가 메서드를 정의할 수 없습니다.','DtoArchTest','responseDtosShouldNotHaveCustomMethods','@ArchTest\nstatic final ArchRule responseDtosShouldNotHaveCustomMethods =\n    classes()\n        .that().resideInAPackage(\"..dto.response..\")\n        .and().haveSimpleNameEndingWith(\"ApiResponse\")\n        .should(new ArchCondition<JavaClass>(\"not have custom methods\") {\n            @Override\n            public void check(JavaClass javaClass, ConditionEvents events) {\n                long customMethodCount = javaClass.getMethods().stream()\n                    .filter(method -> !isRecordGeneratedMethod(method))\n                    .count();\n                if (customMethodCount > 0) {\n                    events.add(SimpleConditionEvent.violated(javaClass,\n                        String.format(\"Response DTO %s has %d custom methods\",\n                            javaClass.getSimpleName(), customMethodCount)));\n                }\n            }\n\n            private boolean isRecordGeneratedMethod(JavaMethod method) {\n                String name = method.getName();\n                return name.equals(\"equals\") || name.equals(\"hashCode\") || name.equals(\"toString\");\n            }\n        })\n        .because(\"Response DTO에는 추가 메서드를 정의할 수 없습니다\");','BLOCKER','2026-01-16 02:26:18','2026-01-16 02:26:18',NULL),(16,1,16,'ARCH-MAP-001','Mapper에 @Component 필수','Mapper 클래스에는 @Component 어노테이션이 필수입니다. @Service, @Repository는 사용하지 않습니다.','MapperArchTest','mappersShouldBeAnnotatedWithComponent','@ArchTest\nstatic final ArchRule mappersShouldBeAnnotatedWithComponent =\n    classes()\n        .that().haveSimpleNameEndingWith(\"Mapper\")\n        .and().resideInAPackage(\"..mapper..\")\n        .should().beAnnotatedWith(Component.class)\n        .because(\"Mapper는 @Component 어노테이션이 필수입니다\");','BLOCKER','2026-01-16 02:26:18','2026-01-16 02:26:18',NULL),(17,1,16,'ARCH-MAP-002','Mapper 네이밍 규칙 (*ApiMapper)','Mapper 클래스명은 *CommandApiMapper 또는 *QueryApiMapper 형식이어야 합니다.','MapperArchTest','mappersShouldFollowNamingConvention','@ArchTest\nstatic final ArchRule mappersShouldFollowNamingConvention =\n    classes()\n        .that().resideInAPackage(\"..mapper..\")\n        .and().haveSimpleNameEndingWith(\"Mapper\")\n        .should().haveSimpleNameEndingWith(\"ApiMapper\")\n        .because(\"Mapper는 *ApiMapper 네이밍을 따라야 합니다\");','MAJOR','2026-01-16 02:26:18','2026-01-16 02:26:18',NULL),(18,1,16,'ARCH-MAP-003','Mapper는 Repository 의존 금지','Mapper는 Repository, Entity를 의존할 수 없습니다. 순수 변환 로직만 수행합니다.','MapperArchTest','mappersShouldNotDependOnRepository','@ArchTest\nstatic final ArchRule mappersShouldNotDependOnRepository =\n    noClasses()\n        .that().resideInAPackage(\"..mapper..\")\n        .should().dependOnClassesThat()\n        .resideInAnyPackage(\n            \"..repository..\",\n            \"..adapter.out..\",\n            \"..persistence..\"\n        )\n        .because(\"Mapper는 Repository/Persistence를 의존할 수 없습니다\");','BLOCKER','2026-01-16 02:26:18','2026-01-16 02:26:18',NULL),(19,1,16,'ARCH-MAP-004','Mapper 패키지 위치 검증','Mapper는 mapper.command 또는 mapper.query 패키지에 위치해야 합니다.','MapperArchTest','mappersShouldResideInCorrectPackage','@ArchTest\nstatic final ArchRule mappersShouldResideInCorrectPackage =\n    classes()\n        .that().haveSimpleNameEndingWith(\"Mapper\")\n        .and().resideInAPackage(\"..adapter.in.rest..\")\n        .should().resideInAnyPackage(\n            \"..mapper.command..\",\n            \"..mapper.query..\"\n        )\n        .because(\"Mapper는 mapper.command 또는 mapper.query 패키지에 위치해야 합니다\");','CRITICAL','2026-01-16 02:26:18','2026-01-16 02:26:18',NULL),(20,1,19,'ARCH-CFG-001','Config에 @Configuration 필수','Config 클래스에는 @Configuration 어노테이션이 필수입니다.','ConfigArchTest','configsShouldBeAnnotatedWithConfiguration','@ArchTest\nstatic final ArchRule configsShouldBeAnnotatedWithConfiguration =\n    classes()\n        .that().haveSimpleNameEndingWith(\"Config\")\n        .and().resideInAPackage(\"..config..\")\n        .should().beAnnotatedWith(Configuration.class)\n        .because(\"Config 클래스는 @Configuration 어노테이션이 필수입니다\");','BLOCKER','2026-01-16 02:26:18','2026-01-16 02:26:18',NULL),(21,1,19,'ARCH-CFG-002','Config 패키지 위치 검증','Config 클래스는 config 패키지에 위치해야 합니다.','ConfigArchTest','configsShouldResideInConfigPackage','@ArchTest\nstatic final ArchRule configsShouldResideInConfigPackage =\n    classes()\n        .that().haveSimpleNameEndingWith(\"Config\")\n        .should().resideInAPackage(\"..config..\")\n        .because(\"Config 클래스는 config 패키지에 위치해야 합니다\");','MAJOR','2026-01-16 02:26:19','2026-01-16 02:26:19',NULL),(22,2,NULL,'ARCH-TSCH-LAYER-001','Thin Scheduler는 UseCase 인터페이스만 의존','adapter.in.scheduler 패키지는 port.in.scheduler의 UseCase 인터페이스만 의존할 수 있습니다. Manager, Port, Repository 직접 의존을 금지합니다.','ThinSchedulerArchTest','schedulerShouldOnlyDependOnUseCase','@ArchTest\nstatic final ArchRule schedulerShouldOnlyDependOnUseCase =\n    classes()\n        .that().resideInAPackage(\"..adapter.in.scheduler..\")\n        .and().haveSimpleNameEndingWith(\"Scheduler\")\n        .should().onlyDependOnClassesThat()\n        .resideInAnyPackage(\n            \"..adapter.in.scheduler..\",\n            \"..port.in.scheduler..\",\n            \"java..\",\n            \"org.springframework.scheduling..\",\n            \"org.springframework.stereotype..\"\n        )\n        .because(\"Thin Scheduler는 UseCase 인터페이스만 의존해야 합니다 (TSCH-002)\");','BLOCKER','2026-01-16 02:26:27','2026-01-16 02:26:27',NULL),(23,2,NULL,'ARCH-TSCH-LAYER-002','Thin Scheduler는 Manager 직접 의존 금지','Thin Scheduler에서 Manager를 직접 주입받으면 비즈니스 로직이 Scheduler에 위치하게 됩니다. Manager는 Application Layer의 Scheduler Service에서만 사용합니다.','ThinSchedulerArchTest','schedulerShouldNotDependOnManager','@ArchTest\nstatic final ArchRule schedulerShouldNotDependOnManager =\n    noClasses()\n        .that().resideInAPackage(\"..adapter.in.scheduler..\")\n        .should().dependOnClassesThat()\n        .haveSimpleNameEndingWith(\"Manager\")\n        .because(\"Thin Scheduler는 Manager를 직접 의존할 수 없습니다. UseCase를 통해 위임하세요 (TSCH-002, TSCH-004)\");','BLOCKER','2026-01-16 02:26:27','2026-01-16 02:26:27',NULL),(24,2,NULL,'ARCH-TSCH-LAYER-003','Thin Scheduler는 Port 직접 의존 금지','Thin Scheduler에서 QueryPort, CommandPort, ClientPort를 직접 주입받을 수 없습니다. 모든 Port 접근은 Application Layer를 통해야 합니다.','ThinSchedulerArchTest','schedulerShouldNotDependOnPort','@ArchTest\nstatic final ArchRule schedulerShouldNotDependOnPort =\n    noClasses()\n        .that().resideInAPackage(\"..adapter.in.scheduler..\")\n        .should().dependOnClassesThat()\n        .haveSimpleNameEndingWith(\"Port\")\n        .because(\"Thin Scheduler는 Port를 직접 의존할 수 없습니다. UseCase를 통해 위임하세요 (TSCH-002)\");','BLOCKER','2026-01-16 02:26:27','2026-01-16 02:26:27',NULL),(25,2,NULL,'ARCH-TSCH-LAYER-004','Thin Scheduler는 Repository 직접 의존 금지','Thin Scheduler에서 Repository를 직접 주입받을 수 없습니다. DB 접근은 Application Layer를 통해야 합니다.','ThinSchedulerArchTest','schedulerShouldNotDependOnRepository','@ArchTest\nstatic final ArchRule schedulerShouldNotDependOnRepository =\n    noClasses()\n        .that().resideInAPackage(\"..adapter.in.scheduler..\")\n        .should().dependOnClassesThat()\n        .haveSimpleNameEndingWith(\"Repository\")\n        .because(\"Thin Scheduler는 Repository를 직접 의존할 수 없습니다. UseCase를 통해 위임하세요 (TSCH-002)\");','BLOCKER','2026-01-16 02:26:27','2026-01-16 02:26:27',NULL),(26,2,NULL,'ARCH-TSCH-NAME-001','Scheduler 클래스는 Scheduler로 끝나야 함','adapter.in.scheduler 패키지의 @Component 클래스는 {Domain}Scheduler 또는 {Domain}OutboxScheduler로 네이밍합니다.','ThinSchedulerArchTest','schedulerClassShouldEndWithScheduler','@ArchTest\nstatic final ArchRule schedulerClassShouldEndWithScheduler =\n    classes()\n        .that().resideInAPackage(\"..adapter.in.scheduler..\")\n        .and().areAnnotatedWith(Component.class)\n        .should().haveSimpleNameEndingWith(\"Scheduler\")\n        .because(\"Scheduler 클래스는 Scheduler로 끝나야 합니다 (TSCH-006)\");','MAJOR','2026-01-16 02:26:27','2026-01-16 02:26:27',NULL),(27,2,NULL,'ARCH-TSCH-ANNO-001','Scheduler 클래스는 @Component 어노테이션 필수','Thin Scheduler 클래스는 @Component로 빈 등록합니다. @Service는 사용하지 않습니다.','ThinSchedulerArchTest','schedulerShouldBeAnnotatedWithComponent','@ArchTest\nstatic final ArchRule schedulerShouldBeAnnotatedWithComponent =\n    classes()\n        .that().resideInAPackage(\"..adapter.in.scheduler..\")\n        .and().haveSimpleNameEndingWith(\"Scheduler\")\n        .should().beAnnotatedWith(Component.class)\n        .because(\"Scheduler 클래스는 @Component로 빈 등록해야 합니다 (TSCH-001)\");','MAJOR','2026-01-16 02:26:27','2026-01-16 02:26:27',NULL),(28,2,NULL,'ARCH-TSCH-ANNO-002','@Scheduled 메서드는 void 반환','@Scheduled 어노테이션이 적용된 메서드는 void를 반환해야 합니다. 반환값이 있어도 Spring이 무시합니다.','ThinSchedulerArchTest','scheduledMethodShouldReturnVoid','@ArchTest\nstatic final ArchRule scheduledMethodShouldReturnVoid =\n    methods()\n        .that().areAnnotatedWith(Scheduled.class)\n        .should().haveRawReturnType(void.class)\n        .because(\"@Scheduled 메서드는 void를 반환해야 합니다 (TSCH-007)\");','MAJOR','2026-01-16 02:26:27','2026-01-16 02:26:27',NULL),(29,2,NULL,'ARCH-TSCH-ANNO-003','Scheduler 패키지에 @Service 금지','adapter.in.scheduler 패키지에서는 @Service를 사용하지 않습니다. Thin Scheduler는 @Component로 등록합니다.','ThinSchedulerArchTest','schedulerPackageShouldNotUseServiceAnnotation','@ArchTest\nstatic final ArchRule schedulerPackageShouldNotUseServiceAnnotation =\n    noClasses()\n        .that().resideInAPackage(\"..adapter.in.scheduler..\")\n        .should().beAnnotatedWith(Service.class)\n        .because(\"Scheduler 패키지에서는 @Service 대신 @Component를 사용합니다 (TSCH-001)\");','MAJOR','2026-01-16 02:26:27','2026-01-16 02:26:27',NULL),(30,2,NULL,'ARCH-TSCH-STRUCT-001','Scheduler 패키지 간 순환 의존성 금지','adapter.in.scheduler 하위 패키지 간 순환 참조를 금지합니다.','ThinSchedulerArchTest','noPackageCyclesInScheduler','@ArchTest\nstatic final ArchRule noPackageCyclesInScheduler =\n    slices()\n        .matching(\"..adapter.in.scheduler.(*)..\")\n        .should().beFreeOfCycles()\n        .because(\"Scheduler 패키지 간 순환 의존성은 허용되지 않습니다\");','BLOCKER','2026-01-16 02:26:27','2026-01-16 02:26:27',NULL),(31,3,NULL,'ARCH-LAYER-010','Domain은 외부 레이어 의존 금지','domain 패키지는 application, adapter, bootstrap 패키지를 의존할 수 없습니다. 헥사고날 아키텍처의 의존성 역전 원칙.','DomainLayerArchTest','domainShouldNotDependOnOuterLayers','@ArchTest\nstatic final ArchRule domainShouldNotDependOnOuterLayers =\n    noClasses()\n        .that().resideInAPackage(\"..domain..\")\n        .should().dependOnClassesThat()\n        .resideInAnyPackage(\n            \"..application..\",\n            \"..adapter..\",\n            \"..bootstrap..\"\n        )\n        .because(\"Domain Layer는 외부 레이어(Application, Adapter, Bootstrap)를 의존할 수 없습니다\");','BLOCKER','2026-01-16 02:26:46','2026-01-16 02:26:46',NULL),(32,3,NULL,'ARCH-LAYER-011','Domain은 Lombok 의존 금지','domain 패키지에서 lombok 패키지 import를 금지합니다. 순수 자바 원칙.','DomainLayerArchTest','domainShouldNotUseLombok','@ArchTest\nstatic final ArchRule domainShouldNotUseLombok =\n    noClasses()\n        .that().resideInAPackage(\"..domain..\")\n        .should().dependOnClassesThat()\n        .resideInAPackage(\"lombok..\")\n        .because(\"Domain Layer에서 Lombok 사용을 금지합니다. 순수 자바 코드로 작성하세요\");','BLOCKER','2026-01-16 02:26:46','2026-01-16 02:26:46',NULL),(33,3,NULL,'ARCH-LAYER-012','Domain은 JPA 의존 금지','domain 패키지에서 jakarta.persistence 패키지 import를 금지합니다. 영속화는 Persistence Layer에서 처리.','DomainLayerArchTest','domainShouldNotUseJpa','@ArchTest\nstatic final ArchRule domainShouldNotUseJpa =\n    noClasses()\n        .that().resideInAPackage(\"..domain..\")\n        .should().dependOnClassesThat()\n        .resideInAnyPackage(\n            \"jakarta.persistence..\",\n            \"javax.persistence..\",\n            \"org.hibernate..\"\n        )\n        .because(\"Domain Layer에서 JPA/Hibernate 사용을 금지합니다. 영속화는 Persistence Layer에서 처리하세요\");','BLOCKER','2026-01-16 02:26:47','2026-01-16 02:26:47',NULL),(34,3,NULL,'ARCH-LAYER-013','Domain은 Spring 의존 금지','domain 패키지에서 org.springframework 패키지 import를 금지합니다. 프레임워크 독립성 확보.','DomainLayerArchTest','domainShouldNotUseSpring','@ArchTest\nstatic final ArchRule domainShouldNotUseSpring =\n    noClasses()\n        .that().resideInAPackage(\"..domain..\")\n        .should().dependOnClassesThat()\n        .resideInAPackage(\"org.springframework..\")\n        .because(\"Domain Layer에서 Spring Framework 사용을 금지합니다. POJO로 유지하세요\");','BLOCKER','2026-01-16 02:26:47','2026-01-16 02:26:47',NULL),(35,3,NULL,'ARCH-LAYER-014','Domain 내 순환 의존성 금지','domain 하위 패키지(aggregate, vo, event, exception) 간 순환 참조를 금지합니다.','DomainLayerArchTest','noPackageCycles','@ArchTest\nstatic final ArchRule noPackageCycles =\n    slices()\n        .matching(\"..domain.(*)..\")\n        .should().beFreeOfCycles()\n        .because(\"Domain 패키지 간 순환 의존성은 허용되지 않습니다\");','BLOCKER','2026-01-16 02:26:47','2026-01-16 02:26:47',NULL),(36,3,26,'ARCH-AGG-001','Aggregate 패키지 위치','Aggregate 클래스는 domain.[bc].aggregate 패키지에 위치해야 합니다.','AggregateArchTest','aggregatesShouldResideInAggregatePackage','@ArchTest\nstatic final ArchRule aggregatesShouldResideInAggregatePackage =\n    classes()\n        .that().areNotInterfaces()\n        .and().areNotRecords()\n        .and().resideInAPackage(\"..domain..aggregate..\")\n        .should().haveSimpleNameNotEndingWith(\"Test\")\n        .because(\"Aggregate는 domain.[bc].aggregate 패키지에 위치해야 합니다\");','CRITICAL','2026-01-16 02:26:47','2026-01-16 02:26:47',NULL),(37,3,26,'ARCH-AGG-002','Aggregate Lombok 어노테이션 금지','Aggregate 클래스에서 @Getter, @Setter, @Data, @Builder 등 Lombok 어노테이션 사용을 금지합니다.','AggregateArchTest','aggregatesShouldNotUseLombokAnnotations','@ArchTest\nstatic final ArchRule aggregatesShouldNotUseLombokAnnotations =\n    classes()\n        .that().resideInAPackage(\"..domain..aggregate..\")\n        .and().areNotInterfaces()\n        .should().notBeAnnotatedWith(\"lombok.Getter\")\n        .andShould().notBeAnnotatedWith(\"lombok.Setter\")\n        .andShould().notBeAnnotatedWith(\"lombok.Data\")\n        .andShould().notBeAnnotatedWith(\"lombok.Builder\")\n        .andShould().notBeAnnotatedWith(\"lombok.NoArgsConstructor\")\n        .andShould().notBeAnnotatedWith(\"lombok.AllArgsConstructor\")\n        .because(\"Aggregate에서 Lombok 어노테이션 사용을 금지합니다\");','BLOCKER','2026-01-16 02:26:47','2026-01-16 02:26:47',NULL),(38,3,26,'ARCH-AGG-003','Aggregate JPA 어노테이션 금지','Aggregate 클래스에서 @Entity, @Table, @Column, @Id 등 JPA 어노테이션 사용을 금지합니다.','AggregateArchTest','aggregatesShouldNotUseJpaAnnotations','@ArchTest\nstatic final ArchRule aggregatesShouldNotUseJpaAnnotations =\n    classes()\n        .that().resideInAPackage(\"..domain..aggregate..\")\n        .should().notBeAnnotatedWith(\"jakarta.persistence.Entity\")\n        .andShould().notBeAnnotatedWith(\"jakarta.persistence.Table\")\n        .andShould().notBeAnnotatedWith(\"jakarta.persistence.MappedSuperclass\")\n        .because(\"Aggregate에서 JPA 어노테이션 사용을 금지합니다\");','BLOCKER','2026-01-16 02:26:47','2026-01-16 02:26:47',NULL),(39,3,26,'ARCH-AGG-004','Aggregate Spring 어노테이션 금지','Aggregate 클래스에서 @Component, @Service, @Repository 등 Spring 어노테이션 사용을 금지합니다.','AggregateArchTest','aggregatesShouldNotUseSpringAnnotations','@ArchTest\nstatic final ArchRule aggregatesShouldNotUseSpringAnnotations =\n    classes()\n        .that().resideInAPackage(\"..domain..aggregate..\")\n        .should().notBeAnnotatedWith(\"org.springframework.stereotype.Component\")\n        .andShould().notBeAnnotatedWith(\"org.springframework.stereotype.Service\")\n        .andShould().notBeAnnotatedWith(\"org.springframework.stereotype.Repository\")\n        .andShould().notBeAnnotatedWith(\"org.springframework.transaction.annotation.Transactional\")\n        .because(\"Aggregate에서 Spring 어노테이션 사용을 금지합니다\");','BLOCKER','2026-01-16 02:26:47','2026-01-16 02:26:47',NULL),(40,3,26,'ARCH-AGG-005','Aggregate forNew() 메서드 필수','Aggregate 클래스는 static forNew() 팩토리 메서드가 필수입니다.','AggregateArchTest','aggregatesShouldHaveForNewMethod','@ArchTest\nstatic final ArchRule aggregatesShouldHaveForNewMethod =\n    classes()\n        .that().resideInAPackage(\"..domain..aggregate..\")\n        .and().areNotInterfaces()\n        .and().areNotAbstract()\n        .and().haveSimpleNameNotEndingWith(\"UpdateData\")\n        .should(new ArchCondition<JavaClass>(\"have static forNew method\") {\n            @Override\n            public void check(JavaClass javaClass, ConditionEvents events) {\n                boolean hasForNew = javaClass.getMethods().stream()\n                    .anyMatch(m -> m.getName().equals(\"forNew\") && m.getModifiers().contains(JavaModifier.STATIC));\n                if (!hasForNew) {\n                    events.add(SimpleConditionEvent.violated(javaClass,\n                        String.format(\"Aggregate %s must have static forNew() method\", javaClass.getSimpleName())));\n                }\n            }\n        })\n        .because(\"Aggregate는 static forNew() 팩토리 메서드가 필수입니다\");','BLOCKER','2026-01-16 02:26:47','2026-01-16 02:26:47',NULL),(41,3,26,'ARCH-AGG-006','Aggregate reconstitute() 메서드 필수','Aggregate 클래스는 static reconstitute() 팩토리 메서드가 필수입니다.','AggregateArchTest','aggregatesShouldHaveReconstituteMethod','@ArchTest\nstatic final ArchRule aggregatesShouldHaveReconstituteMethod =\n    classes()\n        .that().resideInAPackage(\"..domain..aggregate..\")\n        .and().areNotInterfaces()\n        .and().areNotAbstract()\n        .and().haveSimpleNameNotEndingWith(\"UpdateData\")\n        .should(new ArchCondition<JavaClass>(\"have static reconstitute method\") {\n            @Override\n            public void check(JavaClass javaClass, ConditionEvents events) {\n                boolean hasReconstitute = javaClass.getMethods().stream()\n                    .anyMatch(m -> m.getName().equals(\"reconstitute\") && m.getModifiers().contains(JavaModifier.STATIC));\n                if (!hasReconstitute) {\n                    events.add(SimpleConditionEvent.violated(javaClass,\n                        String.format(\"Aggregate %s must have static reconstitute() method\", javaClass.getSimpleName())));\n                }\n            }\n        })\n        .because(\"Aggregate는 static reconstitute() 팩토리 메서드가 필수입니다\");','BLOCKER','2026-01-16 02:26:47','2026-01-16 02:26:47',NULL),(42,3,26,'ARCH-AGG-007','Aggregate Setter 메서드 금지','Aggregate 클래스에서 setXxx() 형태의 Setter 메서드 정의를 금지합니다.','AggregateArchTest','aggregatesShouldNotHaveSetters','@ArchTest\nstatic final ArchRule aggregatesShouldNotHaveSetters =\n    methods()\n        .that().areDeclaredInClassesThat().resideInAPackage(\"..domain..aggregate..\")\n        .and().haveNameMatching(\"set[A-Z].*\")\n        .should(new ArchCondition<JavaMethod>(\"not exist\") {\n            @Override\n            public void check(JavaMethod method, ConditionEvents events) {\n                events.add(SimpleConditionEvent.violated(method,\n                    String.format(\"Aggregate method %s: setter methods are forbidden. Use explicit business methods instead.\",\n                        method.getFullName())));\n            }\n        })\n        .because(\"Aggregate에서 Setter 메서드를 금지합니다. 명시적 비즈니스 메서드를 사용하세요\");','BLOCKER','2026-01-16 02:26:47','2026-01-16 02:26:47',NULL),(43,3,26,'ARCH-AGG-008','Aggregate ID 필드는 ID VO 사용 (가이드)','Aggregate의 ID 필드는 원시 타입(Long) 대신 ID VO(예: OrderId)를 사용해야 합니다. ArchUnit으로 완전 검증이 어려워 코드 리뷰로 보완.','AggregateArchTest','aggregateIdFieldGuideline','// NOTE: ID 필드 타입 검증은 필드명과 타입을 동시에 체크해야 하므로 복잡합니다.\n// 코드 리뷰에서 \"id\" 필드가 *Id Record 타입인지 확인하세요.\n//\n// 올바른 예:\n// private final OrderId id; // ✅\n//\n// 잘못된 예:\n// private final Long id; // ❌\n@ArchTest\nstatic final ArchRule aggregateIdFieldGuideline =\n    classes()\n        .that().resideInAPackage(\"..domain..aggregate..\")\n        .and().areNotInterfaces()\n        .should().bePublic()\n        .because(\"Aggregate ID 필드는 ID VO(예: OrderId)를 사용해야 합니다 (코드 리뷰로 검증)\");','MAJOR','2026-01-16 02:26:47','2026-01-16 02:26:47',NULL),(44,3,27,'ARCH-ID-001','ID VO는 Record 타입 필수','ID Value Object(*Id)는 Java Record 타입으로 정의해야 합니다.','IdVoArchTest','idVosShouldBeRecords','@ArchTest\nstatic final ArchRule idVosShouldBeRecords =\n    classes()\n        .that().resideInAPackage(\"..domain..id..\")\n        .and().haveSimpleNameEndingWith(\"Id\")\n        .should().beRecords()\n        .because(\"ID VO는 Java Record 타입이어야 합니다\");','BLOCKER','2026-01-16 02:26:47','2026-01-16 02:26:47',NULL),(45,3,27,'ARCH-ID-002','ID VO *Id 네이밍 규칙','ID Value Object는 *Id 네이밍 규칙을 따라야 합니다. 예: OrderId, UserId, ProductId.','IdVoArchTest','idVosShouldFollowNamingConvention','@ArchTest\nstatic final ArchRule idVosShouldFollowNamingConvention =\n    classes()\n        .that().resideInAPackage(\"..domain..id..\")\n        .should().haveSimpleNameEndingWith(\"Id\")\n        .because(\"ID VO는 *Id 네이밍 규칙을 따라야 합니다\");','BLOCKER','2026-01-16 02:26:47','2026-01-16 02:26:47',NULL),(46,3,27,'ARCH-ID-003','ID VO of() 메서드 필수','ID VO는 static of() 팩토리 메서드가 필수입니다.','IdVoArchTest','idVosShouldHaveOfMethod','@ArchTest\nstatic final ArchRule idVosShouldHaveOfMethod =\n    classes()\n        .that().resideInAPackage(\"..domain..id..\")\n        .and().haveSimpleNameEndingWith(\"Id\")\n        .should(new ArchCondition<JavaClass>(\"have static of method\") {\n            @Override\n            public void check(JavaClass javaClass, ConditionEvents events) {\n                boolean hasOf = javaClass.getMethods().stream()\n                    .anyMatch(m -> m.getName().equals(\"of\") && m.getModifiers().contains(JavaModifier.STATIC));\n                if (!hasOf) {\n                    events.add(SimpleConditionEvent.violated(javaClass,\n                        String.format(\"ID VO %s must have static of() method\", javaClass.getSimpleName())));\n                }\n            }\n        })\n        .because(\"ID VO는 static of() 팩토리 메서드가 필수입니다\");','BLOCKER','2026-01-16 02:26:48','2026-01-16 02:26:48',NULL),(47,3,27,'ARCH-ID-004','Long ID VO forNew() 메서드 (가이드)','Long 기반 ID VO는 static forNew() 메서드가 필수입니다. Auto Increment 대응용.','IdVoArchTest','longIdVoForNewGuideline','// NOTE: Long ID vs String ID 구분이 어렵습니다.\n// Long 기반 ID VO에는 forNew()와 isNew()가 필수입니다.\n// String 기반 ID VO에는 forNew(String value)가 필수입니다.\n//\n// 코드 리뷰에서 확인하세요:\n// Long ID: forNew() → new XxxId(null), isNew() → value == null\n// String ID: forNew(String value) → 외부에서 ID 주입, isNew() 금지\n@ArchTest\nstatic final ArchRule longIdVoForNewGuideline =\n    classes()\n        .that().resideInAPackage(\"..domain..id..\")\n        .and().haveSimpleNameEndingWith(\"Id\")\n        .should().beRecords()\n        .because(\"Long ID VO는 forNew(), isNew() 메서드가 필수입니다 (코드 리뷰로 검증)\");','CRITICAL','2026-01-16 02:26:48','2026-01-16 02:26:48',NULL),(48,3,27,'ARCH-ID-005','ID VO Lombok 금지','ID VO에서 Lombok 어노테이션 사용을 금지합니다.','IdVoArchTest','idVosShouldNotUseLombok','@ArchTest\nstatic final ArchRule idVosShouldNotUseLombok =\n    classes()\n        .that().resideInAPackage(\"..domain..id..\")\n        .should().notBeAnnotatedWith(\"lombok.Getter\")\n        .andShould().notBeAnnotatedWith(\"lombok.Setter\")\n        .andShould().notBeAnnotatedWith(\"lombok.Data\")\n        .andShould().notBeAnnotatedWith(\"lombok.Value\")\n        .because(\"ID VO에서 Lombok 어노테이션 사용을 금지합니다\");','BLOCKER','2026-01-16 02:26:48','2026-01-16 02:26:48',NULL),(49,3,28,'ARCH-VO-001','VO는 Record 타입 필수 (Enum 제외)','Value Object는 Java Record 타입으로 정의해야 합니다. Enum은 예외.','VoArchTest','vosShouldBeRecordsOrEnums','@ArchTest\nstatic final ArchRule vosShouldBeRecordsOrEnums =\n    classes()\n        .that().resideInAPackage(\"..domain..vo..\")\n        .should().beRecords()\n        .orShould().beEnums()\n        .because(\"VO는 Record 또는 Enum 타입이어야 합니다\");','BLOCKER','2026-01-16 02:26:48','2026-01-16 02:26:48',NULL),(50,3,28,'ARCH-VO-002','VO of() 메서드 필수','Record VO는 static of() 팩토리 메서드가 필수입니다.','VoArchTest','vosShouldHaveOfMethod','@ArchTest\nstatic final ArchRule vosShouldHaveOfMethod =\n    classes()\n        .that().resideInAPackage(\"..domain..vo..\")\n        .and().areRecords()\n        .should(new ArchCondition<JavaClass>(\"have static of method\") {\n            @Override\n            public void check(JavaClass javaClass, ConditionEvents events) {\n                boolean hasOf = javaClass.getMethods().stream()\n                    .anyMatch(m -> m.getName().equals(\"of\") && m.getModifiers().contains(JavaModifier.STATIC));\n                if (!hasOf) {\n                    events.add(SimpleConditionEvent.violated(javaClass,\n                        String.format(\"VO %s must have static of() method\", javaClass.getSimpleName())));\n                }\n            }\n        })\n        .because(\"Record VO는 static of() 팩토리 메서드가 필수입니다\");','BLOCKER','2026-01-16 02:26:48','2026-01-16 02:26:48',NULL),(51,3,28,'ARCH-VO-003','Enum VO displayName() 메서드 필수','Enum VO는 displayName() 메서드가 필수입니다.','VoArchTest','enumVosShouldHaveDisplayName','@ArchTest\nstatic final ArchRule enumVosShouldHaveDisplayName =\n    classes()\n        .that().resideInAPackage(\"..domain..vo..\")\n        .and().areEnums()\n        .should(new ArchCondition<JavaClass>(\"have displayName method\") {\n            @Override\n            public void check(JavaClass javaClass, ConditionEvents events) {\n                boolean hasDisplayName = javaClass.getMethods().stream()\n                    .anyMatch(m -> m.getName().equals(\"displayName\"));\n                if (!hasDisplayName) {\n                    events.add(SimpleConditionEvent.violated(javaClass,\n                        String.format(\"Enum VO %s must have displayName() method\", javaClass.getSimpleName())));\n                }\n            }\n        })\n        .because(\"Enum VO는 displayName() 메서드가 필수입니다\");','CRITICAL','2026-01-16 02:26:48','2026-01-16 02:26:48',NULL),(52,3,28,'ARCH-VO-004','VO Lombok 금지','VO에서 Lombok 어노테이션 사용을 금지합니다.','VoArchTest','vosShouldNotUseLombok','@ArchTest\nstatic final ArchRule vosShouldNotUseLombok =\n    classes()\n        .that().resideInAPackage(\"..domain..vo..\")\n        .should().notBeAnnotatedWith(\"lombok.Getter\")\n        .andShould().notBeAnnotatedWith(\"lombok.Setter\")\n        .andShould().notBeAnnotatedWith(\"lombok.Data\")\n        .andShould().notBeAnnotatedWith(\"lombok.Value\")\n        .andShould().notBeAnnotatedWith(\"lombok.Builder\")\n        .because(\"VO에서 Lombok 어노테이션 사용을 금지합니다\");','BLOCKER','2026-01-16 02:26:48','2026-01-16 02:26:48',NULL),(53,3,28,'ARCH-VO-005','VO JPA 금지','VO에서 JPA 어노테이션 사용을 금지합니다.','VoArchTest','vosShouldNotUseJpa','@ArchTest\nstatic final ArchRule vosShouldNotUseJpa =\n    classes()\n        .that().resideInAPackage(\"..domain..vo..\")\n        .should().notBeAnnotatedWith(\"jakarta.persistence.Embeddable\")\n        .andShould().notBeAnnotatedWith(\"jakarta.persistence.Embedded\")\n        .because(\"VO에서 JPA 어노테이션 사용을 금지합니다\");','BLOCKER','2026-01-16 02:26:48','2026-01-16 02:26:48',NULL),(54,3,29,'ARCH-EVT-001','Event는 Record 타입 필수','Domain Event는 Java Record 타입으로 정의해야 합니다.','EventArchTest','eventsShouldBeRecords','@ArchTest\nstatic final ArchRule eventsShouldBeRecords =\n    classes()\n        .that().resideInAPackage(\"..domain..event..\")\n        .and().haveSimpleNameEndingWith(\"Event\")\n        .and().areNotInterfaces()\n        .should().beRecords()\n        .because(\"Domain Event는 Record 타입이어야 합니다\");','BLOCKER','2026-01-16 02:26:48','2026-01-16 02:26:48',NULL),(55,3,29,'ARCH-EVT-002','Event 과거형 네이밍 (*edEvent)','Domain Event는 과거형 네이밍이 필수입니다. 예: OrderCreatedEvent, OrderCancelledEvent.','EventArchTest','eventsShouldUsePastTenseNaming','@ArchTest\nstatic final ArchRule eventsShouldUsePastTenseNaming =\n    classes()\n        .that().resideInAPackage(\"..domain..event..\")\n        .and().haveSimpleNameEndingWith(\"Event\")\n        .and().areNotInterfaces()\n        .should(new ArchCondition<JavaClass>(\"use past tense naming\") {\n            @Override\n            public void check(JavaClass javaClass, ConditionEvents events) {\n                String name = javaClass.getSimpleName();\n                // Remove \"Event\" suffix and check if it ends with \"ed\" or common past tense patterns\n                String eventName = name.substring(0, name.length() - 5);\n                if (!eventName.matches(\".*[eE]d$\") && !eventName.matches(\".*(Created|Updated|Deleted|Cancelled|Confirmed|Paid|Shipped|Completed|Failed|Expired|Activated|Deactivated|Changed|Added|Removed)$\")) {\n                    events.add(SimpleConditionEvent.violated(javaClass,\n                        String.format(\"Event %s should use past tense naming (e.g., OrderCreatedEvent)\", name)));\n                }\n            }\n        })\n        .because(\"Domain Event는 과거형 네이밍을 사용해야 합니다 (이미 발생한 사실)\");','BLOCKER','2026-01-16 02:26:48','2026-01-16 02:26:48',NULL),(56,3,29,'ARCH-EVT-003','Event DomainEvent 인터페이스 구현','Domain Event는 DomainEvent 인터페이스를 구현해야 합니다.','EventArchTest','eventsShouldImplementDomainEvent','@ArchTest\nstatic final ArchRule eventsShouldImplementDomainEvent =\n    classes()\n        .that().resideInAPackage(\"..domain..event..\")\n        .and().haveSimpleNameEndingWith(\"Event\")\n        .and().areNotInterfaces()\n        .should().implement(resideInAPackage(\"..domain..\").and(haveSimpleName(\"DomainEvent\")))\n        .because(\"Domain Event는 DomainEvent 인터페이스를 구현해야 합니다\");','BLOCKER','2026-01-16 02:26:48','2026-01-16 02:26:48',NULL),(57,3,29,'ARCH-EVT-004','Event from() 메서드 필수','Domain Event는 static from(Aggregate, Instant) 팩토리 메서드가 필수입니다.','EventArchTest','eventsShouldHaveFromMethod','@ArchTest\nstatic final ArchRule eventsShouldHaveFromMethod =\n    classes()\n        .that().resideInAPackage(\"..domain..event..\")\n        .and().haveSimpleNameEndingWith(\"Event\")\n        .and().areNotInterfaces()\n        .should(new ArchCondition<JavaClass>(\"have static from method\") {\n            @Override\n            public void check(JavaClass javaClass, ConditionEvents events) {\n                boolean hasFrom = javaClass.getMethods().stream()\n                    .anyMatch(m -> m.getName().equals(\"from\") && m.getModifiers().contains(JavaModifier.STATIC));\n                if (!hasFrom) {\n                    events.add(SimpleConditionEvent.violated(javaClass,\n                        String.format(\"Event %s must have static from() method\", javaClass.getSimpleName())));\n                }\n            }\n        })\n        .because(\"Domain Event는 static from(Aggregate, Instant) 팩토리 메서드가 필수입니다\");','BLOCKER','2026-01-16 02:26:48','2026-01-16 02:26:48',NULL),(58,3,29,'ARCH-EVT-005','Event Lombok 금지','Domain Event에서 Lombok 어노테이션 사용을 금지합니다.','EventArchTest','eventsShouldNotUseLombok','@ArchTest\nstatic final ArchRule eventsShouldNotUseLombok =\n    classes()\n        .that().resideInAPackage(\"..domain..event..\")\n        .should().notBeAnnotatedWith(\"lombok.Getter\")\n        .andShould().notBeAnnotatedWith(\"lombok.Setter\")\n        .andShould().notBeAnnotatedWith(\"lombok.Data\")\n        .andShould().notBeAnnotatedWith(\"lombok.Builder\")\n        .because(\"Domain Event에서 Lombok 어노테이션 사용을 금지합니다\");','BLOCKER','2026-01-16 02:26:48','2026-01-16 02:26:48',NULL),(59,3,29,'ARCH-EVT-006','Event Spring 금지','Domain Event에서 Spring 어노테이션 사용을 금지합니다.','EventArchTest','eventsShouldNotUseSpring','@ArchTest\nstatic final ArchRule eventsShouldNotUseSpring =\n    classes()\n        .that().resideInAPackage(\"..domain..event..\")\n        .should().notBeAnnotatedWith(\"org.springframework.stereotype.Component\")\n        .andShould().notBeAnnotatedWith(\"org.springframework.context.event.EventListener\")\n        .because(\"Domain Event에서 Spring 어노테이션 사용을 금지합니다\");','BLOCKER','2026-01-16 02:26:49','2026-01-16 02:26:49',NULL),(60,3,30,'ARCH-EXC-001','Exception DomainException 상속','Concrete Exception은 DomainException을 상속해야 합니다.','ExceptionArchTest','exceptionsShouldExtendDomainException','@ArchTest\nstatic final ArchRule exceptionsShouldExtendDomainException =\n    classes()\n        .that().resideInAPackage(\"..domain..exception..\")\n        .and().haveSimpleNameEndingWith(\"Exception\")\n        .and().haveSimpleNameNotContaining(\"DomainException\")\n        .should().beAssignableTo(\"com.ryuqq.domain.common.exception.DomainException\")\n        .because(\"Concrete Exception은 DomainException을 상속해야 합니다\");','BLOCKER','2026-01-16 02:26:49','2026-01-16 02:26:49',NULL),(61,3,30,'ARCH-EXC-002','ErrorCode 인터페이스 구현','ErrorCode Enum은 ErrorCode 인터페이스를 구현해야 합니다.','ExceptionArchTest','errorCodesShouldImplementErrorCodeInterface','@ArchTest\nstatic final ArchRule errorCodesShouldImplementErrorCodeInterface =\n    classes()\n        .that().resideInAPackage(\"..domain..exception..\")\n        .and().areEnums()\n        .and().haveSimpleNameEndingWith(\"ErrorCode\")\n        .should().implement(resideInAPackage(\"..domain..\").and(haveSimpleName(\"ErrorCode\")))\n        .because(\"ErrorCode Enum은 ErrorCode 인터페이스를 구현해야 합니다\");','BLOCKER','2026-01-16 02:26:49','2026-01-16 02:26:49',NULL),(62,3,30,'ARCH-EXC-003','ErrorCode getCode() 메서드 필수','ErrorCode Enum은 getCode() 메서드가 필수입니다.','ExceptionArchTest','errorCodesShouldHaveGetCodeMethod','@ArchTest\nstatic final ArchRule errorCodesShouldHaveGetCodeMethod =\n    classes()\n        .that().resideInAPackage(\"..domain..exception..\")\n        .and().areEnums()\n        .and().haveSimpleNameEndingWith(\"ErrorCode\")\n        .should(new ArchCondition<JavaClass>(\"have getCode method\") {\n            @Override\n            public void check(JavaClass javaClass, ConditionEvents events) {\n                boolean hasGetCode = javaClass.getMethods().stream()\n                    .anyMatch(m -> m.getName().equals(\"getCode\"));\n                if (!hasGetCode) {\n                    events.add(SimpleConditionEvent.violated(javaClass,\n                        String.format(\"ErrorCode %s must have getCode() method\", javaClass.getSimpleName())));\n                }\n            }\n        })\n        .because(\"ErrorCode Enum은 getCode() 메서드가 필수입니다\");','BLOCKER','2026-01-16 02:26:49','2026-01-16 02:26:49',NULL),(63,3,30,'ARCH-EXC-004','ErrorCode getHttpStatus() int 반환','ErrorCode Enum은 int getHttpStatus() 메서드가 필수입니다. Spring HttpStatus 사용 금지.','ExceptionArchTest','errorCodesShouldHaveIntHttpStatus','@ArchTest\nstatic final ArchRule errorCodesShouldHaveIntHttpStatus =\n    classes()\n        .that().resideInAPackage(\"..domain..exception..\")\n        .and().areEnums()\n        .and().haveSimpleNameEndingWith(\"ErrorCode\")\n        .should(new ArchCondition<JavaClass>(\"have int getHttpStatus method\") {\n            @Override\n            public void check(JavaClass javaClass, ConditionEvents events) {\n                boolean hasGetHttpStatus = javaClass.getMethods().stream()\n                    .anyMatch(m -> m.getName().equals(\"getHttpStatus\") &&\n                        m.getRawReturnType().getName().equals(\"int\"));\n                if (!hasGetHttpStatus) {\n                    events.add(SimpleConditionEvent.violated(javaClass,\n                        String.format(\"ErrorCode %s must have int getHttpStatus() method (not Spring HttpStatus)\",\n                            javaClass.getSimpleName())));\n                }\n            }\n        })\n        .because(\"ErrorCode Enum은 int getHttpStatus() 메서드가 필수입니다 (Spring HttpStatus 금지)\");','BLOCKER','2026-01-16 02:26:49','2026-01-16 02:26:49',NULL),(64,3,30,'ARCH-EXC-005','Exception Lombok 금지','Exception에서 Lombok 어노테이션 사용을 금지합니다.','ExceptionArchTest','exceptionsShouldNotUseLombok','@ArchTest\nstatic final ArchRule exceptionsShouldNotUseLombok =\n    classes()\n        .that().resideInAPackage(\"..domain..exception..\")\n        .should().notBeAnnotatedWith(\"lombok.Getter\")\n        .andShould().notBeAnnotatedWith(\"lombok.Setter\")\n        .andShould().notBeAnnotatedWith(\"lombok.Data\")\n        .because(\"Exception에서 Lombok 어노테이션 사용을 금지합니다\");','BLOCKER','2026-01-16 02:26:49','2026-01-16 02:26:49',NULL),(65,3,30,'ARCH-EXC-006','Exception Spring HttpStatus 금지','Exception에서 org.springframework.http.HttpStatus 사용을 금지합니다.','ExceptionArchTest','exceptionsShouldNotUseSpringHttpStatus','@ArchTest\nstatic final ArchRule exceptionsShouldNotUseSpringHttpStatus =\n    noClasses()\n        .that().resideInAPackage(\"..domain..exception..\")\n        .should().dependOnClassesThat()\n        .haveFullyQualifiedName(\"org.springframework.http.HttpStatus\")\n        .because(\"Exception에서 Spring HttpStatus 사용을 금지합니다. int 타입을 사용하세요\");','BLOCKER','2026-01-16 02:26:49','2026-01-16 02:26:49',NULL),(66,3,31,'ARCH-CRI-001','Criteria Record 타입 필수','Criteria는 Java Record 타입으로 정의해야 합니다.','CriteriaArchTest','criteriasShouldBeRecords','@ArchTest\nstatic final ArchRule criteriasShouldBeRecords =\n    classes()\n        .that().resideInAPackage(\"..domain..query..\")\n        .and().haveSimpleNameEndingWith(\"Criteria\")\n        .should().beRecords()\n        .because(\"Criteria는 Record 타입이어야 합니다\");','BLOCKER','2026-01-16 02:26:49','2026-01-16 02:26:49',NULL),(67,3,31,'ARCH-CRI-002','Criteria *Criteria 네이밍','Criteria는 *Criteria 또는 *SearchCriteria 네이밍 규칙을 따라야 합니다.','CriteriaArchTest','criteriasShouldFollowNamingConvention','@ArchTest\nstatic final ArchRule criteriasShouldFollowNamingConvention =\n    classes()\n        .that().resideInAPackage(\"..domain..query..\")\n        .should().haveSimpleNameEndingWith(\"Criteria\")\n        .because(\"Criteria는 *Criteria 네이밍 규칙을 따라야 합니다\");','BLOCKER','2026-01-16 02:26:49','2026-01-16 02:26:49',NULL),(68,3,31,'ARCH-CRI-003','Criteria of() 메서드 필수','Criteria는 static of() 팩토리 메서드가 필수입니다.','CriteriaArchTest','criteriasShouldHaveOfMethod','@ArchTest\nstatic final ArchRule criteriasShouldHaveOfMethod =\n    classes()\n        .that().resideInAPackage(\"..domain..query..\")\n        .and().haveSimpleNameEndingWith(\"Criteria\")\n        .should(new ArchCondition<JavaClass>(\"have static of method\") {\n            @Override\n            public void check(JavaClass javaClass, ConditionEvents events) {\n                boolean hasOf = javaClass.getMethods().stream()\n                    .anyMatch(m -> m.getName().equals(\"of\") && m.getModifiers().contains(JavaModifier.STATIC));\n                if (!hasOf) {\n                    events.add(SimpleConditionEvent.violated(javaClass,\n                        String.format(\"Criteria %s must have static of() method\", javaClass.getSimpleName())));\n                }\n            }\n        })\n        .because(\"Criteria는 static of() 팩토리 메서드가 필수입니다\");','BLOCKER','2026-01-16 02:26:49','2026-01-16 02:26:49',NULL),(69,3,31,'ARCH-CRI-004','Criteria Lombok 금지','Criteria에서 Lombok 어노테이션 사용을 금지합니다.','CriteriaArchTest','criteriasShouldNotUseLombok','@ArchTest\nstatic final ArchRule criteriasShouldNotUseLombok =\n    classes()\n        .that().resideInAPackage(\"..domain..query..\")\n        .should().notBeAnnotatedWith(\"lombok.Getter\")\n        .andShould().notBeAnnotatedWith(\"lombok.Setter\")\n        .andShould().notBeAnnotatedWith(\"lombok.Data\")\n        .andShould().notBeAnnotatedWith(\"lombok.Builder\")\n        .because(\"Criteria에서 Lombok 어노테이션 사용을 금지합니다\");','BLOCKER','2026-01-16 02:26:49','2026-01-16 02:26:49',NULL),(70,3,31,'ARCH-CRI-005','Criteria JPA 금지','Criteria에서 JPA 어노테이션 사용을 금지합니다.','CriteriaArchTest','criteriasShouldNotUseJpa','@ArchTest\nstatic final ArchRule criteriasShouldNotUseJpa =\n    classes()\n        .that().resideInAPackage(\"..domain..query..\")\n        .should().notBeAnnotatedWith(\"jakarta.persistence.Entity\")\n        .andShould().notBeAnnotatedWith(\"jakarta.persistence.Embeddable\")\n        .because(\"Criteria에서 JPA 어노테이션 사용을 금지합니다\");','BLOCKER','2026-01-16 02:26:49','2026-01-16 02:26:49',NULL),(71,3,31,'ARCH-CRI-006','Criteria 패키지 위치','Criteria는 domain.[bc].query 패키지에 위치해야 합니다.','CriteriaArchTest','criteriasShouldResideInCorrectPackage','@ArchTest\nstatic final ArchRule criteriasShouldResideInCorrectPackage =\n    classes()\n        .that().haveSimpleNameEndingWith(\"Criteria\")\n        .and().resideInAPackage(\"..domain..\")\n        .should().resideInAPackage(\"..query..\")\n        .because(\"Criteria는 domain.[bc].query 패키지에 위치해야 합니다\");','BLOCKER','2026-01-16 02:26:49','2026-01-16 02:26:49',NULL),(72,4,NULL,'ARCH-APP-001','Application Layer는 Domain Layer만 의존','Application Layer는 Domain Layer만 의존하고, Adapter-In/Adapter-Out에 의존하지 않습니다.',NULL,NULL,'@ArchTest\nstatic final ArchRule application_should_only_depend_on_domain =\n    classes()\n        .that().resideInAPackage(\"..application..\")\n        .should().onlyDependOnClassesThat()\n        .resideInAnyPackage(\n            \"..application..\",\n            \"..domain..\",\n            \"java..\",\n            \"jakarta..\",\n            \"org.springframework.stereotype..\",\n            \"org.springframework.transaction..\"\n        )\n        .because(\"Application Layer는 Domain Layer만 의존해야 합니다\");','BLOCKER','2026-01-16 06:51:13','2026-01-16 06:51:13',NULL),(73,4,NULL,'ARCH-APP-002','Application Layer는 Adapter-Out 의존 금지','Application Layer는 persistence, client 등 Adapter-Out 패키지에 의존하면 안 됩니다.',NULL,NULL,'@ArchTest\nstatic final ArchRule application_should_not_depend_on_adapter_out =\n    noClasses()\n        .that().resideInAPackage(\"..application..\")\n        .should().dependOnClassesThat()\n        .resideInAnyPackage(\n            \"..adapter.out..\",\n            \"..persistence..\",\n            \"..infrastructure..\"\n        )\n        .because(\"Application Layer는 Adapter-Out에 의존하면 안 됩니다\");','BLOCKER','2026-01-16 06:51:13','2026-01-16 06:51:13',NULL),(74,4,NULL,'ARCH-SVC-001','Service 클래스는 @Transactional 금지','Service 클래스와 메서드에 @Transactional 어노테이션을 사용하면 안 됩니다.',NULL,NULL,'@ArchTest\nstatic final ArchRule service_should_not_have_transactional =\n    noClasses()\n        .that().resideInAPackage(\"..service..\")\n        .and().haveSimpleNameEndingWith(\"Service\")\n        .should().beAnnotatedWith(Transactional.class)\n        .because(\"Service는 @Transactional을 사용하지 않고 Manager/Facade에 위임합니다\");\n\n@ArchTest\nstatic final ArchRule service_methods_should_not_have_transactional =\n    noMethods()\n        .that().areDeclaredInClassesThat()\n        .resideInAPackage(\"..service..\")\n        .and().areDeclaredInClassesThat()\n        .haveSimpleNameEndingWith(\"Service\")\n        .should().beAnnotatedWith(Transactional.class)\n        .because(\"Service 메서드에 @Transactional을 사용하면 안 됩니다\");','BLOCKER','2026-01-16 06:51:13','2026-01-16 06:51:13',NULL),(75,4,NULL,'ARCH-SVC-002','Service는 Port 직접 의존 금지','Service는 Port 인터페이스를 직접 주입받지 않고 Manager를 통해 사용합니다.',NULL,NULL,'@ArchTest\nstatic final ArchRule service_should_not_depend_on_ports_directly =\n    noClasses()\n        .that().resideInAPackage(\"..service..\")\n        .and().haveSimpleNameEndingWith(\"Service\")\n        .should().dependOnClassesThat()\n        .haveSimpleNameEndingWith(\"Port\")\n        .because(\"Service는 Port를 직접 의존하지 않고 Manager를 통해 사용합니다\");','BLOCKER','2026-01-16 06:51:13','2026-01-16 06:51:13',NULL),(76,4,NULL,'ARCH-SVC-003','Service는 @Component 어노테이션 사용','Service 클래스는 @Service가 아닌 @Component를 사용합니다.',NULL,NULL,'@ArchTest\nstatic final ArchRule service_should_use_component_annotation =\n    classes()\n        .that().resideInAPackage(\"..service..\")\n        .and().haveSimpleNameEndingWith(\"Service\")\n        .and().areNotInterfaces()\n        .should().beAnnotatedWith(Component.class)\n        .andShould().notBeAnnotatedWith(Service.class)\n        .because(\"Service는 @Component를 사용하고 @Service는 금지입니다\");','MAJOR','2026-01-16 06:51:13','2026-01-16 06:51:13',NULL),(77,4,NULL,'ARCH-MGR-001','PersistenceManager는 CommandPort만 의존','PersistenceManager는 쓰기용 CommandPort만 의존해야 합니다.',NULL,NULL,'@ArchTest\nstatic final ArchRule transaction_manager_should_only_depend_on_command_port =\n    classes()\n        .that().haveSimpleNameEndingWith(\"PersistenceManager\")\n        .should().dependOnClassesThat()\n        .haveSimpleNameEndingWith(\"CommandPort\")\n        .orShould().dependOnClassesThat()\n        .haveSimpleNameEndingWith(\"Mapper\")\n        .because(\"PersistenceManager는 CommandPort만 의존해야 합니다\");','MAJOR','2026-01-16 06:51:13','2026-01-16 06:51:13',NULL),(78,4,NULL,'ARCH-MGR-002','ReadManager는 QueryPort만 의존','ReadManager는 읽기용 QueryPort만 의존해야 합니다.',NULL,NULL,'@ArchTest\nstatic final ArchRule read_manager_should_only_depend_on_query_port =\n    classes()\n        .that().haveSimpleNameEndingWith(\"ReadManager\")\n        .should().dependOnClassesThat()\n        .haveSimpleNameEndingWith(\"QueryPort\")\n        .orShould().dependOnClassesThat()\n        .haveSimpleNameEndingWith(\"Mapper\")\n        .because(\"ReadManager는 QueryPort만 의존해야 합니다\");','MAJOR','2026-01-16 06:51:13','2026-01-16 06:51:13',NULL),(79,4,NULL,'ARCH-MGR-003','Manager 퍼블릭 메서드에 @Transactional 필수','Manager의 public 메서드는 반드시 @Transactional 어노테이션이 있어야 합니다.',NULL,NULL,'@ArchTest\nstatic final ArchRule manager_public_methods_should_have_transactional =\n    methods()\n        .that().areDeclaredInClassesThat()\n        .haveSimpleNameEndingWith(\"Manager\")\n        .and().arePublic()\n        .and().areNotConstructors()\n        .should().beAnnotatedWith(Transactional.class)\n        .because(\"Manager의 public 메서드는 @Transactional이 필수입니다\");','BLOCKER','2026-01-16 06:51:13','2026-01-16 06:51:13',NULL),(80,4,NULL,'ARCH-FAC-001','Facade는 Manager만 의존 (Port 직접 의존 금지)','Facade는 PersistenceManager, ReadManager만 의존하고 Port를 직접 주입받지 않습니다.',NULL,NULL,'@ArchTest\nstatic final ArchRule facade_should_not_depend_on_ports =\n    noClasses()\n        .that().haveSimpleNameEndingWith(\"Facade\")\n        .should().dependOnClassesThat()\n        .haveSimpleNameEndingWith(\"Port\")\n        .because(\"Facade는 Port를 직접 의존하지 않고 Manager를 통해 사용합니다\");','BLOCKER','2026-01-16 06:51:13','2026-01-16 06:51:13',NULL),(81,4,NULL,'ARCH-FAC-002','CommandFacade는 ClientManager 의존 금지','CommandFacade는 RDB PersistenceManager만 의존하고 ClientManager를 의존하면 안 됩니다.',NULL,NULL,'@ArchTest\nstatic final ArchRule command_facade_should_not_depend_on_client_manager =\n    noClasses()\n        .that().haveSimpleNameEndingWith(\"CommandFacade\")\n        .should().dependOnClassesThat()\n        .haveSimpleNameEndingWith(\"ClientManager\")\n        .because(\"CommandFacade는 @Transactional 내에서 외부 호출 방지를 위해 ClientManager 의존 금지\");','BLOCKER','2026-01-16 06:51:13','2026-01-16 06:51:13',NULL),(82,4,NULL,'ARCH-DTO-001','Command DTO는 record 타입 필수','Command DTO는 불변성 보장을 위해 Java record로 정의해야 합니다.',NULL,NULL,'@ArchTest\nstatic final ArchRule command_dto_should_be_record =\n    classes()\n        .that().resideInAPackage(\"..dto.command..\")\n        .and().haveSimpleNameEndingWith(\"Command\")\n        .should().beRecords()\n        .because(\"Command DTO는 불변성을 위해 record 타입이어야 합니다\");','BLOCKER','2026-01-16 06:51:14','2026-01-16 06:51:14',NULL),(83,4,NULL,'ARCH-DTO-002','Query DTO는 record 타입 필수','Query DTO는 불변성 보장을 위해 Java record로 정의해야 합니다.',NULL,NULL,'@ArchTest\nstatic final ArchRule query_dto_should_be_record =\n    classes()\n        .that().resideInAPackage(\"..dto.query..\")\n        .and().haveSimpleNameEndingWith(\"Query\")\n        .should().beRecords()\n        .because(\"Query DTO는 불변성을 위해 record 타입이어야 합니다\");','BLOCKER','2026-01-16 06:51:14','2026-01-16 06:51:14',NULL),(84,4,NULL,'ARCH-DTO-003','Response DTO는 record 타입 필수','Response DTO는 불변성 보장을 위해 Java record로 정의해야 합니다.',NULL,NULL,'@ArchTest\nstatic final ArchRule response_dto_should_be_record =\n    classes()\n        .that().resideInAPackage(\"..dto.response..\")\n        .and().haveSimpleNameEndingWith(\"Response\")\n        .should().beRecords()\n        .because(\"Response DTO는 불변성을 위해 record 타입이어야 합니다\");','BLOCKER','2026-01-16 06:51:14','2026-01-16 06:51:14',NULL),(85,4,NULL,'ARCH-DTO-004','DTO는 Domain 클래스 직접 포함 금지','DTO는 Domain 객체를 필드로 포함하지 않고, 필요한 값만 추출하여 보관합니다.',NULL,NULL,'@ArchTest\nstatic final ArchRule dto_should_not_contain_domain_objects =\n    noClasses()\n        .that().resideInAPackage(\"..dto..\")\n        .should().dependOnClassesThat()\n        .resideInAPackage(\"..domain..aggregate..\")\n        .because(\"DTO는 Domain 객체를 직접 포함하지 않습니다\");','MAJOR','2026-01-16 06:51:14','2026-01-16 06:51:14',NULL),(86,4,NULL,'ARCH-EVT-001','EventListener는 @TransactionalEventListener 사용','EventListener의 이벤트 핸들러 메서드는 @TransactionalEventListener를 사용해야 합니다.',NULL,NULL,'@ArchTest\nstatic final ArchRule event_listener_should_use_transactional_event_listener =\n    methods()\n        .that().areDeclaredInClassesThat()\n        .haveSimpleNameEndingWith(\"EventListener\")\n        .and().arePublic()\n        .should().beAnnotatedWith(TransactionalEventListener.class)\n        .because(\"EventListener는 트랜잭션 커밋 후 처리를 위해 @TransactionalEventListener 사용\");','BLOCKER','2026-01-16 06:51:14','2026-01-16 06:51:14',NULL),(87,4,NULL,'ARCH-EVT-002','EventListener는 PersistenceManager 의존 금지','EventListener는 외부 호출만 담당하고 DB 조작을 위한 Manager를 의존하면 안 됩니다.',NULL,NULL,'@ArchTest\nstatic final ArchRule event_listener_should_not_depend_on_transaction_manager =\n    noClasses()\n        .that().haveSimpleNameEndingWith(\"EventListener\")\n        .should().dependOnClassesThat()\n        .haveSimpleNameEndingWith(\"PersistenceManager\")\n        .because(\"EventListener는 외부 호출만 담당하고 DB 조작을 하지 않습니다\");','BLOCKER','2026-01-16 06:51:14','2026-01-16 06:51:14',NULL),(88,4,NULL,'ARCH-EVT-003','EventListener는 ClientManager만 의존','EventListener는 외부 시스템 호출을 위한 ClientManager만 의존해야 합니다.',NULL,NULL,'@ArchTest\nstatic final ArchRule event_listener_should_only_depend_on_client_manager =\n    classes()\n        .that().haveSimpleNameEndingWith(\"EventListener\")\n        .should().onlyDependOnClassesThat()\n        .haveSimpleNameEndingWith(\"ClientManager\")\n        .orShould().dependOnClassesThat()\n        .resideInAnyPackage(\"java..\", \"org.springframework..\")\n        .because(\"EventListener는 외부 호출을 위한 ClientManager만 의존합니다\");','MAJOR','2026-01-16 06:51:14','2026-01-16 06:51:14',NULL),(89,4,NULL,'ARCH-SCHS-001','Scheduler Service에서 @Scheduled 금지','Application Layer의 Scheduler Service는 @Scheduled 어노테이션을 사용하지 않습니다.',NULL,NULL,'@ArchTest\nstatic final ArchRule scheduler_service_should_not_have_scheduled =\n    noMethods()\n        .that().areDeclaredInClassesThat()\n        .resideInAPackage(\"..service.scheduler..\")\n        .should().beAnnotatedWith(Scheduled.class)\n        .because(\"@Scheduled는 adapter-in/scheduler의 Thin Scheduler에서만 사용\");','BLOCKER','2026-01-16 06:51:14','2026-01-16 06:51:14',NULL),(90,4,NULL,'ARCH-SCHS-002','Scheduler Service는 Scheduler UseCase 인터페이스 구현','Scheduler Service는 port/in/scheduler의 UseCase 인터페이스를 구현해야 합니다.',NULL,NULL,'@ArchTest\nstatic final ArchRule scheduler_service_should_implement_usecase =\n    classes()\n        .that().resideInAPackage(\"..service.scheduler..\")\n        .and().haveSimpleNameEndingWith(\"Service\")\n        .should().implement(\n            JavaClass.Predicates.simpleNameEndingWith(\"UseCase\")\n        )\n        .because(\"Scheduler Service는 port/in/scheduler의 UseCase를 구현합니다\");','MAJOR','2026-01-16 06:51:14','2026-01-16 06:51:14',NULL),(91,4,NULL,'ARCH-PORT-001','Port는 인터페이스 타입이어야 함','CommandPort, QueryPort, ClientPort는 모두 인터페이스여야 합니다.',NULL,NULL,'@ArchTest\nstatic final ArchRule ports_should_be_interfaces =\n    classes()\n        .that().resideInAPackage(\"..port.out..\")\n        .and().haveSimpleNameEndingWith(\"Port\")\n        .should().beInterfaces()\n        .because(\"Port는 인터페이스로 정의해야 합니다\");','BLOCKER','2026-01-16 06:51:14','2026-01-16 06:51:14',NULL),(92,4,NULL,'ARCH-PORT-002','UseCase는 인터페이스 타입이어야 함','port/in의 UseCase는 모두 인터페이스여야 합니다.',NULL,NULL,'@ArchTest\nstatic final ArchRule usecases_should_be_interfaces =\n    classes()\n        .that().resideInAPackage(\"..port.in..\")\n        .and().haveSimpleNameEndingWith(\"UseCase\")\n        .should().beInterfaces()\n        .because(\"UseCase는 인터페이스로 정의해야 합니다\");','BLOCKER','2026-01-16 06:51:14','2026-01-16 06:51:14',NULL),(93,4,NULL,'ARCH-NAME-001','Service 네이밍: {Action}{Domain}Service','Service 클래스는 {Action}{Domain}Service 형식으로 네이밍합니다.',NULL,NULL,'@ArchTest\nstatic final ArchRule service_naming_convention =\n    classes()\n        .that().resideInAPackage(\"..service..\")\n        .and().areNotInterfaces()\n        .should().haveSimpleNameEndingWith(\"Service\")\n        .because(\"Service 클래스는 Service 접미사를 사용합니다\");','MINOR','2026-01-16 06:51:14','2026-01-16 06:51:14',NULL),(94,4,NULL,'ARCH-NAME-002','Manager 네이밍: {Domain}PersistenceManager / {Domain}ReadManager','Manager 클래스는 역할에 따라 PersistenceManager 또는 ReadManager 접미사를 사용합니다.',NULL,NULL,'@ArchTest\nstatic final ArchRule manager_naming_convention =\n    classes()\n        .that().resideInAPackage(\"..manager..\")\n        .and().areNotInterfaces()\n        .should().haveSimpleNameMatching(\".*(?:PersistenceManager|ReadManager|ClientManager)\")\n        .because(\"Manager 클래스는 역할에 맞는 접미사를 사용합니다\");','MAJOR','2026-01-16 06:51:14','2026-01-16 06:51:14',NULL),(95,5,NULL,'ARCH-PERS-LAYER-001','Persistence는 Application Port만 의존','adapter.out.persistence 패키지는 application.port.out 패키지만 의존할 수 있습니다. Port-In, UseCase 직접 의존을 금지합니다.','PersistenceLayerArchTest','persistenceShouldOnlyDependOnApplicationPort','@ArchTest\nstatic final ArchRule persistenceShouldOnlyDependOnApplicationPort =\n    classes()\n        .that().resideInAPackage(\"..adapter.out.persistence..\")\n        .should().onlyDependOnClassesThat()\n        .resideInAnyPackage(\n            \"..adapter.out.persistence..\",\n            \"..application..port.out..\",\n            \"..domain..\",\n            \"java..\",\n            \"jakarta..\",\n            \"org.springframework..\",\n            \"com.querydsl..\"\n        )\n        .because(\"Persistence Layer는 Application Port(Out)만 의존해야 합니다\");','BLOCKER','2026-01-16 06:52:06','2026-01-16 07:14:07',NULL),(96,5,NULL,'ARCH-PERS-LAYER-002','Persistence는 REST-API Layer 의존 금지','adapter.out.persistence 패키지에서 adapter.in.rest 패키지를 import할 수 없습니다.','PersistenceLayerArchTest','persistenceShouldNotDependOnRestApi','@ArchTest\nstatic final ArchRule persistenceShouldNotDependOnRestApi =\n    noClasses()\n        .that().resideInAPackage(\"..adapter.out.persistence..\")\n        .should().dependOnClassesThat()\n        .resideInAPackage(\"..adapter.in.rest..\")\n        .because(\"Persistence Layer는 REST-API Layer를 의존할 수 없습니다\");','BLOCKER','2026-01-16 06:52:06','2026-01-16 07:14:07',NULL),(97,5,NULL,'ARCH-PERS-LAYER-003','패키지 간 순환 의존성 금지','adapter.out.persistence 하위 패키지 간 순환 참조를 금지합니다. entity → mapper → adapter 단방향 의존만 허용합니다.','PersistenceLayerArchTest','noPackageCycles','@ArchTest\nstatic final ArchRule noPackageCycles =\n    slices()\n        .matching(\"..adapter.out.persistence.(*)..\")\n        .should().beFreeOfCycles()\n        .because(\"패키지 간 순환 의존성은 허용되지 않습니다\");','BLOCKER','2026-01-16 06:52:06','2026-01-16 07:14:07',NULL),(98,3,26,'ARCH-ENT-001','Entity는 BaseAuditEntity 상속 필수','JPA Entity는 BaseAuditEntity 또는 SoftDeletableEntity를 상속해야 합니다. createdAt/updatedAt 자동 관리를 보장합니다.','EntityArchTest','entitiesShouldExtendBaseAuditEntity','@ArchTest\nstatic final ArchRule entitiesShouldExtendBaseAuditEntity =\n    classes()\n        .that().areAnnotatedWith(Entity.class)\n        .and().resideInAPackage(\"..adapter.out.persistence..\")\n        .should().beAssignableTo(BaseAuditEntity.class)\n        .because(\"JPA Entity는 BaseAuditEntity를 상속해야 합니다\");','BLOCKER','2026-01-16 06:52:06','2026-01-16 06:52:06',NULL),(99,3,26,'ARCH-ENT-002','Entity 클래스에 @Entity 필수','*JpaEntity 클래스에는 @Entity 어노테이션이 필수입니다.','EntityArchTest','entitiesShouldBeAnnotatedWithEntity','@ArchTest\nstatic final ArchRule entitiesShouldBeAnnotatedWithEntity =\n    classes()\n        .that().haveSimpleNameEndingWith(\"JpaEntity\")\n        .and().resideInAPackage(\"..entity..\")\n        .should().beAnnotatedWith(Entity.class)\n        .because(\"Entity 클래스는 @Entity 어노테이션이 필수입니다\");','BLOCKER','2026-01-16 06:52:06','2026-01-16 06:52:06',NULL),(100,3,26,'ARCH-ENT-003','Entity에서 Lombok 금지','Entity 클래스에서 @Data, @Getter, @Setter, @Builder 등 Lombok 어노테이션 사용을 금지합니다.','EntityArchTest','entitiesShouldNotUseLombok','@ArchTest\nstatic final ArchRule entitiesShouldNotUseLombok =\n    noClasses()\n        .that().resideInAPackage(\"..entity..\")\n        .should().beAnnotatedWith(\"lombok.Data\")\n        .orShould().beAnnotatedWith(\"lombok.Getter\")\n        .orShould().beAnnotatedWith(\"lombok.Setter\")\n        .orShould().beAnnotatedWith(\"lombok.Builder\")\n        .orShould().beAnnotatedWith(\"lombok.AllArgsConstructor\")\n        .orShould().beAnnotatedWith(\"lombok.NoArgsConstructor\")\n        .because(\"Entity에서 Lombok 사용은 금지됩니다. Plain Java로 구현하세요\");','BLOCKER','2026-01-16 06:52:06','2026-01-16 06:52:06',NULL),(101,3,26,'ARCH-ENT-004','Entity에서 JPA 관계 어노테이션 금지 (Long FK)','Entity에서 @ManyToOne, @OneToMany, @ManyToMany, @OneToOne 사용을 금지합니다. Long FK 전략을 사용합니다.','EntityArchTest','entitiesShouldNotUseJpaRelationships','@ArchTest\nstatic final ArchRule entitiesShouldNotUseJpaRelationships =\n    noFields()\n        .that().areDeclaredInClassesThat().areAnnotatedWith(Entity.class)\n        .should().beAnnotatedWith(\"jakarta.persistence.ManyToOne\")\n        .orShould().beAnnotatedWith(\"jakarta.persistence.OneToMany\")\n        .orShould().beAnnotatedWith(\"jakarta.persistence.ManyToMany\")\n        .orShould().beAnnotatedWith(\"jakarta.persistence.OneToOne\")\n        .because(\"JPA 관계 어노테이션은 금지됩니다. Long FK 전략을 사용하세요\");','BLOCKER','2026-01-16 06:52:06','2026-01-16 06:52:06',NULL),(102,3,26,'ARCH-ENT-005','Entity 네이밍 규칙 (*JpaEntity)','Entity 클래스명은 *JpaEntity 형식이어야 합니다.','EntityArchTest','entitiesShouldFollowNamingConvention','@ArchTest\nstatic final ArchRule entitiesShouldFollowNamingConvention =\n    classes()\n        .that().areAnnotatedWith(Entity.class)\n        .and().resideInAPackage(\"..adapter.out.persistence..\")\n        .should().haveSimpleNameEndingWith(\"JpaEntity\")\n        .because(\"Entity 클래스는 *JpaEntity 네이밍을 따라야 합니다\");','MAJOR','2026-01-16 06:52:06','2026-01-16 06:52:06',NULL),(103,3,26,'ARCH-ENT-006','Entity 패키지 위치 검증','Entity는 ..entity.. 패키지에 위치해야 합니다.','EntityArchTest','entitiesShouldResideInEntityPackage','@ArchTest\nstatic final ArchRule entitiesShouldResideInEntityPackage =\n    classes()\n        .that().areAnnotatedWith(Entity.class)\n        .should().resideInAPackage(\"..entity..\")\n        .because(\"Entity는 entity 패키지에 위치해야 합니다\");','CRITICAL','2026-01-16 06:52:06','2026-01-16 06:52:06',NULL),(104,3,27,'ARCH-REPO-001','JpaRepository 상속 필수','*JpaRepository 인터페이스는 JpaRepository<Entity, Long>을 상속해야 합니다.','JpaRepositoryArchTest','jpaRepositoriesShouldExtendJpaRepository','@ArchTest\nstatic final ArchRule jpaRepositoriesShouldExtendJpaRepository =\n    classes()\n        .that().haveSimpleNameEndingWith(\"JpaRepository\")\n        .and().areInterfaces()\n        .should().beAssignableTo(JpaRepository.class)\n        .because(\"JpaRepository 인터페이스는 JpaRepository를 상속해야 합니다\");','BLOCKER','2026-01-16 06:52:06','2026-01-16 06:52:06',NULL),(105,3,27,'ARCH-REPO-002','JpaRepository Query Method 금지','JpaRepository에 findByXxx(), existsByXxx() 등 Query Method 정의를 금지합니다. QueryDslRepository를 사용하세요.','JpaRepositoryArchTest','jpaRepositoriesShouldNotHaveQueryMethods','@ArchTest\nstatic final ArchRule jpaRepositoriesShouldNotHaveQueryMethods =\n    classes()\n        .that().haveSimpleNameEndingWith(\"JpaRepository\")\n        .and().areInterfaces()\n        .should(new ArchCondition<JavaClass>(\"not have query methods\") {\n            @Override\n            public void check(JavaClass javaClass, ConditionEvents events) {\n                javaClass.getMethods().stream()\n                    .filter(method -> method.getName().startsWith(\"findBy\") ||\n                                     method.getName().startsWith(\"existsBy\") ||\n                                     method.getName().startsWith(\"countBy\") ||\n                                     method.getName().startsWith(\"deleteBy\"))\n                    .forEach(method -> events.add(SimpleConditionEvent.violated(javaClass,\n                        String.format(\"JpaRepository %s has query method: %s. Use QueryDslRepository instead.\",\n                            javaClass.getSimpleName(), method.getName()))));\n            }\n        })\n        .because(\"JpaRepository에 Query Method 정의를 금지합니다. QueryDslRepository를 사용하세요\");','BLOCKER','2026-01-16 06:52:06','2026-01-16 06:52:06',NULL),(106,3,27,'ARCH-REPO-003','JpaRepository @Query 금지','JpaRepository에서 @Query 어노테이션 사용을 금지합니다. QueryDSL을 사용하세요.','JpaRepositoryArchTest','jpaRepositoriesShouldNotUseQuery','@ArchTest\nstatic final ArchRule jpaRepositoriesShouldNotUseQuery =\n    noMethods()\n        .that().areDeclaredInClassesThat().haveSimpleNameEndingWith(\"JpaRepository\")\n        .should().beAnnotatedWith(\"org.springframework.data.jpa.repository.Query\")\n        .because(\"@Query 사용을 금지합니다. QueryDSL을 사용하세요\");','BLOCKER','2026-01-16 06:52:06','2026-01-16 06:52:06',NULL),(107,3,27,'ARCH-REPO-004','QuerydslPredicateExecutor 상속 금지','JpaRepository에서 QuerydslPredicateExecutor 상속을 금지합니다. 별도 QueryDslRepository 클래스를 사용하세요.','JpaRepositoryArchTest','jpaRepositoriesShouldNotExtendPredicateExecutor','@ArchTest\nstatic final ArchRule jpaRepositoriesShouldNotExtendPredicateExecutor =\n    noClasses()\n        .that().haveSimpleNameEndingWith(\"JpaRepository\")\n        .should().beAssignableTo(\"org.springframework.data.querydsl.QuerydslPredicateExecutor\")\n        .because(\"QuerydslPredicateExecutor 상속을 금지합니다. 별도 QueryDslRepository를 사용하세요\");','BLOCKER','2026-01-16 06:52:06','2026-01-16 06:52:06',NULL),(108,3,27,'ARCH-REPO-005','JpaRepository 네이밍 규칙','JpaRepository 인터페이스명은 *JpaRepository 형식이어야 합니다.','JpaRepositoryArchTest','jpaRepositoriesShouldFollowNamingConvention','@ArchTest\nstatic final ArchRule jpaRepositoriesShouldFollowNamingConvention =\n    classes()\n        .that().areAssignableTo(JpaRepository.class)\n        .and().areInterfaces()\n        .should().haveSimpleNameEndingWith(\"JpaRepository\")\n        .because(\"JpaRepository는 *JpaRepository 네이밍을 따라야 합니다\");','MAJOR','2026-01-16 06:52:06','2026-01-16 06:52:06',NULL),(109,3,28,'ARCH-QDR-001','QueryDslRepository에 @Repository 필수','QueryDslRepository 클래스에는 @Repository 어노테이션이 필수입니다.','QueryDslRepositoryArchTest','queryDslRepositoriesShouldBeAnnotatedWithRepository','@ArchTest\nstatic final ArchRule queryDslRepositoriesShouldBeAnnotatedWithRepository =\n    classes()\n        .that().haveSimpleNameEndingWith(\"QueryDslRepository\")\n        .and().resideInAPackage(\"..repository.querydsl..\")\n        .should().beAnnotatedWith(Repository.class)\n        .because(\"QueryDslRepository는 @Repository 어노테이션이 필수입니다\");','BLOCKER','2026-01-16 06:52:07','2026-01-16 06:52:07',NULL),(110,3,28,'ARCH-QDR-002','QueryDslRepository @Transactional 금지','QueryDslRepository 클래스 및 메서드에서 @Transactional 사용을 금지합니다. Application Layer에서 관리합니다.','QueryDslRepositoryArchTest','queryDslRepositoriesShouldNotUseTransactional','@ArchTest\nstatic final ArchRule queryDslRepositoriesShouldNotUseTransactional =\n    noClasses()\n        .that().haveSimpleNameEndingWith(\"QueryDslRepository\")\n        .should().beAnnotatedWith(\"org.springframework.transaction.annotation.Transactional\")\n        .because(\"QueryDslRepository에서 @Transactional 사용을 금지합니다\");','BLOCKER','2026-01-16 06:52:07','2026-01-16 06:52:07',NULL),(111,3,28,'ARCH-QDR-003','QueryDslRepository save/delete 금지','QueryDslRepository는 Query 전용입니다. save, delete, update 메서드를 정의할 수 없습니다.','QueryDslRepositoryArchTest','queryDslRepositoriesShouldNotHaveCommandMethods','@ArchTest\nstatic final ArchRule queryDslRepositoriesShouldNotHaveCommandMethods =\n    classes()\n        .that().haveSimpleNameEndingWith(\"QueryDslRepository\")\n        .should(new ArchCondition<JavaClass>(\"not have command methods\") {\n            @Override\n            public void check(JavaClass javaClass, ConditionEvents events) {\n                javaClass.getMethods().stream()\n                    .filter(method -> method.getName().startsWith(\"save\") ||\n                                     method.getName().startsWith(\"delete\") ||\n                                     method.getName().startsWith(\"update\") ||\n                                     method.getName().startsWith(\"insert\"))\n                    .forEach(method -> events.add(SimpleConditionEvent.violated(javaClass,\n                        String.format(\"QueryDslRepository %s has command method: %s. Use JpaRepository instead.\",\n                            javaClass.getSimpleName(), method.getName()))));\n            }\n        })\n        .because(\"QueryDslRepository는 Query 전용입니다. save/delete는 JpaRepository를 사용하세요\");','BLOCKER','2026-01-16 06:52:07','2026-01-16 06:52:07',NULL),(112,3,28,'ARCH-QDR-004','QueryDslRepository Join 금지 (가이드)','QueryDslRepository에서 .join(), .leftJoin() 등 Join 사용을 금지합니다. 연관 데이터는 Application에서 조합합니다.','QueryDslRepositoryArchTest','queryDslRepositoriesShouldNotUseJoin','// NOTE: Join 사용은 QueryDSL 메서드 체이닝이므로 ArchUnit으로 직접 검증이 어렵습니다.\n// 코드 리뷰에서 .join(), .leftJoin(), .rightJoin(), .innerJoin() 사용을 확인하세요.\n//\n// 금지 패턴:\n// queryFactory.selectFrom(entity)\n//     .join(entity.parent, parent)  // 금지!\n//     .leftJoin(entity.children, child)  // 금지!\n//\n// 이 규칙은 코드 리뷰 가이드로 활용합니다.\n@ArchTest\nstatic final ArchRule queryDslJoinGuideline =\n    classes()\n        .that().haveSimpleNameEndingWith(\"QueryDslRepository\")\n        .should().bePublic()\n        .because(\"QueryDslRepository에서 Join 사용을 금지합니다 (코드 리뷰로 검증)\");','BLOCKER','2026-01-16 06:52:07','2026-01-16 06:52:07',NULL),(113,3,28,'ARCH-QDR-005','QueryDslRepository 네이밍 규칙','QueryDslRepository 클래스명은 *QueryDslRepository 형식이어야 합니다.','QueryDslRepositoryArchTest','queryDslRepositoriesShouldFollowNamingConvention','@ArchTest\nstatic final ArchRule queryDslRepositoriesShouldFollowNamingConvention =\n    classes()\n        .that().resideInAPackage(\"..repository.querydsl..\")\n        .and().haveSimpleNameContaining(\"Repository\")\n        .should().haveSimpleNameEndingWith(\"QueryDslRepository\")\n        .because(\"QueryDslRepository는 *QueryDslRepository 네이밍을 따라야 합니다\");','MAJOR','2026-01-16 06:52:07','2026-01-16 06:52:07',NULL),(114,3,29,'ARCH-CADP-001','CommandAdapter에 @Component 필수','CommandAdapter 클래스에는 @Component 어노테이션이 필수입니다. @Service, @Repository는 사용하지 않습니다.','CommandAdapterArchTest','commandAdaptersShouldBeAnnotatedWithComponent','@ArchTest\nstatic final ArchRule commandAdaptersShouldBeAnnotatedWithComponent =\n    classes()\n        .that().haveSimpleNameEndingWith(\"CommandAdapter\")\n        .and().resideInAPackage(\"..adapter.command..\")\n        .should().beAnnotatedWith(Component.class)\n        .because(\"CommandAdapter는 @Component 어노테이션이 필수입니다\");','BLOCKER','2026-01-16 06:52:07','2026-01-16 06:52:07',NULL),(115,3,29,'ARCH-CADP-002','CommandAdapter @Transactional 금지','CommandAdapter 클래스 및 메서드에서 @Transactional 사용을 금지합니다. Application Layer에서 관리합니다.','CommandAdapterArchTest','commandAdaptersShouldNotUseTransactional','@ArchTest\nstatic final ArchRule commandAdaptersShouldNotUseTransactional =\n    noClasses()\n        .that().haveSimpleNameEndingWith(\"CommandAdapter\")\n        .should().beAnnotatedWith(\"org.springframework.transaction.annotation.Transactional\")\n        .because(\"CommandAdapter에서 @Transactional 사용을 금지합니다\");','BLOCKER','2026-01-16 06:52:07','2026-01-16 06:52:07',NULL),(116,3,29,'ARCH-CADP-003','CommandAdapter는 CommandPort 구현','CommandAdapter는 Application Layer의 CommandPort 인터페이스를 구현해야 합니다.','CommandAdapterArchTest','commandAdaptersShouldImplementCommandPort','@ArchTest\nstatic final ArchRule commandAdaptersShouldImplementCommandPort =\n    classes()\n        .that().haveSimpleNameEndingWith(\"CommandAdapter\")\n        .should(new ArchCondition<JavaClass>(\"implement CommandPort interface\") {\n            @Override\n            public void check(JavaClass javaClass, ConditionEvents events) {\n                boolean implementsCommandPort = javaClass.getAllRawInterfaces().stream()\n                    .anyMatch(iface -> iface.getName().endsWith(\"CommandPort\"));\n                if (!implementsCommandPort) {\n                    events.add(SimpleConditionEvent.violated(javaClass,\n                        String.format(\"CommandAdapter %s must implement *CommandPort interface\",\n                            javaClass.getSimpleName())));\n                }\n            }\n        })\n        .because(\"CommandAdapter는 CommandPort 인터페이스를 구현해야 합니다\");','CRITICAL','2026-01-16 06:52:07','2026-01-16 06:52:07',NULL),(117,3,29,'ARCH-CADP-004','CommandAdapter 네이밍 규칙','CommandAdapter 클래스명은 *CommandAdapter 형식이어야 합니다.','CommandAdapterArchTest','commandAdaptersShouldFollowNamingConvention','@ArchTest\nstatic final ArchRule commandAdaptersShouldFollowNamingConvention =\n    classes()\n        .that().resideInAPackage(\"..adapter.command..\")\n        .and().haveSimpleNameContaining(\"Adapter\")\n        .should().haveSimpleNameEndingWith(\"CommandAdapter\")\n        .because(\"CommandAdapter는 *CommandAdapter 네이밍을 따라야 합니다\");','MAJOR','2026-01-16 06:52:07','2026-01-16 06:52:07',NULL),(118,3,30,'ARCH-QADP-001','QueryAdapter에 @Component 필수','QueryAdapter 클래스에는 @Component 어노테이션이 필수입니다.','QueryAdapterArchTest','queryAdaptersShouldBeAnnotatedWithComponent','@ArchTest\nstatic final ArchRule queryAdaptersShouldBeAnnotatedWithComponent =\n    classes()\n        .that().haveSimpleNameEndingWith(\"QueryAdapter\")\n        .and().resideInAPackage(\"..adapter.query..\")\n        .should().beAnnotatedWith(Component.class)\n        .because(\"QueryAdapter는 @Component 어노테이션이 필수입니다\");','BLOCKER','2026-01-16 06:52:07','2026-01-16 06:52:07',NULL),(119,3,30,'ARCH-QADP-002','QueryAdapter @Transactional 금지','QueryAdapter 클래스 및 메서드에서 @Transactional 사용을 금지합니다. Application Layer에서 관리합니다.','QueryAdapterArchTest','queryAdaptersShouldNotUseTransactional','@ArchTest\nstatic final ArchRule queryAdaptersShouldNotUseTransactional =\n    noClasses()\n        .that().haveSimpleNameEndingWith(\"QueryAdapter\")\n        .should().beAnnotatedWith(\"org.springframework.transaction.annotation.Transactional\")\n        .because(\"QueryAdapter에서 @Transactional 사용을 금지합니다\");','BLOCKER','2026-01-16 06:52:07','2026-01-16 06:52:07',NULL),(120,3,30,'ARCH-QADP-003','QueryAdapter는 QueryPort 구현','QueryAdapter는 Application Layer의 QueryPort 인터페이스를 구현해야 합니다.','QueryAdapterArchTest','queryAdaptersShouldImplementQueryPort','@ArchTest\nstatic final ArchRule queryAdaptersShouldImplementQueryPort =\n    classes()\n        .that().haveSimpleNameEndingWith(\"QueryAdapter\")\n        .should(new ArchCondition<JavaClass>(\"implement QueryPort interface\") {\n            @Override\n            public void check(JavaClass javaClass, ConditionEvents events) {\n                boolean implementsQueryPort = javaClass.getAllRawInterfaces().stream()\n                    .anyMatch(iface -> iface.getName().endsWith(\"QueryPort\"));\n                if (!implementsQueryPort) {\n                    events.add(SimpleConditionEvent.violated(javaClass,\n                        String.format(\"QueryAdapter %s must implement *QueryPort interface\",\n                            javaClass.getSimpleName())));\n                }\n            }\n        })\n        .because(\"QueryAdapter는 QueryPort 인터페이스를 구현해야 합니다\");','CRITICAL','2026-01-16 06:52:07','2026-01-16 06:52:07',NULL),(121,3,30,'ARCH-QADP-004','QueryAdapter 네이밍 규칙','QueryAdapter 클래스명은 *QueryAdapter 형식이어야 합니다.','QueryAdapterArchTest','queryAdaptersShouldFollowNamingConvention','@ArchTest\nstatic final ArchRule queryAdaptersShouldFollowNamingConvention =\n    classes()\n        .that().resideInAPackage(\"..adapter.query..\")\n        .and().haveSimpleNameContaining(\"Adapter\")\n        .should().haveSimpleNameEndingWith(\"QueryAdapter\")\n        .because(\"QueryAdapter는 *QueryAdapter 네이밍을 따라야 합니다\");','MAJOR','2026-01-16 06:52:07','2026-01-16 06:52:07',NULL),(122,3,31,'ARCH-EMAP-001','EntityMapper에 @Component 필수','EntityMapper 클래스에는 @Component 어노테이션이 필수입니다.','EntityMapperArchTest','entityMappersShouldBeAnnotatedWithComponent','@ArchTest\nstatic final ArchRule entityMappersShouldBeAnnotatedWithComponent =\n    classes()\n        .that().haveSimpleNameEndingWith(\"JpaEntityMapper\")\n        .and().resideInAPackage(\"..mapper..\")\n        .should().beAnnotatedWith(Component.class)\n        .because(\"EntityMapper는 @Component 어노테이션이 필수입니다\");','BLOCKER','2026-01-16 06:52:07','2026-01-16 06:52:07',NULL),(123,3,31,'ARCH-EMAP-002','EntityMapper Lombok/MapStruct 금지','EntityMapper에서 @Data, @Mapper(MapStruct) 등 코드 생성 라이브러리 사용을 금지합니다.','EntityMapperArchTest','entityMappersShouldNotUseLombokOrMapStruct','@ArchTest\nstatic final ArchRule entityMappersShouldNotUseLombokOrMapStruct =\n    noClasses()\n        .that().haveSimpleNameEndingWith(\"JpaEntityMapper\")\n        .should().beAnnotatedWith(\"lombok.Data\")\n        .orShould().beAnnotatedWith(\"lombok.Builder\")\n        .orShould().beAnnotatedWith(\"org.mapstruct.Mapper\")\n        .because(\"EntityMapper에서 Lombok/MapStruct 사용을 금지합니다. Pure Java로 구현하세요\");','BLOCKER','2026-01-16 06:52:07','2026-01-16 06:52:07',NULL),(124,3,31,'ARCH-EMAP-003','EntityMapper @Transactional 금지','EntityMapper에서 @Transactional 사용을 금지합니다. Mapper는 순수 변환 로직만 수행합니다.','EntityMapperArchTest','entityMappersShouldNotUseTransactional','@ArchTest\nstatic final ArchRule entityMappersShouldNotUseTransactional =\n    noClasses()\n        .that().haveSimpleNameEndingWith(\"JpaEntityMapper\")\n        .should().beAnnotatedWith(\"org.springframework.transaction.annotation.Transactional\")\n        .because(\"EntityMapper에서 @Transactional 사용을 금지합니다\");','BLOCKER','2026-01-16 06:52:07','2026-01-16 06:52:07',NULL),(125,3,31,'ARCH-EMAP-004','EntityMapper 네이밍 규칙','EntityMapper 클래스명은 *JpaEntityMapper 형식이어야 합니다.','EntityMapperArchTest','entityMappersShouldFollowNamingConvention','@ArchTest\nstatic final ArchRule entityMappersShouldFollowNamingConvention =\n    classes()\n        .that().resideInAPackage(\"..mapper..\")\n        .and().haveSimpleNameContaining(\"Mapper\")\n        .and().resideInAPackage(\"..adapter.out.persistence..\")\n        .should().haveSimpleNameEndingWith(\"JpaEntityMapper\")\n        .because(\"EntityMapper는 *JpaEntityMapper 네이밍을 따라야 합니다\");','MAJOR','2026-01-16 06:52:07','2026-01-16 06:52:07',NULL),(126,3,31,'ARCH-EMAP-005','EntityMapper 패키지 위치 검증','EntityMapper는 ..mapper.. 패키지에 위치해야 합니다.','EntityMapperArchTest','entityMappersShouldResideInMapperPackage','@ArchTest\nstatic final ArchRule entityMappersShouldResideInMapperPackage =\n    classes()\n        .that().haveSimpleNameEndingWith(\"JpaEntityMapper\")\n        .should().resideInAPackage(\"..mapper..\")\n        .because(\"EntityMapper는 mapper 패키지에 위치해야 합니다\");','CRITICAL','2026-01-16 06:52:07','2026-01-16 06:52:07',NULL);
/*!40000 ALTER TABLE `archunit_test` ENABLE KEYS */;
UNLOCK TABLES;

LOCK TABLES `rule_example` WRITE;
/*!40000 ALTER TABLE `rule_example` DISABLE KEYS */;
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `created_at`, `updated_at`, `source`, `feedback_id`, `deleted_at`) VALUES (1,1,'GOOD','@RestController\n@RequestMapping(ApiPaths.Order.BASE)\npublic class OrderCommandController {\n\n    private final CreateOrderUseCase createOrderUseCase;\n    private final OrderCommandApiMapper mapper;\n\n    public OrderCommandController(CreateOrderUseCase createOrderUseCase,\n            OrderCommandApiMapper mapper) {\n        this.createOrderUseCase = createOrderUseCase;\n        this.mapper = mapper;\n    }\n\n    @PostMapping\n    public ResponseEntity<ApiResponse<Long>> create(\n            @Valid @RequestBody CreateOrderApiRequest request) {\n        Long id = createOrderUseCase.execute(mapper.toCommand(request));\n        return ResponseEntity.status(HttpStatus.CREATED).body(ApiResponse.of(id));\n    }\n}','JAVA','Thin Controller 패턴: Controller는 HTTP 요청을 UseCase로 전달하고 결과를 HTTP 응답으로 반환하는 역할만 수행합니다. 비즈니스 로직, 예외 처리, Domain 객체 생성 등은 포함하지 않습니다. 메서드 본문은 최대 5줄 이내로 유지합니다.','[14, 15, 16, 17]','2026-01-16 02:26:00','2026-01-16 02:26:00','MANUAL',NULL,NULL),(2,2,'GOOD','@GetMapping(\"/{id}\")\npublic ResponseEntity<ApiResponse<OrderApiResponse>> getById(@PathVariable Long id) {\n    OrderResponse response = getOrderUseCase.execute(new GetOrderQuery(id));\n    return ResponseEntity.ok(ApiResponse.of(mapper.toApiResponse(response)));\n}\n\n@PostMapping\npublic ResponseEntity<ApiResponse<Long>> create(\n        @Valid @RequestBody CreateOrderApiRequest request) {\n    Long id = createOrderUseCase.execute(mapper.toCommand(request));\n    return ResponseEntity.status(HttpStatus.CREATED).body(ApiResponse.of(id));\n}\n\n@PutMapping(\"/{id}\")\npublic ResponseEntity<ApiResponse<Void>> update(\n        @PathVariable Long id,\n        @Valid @RequestBody UpdateOrderApiRequest request) {\n    updateOrderUseCase.execute(mapper.toCommand(id, request));\n    return ResponseEntity.ok(ApiResponse.of());\n}','JAVA','ResponseEntity<ApiResponse<T>> 형식으로 반환하여 HTTP 상태 코드 제어와 표준 응답 형식을 동시에 만족합니다. GET은 200 OK, POST는 201 Created, PUT/PATCH는 200 OK를 사용합니다.','[2, 8, 15]','2026-01-16 02:26:00','2026-01-16 02:26:00','MANUAL',NULL,NULL),(3,4,'GOOD','@PatchMapping(\"/{id}/delete\")\npublic ResponseEntity<ApiResponse<Void>> softDelete(@PathVariable Long id) {\n    softDeleteOrderUseCase.execute(new SoftDeleteOrderCommand(id));\n    return ResponseEntity.ok(ApiResponse.of());\n}\n\n@PatchMapping(\"/{id}/cancel\")\npublic ResponseEntity<ApiResponse<Void>> cancel(@PathVariable Long id) {\n    cancelOrderUseCase.execute(new CancelOrderCommand(id));\n    return ResponseEntity.ok(ApiResponse.of());\n}','JAVA','소프트 삭제는 상태 변경이므로 PATCH /{id}/delete 형태로 처리합니다. @DeleteMapping 사용이 금지됩니다. 실제 DB 삭제는 위험하며 복구 불가하므로, 상태를 DELETED로 변경하여 감사 추적(Audit Trail)을 유지합니다.','[1, 7]','2026-01-16 02:26:00','2026-01-16 02:26:00','MANUAL',NULL,NULL),(4,5,'GOOD','@RestController\n@RequestMapping(ApiPaths.Order.BASE)\npublic class OrderCommandController {\n\n    private final CreateOrderUseCase createOrderUseCase;\n    private final OrderCommandApiMapper mapper;\n\n    public OrderCommandController(CreateOrderUseCase createOrderUseCase,\n            OrderCommandApiMapper mapper) {\n        this.createOrderUseCase = createOrderUseCase;\n        this.mapper = mapper;\n    }\n\n    // @Transactional 없음 - 트랜잭션은 UseCase에서 관리\n    @PostMapping\n    public ResponseEntity<ApiResponse<Long>> create(\n            @Valid @RequestBody CreateOrderApiRequest request) {\n        Long id = createOrderUseCase.execute(mapper.toCommand(request));\n        return ResponseEntity.status(HttpStatus.CREATED).body(ApiResponse.of(id));\n    }\n}','JAVA','Controller에 @Transactional 어노테이션을 사용하지 않습니다. 트랜잭션 관리는 UseCase(Service) 계층의 책임입니다. Controller는 HTTP 어댑터 역할만 수행합니다.','[1, 2, 14, 15]','2026-01-16 02:26:00','2026-01-16 02:26:00','MANUAL',NULL,NULL),(5,7,'GOOD','@PostMapping\npublic ResponseEntity<ApiResponse<Long>> create(\n        @Valid @RequestBody CreateOrderApiRequest request) {\n    // 비즈니스 로직 없음 - Mapper 변환과 UseCase 호출만 수행\n    Long id = createOrderUseCase.execute(mapper.toCommand(request));\n    return ResponseEntity.status(HttpStatus.CREATED).body(ApiResponse.of(id));\n}\n\n@GetMapping\npublic ResponseEntity<ApiResponse<SliceApiResponse<OrderSummaryApiResponse>>> search(\n        @Valid @ModelAttribute SearchOrderApiRequest request) {\n    // 검색 조건 처리도 UseCase에 위임\n    SliceResponse<OrderSummary> response = searchOrdersUseCase.execute(mapper.toQuery(request));\n    return ResponseEntity.ok(ApiResponse.of(mapper.toSliceApiResponse(response)));\n}','JAVA','Controller는 if/switch 비즈니스 규칙, 계산 로직, 상태 변경 로직을 포함하지 않습니다. Mapper 변환과 UseCase 호출만 수행합니다. 비즈니스 로직은 Domain과 UseCase에서 처리합니다.','[4, 5, 12, 13]','2026-01-16 02:26:01','2026-01-16 02:26:01','MANUAL',NULL,NULL),(6,8,'GOOD','@PostMapping\npublic ResponseEntity<ApiResponse<Long>> create(\n        @Valid @RequestBody CreateOrderApiRequest request) {\n    // API DTO → Application DTO(Command) 변환만 수행\n    // Domain 객체 생성은 Application Layer(Factory/Assembler)에서 처리\n    Long id = createOrderUseCase.execute(mapper.toCommand(request));\n    return ResponseEntity.status(HttpStatus.CREATED).body(ApiResponse.of(id));\n}\n\n@GetMapping(\"/{id}\")\npublic ResponseEntity<ApiResponse<OrderApiResponse>> getById(@PathVariable Long id) {\n    // Application DTO(Response) → API DTO 변환만 수행\n    // Domain 객체에 직접 접근하지 않음\n    OrderResponse response = getOrderUseCase.execute(new GetOrderQuery(id));\n    return ResponseEntity.ok(ApiResponse.of(mapper.toApiResponse(response)));\n}','JAVA','Controller에서 Domain Entity, Aggregate, Value Object를 직접 생성하거나 조작하지 않습니다. Domain 변환은 Application Layer의 Assembler/Factory 책임입니다. REST API Layer는 Application Layer의 DTO만 사용합니다.','[4, 5, 6, 12, 13, 14]','2026-01-16 02:26:01','2026-01-16 02:26:01','MANUAL',NULL,NULL),(7,9,'GOOD','@RestController\n@RequestMapping(ApiPaths.Order.BASE)\npublic class OrderCommandController {\n\n    private final CreateOrderUseCase createOrderUseCase;\n    private final UpdateOrderUseCase updateOrderUseCase;\n    private final OrderCommandApiMapper mapper;\n\n    // 명시적 생성자 주입 (Lombok @RequiredArgsConstructor 미사용)\n    public OrderCommandController(CreateOrderUseCase createOrderUseCase,\n            UpdateOrderUseCase updateOrderUseCase,\n            OrderCommandApiMapper mapper) {\n        this.createOrderUseCase = createOrderUseCase;\n        this.updateOrderUseCase = updateOrderUseCase;\n        this.mapper = mapper;\n    }\n\n    @PostMapping\n    public ResponseEntity<ApiResponse<Long>> create(\n            @Valid @RequestBody CreateOrderApiRequest request) {\n        Long id = createOrderUseCase.execute(mapper.toCommand(request));\n        return ResponseEntity.status(HttpStatus.CREATED).body(ApiResponse.of(id));\n    }\n}','JAVA','Lombok(@Data, @Builder, @Getter, @Setter, @RequiredArgsConstructor 등) 사용이 금지됩니다. 생성자 주입은 명시적으로 작성합니다. Pure Java 원칙으로 컴파일 타임에 코드가 명확히 보이고, IDE 지원이 확실합니다.','[9, 10, 11, 12, 13, 14, 15, 16]','2026-01-16 02:26:01','2026-01-16 02:26:01','MANUAL',NULL,NULL),(8,15,'GOOD','@Schema(description = \"주문 생성 요청\")\npublic record CreateOrderApiRequest(\n        @NotBlank(message = \"고객 ID는 필수입니다\")\n        @Schema(description = \"고객 ID\", example = \"CUST-001\")\n        String customerId,\n\n        @NotNull(message = \"주문 항목은 필수입니다\")\n        @Size(min = 1, message = \"최소 1개 이상의 주문 항목이 필요합니다\")\n        @Valid\n        @Schema(description = \"주문 항목 목록\")\n        List<OrderItemRequest> items\n) {\n    // Nested Record도 record로 정의\n    public record OrderItemRequest(\n            @NotBlank(message = \"상품 ID는 필수입니다\")\n            @Schema(description = \"상품 ID\")\n            String productId,\n\n            @Min(value = 1, message = \"수량은 1 이상이어야 합니다\")\n            @Schema(description = \"수량\", example = \"2\")\n            int quantity\n    ) {}\n}','JAVA','모든 Request/Response DTO는 public record 키워드로 정의합니다. Record는 불변성, equals/hashCode/toString 자동 생성, Compact Constructor를 제공합니다. Nested DTO도 record로 정의합니다.','[2, 14]','2026-01-16 02:26:01','2026-01-16 02:26:01','MANUAL',NULL,NULL),(9,19,'GOOD','// Java 21 Record 사용 - Lombok 불필요\npublic record OrderApiResponse(\n        Long id,\n        String orderNumber,\n        String status,\n        String customerId,\n        List<OrderItemResponse> items,\n        String createdAt,\n        String updatedAt\n) {\n    // Record는 자동으로 다음을 제공:\n    // - 불변성 (final 필드)\n    // - Getter (id(), orderNumber() 등)\n    // - equals(), hashCode(), toString()\n    // - Canonical Constructor\n\n    public record OrderItemResponse(\n            Long id,\n            String productId,\n            int quantity,\n            String unitPrice\n    ) {}\n}','JAVA','Lombok(@Data, @Builder, @Getter, @Setter, @NoArgsConstructor, @AllArgsConstructor 등) 사용이 금지됩니다. Java 21 Record가 Lombok의 기능을 언어 레벨에서 제공하므로 Lombok이 불필요합니다.','[1, 2, 16]','2026-01-16 02:26:01','2026-01-16 02:26:01','MANUAL',NULL,NULL),(10,20,'GOOD','public record OrderApiResponse(\n        Long id,\n        String orderNumber,\n        String status,\n        String customerId,\n        // camelCase 필드명 사용 - Jackson 어노테이션 불필요\n        // @JsonFormat, @JsonProperty, @JsonIgnore 사용 금지\n        String createdAt,   // ISO 8601 문자열 (전역 ObjectMapper 설정)\n        String updatedAt\n) {}\n\n// 전역 ObjectMapper 설정 (인프라 레이어)\n@Configuration\npublic class JacksonConfig {\n    @Bean\n    public ObjectMapper objectMapper() {\n        return new ObjectMapper()\n            .setPropertyNamingStrategy(PropertyNamingStrategies.LOWER_CAMEL_CASE)\n            .registerModule(new JavaTimeModule())\n            .disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n    }\n}','JAVA','Jackson 어노테이션(@JsonFormat, @JsonProperty, @JsonIgnore, @JsonInclude) 사용이 금지됩니다. 필드명은 camelCase를 사용하고, 직렬화 설정은 전역 ObjectMapper에서 중앙 관리합니다.','[6, 7, 8, 14, 15, 16, 17, 18, 19, 20]','2026-01-16 02:26:01','2026-01-16 02:26:01','MANUAL',NULL,NULL),(11,21,'GOOD','// DTO는 데이터만 담음 - 변환 메서드 없음\npublic record CreateOrderApiRequest(\n        @NotBlank String customerId,\n        @Valid List<OrderItemRequest> items\n) {\n    // toDomain(), toEntity(), toAggregate() 메서드 없음\n    // API DTO → Application DTO 변환은 Mapper 책임\n    // Application DTO → Domain 변환은 Assembler 책임\n\n    public record OrderItemRequest(\n            @NotBlank String productId,\n            @Min(1) int quantity\n    ) {}\n}\n\n// 변환은 Mapper에서 처리\n@Component\npublic class OrderCommandApiMapper {\n    public CreateOrderCommand toCommand(CreateOrderApiRequest request) {\n        return new CreateOrderCommand(\n            request.customerId(),\n            request.items().stream()\n                .map(item -> new OrderItemCommand(item.productId(), item.quantity()))\n                .toList()\n        );\n    }\n}','JAVA','DTO에 toDomain(), toEntity(), toAggregate() 등 Domain 객체 변환 메서드를 포함하지 않습니다. API DTO → Application DTO 변환은 Mapper, Application DTO → Domain 변환은 Assembler 책임입니다.','[1, 2, 6, 7, 8, 17, 18]','2026-01-16 02:26:01','2026-01-16 02:26:01','MANUAL',NULL,NULL),(12,22,'GOOD','// DTO는 순수 데이터 전송 객체 - 비즈니스 로직 없음\npublic record OrderApiResponse(\n        Long id,\n        String orderNumber,\n        String status,\n        String totalAmount,\n        String customerId,\n        List<OrderItemResponse> items,\n        String createdAt\n) {\n    // isVip(), calculateTotal(), validate() 등 비즈니스 메서드 없음\n    // 비즈니스 로직은 Domain Layer에서 처리\n\n    public record OrderItemResponse(\n            Long id,\n            String productId,\n            int quantity,\n            String unitPrice,\n            String subtotal\n    ) {}\n}','JAVA','DTO에 isVip(), calculateTotal(), validate() 등 비즈니스 로직 메서드를 포함하지 않습니다. DTO는 데이터 전송 객체로서 데이터만 담습니다. 비즈니스 로직은 Domain Layer의 책임입니다.','[1, 2, 11, 12]','2026-01-16 02:26:01','2026-01-16 02:26:01','MANUAL',NULL,NULL),(13,25,'GOOD','// Record는 기본적으로 불변 - Setter 없음\npublic record OrderApiResponse(\n        Long id,\n        String orderNumber,\n        String status,\n        String customerId,\n        List<OrderItemResponse> items\n) {\n    // Record는 자동으로 불변성 보장\n    // - 모든 필드가 final\n    // - Setter 메서드 없음\n    // - 생성 후 상태 변경 불가\n\n    // Compact Constructor로 불변 리스트 보장\n    public OrderApiResponse {\n        items = items != null ? List.copyOf(items) : List.of();\n    }\n\n    public record OrderItemResponse(\n            Long id,\n            String productId,\n            int quantity\n    ) {}\n}','JAVA','DTO는 불변 객체여야 합니다. Setter 메서드를 정의하지 않습니다. Record는 기본적으로 불변이므로 Setter가 없습니다. 불변성으로 Thread-Safe하고 예측 가능합니다.','[1, 2, 9, 10, 11, 12, 15, 16]','2026-01-16 02:26:01','2026-01-16 02:26:01','MANUAL',NULL,NULL),(14,26,'GOOD','// DTO는 순수 POJO - Spring 어노테이션 없음\n// @Component, @Service, @Repository 등 사용 금지\npublic record CreateOrderApiRequest(\n        @NotBlank(message = \"고객 ID는 필수입니다\")\n        @Schema(description = \"고객 ID\")\n        String customerId,\n\n        @NotNull(message = \"주문 항목은 필수입니다\")\n        @Valid\n        List<OrderItemRequest> items\n) {\n    // 허용되는 어노테이션:\n    // - Bean Validation: @NotBlank, @NotNull, @Valid, @Size, @Min, @Max 등\n    // - OpenAPI/Swagger: @Schema\n\n    public record OrderItemRequest(\n            @NotBlank String productId,\n            @Min(1) int quantity\n    ) {}\n}','JAVA','DTO에 @Component, @Service, @Repository, @Controller 등 Spring 어노테이션을 사용하지 않습니다. DTO는 프레임워크에 독립적인 POJO여야 합니다. Bean Validation과 OpenAPI 어노테이션은 허용됩니다.','[1, 2, 3, 12, 13, 14]','2026-01-16 02:26:01','2026-01-16 02:26:01','MANUAL',NULL,NULL),(15,28,'GOOD','@Component\npublic class OrderCommandApiMapper {\n\n    // 다른 빈 주입 가능 (선택적)\n    // private final MessageSource messageSource;\n\n    // 기본 생성자 또는 의존성 주입 생성자\n    public OrderCommandApiMapper() {\n    }\n\n    public CreateOrderCommand toCommand(CreateOrderApiRequest request) {\n        return new CreateOrderCommand(\n            request.customerId(),\n            request.items().stream()\n                .map(item -> new OrderItemCommand(item.productId(), item.quantity()))\n                .toList()\n        );\n    }\n\n    public UpdateOrderCommand toCommand(Long id, UpdateOrderApiRequest request) {\n        return new UpdateOrderCommand(id, request.status());\n    }\n}','JAVA','Mapper 클래스는 @Component 어노테이션으로 Spring Bean 등록합니다. Static 메서드로 구현하지 않습니다. 의존성 주입으로 MessageSource, ObjectMapper 등 다른 빈을 주입받을 수 있고, 테스트 시 Mock 교체가 용이합니다.','[1, 2, 8, 9]','2026-01-16 02:26:01','2026-01-16 02:26:01','MANUAL',NULL,NULL),(16,29,'GOOD','@Component\npublic class OrderQueryApiMapper {\n\n    // 인스턴스 메서드로 구현 - static 아님\n    public SearchOrdersQuery toQuery(SearchOrderApiRequest request) {\n        return new SearchOrdersQuery(\n            request.status(),\n            request.customerId(),\n            request.fromDate(),\n            request.toDate(),\n            request.pageNo(),\n            request.pageSize()\n        );\n    }\n\n    public OrderApiResponse toApiResponse(OrderResponse response) {\n        return new OrderApiResponse(\n            response.id(),\n            response.orderNumber(),\n            response.status(),\n            response.customerId(),\n            response.items().stream()\n                .map(this::toItemApiResponse)\n                .toList(),\n            DateTimeFormatUtils.formatIso8601(response.createdAt())\n        );\n    }\n\n    private OrderItemApiResponse toItemApiResponse(OrderItemResponse item) {\n        return new OrderItemApiResponse(\n            item.id(),\n            item.productId(),\n            item.quantity()\n        );\n    }\n}','JAVA','Mapper의 변환 메서드를 static으로 정의하지 않습니다. 인스턴스 메서드로 구현하여 DI가 가능하게 합니다. Static 메서드는 의존성 주입이 불가능하고 테스트 시 Mock 교체가 어렵습니다.','[4, 5, 15, 16, 27, 28]','2026-01-16 02:26:01','2026-01-16 02:26:01','MANUAL',NULL,NULL),(17,31,'GOOD','@Component\npublic class OrderCommandApiMapper {\n\n    // 순수 필드 매핑만 수행 - 비즈니스 로직 없음\n    public CreateOrderCommand toCommand(CreateOrderApiRequest request) {\n        return new CreateOrderCommand(\n            request.customerId(),\n            request.items().stream()\n                .map(item -> new OrderItemCommand(\n                    item.productId(),\n                    item.quantity()\n                ))\n                .toList()\n        );\n    }\n\n    // null 값은 그대로 전달 (검증/기본값 설정 안함)\n    public UpdateOrderCommand toCommand(Long id, UpdateOrderApiRequest request) {\n        return new UpdateOrderCommand(\n            id,\n            request.status(),\n            request.customerId()\n        );\n    }\n}','JAVA','Mapper는 API DTO ↔ Application DTO 간 필드 매핑만 수행합니다. 비즈니스 로직, 검증 로직, 기본값 설정, 계산 로직 등을 포함하지 않습니다. null 값은 그대로 전달합니다.','[4, 5, 17, 18]','2026-01-16 02:26:01','2026-01-16 02:26:01','MANUAL',NULL,NULL),(18,32,'GOOD','@Component\npublic class OrderQueryApiMapper {\n\n    // 순수 필드 복사만 수행\n    // if/switch 조건부 로직, 계산, 상태 변환 없음\n    public OrderApiResponse toApiResponse(OrderResponse response) {\n        return new OrderApiResponse(\n            response.id(),\n            response.orderNumber(),\n            response.status(),           // 상태 변환(enum → label) 안함\n            response.totalAmount(),      // 계산 안함\n            response.customerId(),\n            response.items().stream()\n                .map(this::toItemApiResponse)\n                .toList(),\n            DateTimeFormatUtils.formatIso8601(response.createdAt())\n        );\n    }\n\n    private OrderItemApiResponse toItemApiResponse(OrderItemResponse item) {\n        return new OrderItemApiResponse(\n            item.id(),\n            item.productId(),\n            item.quantity(),\n            item.unitPrice(),\n            item.subtotal()              // 계산된 값은 Application Layer에서 전달\n        );\n    }\n}','JAVA','if/switch 조건부 로직, 계산(tax, discount), 상태 변환(enum → label), 기본값 설정 등을 Mapper에 포함하지 않습니다. 비즈니스 로직은 Domain Layer 또는 Application Layer UseCase에서 처리합니다.','[4, 5, 10, 11, 25]','2026-01-16 02:26:02','2026-01-16 02:26:02','MANUAL',NULL,NULL),(19,33,'GOOD','package com.example.adapter.in.rest.order.mapper;\n\n// API Layer imports\nimport com.example.adapter.in.rest.order.dto.command.CreateOrderApiRequest;\nimport com.example.adapter.in.rest.order.dto.response.OrderApiResponse;\n\n// Application Layer imports만 허용\nimport com.example.application.order.dto.command.CreateOrderCommand;\nimport com.example.application.order.dto.response.OrderResponse;\n\n// Domain Layer imports 금지!\n// import com.example.domain.order.aggregate.Order;          // 금지\n// import com.example.domain.order.vo.OrderStatus;           // 금지\n// import com.example.domain.order.entity.OrderItem;         // 금지\n\n@Component\npublic class OrderCommandApiMapper {\n\n    // API DTO ↔ Application DTO 변환만 담당\n    public CreateOrderCommand toCommand(CreateOrderApiRequest request) {\n        return new CreateOrderCommand(\n            request.customerId(),\n            request.items().stream()\n                .map(item -> new OrderItemCommand(item.productId(), item.quantity()))\n                .toList()\n        );\n    }\n}','JAVA','Mapper에서 Domain Entity, Aggregate, Value Object를 직접 import하거나 사용하지 않습니다. API DTO ↔ Application DTO 변환만 담당합니다. REST API Layer는 Domain Layer를 직접 알지 못합니다.','[7, 8, 9, 11, 12, 13, 14, 19]','2026-01-16 02:26:02','2026-01-16 02:26:02','MANUAL',NULL,NULL),(20,34,'GOOD','@Component\npublic class OrderCommandApiMapper {\n\n    // 의존성 필드 명시적 선언\n    private final DateTimeFormatUtils dateTimeFormatUtils;\n\n    // 명시적 생성자 - Lombok @RequiredArgsConstructor 미사용\n    public OrderCommandApiMapper(DateTimeFormatUtils dateTimeFormatUtils) {\n        this.dateTimeFormatUtils = dateTimeFormatUtils;\n    }\n\n    public CreateOrderCommand toCommand(CreateOrderApiRequest request) {\n        return new CreateOrderCommand(\n            request.customerId(),\n            request.items().stream()\n                .map(item -> new OrderItemCommand(item.productId(), item.quantity()))\n                .toList()\n        );\n    }\n}','JAVA','Lombok(@Data, @Builder, @RequiredArgsConstructor 등) 사용이 금지됩니다. 생성자와 의존성 필드는 명시적으로 작성합니다. Pure Java 원칙으로 컴파일 타임에 코드가 명확히 보입니다.','[4, 5, 7, 8, 9, 10]','2026-01-16 02:26:02','2026-01-16 02:26:02','MANUAL',NULL,NULL),(21,35,'GOOD','@Component\npublic class OrderQueryApiMapper {\n\n    // 허용되는 의존성: 인프라 유틸리티만\n    // private final MessageSource messageSource;     // OK\n    // private final ObjectMapper objectMapper;       // OK\n\n    // 금지되는 의존성:\n    // private final OrderRepository orderRepository;           // 금지!\n    // private final GetOrderUseCase getOrderUseCase;           // 금지!\n    // private final OrderService orderService;                 // 금지!\n\n    public OrderQueryApiMapper() {\n        // 의존성 없는 기본 생성자 OK\n    }\n\n    public OrderApiResponse toApiResponse(OrderResponse response) {\n        return new OrderApiResponse(\n            response.id(),\n            response.orderNumber(),\n            response.status(),\n            response.customerId(),\n            DateTimeFormatUtils.formatIso8601(response.createdAt())\n        );\n    }\n}','JAVA','Mapper에 Repository, UseCase, Service 등 다른 계층의 컴포넌트를 주입하지 않습니다. 허용되는 의존성은 MessageSource, ObjectMapper 등 인프라 유틸리티만 가능합니다. Mapper는 순수 변환기입니다.','[4, 5, 6, 8, 9, 10, 11]','2026-01-16 02:26:02','2026-01-16 02:26:02','MANUAL',NULL,NULL),(22,40,'GOOD','@WebMvcTest(TechStackCommandController.class)\n@AutoConfigureMockMvc(addFilters = false)\n@DisplayName(\"TechStackCommandController REST Docs\")\n@Tag(\"restdocs\")\nclass TechStackCommandControllerDocsTest extends RestDocsTestSupport {\n\n    @MockitoBean private TechStackCommandApiMapper mapper;\n    @MockitoBean private CreateTechStackUseCase createTechStackUseCase;\n    @MockitoBean private UpdateTechStackUseCase updateTechStackUseCase;\n\n    // Filter dependencies\n    @MockitoBean private SecurityContextAuthenticator authenticator;\n    @MockitoBean private ErrorMapperRegistry errorMapperRegistry;\n\n    // ... tests\n}','JAVA','TEST-001, 002, 005, 007, 010 Good:\n• @WebMvcTest: 테스트 대상 Controller 명시로 Slice Test 구성\n• extends RestDocsTestSupport: MockMvc, ObjectMapper, REST Docs 설정 상속\n• @AutoConfigureMockMvc(addFilters = false): Security Filter 비활성화\n• @Tag(\"restdocs\"): 문서 생성 테스트 그룹화\n• @MockitoBean: UseCase, Mapper, Filter 의존성 Mock 처리\n• *DocsTest 네이밍: Controller와 1:1 매핑으로 테스트 위치 명확','[1, 2, 3, 4, 5]','2026-01-16 02:26:09','2026-01-16 02:26:09','MANUAL',NULL,NULL),(23,42,'GOOD','@Test\n@DisplayName(\"POST /api/v1/tech-stacks - TechStack 생성 API 문서\")\nvoid createTechStack() throws Exception {\n    // Given\n    CreateTechStackApiRequest request = new CreateTechStackApiRequest(\n        \"Spring Boot 3.5 Backend\", \"JAVA\", \"21\", \"Eclipse Temurin\",\n        List.of(\"virtual-threads\"), \"SPRING_BOOT\", \"3.5.0\",\n        List.of(\"spring-web\"), \"BACKEND\", \"JVM\", \"GRADLE\", \"8.5\", \"build.gradle.kts\");\n\n    given(mapper.toCommand(any())).willReturn(mockCommand);\n    given(createTechStackUseCase.execute(any())).willReturn(1L);\n\n    // When & Then\n    mockMvc.perform(\n            post(\"/api/v1/tech-stacks\")\n                .contentType(MediaType.APPLICATION_JSON)\n                .content(objectMapper.writeValueAsString(request)))\n        .andExpect(status().isCreated())\n        .andDo(\n            document(\"tech-stack-create\",\n                requestFields(\n                    fieldWithPath(\"name\").type(JsonFieldType.STRING)\n                        .description(\"기술 스택 이름 (필수, 100자 이내)\"),\n                    fieldWithPath(\"languageType\").type(JsonFieldType.STRING)\n                        .description(\"언어 타입 (필수)\"),\n                    fieldWithPath(\"languageVendor\").type(JsonFieldType.STRING)\n                        .description(\"언어 벤더\").optional()),\n                responseFields(\n                    fieldWithPath(\"data\").type(JsonFieldType.NUMBER)\n                        .description(\"생성된 TechStack ID\"),\n                    fieldWithPath(\"timestamp\").type(JsonFieldType.STRING)\n                        .description(\"응답 시간 (ISO 8601)\"),\n                    fieldWithPath(\"requestId\").type(JsonFieldType.STRING)\n                        .description(\"요청 ID\"))));\n}','JAVA','TEST-003, 004 Good:\n• document(\"tech-stack-create\"): kebab-case identifier로 문서 생성\n• requestFields(): Request Body 필드 문서화\n• responseFields(): Response Body 필드 문서화\n• .optional(): 선택 필드 명시\n• fieldWithPath().type().description(): 필드 타입과 설명 필수','[18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]','2026-01-16 02:26:09','2026-01-16 02:26:09','MANUAL',NULL,NULL),(24,45,'GOOD','@Test\n@DisplayName(\"PUT /api/v1/tech-stacks/{id} - TechStack 수정 API 문서\")\nvoid updateTechStack() throws Exception {\n    // Given - Mock 설정, 데이터 준비\n    UpdateTechStackApiRequest request = new UpdateTechStackApiRequest(\n        \"Spring Boot 3.6 Backend\", \"ACTIVE\", \"JAVA\", \"22\",\n        \"Eclipse Temurin\", List.of(\"virtual-threads\", \"records\"),\n        \"SPRING_BOOT\", \"3.6.0\", List.of(\"spring-web\", \"spring-security\"),\n        \"BACKEND\", \"JVM\", \"GRADLE\", \"8.6\", \"build.gradle.kts\");\n\n    given(mapper.toCommand(anyLong(), any())).willReturn(mockCommand);\n    willDoNothing().given(updateTechStackUseCase).execute(any());\n\n    // When & Then - mockMvc.perform + 검증 + 문서화\n    mockMvc.perform(\n            put(\"/api/v1/tech-stacks/{id}\", TECH_STACK_ID)\n                .contentType(MediaType.APPLICATION_JSON)\n                .content(objectMapper.writeValueAsString(request)))\n        .andExpect(status().isOk())\n        .andDo(document(\"tech-stack-update\", ...));\n}','JAVA','TEST-006, 008 Good:\n• @DisplayName: \"{HTTP메서드} {URI} - {설명}\" 형식 한글 설명\n• // Given: Mock 설정, 테스트 데이터 준비 단계\n• // When & Then: mockMvc.perform + 상태 검증 + 문서화 단계\n• BDD 스타일로 테스트 의도 명확화','[1, 2, 4, 14]','2026-01-16 02:26:09','2026-01-16 02:26:09','MANUAL',NULL,NULL),(25,48,'GOOD','@Test\n@DisplayName(\"GET /api/v1/tech-stacks/{id} - TechStack 단건 조회 API 문서\")\nvoid getTechStack() throws Exception {\n    // Given\n    given(getTechStackUseCase.execute(any())).willReturn(mockResponse);\n\n    // When & Then\n    mockMvc.perform(\n            get(\"/api/v1/tech-stacks/{id}\", TECH_STACK_ID))\n        .andExpect(status().isOk())\n        .andDo(\n            document(\"tech-stack-get\",\n                pathParameters(\n                    parameterWithName(\"id\").description(\"TechStack ID\")),\n                responseFields(...)));\n}\n\n@Test\n@DisplayName(\"GET /api/v1/tech-stacks - TechStack 목록 조회 API 문서\")\nvoid searchTechStacks() throws Exception {\n    // When & Then\n    mockMvc.perform(\n            get(\"/api/v1/tech-stacks\")\n                .param(\"keyword\", \"Spring\")\n                .param(\"platformType\", \"BACKEND\")\n                .param(\"page\", \"0\")\n                .param(\"size\", \"20\"))\n        .andExpect(status().isOk())\n        .andDo(\n            document(\"tech-stack-search\",\n                queryParameters(\n                    parameterWithName(\"keyword\").description(\"검색 키워드\").optional(),\n                    parameterWithName(\"platformType\").description(\"플랫폼 타입\").optional(),\n                    parameterWithName(\"page\").description(\"페이지 번호\").optional(),\n                    parameterWithName(\"size\").description(\"페이지 크기\").optional()),\n                responseFields(...)));\n}','JAVA','TEST-009 Good:\n• pathParameters(): Path Variable 문서화 (@PathVariable {id})\n• parameterWithName(\"id\").description(): 파라미터 설명 추가\n• queryParameters(): Query Parameter 문서화 (@RequestParam)\n• .optional(): 선택적 파라미터 명시\n• REST Docs가 자동 인식하지 않으므로 명시적 문서화 필수','[13, 14, 32, 33, 34, 35, 36]','2026-01-16 02:26:09','2026-01-16 02:26:09','MANUAL',NULL,NULL),(26,50,'GOOD','@Schema(description = \"TechStack 생성 요청\")\npublic record CreateTechStackApiRequest(\n    @NotBlank(message = \"기술 스택 이름은 필수입니다\")\n    @Size(max = 100, message = \"기술 스택 이름은 100자 이내여야 합니다\")\n    @Schema(description = \"기술 스택 이름\", example = \"Spring Boot 3.5 Backend\")\n    String name,\n\n    @NotBlank(message = \"언어 타입은 필수입니다\")\n    @Schema(description = \"언어 타입\", example = \"JAVA\")\n    String languageType,\n\n    @Nullable\n    @Schema(description = \"언어 벤더\", example = \"Eclipse Temurin\")\n    String languageVendor,\n\n    @Nullable\n    @Schema(description = \"언어 기능 목록\", example = \"[\"virtual-threads\", \"pattern-matching\"]\")\n    List<String> languageFeatures\n) {}','JAVA','OAS-001 Good:\n• Record 레벨 @Schema(description): DTO 전체 설명\n• 필드별 @Schema(description, example): 필드 설명과 예시값\n• example: 실제 사용 가능한 값 제공으로 Swagger UI 테스트 용이\n• @Nullable 필드도 @Schema 적용하여 문서 완전성 보장','[1, 5, 9, 13, 17]','2026-01-16 02:26:09','2026-01-16 02:26:09','MANUAL',NULL,NULL),(27,51,'GOOD','@Tag(name = \"TechStack Command\", description = \"TechStack 생성/수정 API\")\n@RestController\n@RequestMapping(ApiPaths.TechStack.BASE)\npublic class TechStackCommandController {\n\n    private final CreateTechStackUseCase createTechStackUseCase;\n    private final TechStackCommandApiMapper mapper;\n\n    // ... constructor ...\n\n    @Operation(\n        summary = \"TechStack 생성\",\n        description = \"새로운 TechStack을 생성합니다. 언어, 프레임워크, 빌드 도구 정보를 포함합니다.\")\n    @ApiResponses(value = {\n        @ApiResponse(responseCode = \"201\", description = \"생성 성공\"),\n        @ApiResponse(responseCode = \"400\", description = \"잘못된 요청 - 유효성 검증 실패\"),\n        @ApiResponse(responseCode = \"409\", description = \"충돌 - 중복된 이름\")\n    })\n    @PostMapping\n    public ResponseEntity<ApiResponse<Long>> create(\n            @Valid @RequestBody CreateTechStackApiRequest request) {\n        Long id = createTechStackUseCase.execute(mapper.toCommand(request));\n        return ResponseEntity.status(HttpStatus.CREATED).body(ApiResponse.of(id));\n    }\n}','JAVA','OAS-002, 003, 004 Good:\n• @Tag(name, description): Controller 레벨 API 그룹화\n• @Operation(summary, description): 메서드별 API 설명\n  - summary: 간결한 요약 (목록 표시)\n  - description: 상세 설명 (상세 페이지 표시)\n• @ApiResponses: 예상 HTTP 상태 코드와 설명\n  - 200/201: 성공 케이스\n  - 400: 유효성 검증 실패\n  - 404: 리소스 미존재\n  - 409: 비즈니스 충돌','[1, 11, 12, 13, 14, 15, 16, 17]','2026-01-16 02:26:09','2026-01-16 02:26:09','MANUAL',NULL,NULL),(28,54,'GOOD','/**\n * OpenAPI (Swagger) 설정\n *\n * <p>REST API 문서화를 위한 OpenAPI 3.0 설정\n * <p><strong>제공 기능:</strong>\n * <ul>\n *   <li>API 정보 (제목, 버전, 설명)\n *   <li>Security Scheme (Bearer Token)\n *   <li>공통 응답 스키마 (ApiResponse, ProblemDetail)\n * </ul>\n */\n@Configuration\npublic class OpenApiConfig {\n\n    private static final String SECURITY_SCHEME_NAME = \"bearerAuth\";\n\n    /**\n     * OpenAPI 설정 Bean\n     * @return OpenAPI 설정 객체\n     */\n    @Bean\n    public OpenAPI openAPI() {\n        return new OpenAPI()\n            .info(apiInfo())\n            .servers(servers())\n            .components(securityComponents())\n            .addSecurityItem(new SecurityRequirement().addList(SECURITY_SCHEME_NAME));\n    }\n\n    private Info apiInfo() {\n        return new Info()\n            .title(\"CrawlingHub REST API\")\n            .version(\"1.0.0\")\n            .description(\"## 인증\\n모든 API는 Bearer Token 인증이 필요합니다.\")\n            .contact(new Contact().name(\"Development Team\").email(\"dev@example.com\"));\n    }\n\n    private Components securityComponents() {\n        return new Components()\n            .addSecuritySchemes(SECURITY_SCHEME_NAME,\n                new SecurityScheme()\n                    .type(SecurityScheme.Type.HTTP)\n                    .scheme(\"bearer\")\n                    .bearerFormat(\"JWT\"))\n            .schemas(responseSchemas());\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    private Map<String, Schema> responseSchemas() {\n        return Map.of(\n            \"ApiResponse\", apiResponseSchema(),\n            \"ProblemDetail\", problemDetailSchema());\n    }\n}','JAVA','CFG-001 Good:\n• config/OpenApiConfig.java: 중앙 집중식 Swagger 설정\n• API 정보: title, version, description 전역 정의\n• Security Scheme: Bearer Token (JWT) 인증 설정\n• 공통 스키마: ApiResponse, ProblemDetail 재사용 정의\n• @Bean Javadoc: Bean 역할과 설정 내용 문서화','[12, 13, 20, 21, 37, 38, 39, 40, 41, 42, 43, 44]','2026-01-16 02:26:09','2026-01-16 02:26:09','MANUAL',NULL,NULL),(29,55,'GOOD','/**\n * Jackson ObjectMapper 설정\n *\n * <p>RFC 7807 ProblemDetail의 extension properties가 루트 레벨에\n * 평탄화되도록 ProblemDetailJacksonMixin을 등록합니다.\n *\n * <p><strong>Mixin 적용 전:</strong>\n * <pre>{@code\n * { \"status\": 400, \"properties\": { \"code\": \"ERROR\" } }\n * }</pre>\n *\n * <p><strong>Mixin 적용 후:</strong>\n * <pre>{@code\n * { \"status\": 400, \"code\": \"ERROR\" }\n * }</pre>\n */\n@Configuration\npublic class JacksonConfig {\n\n    /**\n     * ProblemDetail Mixin 등록\n     *\n     * <p>Spring Framework의 ProblemDetailJacksonMixin을 ObjectMapper에 등록하여\n     * extension properties가 루트 레벨에 직렬화되도록 합니다.\n     */\n    @Bean\n    public Jackson2ObjectMapperBuilderCustomizer problemDetailMixinCustomizer() {\n        return builder -> builder.mixIn(ProblemDetail.class, ProblemDetailJacksonMixin.class);\n    }\n\n    /**\n     * ParameterNamesModule 등록\n     *\n     * <p>Java Record의 생성자 파라미터 이름을 Jackson이 인식할 수 있도록 합니다.\n     * -parameters 컴파일 옵션과 함께 사용합니다.\n     */\n    @Bean\n    public Jackson2ObjectMapperBuilderCustomizer parameterNamesModuleCustomizer() {\n        return builder -> builder.modules(new ParameterNamesModule());\n    }\n}','JAVA','CFG-002 Good:\n• config/JacksonConfig.java: 중앙 집중식 Jackson 설정\n• ProblemDetailJacksonMixin: RFC 7807 extension properties 평탄화\n• ParameterNamesModule: Java Record 지원\n• Jackson2ObjectMapperBuilderCustomizer: Spring Boot 방식 커스터마이징\n• Javadoc: 설정 의도와 전/후 비교 예시 명시\n• DTO에 @JsonFormat 등 개별 설정 금지 (DTO-006 참조)','[17, 18, 26, 27, 28, 36, 37, 38]','2026-01-16 02:26:09','2026-01-16 02:26:09','MANUAL',NULL,NULL),(30,56,'GOOD','/**\n * WebMvc 설정\n *\n * <p>CORS, Interceptor, MessageConverter 등 웹 관련 설정을 정의합니다.\n */\n@Configuration\npublic class WebMvcConfig implements WebMvcConfigurer {\n\n    /**\n     * CORS 설정\n     *\n     * <p>개발 환경에서 localhost:3000 (프론트엔드) 요청을 허용합니다.\n     * 운영 환경에서는 application.yml에서 설정을 주입받아야 합니다.\n     *\n     * @param registry CORS 레지스트리\n     */\n    @Override\n    public void addCorsMappings(CorsRegistry registry) {\n        registry.addMapping(\"/api/**\")\n            .allowedOrigins(\"http://localhost:3000\")\n            .allowedMethods(\"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\")\n            .allowCredentials(true);\n    }\n\n    /**\n     * 요청 로깅 인터셉터 등록\n     *\n     * <p>모든 API 요청에 대해 로깅 인터셉터를 적용합니다.\n     * /actuator/** 경로는 제외합니다.\n     *\n     * @param registry 인터셉터 레지스트리\n     */\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(loggingInterceptor())\n            .addPathPatterns(\"/api/**\")\n            .excludePathPatterns(\"/actuator/**\");\n    }\n\n    @Bean\n    public LoggingInterceptor loggingInterceptor() {\n        return new LoggingInterceptor();\n    }\n}','JAVA','CFG-003, 004 Good:\n• *Config 접미사: 설정 클래스임을 명확히 표시\n• config/ 패키지: 설정 파일 위치 일관성\n• Javadoc: 클래스 역할과 제공 기능 설명\n• @Bean/@Override 메서드: 상세 Javadoc으로 설정 의도 명시\n• 환경별 주의사항: 개발/운영 환경 차이점 명시','[6, 7, 10, 11, 12, 13, 25, 26, 27, 28, 29]','2026-01-16 02:26:09','2026-01-16 02:26:09','MANUAL',NULL,NULL),(31,41,'GOOD','/**\n * REST Docs 테스트 지원 추상 클래스\n *\n * <p>MockMvc, ObjectMapper, REST Docs 설정을 제공합니다.\n */\n@ExtendWith(RestDocumentationExtension.class)\npublic abstract class RestDocsTestSupport {\n\n    protected MockMvc mockMvc;\n    protected ObjectMapper objectMapper;\n\n    @BeforeEach\n    void setUp(WebApplicationContext context, RestDocumentationContextProvider restDocs) {\n        this.objectMapper = new ObjectMapper()\n            .registerModule(new JavaTimeModule())\n            .disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n\n        this.mockMvc = MockMvcBuilders.webAppContextSetup(context)\n            .apply(documentationConfiguration(restDocs)\n                .operationPreprocessors()\n                .withRequestDefaults(prettyPrint())\n                .withResponseDefaults(prettyPrint()))\n            .build();\n    }\n}\n\n// 테스트 클래스에서 @MockitoBean으로 의존성 Mock\n@WebMvcTest(TechStackCommandController.class)\nclass TechStackCommandControllerDocsTest extends RestDocsTestSupport {\n\n    @MockitoBean private TechStackCommandApiMapper mapper;\n    @MockitoBean private CreateTechStackUseCase createTechStackUseCase;\n    @MockitoBean private UpdateTechStackUseCase updateTechStackUseCase;\n\n    // Filter dependencies - 실제 필터가 로드되지 않도록 Mock\n    @MockitoBean private SecurityContextAuthenticator authenticator;\n    @MockitoBean private UserContextMapper userContextMapper;\n    @MockitoBean private ErrorMapperRegistry errorMapperRegistry;\n}','JAVA','TEST-002 Good (보충):\n• RestDocsTestSupport: MockMvc, ObjectMapper 공통 설정 제공\n• @ExtendWith(RestDocumentationExtension.class): REST Docs 확장\n• prettyPrint(): 문서 가독성을 위한 포맷팅\n• @MockitoBean UseCase: 비즈니스 로직 Mock\n• @MockitoBean Mapper: 변환 로직 Mock\n• @MockitoBean Filter dependencies: Security Filter 의존성 Mock\n• Slice Test 원칙: Controller 레이어만 격리 테스트','[6, 7, 30, 31, 32, 33, 34, 35, 36]','2026-01-16 02:26:09','2026-01-16 02:26:09','MANUAL',NULL,NULL),(32,67,'GOOD','@Component\npublic class OrderOutboxScheduler {\n\n    // ✅ UseCase 인터페이스만 의존\n    private final ProcessOrderOutboxUseCase processOrderOutboxUseCase;\n\n    public OrderOutboxScheduler(ProcessOrderOutboxUseCase processOrderOutboxUseCase) {\n        this.processOrderOutboxUseCase = processOrderOutboxUseCase;\n    }\n\n    @Scheduled(fixedDelay = 5000)\n    public void processOutbox() {\n        // ✅ UseCase.execute() 단일 호출\n        processOrderOutboxUseCase.execute();\n    }\n}','JAVA','Thin Scheduler는 UseCase 인터페이스만 의존. UseCase 인터페이스만 주입받아 비즈니스 로직을 완전히 위임합니다.',NULL,'2026-01-16 02:26:25','2026-01-16 02:26:25','MANUAL',NULL,NULL),(33,67,'BAD','@Component\npublic class OrderOutboxScheduler {\n\n    // ❌ Manager 직접 주입 금지\n    private final OutboxReadManager outboxReadManager;\n    private final OutboxPersistenceManager outboxPersistenceManager;\n    private final DistributedLockManager lockManager;\n\n    @Scheduled(fixedDelay = 5000)\n    public void processOutbox() {\n        // ❌ 비즈니스 로직이 Scheduler에 존재\n        if (!lockManager.tryLock(\"order-outbox\", Duration.ofMinutes(5))) {\n            return;\n        }\n        try {\n            List<Outbox> items = outboxReadManager.findPending(100);\n            for (Outbox item : items) {\n                // 처리 로직...\n                outboxPersistenceManager.markAsProcessed(item.id());\n            }\n        } finally {\n            lockManager.unlock(\"order-outbox\");\n        }\n    }\n}','JAVA','Thin Scheduler에 Manager/Port 직접 주입 금지. Manager, Port, Repository를 직접 주입하면 Thin Layer 원칙을 위반합니다.',NULL,'2026-01-16 02:26:25','2026-01-16 02:26:25','MANUAL',NULL,NULL),(34,68,'GOOD','@Component\npublic class PaymentRetryScheduler {\n\n    private final RetryFailedPaymentUseCase retryFailedPaymentUseCase;\n\n    public PaymentRetryScheduler(RetryFailedPaymentUseCase retryFailedPaymentUseCase) {\n        this.retryFailedPaymentUseCase = retryFailedPaymentUseCase;\n    }\n\n    @Scheduled(fixedDelay = 60000)\n    public void retryFailedPayments() {\n        // ✅ UseCase.execute() 단일 호출만!\n        retryFailedPaymentUseCase.execute();\n    }\n}','JAVA','@Scheduled 메서드는 UseCase.execute() 한 줄만. @Scheduled 메서드 body에는 UseCase.execute() 호출만 포함합니다.',NULL,'2026-01-16 02:26:25','2026-01-16 02:26:25','MANUAL',NULL,NULL),(35,68,'BAD','@Component\npublic class PaymentRetryScheduler {\n\n    private final RetryFailedPaymentUseCase retryFailedPaymentUseCase;\n\n    @Scheduled(fixedDelay = 60000)\n    public void retryFailedPayments() {\n        // ❌ 로깅 추가 금지\n        log.info(\"Starting payment retry...\");\n\n        // ❌ 시간 측정 금지\n        long startTime = System.currentTimeMillis();\n\n        retryFailedPaymentUseCase.execute();\n\n        // ❌ 후처리 로직 금지\n        long elapsed = System.currentTimeMillis() - startTime;\n        log.info(\"Completed in {} ms\", elapsed);\n    }\n}','JAVA','@Scheduled 메서드에 여러 줄 로직 금지. 로깅, 조건 분기, 전후 처리 등을 추가하면 안 됩니다.',NULL,'2026-01-16 02:26:25','2026-01-16 02:26:25','MANUAL',NULL,NULL),(36,69,'GOOD','@Component\npublic class NotificationScheduler {\n\n    private final ProcessNotificationOutboxUseCase processNotificationOutboxUseCase;\n\n    public NotificationScheduler(ProcessNotificationOutboxUseCase processNotificationOutboxUseCase) {\n        this.processNotificationOutboxUseCase = processNotificationOutboxUseCase;\n    }\n\n    // ✅ Thin Scheduler: 호출만 담당\n    // 분산락, 배치 처리, 예외 처리 등은 모두 UseCase 내부에서 처리\n    @Scheduled(fixedDelay = 5000)\n    public void processNotifications() {\n        processNotificationOutboxUseCase.execute();\n    }\n}','JAVA','Thin Scheduler는 비즈니스 로직 없이 호출만. 분산락, 배치 조회, 상태 업데이트 등 모든 로직은 Application Layer에 위임합니다.',NULL,'2026-01-16 02:26:25','2026-01-16 02:26:25','MANUAL',NULL,NULL),(37,69,'BAD','@Component\npublic class NotificationScheduler {\n\n    // ❌ 여러 컴포넌트 주입\n    private final DistributedLockManager lockManager;\n    private final NotificationOutboxReadManager outboxReadManager;\n    private final NotificationClientManager clientManager;\n    private final NotificationOutboxPersistenceManager outboxPersistenceManager;\n\n    @Scheduled(fixedDelay = 5000)\n    public void processNotifications() {\n        // ❌ 분산락 로직\n        if (!lockManager.tryLock(\"notification-outbox\", Duration.ofMinutes(5))) {\n            return;\n        }\n\n        try {\n            // ❌ 배치 조회 로직\n            List<NotificationOutbox> outboxes = outboxReadManager.findPending(100);\n\n            for (NotificationOutbox outbox : outboxes) {\n                try {\n                    // ❌ 외부 호출 로직\n                    clientManager.send(outbox.toNotification());\n                    // ❌ 상태 업데이트 로직\n                    outboxPersistenceManager.markAsSuccess(outbox.id());\n                } catch (Exception e) {\n                    outboxPersistenceManager.incrementRetryCount(outbox.id());\n                }\n            }\n        } finally {\n            lockManager.unlock(\"notification-outbox\");\n        }\n    }\n}','JAVA','Thin Scheduler에 분산락/배치 로직 포함 금지. Thin Scheduler에 비즈니스 로직이 들어가면 테스트와 유지보수가 어려워집니다.',NULL,'2026-01-16 02:26:25','2026-01-16 02:26:25','MANUAL',NULL,NULL),(38,70,'GOOD','@Component\npublic class OrderOutboxScheduler {\n\n    private final ProcessOrderOutboxUseCase processOrderOutboxUseCase;\n\n    public OrderOutboxScheduler(ProcessOrderOutboxUseCase processOrderOutboxUseCase) {\n        this.processOrderOutboxUseCase = processOrderOutboxUseCase;\n    }\n\n    // ✅ fixedDelay: 이전 작업 완료 후 5초 대기\n    // 작업 시간이 길어져도 중첩 실행되지 않음\n    @Scheduled(fixedDelay = 5000)\n    public void processOutbox() {\n        processOrderOutboxUseCase.execute();\n    }\n}','JAVA','fixedDelay로 작업 중첩 방지. fixedDelay는 이전 작업 완료 후 지연을 적용하여 작업이 중첩되지 않습니다.',NULL,'2026-01-16 02:26:25','2026-01-16 02:26:25','MANUAL',NULL,NULL),(39,70,'BAD','@Component\npublic class OrderOutboxScheduler {\n\n    private final ProcessOrderOutboxUseCase processOrderOutboxUseCase;\n\n    public OrderOutboxScheduler(ProcessOrderOutboxUseCase processOrderOutboxUseCase) {\n        this.processOrderOutboxUseCase = processOrderOutboxUseCase;\n    }\n\n    // ⚠️ fixedRate: 작업 완료와 무관하게 5초마다 실행\n    // 작업이 5초 이상 걸리면 중첩 실행됨!\n    // 예: 작업A(7초) 실행 중에 작업B 시작 → 동시 실행 문제\n    @Scheduled(fixedRate = 5000)\n    public void processOutbox() {\n        processOrderOutboxUseCase.execute();\n    }\n}','JAVA','fixedRate는 작업 중첩 위험. fixedRate는 작업 완료와 무관하게 일정 간격으로 실행되어 중첩될 수 있습니다.',NULL,'2026-01-16 02:26:25','2026-01-16 02:26:25','MANUAL',NULL,NULL),(40,73,'GOOD','@Component\npublic class InventoryScheduler {\n\n    private final SyncInventoryUseCase syncInventoryUseCase;\n\n    public InventoryScheduler(SyncInventoryUseCase syncInventoryUseCase) {\n        this.syncInventoryUseCase = syncInventoryUseCase;\n    }\n\n    // ✅ 예외 처리 없음 - UseCase에서 처리\n    // UseCase 내부에서 try-catch, 로깅, 재시도 등 처리\n    @Scheduled(fixedDelay = 30000)\n    public void syncInventory() {\n        syncInventoryUseCase.execute();\n    }\n}','JAVA','Thin Scheduler는 예외 처리를 UseCase에 위임. 모든 예외 처리는 UseCase 구현체 내부에서 처리합니다.',NULL,'2026-01-16 02:26:25','2026-01-16 02:26:25','MANUAL',NULL,NULL),(41,73,'BAD','@Component\npublic class InventoryScheduler {\n\n    private final SyncInventoryUseCase syncInventoryUseCase;\n\n    public InventoryScheduler(SyncInventoryUseCase syncInventoryUseCase) {\n        this.syncInventoryUseCase = syncInventoryUseCase;\n    }\n\n    @Scheduled(fixedDelay = 30000)\n    public void syncInventory() {\n        // ❌ Scheduler에서 예외 처리 금지\n        try {\n            syncInventoryUseCase.execute();\n        } catch (ExternalApiException e) {\n            // ❌ 재시도 로직 금지 - UseCase에서 처리해야 함\n            log.error(\"External API failed, will retry next cycle\", e);\n        } catch (Exception e) {\n            // ❌ 일반 예외 처리도 금지\n            log.error(\"Unexpected error in inventory sync\", e);\n        }\n    }\n}','JAVA','Thin Scheduler에서 try-catch 금지. Scheduler에서 예외 처리하면 비즈니스 로직이 분산됩니다.',NULL,'2026-01-16 02:26:26','2026-01-16 02:26:26','MANUAL',NULL,NULL),(42,74,'GOOD','package com.ryuqq.domain.order.aggregate;\n\nimport com.ryuqq.domain.order.id.OrderId;\nimport com.ryuqq.domain.order.vo.OrderStatus;\nimport com.ryuqq.domain.order.event.OrderCreatedEvent;\nimport com.ryuqq.domain.common.event.DomainEvent;\n\nimport java.time.Instant;\nimport java.util.List;\n\n/**\n * Order Aggregate Root.\n */\npublic class Order {\n    // Aggregate 구현\n}','JAVA','Aggregate Root는 domain.{bc}.aggregate 패키지에 위치합니다. 같은 Bounded Context 내의 id, vo, event 패키지를 import할 수 있습니다.','[1]','2026-01-16 02:26:53','2026-01-16 02:26:53','MANUAL',NULL,NULL),(43,75,'GOOD','public class Order {\n\n    /**\n     * 새로운 Order 생성을 위한 팩토리 메서드.\n     *\n     * @param customerId 고객 ID\n     * @param items 주문 항목\n     * @param now 생성 시점 (외부 주입)\n     * @return 새로운 Order 인스턴스\n     */\n    public static Order forNew(\n            CustomerId customerId,\n            List<OrderItem> items,\n            Instant now) {\n        validateForNew(customerId, items);\n        Order order = new Order(\n            OrderId.forNew(),\n            customerId,\n            items,\n            OrderStatus.PENDING,\n            now,\n            now\n        );\n        order.registerEvent(OrderCreatedEvent.from(order, now));\n        return order;\n    }\n\n    private static void validateForNew(CustomerId customerId, List<OrderItem> items) {\n        if (customerId == null) {\n            throw new IllegalArgumentException(\"customerId must not be null\");\n        }\n        if (items == null || items.isEmpty()) {\n            throw new IllegalArgumentException(\"items must not be empty\");\n        }\n    }\n}','JAVA','forNew()는 새로운 Aggregate 생성을 위한 정적 팩토리 메서드입니다. 검증 → 생성 → 이벤트 발행 순서로 처리합니다. Instant는 외부에서 주입받습니다.','[11, 12, 13, 14, 22]','2026-01-16 02:26:53','2026-01-16 02:26:53','MANUAL',NULL,NULL),(44,76,'GOOD','public class Order {\n\n    /**\n     * DB에서 복원하기 위한 팩토리 메서드.\n     * 검증 없이 그대로 복원합니다.\n     *\n     * @param id 주문 ID\n     * @param customerId 고객 ID\n     * @param status 주문 상태\n     * @param createdAt 생성 시점\n     * @param updatedAt 수정 시점\n     * @return 복원된 Order 인스턴스\n     */\n    public static Order reconstitute(\n            OrderId id,\n            CustomerId customerId,\n            OrderStatus status,\n            Instant createdAt,\n            Instant updatedAt) {\n        // DB 데이터는 이미 검증된 데이터이므로 검증 생략\n        // 이벤트 발행하지 않음\n        return new Order(id, customerId, status, createdAt, updatedAt);\n    }\n}','JAVA','reconstitute()는 DB에서 Aggregate를 복원하기 위한 팩토리 메서드입니다. DB 데이터는 이미 검증된 것이므로 검증을 생략하고, 이벤트도 발행하지 않습니다.','[14, 15, 16, 17, 18, 19, 22]','2026-01-16 02:26:53','2026-01-16 02:26:53','MANUAL',NULL,NULL),(45,77,'GOOD','public class Order {\n\n    private final OrderId id;\n    private final CustomerId customerId;\n    private OrderStatus status;\n    private final Instant createdAt;\n    private Instant updatedAt;\n\n    // private 생성자 - 외부에서 직접 호출 불가\n    private Order(\n            OrderId id,\n            CustomerId customerId,\n            OrderStatus status,\n            Instant createdAt,\n            Instant updatedAt) {\n        this.id = id;\n        this.customerId = customerId;\n        this.status = status;\n        this.createdAt = createdAt;\n        this.updatedAt = updatedAt;\n    }\n\n    // JPA용 protected 기본 생성자\n    protected Order() {\n        this.id = null;\n        this.customerId = null;\n        this.status = null;\n        this.createdAt = null;\n        this.updatedAt = null;\n    }\n\n    // 생성은 forNew(), 복원은 reconstitute() 사용\n    public static Order forNew(...) { ... }\n    public static Order reconstitute(...) { ... }\n}','JAVA','생성자는 private 또는 protected로 선언합니다. 객체 생성은 forNew()/reconstitute() 팩토리 메서드를 통해서만 가능합니다. JPA 프록시를 위해 protected 기본 생성자를 제공합니다.','[10, 11, 24, 25]','2026-01-16 02:26:53','2026-01-16 02:26:53','MANUAL',NULL,NULL),(46,78,'GOOD','public class Order {\n\n    private OrderStatus status;\n    private Instant updatedAt;\n\n    // ❌ Setter 금지\n    // public void setStatus(OrderStatus status) { ... }\n\n    // ✅ 비즈니스 의도가 드러나는 명시적 메서드\n    public void confirm(Instant now) {\n        if (this.status != OrderStatus.PENDING) {\n            throw new IllegalStateException(\"Only PENDING order can be confirmed\");\n        }\n        this.status = OrderStatus.CONFIRMED;\n        this.updatedAt = now;\n        registerEvent(OrderConfirmedEvent.from(this, now));\n    }\n\n    public void cancel(String reason, Instant now) {\n        if (this.status.isTerminal()) {\n            throw new IllegalStateException(\"Cannot cancel terminal order\");\n        }\n        this.status = OrderStatus.CANCELLED;\n        this.updatedAt = now;\n        registerEvent(OrderCancelledEvent.from(this, reason, now));\n    }\n\n    public void ship(TrackingNumber trackingNumber, Instant now) {\n        if (this.status != OrderStatus.CONFIRMED) {\n            throw new IllegalStateException(\"Only CONFIRMED order can be shipped\");\n        }\n        this.status = OrderStatus.SHIPPED;\n        this.trackingNumber = trackingNumber;\n        this.updatedAt = now;\n        registerEvent(OrderShippedEvent.from(this, now));\n    }\n}','JAVA','Setter 메서드를 사용하지 않습니다. 상태 변경은 비즈니스 의도가 명확한 메서드(confirm, cancel, ship)로 수행합니다. 각 메서드는 불변식 검증 후 상태를 변경하고 이벤트를 발행합니다.','[10, 11, 19, 20, 27, 28]','2026-01-16 02:26:53','2026-01-16 02:26:53','MANUAL',NULL,NULL),(47,79,'GOOD','package com.ryuqq.domain.order.aggregate;\n\n// ❌ Lombok 금지\n// import lombok.Getter;\n// import lombok.Builder;\n// import lombok.RequiredArgsConstructor;\n\nimport java.time.Instant;\n\n/**\n * Order Aggregate Root.\n * Lombok 없이 순수 Java로 구현합니다.\n */\npublic class Order {\n\n    private final OrderId id;\n    private String name;\n    private final Instant createdAt;\n\n    // 명시적 생성자\n    private Order(OrderId id, String name, Instant createdAt) {\n        this.id = id;\n        this.name = name;\n        this.createdAt = createdAt;\n    }\n\n    // 명시적 접근자 (Getter가 아닌 도메인 용어 사용)\n    public OrderId id() {\n        return id;\n    }\n\n    public String name() {\n        return name;\n    }\n\n    public Instant createdAt() {\n        return createdAt;\n    }\n}','JAVA','Domain Layer에서 Lombok(@Getter, @Setter, @Builder, @Data 등) 사용이 금지됩니다. 생성자와 접근자를 명시적으로 작성합니다. 접근자는 getXxx() 대신 xxx() 형태를 권장합니다.','[3, 4, 5, 6, 20, 21, 27, 28, 31, 32, 35, 36]','2026-01-16 02:26:53','2026-01-16 02:26:53','MANUAL',NULL,NULL),(48,81,'GOOD','public class Order {\n\n    private final ShippingAddress shippingAddress;\n    private final Customer customer;\n\n    // ❌ Bad: 외부에서 Getter 체이닝 유발\n    // public ShippingAddress getShippingAddress() { return shippingAddress; }\n    // 사용: order.getShippingAddress().getCity() - Law of Demeter 위반\n\n    // ✅ Good: 위임 메서드로 필요한 정보만 노출\n    public String deliveryCity() {\n        return shippingAddress.city();\n    }\n\n    public String deliveryFullAddress() {\n        return shippingAddress.fullAddress();\n    }\n\n    public boolean isVipCustomer() {\n        return customer.isVip();\n    }\n\n    public String customerName() {\n        return customer.name();\n    }\n}','JAVA','Law of Demeter: 객체 내부 구조를 노출하는 Getter 체이닝(order.getCustomer().getAddress().getCity())을 금지합니다. 위임 메서드(deliveryCity())로 필요한 정보만 노출합니다.','[11, 12, 15, 16, 19, 20, 23, 24]','2026-01-16 02:26:53','2026-01-16 02:26:53','MANUAL',NULL,NULL),(49,82,'GOOD','public class Order {\n\n    // ❌ Bad: 상태를 물어보고 외부에서 판단\n    // if (order.getStatus() == OrderStatus.PENDING) {\n    //     order.setStatus(OrderStatus.CONFIRMED);\n    // }\n\n    // ✅ Good: 객체에게 행동을 요청\n    public void confirm(Instant now) {\n        // 상태 판단은 객체 내부에서 수행\n        if (!canConfirm()) {\n            throw new OrderCannotBeConfirmedException(this.id);\n        }\n        this.status = OrderStatus.CONFIRMED;\n        this.updatedAt = now;\n        registerEvent(OrderConfirmedEvent.from(this, now));\n    }\n\n    // 내부 상태 판단 메서드\n    private boolean canConfirm() {\n        return this.status == OrderStatus.PENDING;\n    }\n\n    // 상태 확인이 필요한 경우 의미 있는 메서드 제공\n    public boolean isConfirmable() {\n        return canConfirm();\n    }\n\n    public boolean isShippable() {\n        return this.status == OrderStatus.CONFIRMED;\n    }\n\n    public boolean isTerminal() {\n        return this.status == OrderStatus.COMPLETED\n            || this.status == OrderStatus.CANCELLED;\n    }\n}','JAVA','Tell, Don\'t Ask: 객체의 상태를 물어보고 외부에서 판단하지 않습니다. 객체에게 행동(confirm, cancel)을 요청하고, 판단은 객체 내부에서 수행합니다.','[9, 10, 11, 12, 25, 26, 29, 30, 33, 34]','2026-01-16 02:26:53','2026-01-16 02:26:53','MANUAL',NULL,NULL),(50,83,'GOOD','public class Order {\n\n    // ❌ Bad: 내부에서 시간 생성\n    // public static Order forNew(CustomerId customerId) {\n    //     Instant now = Instant.now();  // 금지\n    //     return new Order(OrderId.forNew(), customerId, now, now);\n    // }\n\n    // ❌ Bad: Clock 주입\n    // public static Order forNew(CustomerId customerId, Clock clock) {\n    //     Instant now = Instant.now(clock);\n    //     return new Order(OrderId.forNew(), customerId, now, now);\n    // }\n\n    // ✅ Good: Instant 파라미터로 외부 주입\n    public static Order forNew(CustomerId customerId, List<OrderItem> items, Instant now) {\n        validateForNew(customerId, items);\n        return new Order(OrderId.forNew(), customerId, items, now, now);\n    }\n\n    public void confirm(Instant now) {\n        this.status = OrderStatus.CONFIRMED;\n        this.updatedAt = now;\n    }\n\n    public void cancel(String reason, Instant now) {\n        this.status = OrderStatus.CANCELLED;\n        this.updatedAt = now;\n    }\n}','JAVA','Domain Layer에서 Instant.now()나 Clock을 직접 사용하지 않습니다. 시간은 Instant 파라미터로 외부(Application Layer)에서 주입받습니다. 테스트 시 시간 제어가 용이합니다.','[16, 17, 21, 25]','2026-01-16 02:26:53','2026-01-16 02:26:53','MANUAL',NULL,NULL),(51,86,'GOOD','public class Order {\n\n    private String name;\n    private String description;\n    private OrderStatus status;\n    private Instant updatedAt;\n\n    /**\n     * UpdateData를 사용한 부분 업데이트.\n     * null이 아닌 필드만 업데이트됩니다.\n     */\n    public void applyUpdate(OrderUpdateData updateData, Instant now) {\n        if (updateData.hasName()) {\n            this.name = updateData.name();\n        }\n        if (updateData.hasDescription()) {\n            this.description = updateData.description();\n        }\n        if (updateData.hasStatus()) {\n            validateStatusTransition(updateData.status());\n            this.status = updateData.status();\n        }\n        this.updatedAt = now;\n    }\n\n    private void validateStatusTransition(OrderStatus newStatus) {\n        if (!this.status.canTransitionTo(newStatus)) {\n            throw new InvalidStatusTransitionException(this.status, newStatus);\n        }\n    }\n}\n\n// UpdateData Record\npublic record OrderUpdateData(\n    String name,\n    String description,\n    OrderStatus status\n) {\n    public boolean hasName() { return name != null; }\n    public boolean hasDescription() { return description != null; }\n    public boolean hasStatus() { return status != null; }\n}','JAVA','UpdateData Record를 사용하여 부분 업데이트를 처리합니다. null이면 변경하지 않음을 의미합니다. hasXxx() 메서드로 변경 여부를 확인하고, 상태 전이는 내부에서 검증합니다.','[12, 13, 14, 15, 17, 18, 20, 21, 22, 36, 37, 38]','2026-01-16 02:26:54','2026-01-16 02:26:54','MANUAL',NULL,NULL),(52,88,'GOOD','public class Order {\n\n    private final OrderId id;\n    private String name;\n    private OrderStatus status;\n\n    // ID 기반 동등성 비교\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Order order = (Order) o;\n        // ID가 null이면 동등하지 않음 (신규 객체)\n        return id != null && id.equals(order.id);\n    }\n\n    @Override\n    public int hashCode() {\n        // ID가 null이면 0 반환\n        return id != null ? id.hashCode() : 0;\n    }\n\n    // name, status 등 다른 필드는 비교하지 않음\n    // Entity의 동등성은 ID로만 판단\n}','JAVA','Aggregate의 equals/hashCode는 ID 기반으로 구현합니다. 다른 필드(name, status 등)는 비교하지 않습니다. ID가 null인 신규 객체는 동등하지 않은 것으로 처리합니다.','[9, 10, 11, 12, 14, 18, 19]','2026-01-16 02:26:54','2026-01-16 02:26:54','MANUAL',NULL,NULL),(53,89,'GOOD','public class Order {\n\n    private final Money totalAmount;\n    private final Email customerEmail;\n    private final PhoneNumber customerPhone;\n\n    // ❌ Bad: Aggregate에서 복잡한 검증 로직 직접 구현\n    // private void validateEmail(String email) {\n    //     Pattern pattern = Pattern.compile(\"^[A-Za-z0-9+_.-]+@(.+)$\");\n    //     if (!pattern.matcher(email).matches()) { ... }\n    // }\n\n    // ✅ Good: 복잡한 검증/계산은 VO에 위임\n    public static Order forNew(\n            CustomerId customerId,\n            String email,\n            String phone,\n            List<OrderItem> items,\n            Instant now) {\n        // VO 생성 시 검증이 자동으로 수행됨\n        Email customerEmail = Email.of(email);         // Email VO가 형식 검증\n        PhoneNumber customerPhone = PhoneNumber.of(phone);  // PhoneNumber VO가 검증\n        Money totalAmount = calculateTotal(items);     // Money VO가 금액 계산\n\n        return new Order(\n            OrderId.forNew(),\n            customerId,\n            customerEmail,\n            customerPhone,\n            totalAmount,\n            now\n        );\n    }\n\n    private static Money calculateTotal(List<OrderItem> items) {\n        return items.stream()\n            .map(OrderItem::subtotal)\n            .reduce(Money.zero(), Money::add);\n    }\n}','JAVA','복잡한 비즈니스 규칙(검증, 계산, 형식 확인)은 Value Object에 위임합니다. Aggregate는 VO를 조합하고 전체 불변식을 관리하는 역할에 집중합니다.','[18, 19, 20, 31, 32, 33]','2026-01-16 02:26:54','2026-01-16 02:26:54','MANUAL',NULL,NULL),(54,101,'GOOD','package com.ryuqq.domain.order.id;\n\n/**\n * Order ID Value Object.\n * Long 기반 Auto Increment ID.\n */\npublic record OrderId(Long value) {\n\n    public static OrderId forNew() {\n        return new OrderId(null);\n    }\n\n    public static OrderId of(Long value) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"OrderId value must not be null\");\n        }\n        return new OrderId(value);\n    }\n\n    public boolean isNew() {\n        return value == null;\n    }\n}','JAVA','ID Value Object는 domain.{bc}.id 패키지에 위치합니다. Bounded Context별로 ID를 분리하여 관리합니다.','[1]','2026-01-16 02:26:54','2026-01-16 02:26:54','MANUAL',NULL,NULL),(55,102,'GOOD','// ✅ Good: Record 타입 사용\npublic record OrderId(Long value) {\n\n    // Compact Constructor로 검증\n    public OrderId {\n        // Long ID는 null 허용 (신규 생성 시)\n    }\n\n    public static OrderId forNew() {\n        return new OrderId(null);\n    }\n\n    public static OrderId of(Long value) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"OrderId value must not be null for existing entity\");\n        }\n        return new OrderId(value);\n    }\n\n    public boolean isNew() {\n        return value == null;\n    }\n}\n\n// ❌ Bad: class 타입 사용\n// public class OrderId {\n//     private final Long value;\n//     public OrderId(Long value) { this.value = value; }\n//     public Long getValue() { return value; }\n// }','JAVA','ID Value Object는 반드시 Java Record 타입으로 정의합니다. Record는 불변성, equals/hashCode, toString을 자동 제공합니다.','[2]','2026-01-16 02:26:54','2026-01-16 02:26:54','MANUAL',NULL,NULL),(56,104,'GOOD','public record OrderId(Long value) {\n\n    /**\n     * 새로운 ID 생성 (Auto Increment용).\n     * ID는 null로, persist 시점에 DB에서 할당됩니다.\n     */\n    public static OrderId forNew() {\n        return new OrderId(null);\n    }\n\n    /**\n     * 기존 ID 복원.\n     */\n    public static OrderId of(Long value) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"OrderId value must not be null for existing entity\");\n        }\n        return new OrderId(value);\n    }\n\n    /**\n     * 신규 생성 여부.\n     * @return ID가 null이면 true (아직 persist 전)\n     */\n    public boolean isNew() {\n        return value == null;\n    }\n}\n\n// 사용 예시\n// Order order = Order.forNew(...);  // order.id().isNew() == true\n// orderRepository.save(order);       // DB에서 ID 할당\n// order.id().isNew() == false        // persist 후','JAVA','Long 기반 ID는 forNew() → null 반환, isNew()로 신규 여부 판단 패턴을 사용합니다. Auto Increment 방식에서 ID는 persist 시점에 DB에서 할당됩니다.','[7, 8, 14, 15, 16, 25, 26]','2026-01-16 02:26:54','2026-01-16 02:26:54','MANUAL',NULL,NULL),(57,108,'GOOD','public record OrderId(String value) {\n\n    // Compact Constructor에서 검증\n    public OrderId {\n        if (value == null || value.isBlank()) {\n            throw new IllegalArgumentException(\"OrderId value must not be blank\");\n        }\n    }\n\n    /**\n     * 새로운 ID 생성 (외부 주입 필수).\n     * Application Layer의 ID Generator에서 생성된 값을 받습니다.\n     *\n     * @param value 외부에서 생성된 ID 값 (UUIDv7, Snowflake 등)\n     */\n    public static OrderId forNew(String value) {\n        return new OrderId(value);\n    }\n\n    /**\n     * 기존 ID 복원.\n     */\n    public static OrderId of(String value) {\n        return new OrderId(value);\n    }\n\n    // ❌ String ID는 isNew() 없음\n    // 생성 시점에 이미 값이 존재하므로 신규 여부를 ID로 판단 불가\n}\n\n// Application Layer에서 ID 생성\n// public class CreateOrderService {\n//     private final IdGenerator idGenerator;\n//\n//     public Long execute(CreateOrderCommand cmd, Instant now) {\n//         String newId = idGenerator.generate();  // UUIDv7 등\n//         Order order = Order.forNew(OrderId.forNew(newId), ...);\n//     }\n// }','JAVA','String 기반 ID는 forNew(String value)로 외부에서 생성된 값을 주입받습니다. Domain Layer에서 UUID를 직접 생성하지 않습니다. String ID는 isNew() 메서드가 없습니다.','[4, 5, 6, 16, 17, 27, 28]','2026-01-16 02:26:54','2026-01-16 02:26:54','MANUAL',NULL,NULL),(58,111,'GOOD','package com.ryuqq.domain.order.vo;\n\n/**\n * Order Status Value Object.\n */\npublic enum OrderStatus {\n    PENDING(\"대기중\"),\n    CONFIRMED(\"확정됨\"),\n    SHIPPED(\"배송중\"),\n    COMPLETED(\"완료됨\"),\n    CANCELLED(\"취소됨\");\n\n    private final String displayName;\n\n    OrderStatus(String displayName) {\n        this.displayName = displayName;\n    }\n\n    public String displayName() {\n        return displayName;\n    }\n}','JAVA','Value Object는 domain.{bc}.vo 패키지에 위치합니다. 상태, 금액, 주소 등 도메인 개념을 표현하는 불변 객체입니다.','[1]','2026-01-16 02:26:54','2026-01-16 02:26:54','MANUAL',NULL,NULL),(59,112,'GOOD','// ✅ Good: Record 타입 (단일/복합 값)\npublic record Email(String value) {\n\n    public Email {\n        if (value == null || value.isBlank()) {\n            throw new IllegalArgumentException(\"Email must not be blank\");\n        }\n        if (!value.contains(\"@\")) {\n            throw new IllegalArgumentException(\"Invalid email format\");\n        }\n    }\n\n    public static Email of(String value) {\n        return new Email(value);\n    }\n\n    public String domain() {\n        return value.substring(value.indexOf(\"@\") + 1);\n    }\n}\n\n// ✅ Good: Enum 타입 (유한 집합)\npublic enum PaymentMethod {\n    CREDIT_CARD(\"신용카드\"),\n    BANK_TRANSFER(\"계좌이체\"),\n    VIRTUAL_ACCOUNT(\"가상계좌\");\n\n    private final String displayName;\n\n    PaymentMethod(String displayName) {\n        this.displayName = displayName;\n    }\n\n    public String displayName() {\n        return displayName;\n    }\n}','JAVA','Value Object는 Record(단일/복합 값) 또는 Enum(유한 집합) 타입으로 정의합니다. Compact Constructor에서 검증을 수행합니다.','[2, 22]','2026-01-16 02:26:54','2026-01-16 02:26:54','MANUAL',NULL,NULL),(60,113,'GOOD','public record Money(BigDecimal amount) {\n\n    public Money {\n        if (amount == null) {\n            throw new IllegalArgumentException(\"amount must not be null\");\n        }\n        // 소수점 2자리로 정규화\n        amount = amount.setScale(2, RoundingMode.HALF_UP);\n    }\n\n    // of() 정적 팩토리 메서드\n    public static Money of(BigDecimal amount) {\n        return new Money(amount);\n    }\n\n    public static Money of(long amount) {\n        return new Money(BigDecimal.valueOf(amount));\n    }\n\n    public static Money of(String amount) {\n        return new Money(new BigDecimal(amount));\n    }\n\n    public static Money zero() {\n        return new Money(BigDecimal.ZERO);\n    }\n\n    // 연산 메서드\n    public Money add(Money other) {\n        return new Money(this.amount.add(other.amount));\n    }\n\n    public Money multiply(int quantity) {\n        return new Money(this.amount.multiply(BigDecimal.valueOf(quantity)));\n    }\n}','JAVA','Value Object는 of() 정적 팩토리 메서드를 제공합니다. 다양한 입력 타입(BigDecimal, long, String)에 대한 오버로드와 zero() 같은 특수 팩토리를 제공할 수 있습니다.','[12, 13, 16, 17, 20, 21, 24, 25]','2026-01-16 02:26:54','2026-01-16 02:26:54','MANUAL',NULL,NULL),(61,114,'GOOD','public enum OrderStatus {\n\n    PENDING(\"대기중\"),\n    CONFIRMED(\"확정됨\"),\n    SHIPPED(\"배송중\"),\n    COMPLETED(\"완료됨\"),\n    CANCELLED(\"취소됨\");\n\n    private final String displayName;\n\n    OrderStatus(String displayName) {\n        this.displayName = displayName;\n    }\n\n    /**\n     * UI 표시용 이름.\n     * @return 한글 표시명\n     */\n    public String displayName() {\n        return displayName;\n    }\n\n    // 도메인 로직 메서드\n    public boolean isTerminal() {\n        return this == COMPLETED || this == CANCELLED;\n    }\n\n    public boolean canTransitionTo(OrderStatus target) {\n        return switch (this) {\n            case PENDING -> target == CONFIRMED || target == CANCELLED;\n            case CONFIRMED -> target == SHIPPED || target == CANCELLED;\n            case SHIPPED -> target == COMPLETED;\n            case COMPLETED, CANCELLED -> false;\n        };\n    }\n}','JAVA','Enum Value Object는 displayName() 메서드를 필수로 제공합니다. UI 표시용 한글 이름을 반환합니다. 추가로 도메인 로직 메서드(isTerminal, canTransitionTo)를 포함할 수 있습니다.','[19, 20, 24, 25, 28, 29]','2026-01-16 02:26:54','2026-01-16 02:26:54','MANUAL',NULL,NULL),(62,117,'GOOD','// ✅ Good: Record 사용 - Lombok 불필요\npublic record Address(\n    String zipCode,\n    String city,\n    String street,\n    String detail\n) {\n\n    public Address {\n        if (zipCode == null || zipCode.isBlank()) {\n            throw new IllegalArgumentException(\"zipCode must not be blank\");\n        }\n        if (city == null || city.isBlank()) {\n            throw new IllegalArgumentException(\"city must not be blank\");\n        }\n    }\n\n    public static Address of(String zipCode, String city, String street, String detail) {\n        return new Address(zipCode, city, street, detail);\n    }\n\n    public String fullAddress() {\n        return String.format(\"(%s) %s %s %s\", zipCode, city, street, detail);\n    }\n}\n\n// Record가 자동 제공하는 기능:\n// - 불변성 (final 필드)\n// - 접근자 (zipCode(), city(), street(), detail())\n// - equals(), hashCode(), toString()\n// - Canonical Constructor','JAVA','Value Object에서 Lombok을 사용하지 않습니다. Java Record가 불변성, 접근자, equals/hashCode/toString을 자동 제공하므로 Lombok이 불필요합니다.','[2, 27, 28, 29, 30]','2026-01-16 02:26:54','2026-01-16 02:26:54','MANUAL',NULL,NULL),(63,120,'GOOD','package com.ryuqq.domain.order.event;\n\nimport com.ryuqq.domain.order.id.OrderId;\nimport com.ryuqq.domain.common.event.DomainEvent;\n\nimport java.time.Instant;\n\n/**\n * Order 생성 이벤트.\n */\npublic record OrderCreatedEvent(\n    OrderId orderId,\n    String customerName,\n    Instant occurredAt\n) implements DomainEvent {\n\n    public static OrderCreatedEvent from(Order order, Instant now) {\n        return new OrderCreatedEvent(order.id(), order.customerName(), now);\n    }\n}','JAVA','Domain Event는 domain.{bc}.event 패키지에 위치합니다. Bounded Context별로 이벤트를 분리하여 관리합니다.','[1]','2026-01-16 02:26:54','2026-01-16 02:26:54','MANUAL',NULL,NULL),(64,121,'GOOD','// ✅ Good: Record 타입 + DomainEvent 구현\npublic record OrderCreatedEvent(\n    OrderId orderId,\n    CustomerId customerId,\n    Money totalAmount,\n    Instant occurredAt\n) implements DomainEvent {\n\n    public static OrderCreatedEvent from(Order order, Instant now) {\n        return new OrderCreatedEvent(\n            order.id(),\n            order.customerId(),\n            order.totalAmount(),\n            now\n        );\n    }\n}\n\n// 공통 인터페이스\npackage com.ryuqq.domain.common.event;\n\npublic interface DomainEvent {\n    Instant occurredAt();\n}','JAVA','Domain Event는 반드시 Record 타입으로 정의하고 DomainEvent 인터페이스를 구현합니다. Record는 이벤트의 불변성을 보장합니다.','[2, 7, 21, 22]','2026-01-16 02:26:55','2026-01-16 02:26:55','MANUAL',NULL,NULL),(65,122,'GOOD','// ✅ Good: 과거형 네이밍 (이미 발생한 사실)\npublic record OrderCreatedEvent(...) implements DomainEvent { }\npublic record OrderConfirmedEvent(...) implements DomainEvent { }\npublic record OrderCancelledEvent(...) implements DomainEvent { }\npublic record OrderShippedEvent(...) implements DomainEvent { }\npublic record OrderCompletedEvent(...) implements DomainEvent { }\npublic record PaymentPaidEvent(...) implements DomainEvent { }\npublic record PaymentRefundedEvent(...) implements DomainEvent { }\n\n// ❌ Bad: 현재형/명령형 네이밍\n// public record OrderCreateEvent(...) { }      // 현재형\n// public record CreateOrderEvent(...) { }      // 명령형\n// public record OrderConfirmEvent(...) { }     // 현재형\n\n// 정규식 패턴:\n// ^[A-Z][a-zA-Z]*(ed|ent|aid|ade|one|ept|ilt|elt|ought|aught|old|eld|own|ven|ken|ten|ung|ost|eft)Event$\n// - Created, Confirmed, Cancelled, Completed, Paid, Sent, Made, Done, Bought, Sold, Shown 등','JAVA','Domain Event는 과거형으로 네이밍합니다. 이벤트는 \"이미 발생한 사실\"을 나타내므로 Created, Confirmed, Cancelled 등 과거분사를 사용합니다.','[2, 3, 4, 5, 6, 7, 8]','2026-01-16 02:26:55','2026-01-16 02:26:55','MANUAL',NULL,NULL),(66,123,'GOOD','public record OrderCreatedEvent(\n    OrderId orderId,\n    CustomerId customerId,\n    Money totalAmount,\n    List<OrderItemSnapshot> items,\n    Instant occurredAt\n) implements DomainEvent {\n\n    /**\n     * Aggregate로부터 이벤트 생성.\n     * @param order 이벤트 발생 원인이 된 Aggregate\n     * @param now 이벤트 발생 시점\n     * @return 생성 이벤트\n     */\n    public static OrderCreatedEvent from(Order order, Instant now) {\n        return new OrderCreatedEvent(\n            order.id(),\n            order.customerId(),\n            order.totalAmount(),\n            order.items().stream()\n                .map(OrderItemSnapshot::from)\n                .toList(),\n            now\n        );\n    }\n\n    // 이벤트 내 스냅샷 (이벤트 발생 시점의 상태 보존)\n    public record OrderItemSnapshot(\n        String productId,\n        int quantity,\n        Money unitPrice\n    ) {\n        public static OrderItemSnapshot from(OrderItem item) {\n            return new OrderItemSnapshot(\n                item.productId().value(),\n                item.quantity(),\n                item.unitPrice()\n            );\n        }\n    }\n}','JAVA','Domain Event는 from(Aggregate, Instant) 정적 팩토리 메서드를 제공합니다. Aggregate에서 필요한 정보를 추출하여 이벤트를 생성합니다. 스냅샷으로 이벤트 발생 시점의 상태를 보존합니다.','[15, 16, 17, 18, 19, 20, 21, 22, 23, 32, 33]','2026-01-16 02:26:55','2026-01-16 02:26:55','MANUAL',NULL,NULL),(67,125,'GOOD','// DomainEvent 인터페이스\npackage com.ryuqq.domain.common.event;\n\npublic interface DomainEvent {\n    /**\n     * 이벤트 발생 시점.\n     * @return 발생 시점 (UTC)\n     */\n    Instant occurredAt();\n}\n\n// 구현 예시\npublic record OrderCreatedEvent(\n    OrderId orderId,\n    CustomerId customerId,\n    Instant occurredAt        // 필수 필드\n) implements DomainEvent {\n\n    public static OrderCreatedEvent from(Order order, Instant now) {\n        return new OrderCreatedEvent(\n            order.id(),\n            order.customerId(),\n            now                // 외부에서 주입받은 시간\n        );\n    }\n}\n\n// Aggregate에서 이벤트 발행\npublic class Order {\n    public static Order forNew(CustomerId customerId, Instant now) {\n        Order order = new Order(...);\n        order.registerEvent(OrderCreatedEvent.from(order, now));\n        return order;\n    }\n}','JAVA','Domain Event는 occurredAt(Instant) 필드가 필수입니다. DomainEvent 인터페이스에서 occurredAt() 메서드를 정의하고, 모든 이벤트가 구현합니다.','[5, 6, 7, 15, 22]','2026-01-16 02:26:55','2026-01-16 02:26:55','MANUAL',NULL,NULL),(68,131,'GOOD','package com.ryuqq.domain.order.exception;\n\nimport com.ryuqq.domain.common.exception.DomainException;\nimport com.ryuqq.domain.order.id.OrderId;\n\n/**\n * Order를 찾을 수 없을 때 발생하는 예외.\n */\npublic class OrderNotFoundException extends DomainException {\n\n    private final OrderId orderId;\n\n    public OrderNotFoundException(OrderId orderId) {\n        super(OrderErrorCode.ORDER_NOT_FOUND,\n            String.format(\"Order not found: %s\", orderId.value()));\n        this.orderId = orderId;\n    }\n\n    public OrderId getOrderId() {\n        return orderId;\n    }\n}','JAVA','Domain Exception은 domain.{bc}.exception 패키지에 위치합니다. Bounded Context별로 예외를 분리하여 관리합니다.','[1]','2026-01-16 02:26:55','2026-01-16 02:26:55','MANUAL',NULL,NULL),(69,133,'GOOD','// 공통 DomainException\npackage com.ryuqq.domain.common.exception;\n\npublic class DomainException extends RuntimeException {\n\n    private final ErrorCode errorCode;\n\n    public DomainException(ErrorCode errorCode) {\n        super(errorCode.getMessage());\n        this.errorCode = errorCode;\n    }\n\n    public DomainException(ErrorCode errorCode, String message) {\n        super(message);\n        this.errorCode = errorCode;\n    }\n\n    public DomainException(ErrorCode errorCode, Throwable cause) {\n        super(errorCode.getMessage(), cause);\n        this.errorCode = errorCode;\n    }\n\n    public ErrorCode getErrorCode() {\n        return errorCode;\n    }\n\n    public String getCode() {\n        return errorCode.getCode();\n    }\n\n    public int getHttpStatus() {\n        return errorCode.getHttpStatus();\n    }\n}\n\n// BC별 Exception\npublic class OrderNotFoundException extends DomainException {\n    public OrderNotFoundException(OrderId orderId) {\n        super(OrderErrorCode.ORDER_NOT_FOUND,\n            String.format(\"Order not found: %s\", orderId.value()));\n    }\n}\n\npublic class OrderCannotBeCancelledException extends DomainException {\n    public OrderCannotBeCancelledException(OrderId orderId, OrderStatus currentStatus) {\n        super(OrderErrorCode.ORDER_CANNOT_BE_CANCELLED,\n            String.format(\"Order %s cannot be cancelled. Current status: %s\",\n                orderId.value(), currentStatus));\n    }\n}','JAVA','모든 Domain Exception은 DomainException을 상속합니다. DomainException은 RuntimeException을 상속하고 ErrorCode를 포함합니다.','[4, 37, 43]','2026-01-16 02:26:55','2026-01-16 02:26:55','MANUAL',NULL,NULL),(70,135,'GOOD','// ErrorCode 인터페이스\npackage com.ryuqq.domain.common.exception;\n\npublic interface ErrorCode {\n    String getCode();\n    int getHttpStatus();\n    String getMessage();\n}\n\n// BC별 ErrorCode Enum\npackage com.ryuqq.domain.order.exception;\n\npublic enum OrderErrorCode implements ErrorCode {\n\n    // 400 Bad Request\n    INVALID_ORDER_ITEM(\"ORDER_INVALID_ITEM\", 400, \"주문 항목이 유효하지 않습니다\"),\n    INVALID_QUANTITY(\"ORDER_INVALID_QUANTITY\", 400, \"수량이 유효하지 않습니다\"),\n\n    // 404 Not Found\n    ORDER_NOT_FOUND(\"ORDER_NOT_FOUND\", 404, \"주문을 찾을 수 없습니다\"),\n    ORDER_ITEM_NOT_FOUND(\"ORDER_ITEM_NOT_FOUND\", 404, \"주문 항목을 찾을 수 없습니다\"),\n\n    // 409 Conflict\n    ORDER_ALREADY_CONFIRMED(\"ORDER_ALREADY_CONFIRMED\", 409, \"이미 확정된 주문입니다\"),\n    ORDER_ALREADY_CANCELLED(\"ORDER_ALREADY_CANCELLED\", 409, \"이미 취소된 주문입니다\"),\n\n    // 422 Unprocessable Entity\n    ORDER_CANNOT_BE_CANCELLED(\"ORDER_CANNOT_CANCEL\", 422, \"취소할 수 없는 주문 상태입니다\"),\n    ORDER_CANNOT_BE_SHIPPED(\"ORDER_CANNOT_SHIP\", 422, \"배송할 수 없는 주문 상태입니다\");\n\n    private final String code;\n    private final int httpStatus;\n    private final String message;\n\n    OrderErrorCode(String code, int httpStatus, String message) {\n        this.code = code;\n        this.httpStatus = httpStatus;\n        this.message = message;\n    }\n\n    @Override\n    public String getCode() { return code; }\n\n    @Override\n    public int getHttpStatus() { return httpStatus; }\n\n    @Override\n    public String getMessage() { return message; }\n}','JAVA','ErrorCode는 인터페이스로 정의하고, BC별 Enum이 구현합니다. HTTP 상태별로 그룹화하여 관리합니다.','[4, 5, 6, 7, 13, 40, 43, 46]','2026-01-16 02:26:55','2026-01-16 02:26:55','MANUAL',NULL,NULL),(71,139,'GOOD','// ✅ Good: int 타입 HTTP 상태 코드\npublic enum OrderErrorCode implements ErrorCode {\n\n    ORDER_NOT_FOUND(\"ORDER_NOT_FOUND\", 404, \"주문을 찾을 수 없습니다\"),\n    ORDER_CANNOT_BE_CANCELLED(\"ORDER_CANNOT_CANCEL\", 422, \"취소할 수 없습니다\");\n\n    private final String code;\n    private final int httpStatus;  // int 타입\n    private final String message;\n\n    OrderErrorCode(String code, int httpStatus, String message) {\n        this.code = code;\n        this.httpStatus = httpStatus;\n        this.message = message;\n    }\n\n    @Override\n    public int getHttpStatus() {\n        return httpStatus;\n    }\n}\n\n// ❌ Bad: Spring HttpStatus 사용\n// import org.springframework.http.HttpStatus;  // Domain Layer에서 금지!\n//\n// public enum OrderErrorCode implements ErrorCode {\n//     ORDER_NOT_FOUND(\"ORDER_NOT_FOUND\", HttpStatus.NOT_FOUND, \"...\");\n//\n//     private final HttpStatus httpStatus;  // Spring 의존성!\n// }','JAVA','HTTP 상태 코드는 int 타입으로 정의합니다. Spring의 HttpStatus를 사용하면 Domain Layer가 Spring에 의존하게 되어 금지됩니다.','[8, 18, 19, 24, 25, 28]','2026-01-16 02:26:55','2026-01-16 02:26:55','MANUAL',NULL,NULL),(72,143,'GOOD','public class OrderNotFoundException extends DomainException {\n\n    private final OrderId orderId;\n\n    public OrderNotFoundException(OrderId orderId) {\n        super(OrderErrorCode.ORDER_NOT_FOUND,\n            String.format(\"Order not found: %s\", orderId.value()));\n        this.orderId = orderId;\n    }\n\n    public OrderId getOrderId() {\n        return orderId;\n    }\n}\n\npublic class OrderCannotBeCancelledException extends DomainException {\n\n    private final OrderId orderId;\n    private final OrderStatus currentStatus;\n\n    public OrderCannotBeCancelledException(OrderId orderId, OrderStatus currentStatus) {\n        super(OrderErrorCode.ORDER_CANNOT_BE_CANCELLED,\n            String.format(\"Order %s cannot be cancelled. Current status: %s\",\n                orderId.value(), currentStatus.displayName()));\n        this.orderId = orderId;\n        this.currentStatus = currentStatus;\n    }\n\n    public OrderId getOrderId() {\n        return orderId;\n    }\n\n    public OrderStatus getCurrentStatus() {\n        return currentStatus;\n    }\n}','JAVA','Exception은 디버깅에 필요한 컨텍스트 정보(ID, 현재 상태 등)를 필드로 포함합니다. 메시지에 포함하고, getter로 접근 가능하게 합니다.','[3, 11, 12, 18, 19, 29, 30, 33, 34]','2026-01-16 02:26:55','2026-01-16 02:26:55','MANUAL',NULL,NULL),(73,151,'GOOD','package com.ryuqq.domain.order.query;\n\nimport com.ryuqq.domain.common.vo.PageRequest;\nimport com.ryuqq.domain.common.vo.SortDirection;\n\n/**\n * Order 검색 조건.\n */\npublic record OrderSearchCriteria(\n    String status,\n    String customerId,\n    PageRequest page,\n    SortDirection sortDirection\n) {\n    // 구현\n}','JAVA','Criteria는 domain.{bc}.query 패키지에 위치합니다. Query 관련 객체를 query 하위 패키지로 분리하여 CQRS 패턴을 명확히 합니다.','[1]','2026-01-16 02:26:55','2026-01-16 02:26:55','MANUAL',NULL,NULL),(74,154,'GOOD','// ✅ Good: Record 타입\npublic record OrderSearchCriteria(\n    String status,\n    String customerId,\n    String fromDate,\n    String toDate,\n    PageRequest page,\n    SortDirection sortDirection\n) {\n\n    // Compact Constructor로 기본값 및 검증\n    public OrderSearchCriteria {\n        if (page == null) {\n            page = PageRequest.of(0, 20);\n        }\n        if (sortDirection == null) {\n            sortDirection = SortDirection.DESC;\n        }\n    }\n\n    public static OrderSearchCriteria of(\n            String status,\n            String customerId,\n            String fromDate,\n            String toDate,\n            int pageNo,\n            int pageSize,\n            SortDirection sortDirection) {\n        return new OrderSearchCriteria(\n            status,\n            customerId,\n            fromDate,\n            toDate,\n            PageRequest.of(pageNo, pageSize),\n            sortDirection\n        );\n    }\n\n    public boolean hasStatusFilter() {\n        return status != null && !status.isBlank();\n    }\n\n    public boolean hasCustomerFilter() {\n        return customerId != null && !customerId.isBlank();\n    }\n\n    public boolean hasDateRange() {\n        return fromDate != null && toDate != null;\n    }\n}','JAVA','Criteria는 Record 타입으로 정의합니다. Compact Constructor에서 기본값을 적용하고, hasXxxFilter() 메서드로 필터 존재 여부를 확인합니다.','[2, 12, 13, 14, 15, 16, 17, 37, 41, 45]','2026-01-16 02:26:55','2026-01-16 02:26:55','MANUAL',NULL,NULL),(75,155,'GOOD','public record OrderSearchCriteria(\n    String status,\n    String customerId,\n    PageRequest page,\n    SortDirection sortDirection\n) {\n\n    /**\n     * 검색 조건 생성.\n     */\n    public static OrderSearchCriteria of(\n            String status,\n            String customerId,\n            int pageNo,\n            int pageSize,\n            SortDirection sortDirection) {\n        return new OrderSearchCriteria(\n            status,\n            customerId,\n            PageRequest.of(pageNo, Math.min(pageSize, 100)),  // 최대 100개 제한\n            sortDirection != null ? sortDirection : SortDirection.DESC\n        );\n    }\n\n    /**\n     * 기본 검색 조건 (전체 조회, 첫 페이지).\n     */\n    public static OrderSearchCriteria defaultCriteria() {\n        return new OrderSearchCriteria(null, null, PageRequest.of(0, 20), SortDirection.DESC);\n    }\n\n    /**\n     * 특정 고객의 주문 검색.\n     */\n    public static OrderSearchCriteria byCustomer(String customerId, int pageNo, int pageSize) {\n        return of(null, customerId, pageNo, pageSize, SortDirection.DESC);\n    }\n\n    /**\n     * 특정 상태의 주문 검색.\n     */\n    public static OrderSearchCriteria byStatus(String status, int pageNo, int pageSize) {\n        return of(status, null, pageNo, pageSize, SortDirection.DESC);\n    }\n}','JAVA','Criteria는 of() 정적 팩토리 메서드를 제공합니다. 기본값 적용, 최대값 제한 등의 로직을 포함합니다. 자주 사용하는 조건은 별도 팩토리 메서드(byCustomer, byStatus)로 제공합니다.','[11, 12, 13, 14, 15, 16, 20, 27, 28, 34, 35, 41, 42]','2026-01-16 02:26:55','2026-01-16 02:26:55','MANUAL',NULL,NULL),(76,156,'GOOD','// ✅ Good: Record 사용 - Lombok 불필요\npublic record OrderSearchCriteria(\n    String status,\n    String customerId,\n    PageRequest page,\n    SortDirection sortDirection\n) {\n\n    public static OrderSearchCriteria of(\n            String status,\n            String customerId,\n            int pageNo,\n            int pageSize,\n            SortDirection sortDirection) {\n        return new OrderSearchCriteria(\n            status,\n            customerId,\n            PageRequest.of(pageNo, pageSize),\n            sortDirection != null ? sortDirection : SortDirection.DESC\n        );\n    }\n}\n\n// Record가 자동 제공:\n// - 불변성 (final 필드)\n// - 접근자 (status(), customerId(), page(), sortDirection())\n// - equals(), hashCode(), toString()\n\n// ❌ Bad: Lombok 사용\n// @Getter\n// @Builder\n// public class OrderSearchCriteria {\n//     private final String status;\n//     private final String customerId;\n//     ...\n// }','JAVA','Criteria에서 Lombok을 사용하지 않습니다. Java Record가 불변성, 접근자, equals/hashCode/toString을 자동 제공합니다.','[2, 24, 25, 26, 29, 30, 31]','2026-01-16 02:26:55','2026-01-16 02:26:55','MANUAL',NULL,NULL),(77,314,'GOOD','@Entity\n@Table(name = \"orders\")\npublic class OrderJpaEntity extends BaseAuditEntity {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @Column(name = \"order_number\", nullable = false, unique = true)\n    private String orderNumber;\n\n    @Column(name = \"customer_id\", nullable = false)\n    private Long customerId;  // Long FK 전략\n\n    @Enumerated(EnumType.STRING)\n    @Column(name = \"status\", nullable = false)\n    private OrderStatus status;\n\n    protected OrderJpaEntity() {\n    }\n\n    // Entity.of() 정적 팩토리 메서드\n    public static OrderJpaEntity of(String orderNumber, Long customerId, OrderStatus status) {\n        OrderJpaEntity entity = new OrderJpaEntity();\n        entity.orderNumber = orderNumber;\n        entity.customerId = customerId;\n        entity.status = status;\n        return entity;\n    }\n\n    // Getter만 제공 (Setter 금지)\n    public Long getId() { return id; }\n    public String getOrderNumber() { return orderNumber; }\n    public Long getCustomerId() { return customerId; }\n    public OrderStatus getStatus() { return status; }\n}','JAVA','BaseAuditEntity를 상속하여 createdAt, updatedAt 필드를 자동 관리합니다. @CreatedDate, @LastModifiedDate는 부모 클래스에서 처리됩니다. 모든 Entity는 생성/수정 시간 추적을 위해 BaseAuditEntity를 상속해야 합니다.','[3, 4, 5]','2026-01-16 06:53:00','2026-01-16 06:53:00','MANUAL',NULL,NULL),(78,315,'GOOD','@Entity\n@Table(name = \"order_items\")\npublic class OrderItemJpaEntity extends BaseAuditEntity {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @Column(name = \"order_id\", nullable = false)\n    private Long orderId;  // Long FK (JPA 관계 어노테이션 금지)\n\n    @Column(name = \"product_id\", nullable = false)\n    private String productId;\n\n    @Column(name = \"quantity\", nullable = false)\n    private int quantity;\n\n    // 명시적 protected 생성자 (Lombok @NoArgsConstructor 미사용)\n    protected OrderItemJpaEntity() {\n    }\n\n    // 명시적 정적 팩토리 메서드 (Lombok @Builder 미사용)\n    public static OrderItemJpaEntity of(Long orderId, String productId, int quantity) {\n        OrderItemJpaEntity entity = new OrderItemJpaEntity();\n        entity.orderId = orderId;\n        entity.productId = productId;\n        entity.quantity = quantity;\n        return entity;\n    }\n\n    // 명시적 Getter (Lombok @Getter 미사용)\n    public Long getId() { return id; }\n    public Long getOrderId() { return orderId; }\n    public String getProductId() { return productId; }\n    public int getQuantity() { return quantity; }\n}','JAVA','@Data, @Builder, @Getter, @Setter, @NoArgsConstructor, @AllArgsConstructor 등 Lombok 사용이 금지됩니다. Pure Java로 생성자, Getter를 명시적으로 작성합니다. 컴파일 타임에 코드가 명확히 보이고 디버깅이 용이합니다.','[20, 21, 24, 25, 31, 32, 33, 34]','2026-01-16 06:53:00','2026-01-16 06:53:00','MANUAL',NULL,NULL),(79,317,'GOOD','@Entity\n@Table(name = \"orders\")\npublic class OrderJpaEntity extends BaseAuditEntity {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    // Long FK 전략 - @ManyToOne, @OneToMany 금지\n    @Column(name = \"customer_id\", nullable = false)\n    private Long customerId;\n\n    @Column(name = \"shipping_address_id\")\n    private Long shippingAddressId;\n\n    @Column(name = \"payment_method_id\")\n    private Long paymentMethodId;\n\n    // 연관 엔티티 필요 시 Repository에서 별도 조회\n    // List<OrderItemJpaEntity> items; 금지!\n    // CustomerJpaEntity customer;    금지!\n\n    protected OrderJpaEntity() {\n    }\n\n    public static OrderJpaEntity of(Long customerId, Long shippingAddressId, Long paymentMethodId) {\n        OrderJpaEntity entity = new OrderJpaEntity();\n        entity.customerId = customerId;\n        entity.shippingAddressId = shippingAddressId;\n        entity.paymentMethodId = paymentMethodId;\n        return entity;\n    }\n\n    public Long getId() { return id; }\n    public Long getCustomerId() { return customerId; }\n    public Long getShippingAddressId() { return shippingAddressId; }\n    public Long getPaymentMethodId() { return paymentMethodId; }\n}','JAVA','@ManyToOne, @OneToMany, @OneToOne, @ManyToMany JPA 관계 어노테이션 사용이 금지됩니다. 외래 키는 Long 타입 필드로 저장하고, 연관 엔티티가 필요하면 Repository에서 별도 조회합니다. N+1 문제와 LazyLoading 이슈를 원천 차단합니다.','[9, 10, 11, 13, 14, 16, 17, 20, 21, 22]','2026-01-16 06:53:00','2026-01-16 06:53:00','MANUAL',NULL,NULL),(80,319,'GOOD','@Entity\n@Table(name = \"products\")\npublic class ProductJpaEntity extends BaseAuditEntity {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @Column(name = \"name\", nullable = false)\n    private String name;\n\n    @Column(name = \"price\", nullable = false)\n    private Long price;\n\n    @Column(name = \"category_id\")\n    private Long categoryId;\n\n    // 생성자는 protected/private (외부 직접 호출 금지)\n    protected ProductJpaEntity() {\n    }\n\n    // of() 정적 팩토리 메서드 - 유일한 public 생성 경로\n    public static ProductJpaEntity of(String name, Long price, Long categoryId) {\n        ProductJpaEntity entity = new ProductJpaEntity();\n        entity.name = name;\n        entity.price = price;\n        entity.categoryId = categoryId;\n        return entity;\n    }\n\n    // ID 포함 복원용 (영속화된 데이터에서 Entity 재생성)\n    public static ProductJpaEntity withId(Long id, String name, Long price, Long categoryId) {\n        ProductJpaEntity entity = new ProductJpaEntity();\n        entity.id = id;\n        entity.name = name;\n        entity.price = price;\n        entity.categoryId = categoryId;\n        return entity;\n    }\n\n    public Long getId() { return id; }\n    public String getName() { return name; }\n    public Long getPrice() { return price; }\n    public Long getCategoryId() { return categoryId; }\n}','JAVA','Entity 생성은 of(...) 정적 팩토리 메서드만 외부에 공개합니다. 생성자는 protected/private으로 선언하여 외부에서 직접 new 호출을 금지합니다. 불변식 검증과 생성 로직을 of() 메서드에서 중앙 관리합니다.','[19, 20, 23, 24, 31, 32]','2026-01-16 06:53:00','2026-01-16 06:53:00','MANUAL',NULL,NULL),(81,320,'GOOD','@Entity\n@Table(name = \"orders\")\npublic class OrderJpaEntity extends BaseAuditEntity {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @Column(name = \"order_number\", nullable = false)\n    private String orderNumber;\n\n    @Enumerated(EnumType.STRING)\n    @Column(name = \"status\", nullable = false)\n    private OrderStatus status;\n\n    protected OrderJpaEntity() {\n    }\n\n    public static OrderJpaEntity of(String orderNumber, OrderStatus status) {\n        OrderJpaEntity entity = new OrderJpaEntity();\n        entity.orderNumber = orderNumber;\n        entity.status = status;\n        return entity;\n    }\n\n    // Getter만 제공 (Setter 금지)\n    public Long getId() { return id; }\n    public String getOrderNumber() { return orderNumber; }\n    public OrderStatus getStatus() { return status; }\n\n    // 상태 변경이 필요하면 의미 있는 이름의 메서드로 제공\n    // setStatus(OrderStatus) 대신 의미 있는 비즈니스 메서드 사용\n    public void changeStatus(OrderStatus newStatus) {\n        // 상태 전이 검증 등 비즈니스 로직 포함 가능\n        this.status = newStatus;\n    }\n\n    public void cancel() {\n        if (this.status == OrderStatus.SHIPPED) {\n            throw new IllegalStateException(\"배송 완료된 주문은 취소할 수 없습니다\");\n        }\n        this.status = OrderStatus.CANCELLED;\n    }\n}','JAVA','setXxx() 형태의 Setter 메서드를 제공하지 않습니다. 상태 변경이 필요하면 의미 있는 이름의 비즈니스 메서드(cancel(), changeStatus())로 제공합니다. 불변성과 데이터 무결성을 보호합니다.','[26, 27, 28, 32, 33, 37, 38]','2026-01-16 06:53:00','2026-01-16 06:53:00','MANUAL',NULL,NULL),(82,324,'GOOD','package com.example.adapter.out.persistence.order.repository;\n\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport com.example.adapter.out.persistence.order.entity.OrderJpaEntity;\n\n/**\n * OrderJpaRepository - Command 작업 전용\n * save(), delete() 메서드만 사용\n * Query 작업은 OrderQueryDslRepository에서 처리\n */\npublic interface OrderJpaRepository extends JpaRepository<OrderJpaEntity, Long> {\n    // 추가 메서드 정의 금지\n    // Query Method, @Query 어노테이션 금지\n    // 상속받은 save(), delete(), findById()만 사용\n}','JAVA','JpaRepository<Entity, ID>를 상속하여 기본 CRUD 기능을 제공받습니다. JpaRepository 상속만 허용하고 CrudRepository, PagingAndSortingRepository 직접 상속은 금지합니다.','[10, 11]','2026-01-16 06:53:00','2026-01-16 06:53:00','MANUAL',NULL,NULL),(83,325,'GOOD','// JpaRepository는 Command 작업 전용\npublic interface OrderJpaRepository extends JpaRepository<OrderJpaEntity, Long> {\n    // 상속받은 메서드만 사용:\n    // - save(S entity): 저장/수정\n    // - delete(T entity): 삭제\n    // - saveAll(Iterable<S> entities): 일괄 저장\n    // - deleteAll(Iterable<? extends T> entities): 일괄 삭제\n\n    // 조회 메서드 추가 금지:\n    // List<OrderJpaEntity> findByStatus(String status);     // 금지!\n    // Optional<OrderJpaEntity> findByOrderNumber(String n); // 금지!\n    // → QueryDslRepository에서 처리\n}\n\n// CommandAdapter에서 사용 예시\n@Component\npublic class OrderCommandAdapter implements OrderCommandPort {\n\n    private final OrderJpaRepository repository;\n    private final OrderJpaEntityMapper mapper;\n\n    public OrderCommandAdapter(OrderJpaRepository repository, OrderJpaEntityMapper mapper) {\n        this.repository = repository;\n        this.mapper = mapper;\n    }\n\n    @Override\n    public OrderId persist(Order order) {\n        OrderJpaEntity entity = mapper.toEntity(order);\n        OrderJpaEntity saved = repository.save(entity);  // save()만 사용\n        return new OrderId(saved.getId());\n    }\n}','JAVA','JpaRepository는 save(), delete() 등 Command 작업만 수행합니다. 조회 메서드(findByXxx)를 추가하지 않습니다. CQRS 원칙에 따라 조회는 QueryDslRepository에서 처리합니다.','[3, 4, 5, 6, 7, 10, 11, 12, 28, 29]','2026-01-16 06:53:00','2026-01-16 06:53:00','MANUAL',NULL,NULL),(84,326,'GOOD','// JpaRepository - Query Method 없는 깨끗한 인터페이스\npublic interface ProductJpaRepository extends JpaRepository<ProductJpaEntity, Long> {\n    // Query Method 정의 금지!\n    // List<ProductJpaEntity> findByCategory(String category);   // 금지!\n    // Optional<ProductJpaEntity> findByName(String name);       // 금지!\n    // List<ProductJpaEntity> findByPriceGreaterThan(Long p);    // 금지!\n    // boolean existsByName(String name);                        // 금지!\n    // long countByCategory(String category);                    // 금지!\n\n    // 모든 조회는 QueryDslRepository에서 처리\n}\n\n// 조회는 QueryDslRepository에서 담당\n@Repository\npublic class ProductQueryDslRepository {\n\n    private final JPAQueryFactory queryFactory;\n\n    public ProductQueryDslRepository(JPAQueryFactory queryFactory) {\n        this.queryFactory = queryFactory;\n    }\n\n    public Optional<ProductJpaEntity> findById(Long id) {\n        return Optional.ofNullable(\n            queryFactory\n                .selectFrom(product)\n                .where(product.id.eq(id))\n                .fetchOne()\n        );\n    }\n\n    public List<ProductJpaEntity> findByCategory(String category) {\n        return queryFactory\n            .selectFrom(product)\n            .where(product.categoryId.eq(category))\n            .fetch();\n    }\n}','JAVA','findByXxx, existsByXxx, countByXxx 등 Spring Data JPA Query Method를 정의하지 않습니다. 모든 조회는 QueryDslRepository에서 QueryDSL로 구현합니다. 쿼리 가독성과 타입 안전성을 보장합니다.','[3, 4, 5, 6, 7, 8, 11, 23, 24, 31, 32]','2026-01-16 06:53:00','2026-01-16 06:53:00','MANUAL',NULL,NULL),(85,327,'GOOD','// JpaRepository - @Query 없는 깨끗한 인터페이스\npublic interface CustomerJpaRepository extends JpaRepository<CustomerJpaEntity, Long> {\n    // @Query 어노테이션 사용 금지!\n    // @Query(\"SELECT c FROM CustomerJpaEntity c WHERE c.email = :email\")\n    // Optional<CustomerJpaEntity> findByEmail(@Param(\"email\") String email);\n\n    // Native Query도 금지!\n    // @Query(value = \"SELECT * FROM customers WHERE email = ?1\", nativeQuery = true)\n    // CustomerJpaEntity findByEmailNative(String email);\n}\n\n// 복잡한 쿼리는 QueryDslRepository에서 처리\n@Repository\npublic class CustomerQueryDslRepository {\n\n    private final JPAQueryFactory queryFactory;\n\n    public CustomerQueryDslRepository(JPAQueryFactory queryFactory) {\n        this.queryFactory = queryFactory;\n    }\n\n    public Optional<CustomerJpaEntity> findByEmail(String email) {\n        return Optional.ofNullable(\n            queryFactory\n                .selectFrom(customer)\n                .where(customer.email.eq(email))\n                .fetchOne()\n        );\n    }\n\n    public List<CustomerJpaEntity> findVipCustomers() {\n        return queryFactory\n            .selectFrom(customer)\n            .where(customer.grade.eq(CustomerGrade.VIP))\n            .orderBy(customer.createdAt.desc())\n            .fetch();\n    }\n}','JAVA','@Query 어노테이션(JPQL, Native Query)을 JpaRepository에 사용하지 않습니다. 문자열 기반 쿼리는 컴파일 타임 검증이 불가능합니다. 모든 쿼리는 QueryDSL의 타입 안전 API로 작성합니다.','[3, 4, 5, 7, 8, 9, 23, 24, 31, 32]','2026-01-16 06:53:00','2026-01-16 06:53:00','MANUAL',NULL,NULL),(86,329,'GOOD','@Repository\npublic class OrderQueryDslRepository {\n\n    private final JPAQueryFactory queryFactory;\n\n    public OrderQueryDslRepository(JPAQueryFactory queryFactory) {\n        this.queryFactory = queryFactory;\n    }\n\n    private static final QOrderJpaEntity order = QOrderJpaEntity.orderJpaEntity;\n\n    public Optional<OrderJpaEntity> findById(Long id) {\n        return Optional.ofNullable(\n            queryFactory\n                .selectFrom(order)\n                .where(order.id.eq(id))\n                .fetchOne()\n        );\n    }\n\n    public List<OrderJpaEntity> findByCriteria(OrderCriteria criteria) {\n        return queryFactory\n            .selectFrom(order)\n            .where(buildWhereClause(criteria))\n            .orderBy(order.createdAt.desc())\n            .fetch();\n    }\n\n    private BooleanBuilder buildWhereClause(OrderCriteria criteria) {\n        BooleanBuilder builder = new BooleanBuilder();\n        if (criteria.status() != null) {\n            builder.and(order.status.eq(criteria.status()));\n        }\n        if (criteria.customerId() != null) {\n            builder.and(order.customerId.eq(criteria.customerId()));\n        }\n        return builder;\n    }\n}','JAVA','QueryDslRepository 클래스는 @Repository 어노테이션으로 Bean 등록합니다. 인터페이스가 아닌 구체 클래스로 구현하며, JPAQueryFactory를 생성자 주입받습니다.','[1, 2, 6, 7]','2026-01-16 06:53:00','2026-01-16 06:53:00','MANUAL',NULL,NULL),(87,330,'GOOD','@Repository\n// @Transactional 어노테이션 없음!\n// 트랜잭션 관리는 Application Layer 책임\npublic class ProductQueryDslRepository {\n\n    private final JPAQueryFactory queryFactory;\n\n    public ProductQueryDslRepository(JPAQueryFactory queryFactory) {\n        this.queryFactory = queryFactory;\n    }\n\n    private static final QProductJpaEntity product = QProductJpaEntity.productJpaEntity;\n\n    // @Transactional 없음 - 메서드 레벨에도 사용 금지\n    public Optional<ProductJpaEntity> findById(Long id) {\n        return Optional.ofNullable(\n            queryFactory\n                .selectFrom(product)\n                .where(product.id.eq(id))\n                .fetchOne()\n        );\n    }\n\n    // 읽기 전용도 Application Layer에서 @Transactional(readOnly = true) 설정\n    public List<ProductJpaEntity> findByCategory(Long categoryId) {\n        return queryFactory\n            .selectFrom(product)\n            .where(product.categoryId.eq(categoryId))\n            .fetch();\n    }\n}','JAVA','@Transactional 어노테이션을 QueryDslRepository 클래스나 메서드에 사용하지 않습니다. 트랜잭션 경계는 Application Layer(UseCase/Service)에서 관리합니다. Repository는 쿼리 실행만 담당합니다.','[1, 2, 3, 14, 15, 24, 25]','2026-01-16 06:53:00','2026-01-16 06:53:00','MANUAL',NULL,NULL),(88,331,'GOOD','@Repository\npublic class CustomerQueryDslRepository {\n\n    private final JPAQueryFactory queryFactory;\n\n    // JPAQueryFactory만 주입받음 - EntityManager 직접 주입 금지\n    public CustomerQueryDslRepository(JPAQueryFactory queryFactory) {\n        this.queryFactory = queryFactory;\n    }\n\n    private static final QCustomerJpaEntity customer = QCustomerJpaEntity.customerJpaEntity;\n\n    public Optional<CustomerJpaEntity> findById(Long id) {\n        return Optional.ofNullable(\n            queryFactory\n                .selectFrom(customer)\n                .where(customer.id.eq(id))\n                .fetchOne()\n        );\n    }\n}\n\n// JPAQueryFactory는 Config에서 Bean 등록\n@Configuration\npublic class QueryDslConfig {\n\n    @PersistenceContext\n    private EntityManager entityManager;\n\n    @Bean\n    public JPAQueryFactory jpaQueryFactory() {\n        return new JPAQueryFactory(entityManager);\n    }\n}','JAVA','QueryDslRepository는 JPAQueryFactory만 생성자 주입받습니다. EntityManager를 직접 주입받지 않습니다. JPAQueryFactory Bean은 Config 클래스에서 중앙 관리합니다.','[4, 5, 6, 7, 8, 26, 27, 30, 31, 32]','2026-01-16 06:53:00','2026-01-16 06:53:00','MANUAL',NULL,NULL),(89,333,'GOOD','@Repository\npublic class OrderQueryDslRepository {\n\n    private final JPAQueryFactory queryFactory;\n\n    public OrderQueryDslRepository(JPAQueryFactory queryFactory) {\n        this.queryFactory = queryFactory;\n    }\n\n    private static final QOrderJpaEntity order = QOrderJpaEntity.orderJpaEntity;\n\n    // Join 없이 단일 테이블 조회만 수행\n    public List<OrderJpaEntity> findByCustomerId(Long customerId) {\n        return queryFactory\n            .selectFrom(order)\n            .where(order.customerId.eq(customerId))\n            .orderBy(order.createdAt.desc())\n            .fetch();\n    }\n\n    // 연관 데이터가 필요하면 Application Layer에서 별도 조회 후 조합\n    // .join(), .leftJoin(), .innerJoin() 사용 금지!\n    // 예시 (금지):\n    // queryFactory.selectFrom(order)\n    //     .leftJoin(orderItem).on(orderItem.orderId.eq(order.id))\n    //     .fetch();\n}\n\n// Application Layer에서 조합\n@Component\npublic class OrderQueryAdapter implements OrderQueryPort {\n\n    private final OrderQueryDslRepository orderRepository;\n    private final OrderItemQueryDslRepository orderItemRepository;\n    private final OrderJpaEntityMapper mapper;\n\n    public OrderQueryAdapter(OrderQueryDslRepository orderRepository,\n            OrderItemQueryDslRepository orderItemRepository,\n            OrderJpaEntityMapper mapper) {\n        this.orderRepository = orderRepository;\n        this.orderItemRepository = orderItemRepository;\n        this.mapper = mapper;\n    }\n\n    @Override\n    public Optional<Order> findById(OrderId id) {\n        return orderRepository.findById(id.value())\n            .map(orderEntity -> {\n                List<OrderItemJpaEntity> items = orderItemRepository.findByOrderId(id.value());\n                return mapper.toDomain(orderEntity, items);\n            });\n    }\n}','JAVA','.join(), .leftJoin(), .innerJoin() 사용이 금지됩니다. QueryDslRepository는 단일 테이블 조회만 수행합니다. 연관 데이터가 필요하면 Application Layer에서 별도 조회 후 조합합니다. N+1 제어와 쿼리 단순화를 위함입니다.','[12, 13, 21, 22, 23, 24, 25, 46, 47, 48, 49, 50]','2026-01-16 06:53:00','2026-01-16 06:53:00','MANUAL',NULL,NULL),(90,336,'GOOD','@Repository\npublic class ProductQueryDslRepository {\n\n    private final JPAQueryFactory queryFactory;\n\n    public ProductQueryDslRepository(JPAQueryFactory queryFactory) {\n        this.queryFactory = queryFactory;\n    }\n\n    private static final QProductJpaEntity product = QProductJpaEntity.productJpaEntity;\n\n    // findAll() 금지! 항상 조건 + 페이징 필수\n    public List<ProductJpaEntity> findByCriteria(ProductCriteria criteria, int offset, int limit) {\n        BooleanBuilder builder = buildWhereClause(criteria);\n\n        return queryFactory\n            .selectFrom(product)\n            .where(builder)\n            .orderBy(product.createdAt.desc())\n            .offset(offset)\n            .limit(limit)  // 필수: 페이징 제한\n            .fetch();\n    }\n\n    public long countByCriteria(ProductCriteria criteria) {\n        BooleanBuilder builder = buildWhereClause(criteria);\n\n        return queryFactory\n            .select(product.count())\n            .from(product)\n            .where(builder)\n            .fetchOne();\n    }\n\n    private BooleanBuilder buildWhereClause(ProductCriteria criteria) {\n        BooleanBuilder builder = new BooleanBuilder();\n        if (criteria.categoryId() != null) {\n            builder.and(product.categoryId.eq(criteria.categoryId()));\n        }\n        if (criteria.minPrice() != null) {\n            builder.and(product.price.goe(criteria.minPrice()));\n        }\n        return builder;\n    }\n}','JAVA','조건 없이 전체 조회하는 findAll() 메서드를 제공하지 않습니다. 항상 조건(criteria)과 페이징(offset, limit)을 필수 파라미터로 요구합니다. 대용량 테이블 전체 조회로 인한 OOM을 방지합니다.','[12, 13, 20, 21, 22]','2026-01-16 06:53:01','2026-01-16 06:53:01','MANUAL',NULL,NULL),(91,339,'GOOD','@Component\npublic class OrderCommandAdapter implements OrderCommandPort {\n\n    private final OrderJpaRepository repository;\n    private final OrderJpaEntityMapper mapper;\n\n    public OrderCommandAdapter(OrderJpaRepository repository, OrderJpaEntityMapper mapper) {\n        this.repository = repository;\n        this.mapper = mapper;\n    }\n\n    // persist() 메서드만 제공 - save(), update(), delete() 별도 메서드 금지\n    @Override\n    public OrderId persist(Order order) {\n        // Domain → Entity 변환\n        OrderJpaEntity entity = mapper.toEntity(order);\n\n        // JPA save() - INSERT/UPDATE 자동 판단 (Merge 방식)\n        // Domain.isNew()로 신규 여부 판단 → Entity에 ID 유무로 JPA가 처리\n        OrderJpaEntity saved = repository.save(entity);\n\n        // 생성된 ID 반환\n        return new OrderId(saved.getId());\n    }\n\n    // save(), update(), delete() 별도 메서드 정의 금지!\n    // public void save(Order order) { ... }    // 금지!\n    // public void update(Order order) { ... }  // 금지!\n    // public void delete(OrderId id) { ... }   // 금지!\n    // → SoftDelete는 Domain 상태 변경 후 persist() 호출\n}','JAVA','CommandAdapter는 persist(Aggregate) 메서드만 제공합니다. save(), update(), delete() 별도 메서드를 정의하지 않습니다. JPA Merge 방식으로 INSERT/UPDATE를 자동 판단하고, SoftDelete는 Domain 상태 변경 후 persist()를 호출합니다.','[12, 13, 14, 17, 18, 19, 20, 21, 25, 26, 27, 28, 29]','2026-01-16 06:53:01','2026-01-16 06:53:01','MANUAL',NULL,NULL),(92,340,'GOOD','@Component\n// @Transactional 어노테이션 없음! 클래스 레벨에서도 금지\npublic class ProductCommandAdapter implements ProductCommandPort {\n\n    private final ProductJpaRepository repository;\n    private final ProductJpaEntityMapper mapper;\n\n    public ProductCommandAdapter(ProductJpaRepository repository, ProductJpaEntityMapper mapper) {\n        this.repository = repository;\n        this.mapper = mapper;\n    }\n\n    // @Transactional 없음 - 메서드 레벨에서도 금지\n    @Override\n    public ProductId persist(Product product) {\n        ProductJpaEntity entity = mapper.toEntity(product);\n        ProductJpaEntity saved = repository.save(entity);\n        return new ProductId(saved.getId());\n    }\n}\n\n// 트랜잭션은 Application Layer에서 관리\n@Service\npublic class CreateProductService implements CreateProductUseCase {\n\n    private final ProductCommandPort productCommandPort;\n\n    public CreateProductService(ProductCommandPort productCommandPort) {\n        this.productCommandPort = productCommandPort;\n    }\n\n    @Override\n    @Transactional  // 트랜잭션 경계는 여기서 설정\n    public ProductId execute(CreateProductCommand command) {\n        Product product = Product.forNew(command.name(), command.price());\n        return productCommandPort.persist(product);\n    }\n}','JAVA','@Transactional 어노테이션을 CommandAdapter 클래스나 메서드에 사용하지 않습니다. 트랜잭션 경계는 Application Layer(UseCase/Service)에서 관리합니다. 여러 Aggregate를 하나의 트랜잭션으로 묶는 것은 Application Layer 책임입니다.','[1, 2, 13, 14, 33, 34]','2026-01-16 06:53:01','2026-01-16 06:53:01','MANUAL',NULL,NULL),(93,345,'GOOD','@Component\npublic class OrderCommandAdapter implements OrderCommandPort {\n\n    private final OrderJpaRepository repository;\n    private final OrderJpaEntityMapper mapper;\n\n    public OrderCommandAdapter(OrderJpaRepository repository, OrderJpaEntityMapper mapper) {\n        this.repository = repository;\n        this.mapper = mapper;\n    }\n\n    @Override\n    public OrderId persist(Order order) {\n        // 비즈니스 로직 없음!\n        // if (order.getTotalAmount() > 1000000) { ... }  // 금지!\n        // order.calculateDiscount();                     // 금지!\n        // validateOrder(order);                          // 금지!\n\n        // 단순히 Domain → Entity 변환 후 저장\n        OrderJpaEntity entity = mapper.toEntity(order);\n        OrderJpaEntity saved = repository.save(entity);\n        return new OrderId(saved.getId());\n    }\n\n    // 검증, 계산, 상태 변경 로직은 Domain 또는 Application Layer에서 처리\n    // Adapter는 기술적 변환(Domain ↔ Entity)만 담당\n}','JAVA','CommandAdapter에 if/switch 조건 분기, 계산 로직, 상태 검증 등 비즈니스 로직을 포함하지 않습니다. 단순히 Domain → Entity 변환 후 저장만 수행합니다. 비즈니스 로직은 Domain과 Application Layer에서 처리합니다.','[14, 15, 16, 17, 19, 20, 23, 24]','2026-01-16 06:53:01','2026-01-16 06:53:01','MANUAL',NULL,NULL),(94,346,'GOOD','@Component\npublic class ProductQueryAdapter implements ProductQueryPort {\n\n    private final ProductQueryDslRepository repository;\n    private final ProductJpaEntityMapper mapper;\n\n    public ProductQueryAdapter(ProductQueryDslRepository repository,\n            ProductJpaEntityMapper mapper) {\n        this.repository = repository;\n        this.mapper = mapper;\n    }\n\n    // Repository 위임 + Mapper 변환만 수행\n    @Override\n    public Optional<Product> findById(ProductId id) {\n        return repository.findById(id.value())\n            .map(mapper::toDomain);\n    }\n\n    @Override\n    public List<Product> findByCriteria(ProductCriteria criteria) {\n        return repository.findByCriteria(criteria).stream()\n            .map(mapper::toDomain)\n            .toList();\n    }\n\n    // JPAQueryFactory 직접 사용 금지!\n    // private final JPAQueryFactory queryFactory;  // 금지!\n    // queryFactory.selectFrom(product)...          // 금지!\n    // → 쿼리 로직은 QueryDslRepository에서 처리\n}','JAVA','QueryAdapter는 QueryDslRepository로 조회를 위임하고 Mapper로 변환하는 역할만 수행합니다. JPAQueryFactory를 직접 사용하거나 쿼리 로직을 포함하지 않습니다. Repository는 쿼리 실행, Mapper는 변환, Adapter는 조합만 담당합니다.','[13, 14, 15, 16, 17, 20, 21, 22, 23, 26, 27, 28, 29]','2026-01-16 06:53:01','2026-01-16 06:53:01','MANUAL',NULL,NULL),(95,347,'GOOD','@Component\n// @Transactional 어노테이션 없음!\n// @Transactional(readOnly = true) 도 금지 - Application Layer에서 설정\npublic class OrderQueryAdapter implements OrderQueryPort {\n\n    private final OrderQueryDslRepository repository;\n    private final OrderJpaEntityMapper mapper;\n\n    public OrderQueryAdapter(OrderQueryDslRepository repository,\n            OrderJpaEntityMapper mapper) {\n        this.repository = repository;\n        this.mapper = mapper;\n    }\n\n    // @Transactional 없음\n    @Override\n    public Optional<Order> findById(OrderId id) {\n        return repository.findById(id.value())\n            .map(mapper::toDomain);\n    }\n\n    @Override\n    public boolean existsById(OrderId id) {\n        return repository.existsById(id.value());\n    }\n}\n\n// 읽기 전용 트랜잭션은 Application Layer에서 설정\n@Service\npublic class GetOrderService implements GetOrderUseCase {\n\n    private final OrderQueryPort orderQueryPort;\n\n    public GetOrderService(OrderQueryPort orderQueryPort) {\n        this.orderQueryPort = orderQueryPort;\n    }\n\n    @Override\n    @Transactional(readOnly = true)  // 읽기 전용 트랜잭션은 여기서 설정\n    public OrderResponse execute(GetOrderQuery query) {\n        Order order = orderQueryPort.findById(new OrderId(query.orderId()))\n            .orElseThrow(() -> new OrderNotFoundException(query.orderId()));\n        return OrderAssembler.toResponse(order);\n    }\n}','JAVA','@Transactional 어노테이션을 QueryAdapter 클래스나 메서드에 사용하지 않습니다. 읽기 전용 트랜잭션(@Transactional(readOnly = true))도 Application Layer에서 관리합니다.','[1, 2, 3, 15, 16, 39, 40]','2026-01-16 06:53:01','2026-01-16 06:53:01','MANUAL',NULL,NULL),(96,353,'GOOD','@Component\npublic class CustomerQueryAdapter implements CustomerQueryPort {\n\n    private final CustomerQueryDslRepository repository;\n    private final CustomerJpaEntityMapper mapper;\n\n    public CustomerQueryAdapter(CustomerQueryDslRepository repository,\n            CustomerJpaEntityMapper mapper) {\n        this.repository = repository;\n        this.mapper = mapper;\n    }\n\n    @Override\n    public Optional<Customer> findById(CustomerId id) {\n        // 비즈니스 로직 없음!\n        // if (customer.isVip()) { ... }        // 금지!\n        // customer.calculateDiscount();        // 금지!\n        // filterInactiveCustomers(customers);  // 금지!\n\n        return repository.findById(id.value())\n            .map(mapper::toDomain);\n    }\n\n    @Override\n    public List<Customer> findByCriteria(CustomerCriteria criteria) {\n        // 조건 필터링은 Repository에서 처리\n        // 비즈니스 필터링은 Application Layer에서 처리\n        return repository.findByCriteria(criteria).stream()\n            .map(mapper::toDomain)\n            .toList();\n    }\n}','JAVA','QueryAdapter에 if/switch 조건 분기, 필터링 로직, 정렬 로직 등 비즈니스 로직을 포함하지 않습니다. 단순히 Repository 호출 후 Mapper 변환만 수행합니다. 조회 조건과 정렬은 Repository에서, 비즈니스 필터링은 Application Layer에서 처리합니다.','[15, 16, 17, 18, 25, 26]','2026-01-16 06:53:01','2026-01-16 06:53:01','MANUAL',NULL,NULL),(97,356,'GOOD','@Component\n// @Mapper(MapStruct) 사용 금지!\n// Lombok @Data, @Builder 등 사용 금지!\npublic class OrderJpaEntityMapper {\n\n    // Pure Java로 구현\n    public OrderJpaEntity toEntity(Order order) {\n        if (order.getId() != null && order.getId().value() != null) {\n            // 기존 Entity 업데이트\n            return OrderJpaEntity.withId(\n                order.getId().value(),\n                order.getOrderNumber(),\n                order.getCustomerId().value(),\n                order.getStatus()\n            );\n        }\n        // 신규 Entity 생성\n        return OrderJpaEntity.of(\n            order.getOrderNumber(),\n            order.getCustomerId().value(),\n            order.getStatus()\n        );\n    }\n\n    public Order toDomain(OrderJpaEntity entity) {\n        return Order.reconstitute(\n            new OrderId(entity.getId()),\n            entity.getOrderNumber(),\n            new CustomerId(entity.getCustomerId()),\n            entity.getStatus(),\n            entity.getCreatedAt(),\n            entity.getUpdatedAt()\n        );\n    }\n}','JAVA','@Mapper(MapStruct), @Data, @Builder 등 모든 코드 생성 라이브러리 사용이 금지됩니다. 순수 Java로 변환 로직을 명시적으로 작성합니다. 바이트코드 생성 도구의 예측 불가능한 동작을 방지하고, 디버깅과 유지보수가 용이합니다.','[1, 2, 3, 6, 7, 24, 25]','2026-01-16 06:53:01','2026-01-16 06:53:01','MANUAL',NULL,NULL),(98,357,'GOOD','@Component\npublic class ProductJpaEntityMapper {\n\n    public ProductJpaEntity toEntity(Product product) {\n        // Instant.now(), LocalDateTime.now() 호출 금지!\n        // 시간 필드는 JPA Auditing이 자동 처리\n        // createdAt, updatedAt은 BaseAuditEntity에서 @CreatedDate, @LastModifiedDate로 설정\n\n        if (product.getId() != null && product.getId().value() != null) {\n            return ProductJpaEntity.withId(\n                product.getId().value(),\n                product.getName(),\n                product.getPrice().value(),\n                product.getCategoryId().value()\n                // createdAt, updatedAt 파라미터 없음!\n            );\n        }\n        return ProductJpaEntity.of(\n            product.getName(),\n            product.getPrice().value(),\n            product.getCategoryId().value()\n            // Instant.now() 호출 안함!\n        );\n    }\n\n    public Product toDomain(ProductJpaEntity entity) {\n        return Product.reconstitute(\n            new ProductId(entity.getId()),\n            entity.getName(),\n            new Money(entity.getPrice()),\n            new CategoryId(entity.getCategoryId()),\n            entity.getCreatedAt(),  // Entity에서 가져온 시간\n            entity.getUpdatedAt()   // Entity에서 가져온 시간\n        );\n    }\n}','JAVA','Mapper에서 Instant.now(), LocalDateTime.now(), System.currentTimeMillis() 등 시간 필드를 직접 생성하지 않습니다. 시간은 Domain에서 주입받거나 JPA Auditing(@CreatedDate, @LastModifiedDate)으로 처리합니다. 테스트 가능성과 결정론적 동작을 보장합니다.','[5, 6, 7, 16, 17, 22, 23, 29, 30]','2026-01-16 06:53:01','2026-01-16 06:53:01','MANUAL',NULL,NULL),(99,358,'GOOD','@Component\npublic class CustomerJpaEntityMapper {\n\n    // toEntity(Domain) 메서드 필수\n    public CustomerJpaEntity toEntity(Customer customer) {\n        if (customer.getId() != null && customer.getId().value() != null) {\n            // 기존 Entity 복원 (ID 포함)\n            return CustomerJpaEntity.withId(\n                customer.getId().value(),\n                customer.getName(),\n                customer.getEmail().value(),\n                customer.getGrade()\n            );\n        }\n        // 신규 Entity 생성 (ID 없음)\n        return CustomerJpaEntity.of(\n            customer.getName(),\n            customer.getEmail().value(),\n            customer.getGrade()\n        );\n    }\n\n    public Customer toDomain(CustomerJpaEntity entity) {\n        return Customer.reconstitute(\n            new CustomerId(entity.getId()),\n            entity.getName(),\n            new Email(entity.getEmail()),\n            entity.getGrade(),\n            entity.getCreatedAt(),\n            entity.getUpdatedAt()\n        );\n    }\n}','JAVA','EntityMapper는 toEntity(Domain) 메서드를 필수로 구현합니다. Domain → Entity 변환 로직을 캡슐화합니다. Entity.of()를 호출하여 Entity를 생성하고, 기존 데이터 업데이트 시 withId()를 사용합니다.','[4, 5, 7, 8, 15, 16]','2026-01-16 06:53:01','2026-01-16 06:53:01','MANUAL',NULL,NULL),(100,359,'GOOD','@Component\npublic class OrderJpaEntityMapper {\n\n    public OrderJpaEntity toEntity(Order order) {\n        if (order.getId() != null && order.getId().value() != null) {\n            return OrderJpaEntity.withId(\n                order.getId().value(),\n                order.getOrderNumber(),\n                order.getCustomerId().value(),\n                order.getStatus()\n            );\n        }\n        return OrderJpaEntity.of(\n            order.getOrderNumber(),\n            order.getCustomerId().value(),\n            order.getStatus()\n        );\n    }\n\n    // toDomain(Entity) 메서드 필수\n    public Order toDomain(OrderJpaEntity entity) {\n        // Domain.reconstitute()를 호출하여 Domain 복원\n        // new Order() 직접 생성 금지!\n        // Domain.forNew() 금지! (신규 생성 전용)\n        return Order.reconstitute(\n            new OrderId(entity.getId()),\n            entity.getOrderNumber(),\n            new CustomerId(entity.getCustomerId()),\n            entity.getStatus(),\n            entity.getCreatedAt(),\n            entity.getUpdatedAt()\n        );\n    }\n}','JAVA','EntityMapper는 toDomain(Entity) 메서드를 필수로 구현합니다. Entity → Domain 변환 로직을 캡슐화합니다. Domain.reconstitute()를 호출하여 Domain을 복원하며, new Domain()이나 forNew()는 신규 생성 전용이므로 사용하지 않습니다.','[20, 21, 22, 23, 24, 25]','2026-01-16 06:53:01','2026-01-16 06:53:01','MANUAL',NULL,NULL),(101,362,'GOOD','@Component\npublic class ProductJpaEntityMapper {\n\n    // null 입력에 대한 안전한 처리\n    public ProductJpaEntity toEntity(Product product) {\n        if (product == null) {\n            return null;  // null 입력 시 null 반환\n        }\n        if (product.getId() != null && product.getId().value() != null) {\n            return ProductJpaEntity.withId(\n                product.getId().value(),\n                product.getName(),\n                product.getPrice().value(),\n                product.getCategoryId() != null ? product.getCategoryId().value() : null\n            );\n        }\n        return ProductJpaEntity.of(\n            product.getName(),\n            product.getPrice().value(),\n            product.getCategoryId() != null ? product.getCategoryId().value() : null\n        );\n    }\n\n    public Product toDomain(ProductJpaEntity entity) {\n        if (entity == null) {\n            return null;  // null 입력 시 null 반환\n        }\n        return Product.reconstitute(\n            new ProductId(entity.getId()),\n            entity.getName(),\n            new Money(entity.getPrice()),\n            entity.getCategoryId() != null ? new CategoryId(entity.getCategoryId()) : null,\n            entity.getCreatedAt(),\n            entity.getUpdatedAt()\n        );\n    }\n\n    // Optional 처리 예시\n    public Optional<Product> toDomainOptional(Optional<ProductJpaEntity> entityOptional) {\n        return entityOptional.map(this::toDomain);\n    }\n}','JAVA','Mapper 메서드에서 null 입력에 대한 안전한 처리를 구현합니다. null 입력 시 null 반환 또는 명시적 예외 발생. Optional 래핑된 입력도 처리합니다. NPE를 방지하고 Repository에서 Optional.empty()가 반환될 수 있음을 고려합니다.','[5, 6, 7, 14, 20, 24, 25, 26, 31, 37, 38, 39]','2026-01-16 06:53:01','2026-01-16 06:53:01','MANUAL',NULL,NULL),(102,414,'BAD','package com.ryuqq.domain.common.exception;\n\n// ❌ BAD: 상황별 예외 클래스 분리\npublic class EntityNotFoundException extends RuntimeException {\n\n    public EntityNotFoundException(String message) {\n        super(message);\n    }\n}\n\n// ❌ BAD: 또 다른 공통 예외 클래스\npublic class DeletionConstraintException extends RuntimeException {\n\n    public DeletionConstraintException(String message) {\n        super(message);\n    }\n}\n\n// ❌ BAD: 이런 식으로 계속 늘어남\npublic class DuplicateEntityException extends RuntimeException {\n\n    public DuplicateEntityException(String message) {\n        super(message);\n    }\n}','JAVA','공통 예외 클래스를 상황별로 분리하면 안 됩니다. EntityNotFoundException, DeletionConstraintException 등을 별도 클래스로 만들면 예외 처리가 복잡해지고, GlobalExceptionHandler에서 일관된 처리가 어려워집니다.','[4, 5, 6, 12, 13, 14, 20, 21, 22]','2026-01-16 06:53:03','2026-01-16 06:53:03','MANUAL',NULL,NULL),(103,414,'GOOD','package com.ryuqq.domain.common.exception;\n\n// ✅ GOOD: 공통 예외 클래스는 DomainException 하나만 사용\npublic class DomainException extends RuntimeException {\n\n    private final ErrorCode errorCode;\n    private final String detail;\n\n    public DomainException(ErrorCode errorCode) {\n        this(errorCode, null);\n    }\n\n    public DomainException(ErrorCode errorCode, String detail) {\n        super(errorCode.getMessage());\n        this.errorCode = errorCode;\n        this.detail = detail;\n    }\n\n    public ErrorCode getErrorCode() {\n        return errorCode;\n    }\n\n    public String getDetail() {\n        return detail;\n    }\n}\n\n// ✅ GOOD: 사용 예시 - ErrorCode로 구분\n// throw new DomainException(OrderErrorCode.ORDER_NOT_FOUND);\n// throw new DomainException(OrderErrorCode.CANNOT_DELETE_ORDER, \"주문 ID: \" + orderId);','JAVA','DomainException 하나만 사용하고, ErrorCode Enum으로 에러 유형을 구분합니다. GlobalExceptionHandler에서 DomainException만 처리하면 되므로 일관된 예외 처리가 가능합니다.','[4, 5, 6, 7, 8, 27, 28]','2026-01-16 06:53:03','2026-01-16 06:53:03','MANUAL',NULL,NULL),(104,415,'BAD','@RestController\n@RequestMapping(\"/api/v1/techstacks\")\npublic class TechStackQueryController {\n\n    @GetMapping\n    public ResponseEntity<ApiResponse<TechStackListApiResponse>> getTechStacks(\n            TechStackSearchApiRequest request\n    ) {\n        // ❌ BAD: Controller에서 Math.max() 계산\n        int size = Math.max(1, Math.min(request.size(), 100));\n\n        // ❌ BAD: Controller에서 삼항 연산자로 기본값 처리\n        String sortOrder = request.sortOrder() != null ? request.sortOrder() : \"DESC\";\n\n        TechStackSearchCriteria criteria = mapper.toQuery(request, size, sortOrder);\n        // ...\n    }\n}','JAVA','Controller에서 Math.max(), Math.min(), 삼항 연산자 등으로 값을 계산하거나 기본값을 설정하면 안 됩니다. 이러한 로직은 Thin Controller 원칙을 위반합니다.','[10, 11, 13, 14]','2026-01-16 06:53:03','2026-01-16 06:53:03','MANUAL',NULL,NULL),(105,415,'GOOD','@RestController\n@RequestMapping(\"/api/v1/techstacks\")\npublic class TechStackQueryController {\n\n    private final TechStackQueryUseCase useCase;\n    private final TechStackApiMapper mapper;\n\n    @GetMapping\n    public ResponseEntity<ApiResponse<TechStackListApiResponse>> getTechStacks(\n            @Valid TechStackSearchApiRequest request\n    ) {\n        // ✅ GOOD: Controller는 단순 위임만 수행\n        TechStackSearchCriteria criteria = mapper.toQuery(request);\n        TechStackResult result = useCase.search(criteria);\n        return ResponseEntity.ok(ApiResponse.success(mapper.toApiResponse(result)));\n    }\n}\n\n// ✅ GOOD: Mapper에서 기본값/계산 로직 처리\n@Component\npublic class TechStackApiMapper {\n\n    public TechStackSearchCriteria toQuery(TechStackSearchApiRequest request) {\n        return new TechStackSearchCriteria(\n            request.name(),\n            request.status(),\n            Math.max(1, Math.min(request.size(), 100)),  // Mapper에서 처리\n            request.sortKey(),\n            request.sortOrder() != null ? request.sortOrder() : \"DESC\"\n        );\n    }\n}','JAVA','Controller는 Mapper 호출과 UseCase 위임만 수행합니다. 계산이나 기본값 로직은 Mapper에서 처리하여 관심사를 명확히 분리합니다.','[13, 14, 15, 27, 28, 29, 30]','2026-01-16 06:53:03','2026-01-16 06:53:03','MANUAL',NULL,NULL),(106,416,'BAD','public record TechStackSearchApiRequest(\n    String name,\n    @NotNull TechStackStatus status,\n    Integer size,\n    String sortKey,\n    String sortOrder\n) {\n    // ❌ BAD: Compact Constructor에서 기본값 설정\n    public TechStackSearchApiRequest {\n        if (size == null || size <= 0) {\n            size = 20;  // 기본값 설정 금지\n        }\n        if (sortOrder == null) {\n            sortOrder = \"DESC\";  // 기본값 설정 금지\n        }\n        if (sortKey == null) {\n            sortKey = \"CREATED_AT\";  // 기본값 설정 금지\n        }\n    }\n}','JAVA','Request DTO의 Compact Constructor에서 기본값을 설정하면 안 됩니다. 이는 비즈니스 로직에 해당하며 Mapper에서 처리해야 합니다.','[9, 10, 11, 13, 14, 16, 17]','2026-01-16 06:53:03','2026-01-16 06:53:03','MANUAL',NULL,NULL),(107,416,'GOOD','// ✅ GOOD: DTO는 유효성 검증만 수행\npublic record TechStackSearchApiRequest(\n    String name,\n    @NotNull TechStackStatus status,\n    @NotNull @Min(1) @Max(100) Integer size,\n    @NotNull String sortKey,\n    @NotNull String sortOrder\n) {\n    // Compact Constructor는 유효성 검증만\n    public TechStackSearchApiRequest {\n        Objects.requireNonNull(status, \"status must not be null\");\n        Objects.requireNonNull(size, \"size must not be null\");\n    }\n}\n\n// ✅ GOOD: 기본값은 Mapper에서 처리\n@Component\npublic class TechStackApiMapper {\n\n    public TechStackSearchCriteria toQuery(TechStackSearchApiRequest request) {\n        return new TechStackSearchCriteria(\n            request.name(),\n            request.status(),\n            request.size(),\n            request.sortKey(),\n            request.sortOrder()\n        );\n    }\n}','JAVA','DTO는 순수 데이터 전송 객체로 유지하고, 기본값 설정은 Mapper에서 처리합니다. DTO의 Compact Constructor는 유효성 검증만 수행합니다.','[2, 10, 11, 12, 20, 21, 22, 23, 24, 25]','2026-01-16 06:53:03','2026-01-16 06:53:03','MANUAL',NULL,NULL),(108,417,'BAD','public record TechStackApiResponse(\n    Long id,\n    String name,\n    String status,\n    // ❌ BAD: LocalDateTime 타입 + @JsonFormat 사용\n    @JsonFormat(pattern = \"yyyy-MM-dd\'T\'HH:mm:ss\")\n    LocalDateTime createdAt,\n    @JsonFormat(pattern = \"yyyy-MM-dd\'T\'HH:mm:ss\")\n    LocalDateTime updatedAt\n) {}','JAVA','Response DTO에서 LocalDateTime 타입과 @JsonFormat 어노테이션을 사용하면 안 됩니다. 이는 JacksonConfig 중앙 설정과 충돌하며, DTO가 직렬화 로직에 의존하게 됩니다.','[5, 6, 7, 8, 9]','2026-01-16 06:53:03','2026-01-16 06:53:03','MANUAL',NULL,NULL),(109,417,'GOOD','// ✅ GOOD: String 타입으로 날짜/시간 표현\npublic record TechStackApiResponse(\n    Long id,\n    String name,\n    String status,\n    String createdAt,   // ISO8601 형식 문자열\n    String updatedAt    // ISO8601 형식 문자열\n) {}\n\n// ✅ GOOD: Mapper에서 DateTimeFormatUtils 사용하여 변환\n@Component\npublic class TechStackApiMapper {\n\n    public TechStackApiResponse toApiResponse(TechStackResult result) {\n        return new TechStackApiResponse(\n            result.id(),\n            result.name(),\n            result.status().name(),\n            DateTimeFormatUtils.toIso8601(result.createdAt()),\n            DateTimeFormatUtils.toIso8601(result.updatedAt())\n        );\n    }\n}','JAVA','Response DTO는 날짜/시간 필드를 String 타입으로 선언하고, Mapper에서 DateTimeFormatUtils.toIso8601()을 사용하여 변환합니다.','[2, 6, 7, 17, 18]','2026-01-16 06:53:03','2026-01-16 06:53:03','MANUAL',NULL,NULL),(110,418,'BAD','// ❌ BAD: 공통 Endpoints 클래스에 모든 도메인 경로 포함\npublic final class ApiPaths {\n    public static final String API_V1 = \"/api/v1\";\n\n    // TechStack 경로\n    public static final String TECH_STACKS = API_V1 + \"/techstacks\";\n    public static final String TECH_STACK_DETAIL = TECH_STACKS + \"/{id}\";\n\n    // Convention 경로\n    public static final String CONVENTIONS = API_V1 + \"/conventions\";\n    public static final String CONVENTION_DETAIL = CONVENTIONS + \"/{id}\";\n\n    // Architecture 경로\n    public static final String ARCHITECTURES = API_V1 + \"/architectures\";\n    // ... 계속 늘어남\n\n    private ApiPaths() {}\n}','JAVA','공통 Endpoints 클래스에 모든 도메인 경로를 포함하면 단일 책임 원칙이 깨지고, 하나의 도메인 변경이 다른 도메인에 영향을 줄 수 있습니다.','[2, 6, 7, 10, 11, 14]','2026-01-16 06:53:03','2026-01-16 06:53:03','MANUAL',NULL,NULL),(111,418,'GOOD','// ✅ GOOD: 도메인별 Endpoints 클래스 분리\npublic final class TechStackApiEndpoints {\n    private static final String BASE = \"/api/v1/techstacks\";\n\n    public static final String LIST = BASE;\n    public static final String DETAIL = BASE + \"/{id}\";\n    public static final String CREATE = BASE;\n    public static final String UPDATE = BASE + \"/{id}\";\n    public static final String DELETE = BASE + \"/{id}/delete\";\n\n    private TechStackApiEndpoints() {}\n}\n\n// 별도 파일\npublic final class ConventionApiEndpoints {\n    private static final String BASE = \"/api/v1/conventions\";\n\n    public static final String LIST = BASE;\n    public static final String DETAIL = BASE + \"/{id}\";\n\n    private ConventionApiEndpoints() {}\n}','JAVA','도메인별로 Endpoints 클래스를 분리하여 응집도를 높이고, 변경 영향을 해당 도메인으로 제한합니다.','[2, 3, 5, 6, 7, 8, 9, 16, 17, 19, 20]','2026-01-16 06:53:03','2026-01-16 06:53:03','MANUAL',NULL,NULL),(112,419,'BAD','// ❌ BAD: GlobalExceptionHandler에서 직접 ErrorCode 처리\n@RestControllerAdvice\npublic class GlobalExceptionHandler {\n\n    @ExceptionHandler(DomainException.class)\n    public ResponseEntity<ApiResponse<Void>> handleDomainException(DomainException ex) {\n        ErrorCode errorCode = ex.getErrorCode();\n\n        // ❌ BAD: 모든 도메인 ErrorCode를 여기서 분기 처리\n        HttpStatus status = switch (errorCode.getCode()) {\n            case \"TECH_001\" -> HttpStatus.NOT_FOUND;\n            case \"TECH_002\" -> HttpStatus.BAD_REQUEST;\n            case \"CONV_001\" -> HttpStatus.NOT_FOUND;\n            // ... 계속 늘어남\n            default -> HttpStatus.INTERNAL_SERVER_ERROR;\n        };\n\n        return ResponseEntity.status(status)\n            .body(ApiResponse.error(errorCode.getMessage()));\n    }\n}','JAVA','GlobalExceptionHandler에서 모든 도메인 ErrorCode를 직접 처리하면 단일 책임 원칙이 깨지고, 코드가 비대해집니다.','[10, 11, 12, 13, 14]','2026-01-16 06:53:04','2026-01-16 06:53:04','MANUAL',NULL,NULL),(113,419,'GOOD','// ✅ GOOD: 도메인별 ErrorMapper 분리\n@Component\npublic class TechStackErrorMapper implements ErrorMapper {\n\n    @Override\n    public boolean supports(ErrorCode errorCode) {\n        return errorCode instanceof TechStackErrorCode;\n    }\n\n    @Override\n    public ErrorResponse toErrorResponse(ErrorCode errorCode) {\n        TechStackErrorCode code = (TechStackErrorCode) errorCode;\n        return switch (code) {\n            case NOT_FOUND -> new ErrorResponse(HttpStatus.NOT_FOUND, code.getMessage());\n            case DUPLICATE_NAME -> new ErrorResponse(HttpStatus.CONFLICT, code.getMessage());\n            case HAS_CHILDREN -> new ErrorResponse(HttpStatus.BAD_REQUEST, code.getMessage());\n        };\n    }\n}\n\n// ✅ GOOD: ErrorMapperRegistry에 등록\n@Configuration\npublic class ErrorMapperConfig {\n\n    @Bean\n    public ErrorMapperRegistry errorMapperRegistry(List<ErrorMapper> mappers) {\n        ErrorMapperRegistry registry = new ErrorMapperRegistry();\n        mappers.forEach(registry::register);\n        return registry;\n    }\n}','JAVA','도메인별 ErrorMapper를 분리하여 각 도메인의 ErrorCode 처리를 캡슐화합니다. ErrorMapperRegistry를 통해 GlobalExceptionHandler에서 적절한 ErrorMapper를 찾아 사용합니다.','[2, 3, 6, 7, 12, 13, 14, 15, 26, 27, 28, 29]','2026-01-16 06:53:04','2026-01-16 06:53:04','MANUAL',NULL,NULL),(114,420,'BAD','// ❌ BAD: 오프셋 기반 페이지네이션\n@GetMapping\npublic ResponseEntity<ApiResponse<TechStackListApiResponse>> getTechStacks(\n        @RequestParam(defaultValue = \"0\") int page,\n        @RequestParam(defaultValue = \"20\") int size\n) {\n    // OFFSET = page * size → 대용량에서 성능 저하\n    PageRequest pageRequest = PageRequest.of(page, size);\n    Page<TechStack> result = useCase.findAll(pageRequest);\n\n    return ResponseEntity.ok(ApiResponse.success(\n        new TechStackListApiResponse(\n            result.getContent(),\n            result.getTotalElements(),\n            result.getTotalPages()  // totalPages 계산도 비용\n        )\n    ));\n}','JAVA','오프셋 기반 페이지네이션은 OFFSET이 클수록 성능이 저하됩니다. 또한 데이터가 변경되면 중복 또는 누락이 발생할 수 있습니다.','[4, 5, 8, 15, 16]','2026-01-16 06:53:04','2026-01-16 06:53:04','MANUAL',NULL,NULL),(115,420,'GOOD','// ✅ GOOD: 커서 기반 페이지네이션\n@GetMapping\npublic ResponseEntity<ApiResponse<TechStackListApiResponse>> getTechStacks(\n        @Valid TechStackSearchApiRequest request\n) {\n    TechStackSearchCriteria criteria = mapper.toQuery(request);\n    CursorPageResponse<TechStackResult> result = useCase.searchWithCursor(criteria);\n\n    return ResponseEntity.ok(ApiResponse.success(\n        new TechStackListApiResponse(\n            mapper.toApiResponses(result.content()),\n            result.nextCursor(),  // 다음 페이지 커서\n            result.hasNext()\n        )\n    ));\n}\n\n// Request DTO\npublic record TechStackSearchApiRequest(\n    String cursor,           // 커서 (이전 응답의 nextCursor)\n    @NotNull @Max(100) Integer size,\n    String sortKey,\n    String sortOrder\n) {}','JAVA','커서 기반 페이지네이션은 WHERE id > :cursor 방식으로 일관된 성능을 제공합니다. 응답에 nextCursor를 포함하여 다음 페이지 조회에 사용합니다.','[4, 7, 12, 13, 19, 20, 21]','2026-01-16 06:53:04','2026-01-16 06:53:04','MANUAL',NULL,NULL),(116,421,'BAD','// ⚠️ 단순한 경우는 허용되지만, 복잡해지면 분리 권장\n@Component\npublic class TechStackApiMapper {\n\n    // Command 매핑\n    public TechStackCommand toCommand(TechStackCreateApiRequest request) { ... }\n    public TechStackCommand toCommand(TechStackUpdateApiRequest request) { ... }\n    public TechStackCommand toCommand(TechStackDeleteApiRequest request) { ... }\n\n    // Query 매핑\n    public TechStackSearchCriteria toQuery(TechStackSearchApiRequest request) { ... }\n    public TechStackDetailCriteria toQuery(Long id) { ... }\n\n    // Response 매핑\n    public TechStackApiResponse toApiResponse(TechStackResult result) { ... }\n    public TechStackListApiResponse toApiResponse(List<TechStackResult> results) { ... }\n    public TechStackDetailApiResponse toDetailApiResponse(TechStackDetailResult result) { ... }\n\n    // 메서드가 계속 늘어나면 클래스가 비대해짐\n}','JAVA','단일 Mapper에 Command, Query, Response 매핑이 모두 포함되면 클래스가 비대해지고 관심사가 혼재됩니다.','[6, 7, 8, 11, 12, 15, 16, 17]','2026-01-16 06:53:04','2026-01-16 06:53:04','MANUAL',NULL,NULL),(117,421,'GOOD','// ✅ GOOD: Command/Query Mapper 분리\n@Component\npublic class TechStackCommandApiMapper {\n\n    public TechStackCommand toCommand(TechStackCreateApiRequest request) { ... }\n    public TechStackCommand toCommand(TechStackUpdateApiRequest request) { ... }\n    public TechStackCommand toCommand(TechStackDeleteApiRequest request) { ... }\n\n    public TechStackIdApiResponse toApiResponse(Long id) { ... }\n}\n\n@Component\npublic class TechStackQueryApiMapper {\n\n    public TechStackSearchCriteria toQuery(TechStackSearchApiRequest request) { ... }\n\n    public TechStackApiResponse toApiResponse(TechStackResult result) { ... }\n    public TechStackListApiResponse toListApiResponse(CursorPageResponse<TechStackResult> result) { ... }\n    public TechStackDetailApiResponse toDetailApiResponse(TechStackDetailResult result) { ... }\n}','JAVA','Command와 Query Mapper를 분리하여 각 Mapper의 책임을 명확히 합니다. CQRS 패턴과 일관성을 유지합니다.','[2, 3, 5, 6, 7, 9, 13, 14, 16, 18, 19, 20]','2026-01-16 06:53:04','2026-01-16 06:53:04','MANUAL',NULL,NULL),(118,422,'BAD','// ❌ BAD: 단일 Factory가 Command와 Query 모두 담당\n@Component\npublic class TechStackFactory {\n\n    private final TimeProvider timeProvider;\n\n    // Command 변환 (DTO → Domain)\n    public TechStack create(CreateTechStackCommand command) {\n        return TechStack.create(\n            new TechStackName(command.name()),\n            // ...\n            timeProvider.now()\n        );\n    }\n\n    public TechStackUpdateData toUpdateData(UpdateTechStackCommand command) {\n        // ...\n    }\n\n    // Query 변환 (Query DTO → Criteria)\n    public TechStackSearchCriteria toSearchCriteria(GetAllTechStacksQuery query) {\n        return new TechStackSearchCriteria(\n            query.page(),\n            query.size(),\n            query.sortKey(),\n            query.sortDirection()\n        );\n    }\n\n    public TechStackSliceCriteria toSliceCriteria(GetActiveTechStacksQuery query) {\n        return new TechStackSliceCriteria(\n            query.cursor(),\n            query.size()\n        );\n    }\n}','JAVA','단일 Factory가 Command와 Query 변환을 모두 담당하면 클래스가 비대해지고, Command와 Query의 변경이 서로 영향을 줄 수 있습니다.','[3, 4, 9, 10, 11, 12, 13, 14, 18, 21, 22, 23, 24, 25, 26, 29, 30, 31, 32]','2026-01-16 06:53:04','2026-01-16 06:53:04','MANUAL',NULL,NULL),(119,422,'GOOD','// ✅ GOOD: CommandFactory - Command DTO → Domain 변환\n@Component\npublic class TechStackCommandFactory {\n\n    private final TimeProvider timeProvider;\n\n    public TechStack create(CreateTechStackCommand command) {\n        return TechStack.create(\n            new TechStackName(command.name()),\n            new FrameworkType(command.frameworkType()),\n            new FrameworkVersion(command.frameworkVersion()),\n            timeProvider.now()\n        );\n    }\n\n    public TechStackUpdateData toUpdateData(UpdateTechStackCommand command) {\n        return new TechStackUpdateData(\n            new TechStackName(command.name()),\n            command.status()\n        );\n    }\n\n    public TechStackId toId(Long id) {\n        return new TechStackId(id);\n    }\n}\n\n// ✅ GOOD: QueryFactory - Query DTO → Criteria 변환\n@Component\npublic class TechStackQueryFactory {\n\n    public TechStackSearchCriteria toSearchCriteria(GetAllTechStacksQuery query) {\n        return new TechStackSearchCriteria(\n            query.page(),\n            query.size(),\n            query.sortKey(),\n            query.sortDirection()\n        );\n    }\n\n    public TechStackSliceCriteria toSliceCriteria(GetActiveTechStacksQuery query) {\n        return new TechStackSliceCriteria(\n            query.cursor(),\n            query.size(),\n            query.sortDirection()\n        );\n    }\n}','JAVA','CommandFactory와 QueryFactory를 분리하여 각 Factory의 책임을 명확히 합니다. CommandFactory는 TimeProvider를 사용하고, QueryFactory는 Criteria 변환에 집중합니다.','[2, 3, 8, 9, 10, 11, 12, 13, 17, 18, 19, 20, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43]','2026-01-16 06:53:04','2026-01-16 06:53:04','MANUAL',NULL,NULL),(120,423,'BAD','// ❌ BAD: UseCase와 Service 시그니처 불일치\npublic interface GetAllTechStacksUseCase {\n    // Domain VO(CursorPageRequest) 직접 사용\n    CursorPage<TechStackResult> execute(CursorPageRequest<Long> request);\n}\n\n@Service\npublic class GetAllTechStacksService implements GetAllTechStacksUseCase {\n    // ❌ BAD: UseCase와 시그니처가 다름 - Primitive 타입 사용\n    public CursorPage<TechStackResult> execute(int page, int size) {\n        // 컴파일 에러! UseCase 인터페이스와 시그니처 불일치\n    }\n}\n\n// ❌ BAD: 커서 파라미터를 별도 필드로 분리\npublic record GetAllTechStacksQuery(\n    Long cursor,\n    int size,\n    String sortDirection\n) {\n    // 중복 코드, 표준화 안됨\n}','JAVA','UseCase 인터페이스에서 Domain VO를 직접 받거나, Service에서 Primitive 타입을 사용하면 시그니처 불일치가 발생합니다. 커서 파라미터를 별도로 정의하면 코드가 중복됩니다.','[3, 4, 11, 12, 17, 18, 19, 20, 21]','2026-01-16 06:53:04','2026-01-16 06:53:04','MANUAL',NULL,NULL),(121,423,'GOOD','// ✅ GOOD: CommonCursorParams 공통 DTO\npublic record CommonCursorParams(\n    Long cursor,\n    int size,\n    String sortDirection\n) {\n    public CommonCursorParams {\n        if (size <= 0 || size > 100) {\n            size = 20;  // 기본값\n        }\n        if (sortDirection == null) {\n            sortDirection = \"DESC\";\n        }\n    }\n}\n\n// ✅ GOOD: Query DTO에 CommonCursorParams 포함\npublic record GetAllTechStacksQuery(\n    CommonCursorParams cursorParams\n) {\n    // Delegate 메서드 제공 (중첩 접근 방지)\n    public Long cursor() { return cursorParams.cursor(); }\n    public int size() { return cursorParams.size(); }\n    public String sortDirection() { return cursorParams.sortDirection(); }\n}\n\n// ✅ GOOD: UseCase와 Service 시그니처 통일\npublic interface GetAllTechStacksUseCase {\n    CursorPage<TechStackResult> execute(GetAllTechStacksQuery query);\n}\n\n@Service\npublic class GetAllTechStacksService implements GetAllTechStacksUseCase {\n\n    @Override\n    public CursorPage<TechStackResult> execute(GetAllTechStacksQuery query) {\n        TechStackSliceCriteria criteria = queryFactory.toSliceCriteria(query);\n        return readManager.findBySliceCriteria(criteria);\n    }\n}','JAVA','CommonCursorParams를 공통 DTO로 정의하고, Query DTO에 포함시킵니다. Delegate 메서드로 중첩 접근을 방지하고, UseCase와 Service 시그니처가 통일됩니다.','[2, 3, 4, 5, 6, 18, 19, 22, 23, 24, 28, 29, 34, 35, 38, 39]','2026-01-16 06:53:04','2026-01-16 06:53:04','MANUAL',NULL,NULL),(122,424,'BAD','// ❌ BAD: 커서 기반 조회가 없는 QueryPort\npublic interface TechStackQueryPort {\n\n    // 표준 4개 메서드만 제공\n    Optional<TechStack> findById(TechStackId id);\n    boolean existsById(TechStackId id);\n    List<TechStack> findByCriteria(TechStackSearchCriteria criteria);\n    long countByCriteria(TechStackSearchCriteria criteria);\n\n    // ❌ BAD: 커서 기반 조회 메서드 없음\n    // Service에서 Offset 기반으로 대용량 조회 시 성능 저하\n}\n\n// ❌ BAD: ReadManager에서 직접 Offset 계산\n@Component\npublic class TechStackReadManager {\n\n    public Page<TechStack> findAll(int page, int size) {\n        // Offset 기반: 대용량에서 성능 저하\n        return queryPort.findByCriteria(\n            new TechStackSearchCriteria(page * size, size)\n        );\n    }\n}','JAVA','QueryPort에 커서 기반 조회 메서드가 없으면 Offset 기반으로 대용량 데이터를 조회해야 하며, 이는 성능 저하를 유발합니다.','[3, 7, 8, 9, 10, 12, 18, 19, 21, 22, 23]','2026-01-16 06:53:04','2026-01-16 06:53:04','MANUAL',NULL,NULL),(123,424,'GOOD','// ✅ GOOD: SliceCriteria 기반 조회 메서드 제공\npublic interface TechStackQueryPort {\n\n    // 표준 4개 메서드\n    Optional<TechStack> findById(TechStackId id);\n    boolean existsById(TechStackId id);\n    List<TechStack> findByCriteria(TechStackSearchCriteria criteria);\n    long countByCriteria(TechStackSearchCriteria criteria);\n\n    // ✅ GOOD: 커서 기반 조회 메서드 추가\n    Slice<TechStack> findBySliceCriteria(TechStackSliceCriteria criteria);\n}\n\n// ✅ GOOD: SliceCriteria 정의\npublic record TechStackSliceCriteria(\n    Long cursor,      // 마지막으로 조회한 ID\n    int size,\n    String sortDirection,\n    TechStackStatus status  // 필터 조건\n) {}\n\n// ✅ GOOD: ReadManager에서 SliceCriteria 메서드 래핑\n@Component\n@Transactional(readOnly = true)\npublic class TechStackReadManager {\n\n    private final TechStackQueryPort queryPort;\n\n    public Slice<TechStack> findBySliceCriteria(TechStackSliceCriteria criteria) {\n        return queryPort.findBySliceCriteria(criteria);\n    }\n}','JAVA','QueryPort에 findBySliceCriteria() 메서드를 추가하여 커서 기반 조회를 지원합니다. SliceCriteria는 cursor, size, sortDirection, 필터 조건을 포함합니다. ReadManager도 이 메서드를 래핑합니다.','[2, 12, 16, 17, 18, 19, 20, 26, 27, 32, 33]','2026-01-16 06:53:04','2026-01-16 06:53:04','MANUAL',NULL,NULL);
/*!40000 ALTER TABLE `rule_example` ENABLE KEYS */;
UNLOCK TABLES;

LOCK TABLES `resource_template` WRITE;
/*!40000 ALTER TABLE `resource_template` DISABLE KEYS */;
INSERT INTO `resource_template` (`id`, `module_id`, `category`, `file_path`, `file_type`, `description`, `template_content`, `required`, `created_at`, `updated_at`, `deleted_at`) VALUES (1,4,'CONFIG','application.yml','YAML','REST-API 모듈 공통 설정. 환경 무관하게 적용되는 기본값 정의. 환경별 설정은 application-{profile}.yml에서 오버라이드.','# ============================================================\n# REST-API Module - Common Configuration\n# ============================================================\n\nspring:\n  application:\n    name: ${APPLICATION_NAME:rest-api}\n\n  # ─────────────────────────────────────────────────────────\n  # Profile 설정\n  # ─────────────────────────────────────────────────────────\n  profiles:\n    active: ${SPRING_PROFILES_ACTIVE:local}\n\n  # ─────────────────────────────────────────────────────────\n  # Jackson JSON 직렬화 설정\n  # ─────────────────────────────────────────────────────────\n  jackson:\n    # 날짜/시간 형식 (ISO 8601)\n    date-format: yyyy-MM-dd\'T\'HH:mm:ss\n    time-zone: Asia/Seoul\n    # 직렬화 옵션\n    serialization:\n      write-dates-as-timestamps: false\n      fail-on-empty-beans: false\n      indent-output: false\n    # 역직렬화 옵션\n    deserialization:\n      fail-on-unknown-properties: false\n      accept-single-value-as-array: true\n    # NULL 처리\n    default-property-inclusion: non_null\n\n  # ─────────────────────────────────────────────────────────\n  # 국제화 (i18n) 설정\n  # ─────────────────────────────────────────────────────────\n  messages:\n    basename: messages/messages\n    encoding: UTF-8\n    fallback-to-system-locale: false\n    use-code-as-default-message: true\n\n# ─────────────────────────────────────────────────────────\n# 서버 공통 설정\n# ─────────────────────────────────────────────────────────\nserver:\n  # 서블릿 설정\n  servlet:\n    context-path: /api\n    encoding:\n      charset: UTF-8\n      enabled: true\n      force: true\n\n  # 에러 처리 설정\n  error:\n    include-message: always\n    include-binding-errors: always\n    include-stacktrace: never\n    include-exception: false\n    whitelabel:\n      enabled: false\n\n# ─────────────────────────────────────────────────────────\n# Spring MVC 설정\n# ─────────────────────────────────────────────────────────\nspring.mvc:\n  # RFC 7807 Problem Details 활성화\n  problemdetails:\n    enabled: true\n  # 핸들러 없을 시 예외 발생\n  throw-exception-if-no-handler-found: true\n  # 날짜/시간 포맷\n  format:\n    date: yyyy-MM-dd\n    time: HH:mm:ss\n    date-time: yyyy-MM-dd\'T\'HH:mm:ss\n\n# ─────────────────────────────────────────────────────────\n# OpenAPI/Swagger 설정\n# ─────────────────────────────────────────────────────────\nspringdoc:\n  api-docs:\n    path: /v3/api-docs\n    enabled: true\n  swagger-ui:\n    path: /swagger-ui.html\n    enabled: true\n    operations-sorter: method\n    tags-sorter: alpha\n    display-request-duration: true\n  # 기본 응답 타입\n  default-produces-media-type: application/json\n  default-consumes-media-type: application/json\n',1,'2026-01-16 02:26:13','2026-01-16 02:26:13',NULL),(2,4,'CONFIG','application-local.yml','YAML','로컬 개발 환경 설정. 개발 편의성 극대화: 상세 로깅, Swagger 활성화, 빠른 피드백.','# ============================================================\n# REST-API Module - Local Development Configuration\n# ============================================================\n\nserver:\n  port: 8080\n\n  # Tomcat 설정 (개발용 - 가벼운 설정)\n  tomcat:\n    threads:\n      max: 10\n      min-spare: 2\n    accept-count: 10\n    connection-timeout: 5000\n\n# ─────────────────────────────────────────────────────────\n# 로깅 설정 (개발: 상세 로깅)\n# ─────────────────────────────────────────────────────────\nlogging:\n  level:\n    root: INFO\n    # 애플리케이션 로그 - DEBUG\n    com.ryuqq: DEBUG\n    # Spring MVC 요청 매핑 로그\n    org.springframework.web: DEBUG\n    org.springframework.web.servlet.mvc.method.annotation: DEBUG\n    # SQL 로그\n    org.hibernate.SQL: DEBUG\n    org.hibernate.type.descriptor.sql: TRACE\n    # Jackson 직렬화 로그\n    com.fasterxml.jackson: DEBUG\n\n  pattern:\n    console: \"%d{HH:mm:ss.SSS} %clr(%-5level) [%thread] %clr(%logger{36}){cyan} - %msg%n\"\n\n# ─────────────────────────────────────────────────────────\n# 개발 편의 설정\n# ─────────────────────────────────────────────────────────\nspring:\n  # 에러 상세 정보 (개발용)\n  mvc:\n    log-request-details: true\n\n  # DevTools (선택적)\n  devtools:\n    restart:\n      enabled: true\n    livereload:\n      enabled: true\n\n# ─────────────────────────────────────────────────────────\n# Swagger UI 설정 (로컬 전체 활성화)\n# ─────────────────────────────────────────────────────────\nspringdoc:\n  swagger-ui:\n    enabled: true\n    try-it-out-enabled: true\n    filter: true\n    show-extensions: true\n  show-actuator: true\n\n# ─────────────────────────────────────────────────────────\n# Actuator 설정 (개발: 전체 노출)\n# ─────────────────────────────────────────────────────────\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: \"*\"\n  endpoint:\n    health:\n      show-details: always\n    env:\n      show-values: always\n',1,'2026-01-16 02:26:13','2026-01-16 02:26:13',NULL),(3,4,'CONFIG','application-dev.yml','YAML','개발 서버 환경 설정. 팀 공유 개발 서버용. 적당한 로깅, Swagger 활성화, 성능보다 디버깅 우선.','# ============================================================\n# REST-API Module - Development Server Configuration\n# ============================================================\n\nserver:\n  port: ${SERVER_PORT:8080}\n\n  # Tomcat 설정 (개발 서버용 - 중간 설정)\n  tomcat:\n    threads:\n      max: 50\n      min-spare: 10\n    accept-count: 50\n    connection-timeout: 10000\n    max-connections: 200\n\n# ─────────────────────────────────────────────────────────\n# 로깅 설정 (개발 서버: INFO + 애플리케이션 DEBUG)\n# ─────────────────────────────────────────────────────────\nlogging:\n  level:\n    root: INFO\n    com.ryuqq: DEBUG\n    org.springframework.web: INFO\n    org.hibernate.SQL: DEBUG\n\n  file:\n    name: ${LOG_PATH:/var/log/app}/rest-api.log\n\n  logback:\n    rollingpolicy:\n      max-file-size: 100MB\n      max-history: 7\n      total-size-cap: 1GB\n\n# ─────────────────────────────────────────────────────────\n# Swagger UI 설정 (개발 서버 활성화)\n# ─────────────────────────────────────────────────────────\nspringdoc:\n  swagger-ui:\n    enabled: true\n  api-docs:\n    enabled: true\n\n# ─────────────────────────────────────────────────────────\n# Actuator 설정 (개발 서버: 제한적 노출)\n# ─────────────────────────────────────────────────────────\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: health,info,metrics,loggers\n  endpoint:\n    health:\n      show-details: when_authorized\n',1,'2026-01-16 02:26:13','2026-01-16 02:26:13',NULL),(4,4,'CONFIG','application-staging.yml','YAML','스테이징 환경 설정. 운영 환경과 동일한 설정으로 사전 검증. Swagger 비활성화, 보안 강화.','# ============================================================\n# REST-API Module - Staging Configuration\n# ============================================================\n\nserver:\n  port: ${SERVER_PORT:8080}\n\n  # Tomcat 설정 (운영과 동일)\n  tomcat:\n    threads:\n      max: 200\n      min-spare: 20\n    accept-count: 100\n    connection-timeout: 20000\n    max-connections: 8192\n\n  # Gzip 압축 활성화\n  compression:\n    enabled: true\n    mime-types: application/json,application/xml,text/html,text/xml,text/plain\n    min-response-size: 1024\n\n# ─────────────────────────────────────────────────────────\n# 로깅 설정 (스테이징: INFO 레벨)\n# ─────────────────────────────────────────────────────────\nlogging:\n  level:\n    root: INFO\n    com.ryuqq: INFO\n    org.springframework.web: WARN\n    org.hibernate.SQL: WARN\n\n  file:\n    name: ${LOG_PATH:/var/log/app}/rest-api.log\n\n  logback:\n    rollingpolicy:\n      max-file-size: 200MB\n      max-history: 14\n      total-size-cap: 3GB\n\n# ─────────────────────────────────────────────────────────\n# Swagger UI 설정 (스테이징: 비활성화)\n# ─────────────────────────────────────────────────────────\nspringdoc:\n  swagger-ui:\n    enabled: false\n  api-docs:\n    enabled: false\n\n# ─────────────────────────────────────────────────────────\n# Actuator 설정 (스테이징: 최소 노출)\n# ─────────────────────────────────────────────────────────\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: health,info,prometheus\n  endpoint:\n    health:\n      show-details: never\n',1,'2026-01-16 02:26:13','2026-01-16 02:26:13',NULL),(5,4,'CONFIG','application-prod.yml','YAML','운영 환경 설정. 보안 최우선, 성능 최적화, 최소 로깅. Swagger/Actuator 엄격 제한.','# ============================================================\n# REST-API Module - Production Configuration\n# ============================================================\n\nserver:\n  port: ${SERVER_PORT:8080}\n\n  # Tomcat 설정 (운영: 고성능)\n  tomcat:\n    threads:\n      max: 200\n      min-spare: 50\n    accept-count: 100\n    connection-timeout: 20000\n    max-connections: 10000\n    # Keep-Alive 설정\n    keep-alive-timeout: 30000\n    max-keep-alive-requests: 100\n\n  # Gzip 압축 활성화 (성능)\n  compression:\n    enabled: true\n    mime-types: application/json,application/xml,text/html,text/xml,text/plain,application/javascript,text/css\n    min-response-size: 1024\n\n  # 보안 헤더\n  error:\n    include-message: never\n    include-binding-errors: never\n    include-stacktrace: never\n    include-exception: false\n\n# ─────────────────────────────────────────────────────────\n# 로깅 설정 (운영: WARN 이상만)\n# ─────────────────────────────────────────────────────────\nlogging:\n  level:\n    root: WARN\n    com.ryuqq: INFO\n    org.springframework.web: WARN\n    org.hibernate: WARN\n\n  file:\n    name: ${LOG_PATH:/var/log/app}/rest-api.log\n\n  logback:\n    rollingpolicy:\n      max-file-size: 500MB\n      max-history: 30\n      total-size-cap: 10GB\n\n  # JSON 로그 포맷 (로그 수집기 연동)\n  pattern:\n    file: \'{\"timestamp\":\"%d{yyyy-MM-dd\'T\'HH:mm:ss.SSSZ}\",\"level\":\"%level\",\"logger\":\"%logger\",\"message\":\"%msg\",\"thread\":\"%thread\"}%n\'\n\n# ─────────────────────────────────────────────────────────\n# Swagger UI 설정 (운영: 완전 비활성화)\n# ─────────────────────────────────────────────────────────\nspringdoc:\n  swagger-ui:\n    enabled: false\n  api-docs:\n    enabled: false\n\n# ─────────────────────────────────────────────────────────\n# Actuator 설정 (운영: 헬스체크만)\n# ─────────────────────────────────────────────────────────\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: health,prometheus\n      base-path: /internal/actuator\n  endpoint:\n    health:\n      show-details: never\n      probes:\n        enabled: true\n  # Prometheus 메트릭\n  prometheus:\n    metrics:\n      export:\n        enabled: true\n\n# ─────────────────────────────────────────────────────────\n# 보안 설정 (운영)\n# ─────────────────────────────────────────────────────────\nspring:\n  # 예외 상세 정보 숨김\n  mvc:\n    log-request-details: false\n',1,'2026-01-16 02:26:14','2026-01-16 02:26:14',NULL),(6,4,'I18N','messages/messages.properties','PROPERTIES','기본 메시지 번들 (영문). 국제화 기본값으로 사용. validation, error, common 메시지 정의.','# ============================================================\n# REST-API Module - Default Messages (English)\n# ============================================================\n\n# ─────────────────────────────────────────────────────────\n# Common Messages\n# ─────────────────────────────────────────────────────────\ncommon.success=Success\ncommon.fail=Failed\ncommon.error=An error occurred\n\n# ─────────────────────────────────────────────────────────\n# Validation Messages (Bean Validation)\n# ─────────────────────────────────────────────────────────\n# Standard constraints\njakarta.validation.constraints.NotNull.message=must not be null\njakarta.validation.constraints.NotEmpty.message=must not be empty\njakarta.validation.constraints.NotBlank.message=must not be blank\njakarta.validation.constraints.Size.message=size must be between {min} and {max}\njakarta.validation.constraints.Min.message=must be greater than or equal to {value}\njakarta.validation.constraints.Max.message=must be less than or equal to {value}\njakarta.validation.constraints.Email.message=must be a valid email address\njakarta.validation.constraints.Pattern.message=must match \"{regexp}\"\njakarta.validation.constraints.Positive.message=must be greater than 0\njakarta.validation.constraints.PositiveOrZero.message=must be greater than or equal to 0\njakarta.validation.constraints.Past.message=must be a past date\njakarta.validation.constraints.Future.message=must be a future date\n\n# ─────────────────────────────────────────────────────────\n# API Error Messages\n# ─────────────────────────────────────────────────────────\n# HTTP Status\nerror.bad-request=Bad request\nerror.unauthorized=Unauthorized access\nerror.forbidden=Access denied\nerror.not-found=Resource not found\nerror.method-not-allowed=Method not allowed\nerror.conflict=Resource conflict\nerror.unprocessable-entity=Unprocessable entity\nerror.internal-server-error=Internal server error\nerror.service-unavailable=Service temporarily unavailable\n\n# Business Errors\nerror.resource.not-found={0} not found with id: {1}\nerror.resource.already-exists={0} already exists\nerror.resource.cannot-delete={0} cannot be deleted\nerror.validation.failed=Validation failed\n\n# ─────────────────────────────────────────────────────────\n# Field Labels (for error messages)\n# ─────────────────────────────────────────────────────────\nfield.id=ID\nfield.name=Name\nfield.email=Email\nfield.password=Password\nfield.phone=Phone number\nfield.address=Address\nfield.createdAt=Created date\nfield.updatedAt=Updated date\n',1,'2026-01-16 02:26:14','2026-01-16 02:26:14',NULL),(7,4,'I18N','messages/messages_ko.properties','PROPERTIES','한국어 메시지 번들. 한국어 사용자를 위한 로컬라이제이션. validation, error, common 메시지 정의.','# ============================================================\n# REST-API Module - Korean Messages\n# ============================================================\n\n# ─────────────────────────────────────────────────────────\n# Common Messages\n# ─────────────────────────────────────────────────────────\ncommon.success=성공\ncommon.fail=실패\ncommon.error=오류가 발생했습니다\n\n# ─────────────────────────────────────────────────────────\n# Validation Messages (Bean Validation)\n# ─────────────────────────────────────────────────────────\n# Standard constraints\njakarta.validation.constraints.NotNull.message=필수 입력값입니다\njakarta.validation.constraints.NotEmpty.message=필수 입력값이며 비어있을 수 없습니다\njakarta.validation.constraints.NotBlank.message=필수 입력값이며 공백일 수 없습니다\njakarta.validation.constraints.Size.message={min}자 이상 {max}자 이하로 입력해주세요\njakarta.validation.constraints.Min.message={value} 이상의 값을 입력해주세요\njakarta.validation.constraints.Max.message={value} 이하의 값을 입력해주세요\njakarta.validation.constraints.Email.message=올바른 이메일 형식이 아닙니다\njakarta.validation.constraints.Pattern.message=올바른 형식이 아닙니다\njakarta.validation.constraints.Positive.message=0보다 큰 값을 입력해주세요\njakarta.validation.constraints.PositiveOrZero.message=0 이상의 값을 입력해주세요\njakarta.validation.constraints.Past.message=과거 날짜를 입력해주세요\njakarta.validation.constraints.Future.message=미래 날짜를 입력해주세요\n\n# ─────────────────────────────────────────────────────────\n# API Error Messages\n# ─────────────────────────────────────────────────────────\n# HTTP Status\nerror.bad-request=잘못된 요청입니다\nerror.unauthorized=인증이 필요합니다\nerror.forbidden=접근 권한이 없습니다\nerror.not-found=요청한 리소스를 찾을 수 없습니다\nerror.method-not-allowed=지원하지 않는 HTTP 메서드입니다\nerror.conflict=리소스 충돌이 발생했습니다\nerror.unprocessable-entity=처리할 수 없는 요청입니다\nerror.internal-server-error=서버 내부 오류가 발생했습니다\nerror.service-unavailable=서비스를 일시적으로 사용할 수 없습니다\n\n# Business Errors\nerror.resource.not-found={0}을(를) 찾을 수 없습니다. ID: {1}\nerror.resource.already-exists={0}이(가) 이미 존재합니다\nerror.resource.cannot-delete={0}을(를) 삭제할 수 없습니다\nerror.validation.failed=입력값 검증에 실패했습니다\n\n# ─────────────────────────────────────────────────────────\n# Field Labels (for error messages)\n# ─────────────────────────────────────────────────────────\nfield.id=아이디\nfield.name=이름\nfield.email=이메일\nfield.password=비밀번호\nfield.phone=전화번호\nfield.address=주소\nfield.createdAt=생성일\nfield.updatedAt=수정일\n',1,'2026-01-16 02:26:14','2026-01-16 02:26:14',NULL),(8,4,'CONFIG','logback-spring.xml','XML','Logback 로깅 설정. 환경별 로그 레벨, 파일 롤링, JSON 포맷 등 상세 설정.','<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<configuration scan=\"true\" scanPeriod=\"30 seconds\">\n\n    <!-- ═══════════════════════════════════════════════════════════════ -->\n    <!-- Properties                                                       -->\n    <!-- ═══════════════════════════════════════════════════════════════ -->\n    <property name=\"LOG_PATH\" value=\"${LOG_PATH:-./logs}\"/>\n    <property name=\"APP_NAME\" value=\"${spring.application.name:-rest-api}\"/>\n\n    <!-- Console Pattern -->\n    <property name=\"CONSOLE_PATTERN\"\n              value=\"%d{HH:mm:ss.SSS} %clr(%-5level){highlight} [%thread] %clr(%logger{36}){cyan} - %msg%n\"/>\n\n    <!-- File Pattern -->\n    <property name=\"FILE_PATTERN\"\n              value=\"%d{yyyy-MM-dd HH:mm:ss.SSS} %-5level [%thread] %logger{36} - %msg%n\"/>\n\n    <!-- JSON Pattern (for log aggregators) -->\n    <property name=\"JSON_PATTERN\"\n              value=\'{\"@timestamp\":\"%d{yyyy-MM-dd\'T\'HH:mm:ss.SSSZ}\",\"level\":\"%level\",\"logger\":\"%logger\",\"message\":\"%msg\",\"thread\":\"%thread\",\"application\":\"${APP_NAME}\"}%n\'/>\n\n    <!-- ═══════════════════════════════════════════════════════════════ -->\n    <!-- Appenders                                                        -->\n    <!-- ═══════════════════════════════════════════════════════════════ -->\n\n    <!-- Console Appender -->\n    <appender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\">\n        <encoder>\n            <pattern>${CONSOLE_PATTERN}</pattern>\n            <charset>UTF-8</charset>\n        </encoder>\n    </appender>\n\n    <!-- File Appender (Rolling) -->\n    <appender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n        <file>${LOG_PATH}/${APP_NAME}.log</file>\n        <encoder>\n            <pattern>${FILE_PATTERN}</pattern>\n            <charset>UTF-8</charset>\n        </encoder>\n        <rollingPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\">\n            <fileNamePattern>${LOG_PATH}/${APP_NAME}.%d{yyyy-MM-dd}.%i.log.gz</fileNamePattern>\n            <maxFileSize>100MB</maxFileSize>\n            <maxHistory>30</maxHistory>\n            <totalSizeCap>3GB</totalSizeCap>\n        </rollingPolicy>\n    </appender>\n\n    <!-- JSON File Appender (for production log aggregation) -->\n    <appender name=\"JSON_FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n        <file>${LOG_PATH}/${APP_NAME}-json.log</file>\n        <encoder>\n            <pattern>${JSON_PATTERN}</pattern>\n            <charset>UTF-8</charset>\n        </encoder>\n        <rollingPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\">\n            <fileNamePattern>${LOG_PATH}/${APP_NAME}-json.%d{yyyy-MM-dd}.%i.log.gz</fileNamePattern>\n            <maxFileSize>200MB</maxFileSize>\n            <maxHistory>7</maxHistory>\n            <totalSizeCap>5GB</totalSizeCap>\n        </rollingPolicy>\n    </appender>\n\n    <!-- ═══════════════════════════════════════════════════════════════ -->\n    <!-- Profile-specific Configuration                                   -->\n    <!-- ═══════════════════════════════════════════════════════════════ -->\n\n    <!-- Local Profile -->\n    <springProfile name=\"local\">\n        <root level=\"INFO\">\n            <appender-ref ref=\"CONSOLE\"/>\n        </root>\n        <logger name=\"com.ryuqq\" level=\"DEBUG\"/>\n        <logger name=\"org.springframework.web\" level=\"DEBUG\"/>\n        <logger name=\"org.hibernate.SQL\" level=\"DEBUG\"/>\n    </springProfile>\n\n    <!-- Development Profile -->\n    <springProfile name=\"dev\">\n        <root level=\"INFO\">\n            <appender-ref ref=\"CONSOLE\"/>\n            <appender-ref ref=\"FILE\"/>\n        </root>\n        <logger name=\"com.ryuqq\" level=\"DEBUG\"/>\n        <logger name=\"org.hibernate.SQL\" level=\"DEBUG\"/>\n    </springProfile>\n\n    <!-- Staging Profile -->\n    <springProfile name=\"staging\">\n        <root level=\"INFO\">\n            <appender-ref ref=\"FILE\"/>\n            <appender-ref ref=\"JSON_FILE\"/>\n        </root>\n        <logger name=\"com.ryuqq\" level=\"INFO\"/>\n    </springProfile>\n\n    <!-- Production Profile -->\n    <springProfile name=\"prod\">\n        <root level=\"WARN\">\n            <appender-ref ref=\"JSON_FILE\"/>\n        </root>\n        <logger name=\"com.ryuqq\" level=\"INFO\"/>\n    </springProfile>\n\n</configuration>',0,'2026-01-16 02:26:14','2026-01-16 02:26:14',NULL),(9,4,'STATIC','banner.txt','TEXT','Spring Boot 시작 배너. 애플리케이션 이름, 버전, 환경 정보 표시.','\n  ____  _____ ____ _____      _    ____ ___\n |  _ | ____/ ___|_   _|    /   |  _ \\_ _|\n | |_) |  _| \\___  | |     / _  | |_) | |\n |  _ <| |___ ___) || |    / ___ |  __/| |\n |_| \\_\\_____|____/ |_|   /_/   \\_\\_|  |___|\n\n :: ${spring.application.name} :: v${application.version:1.0.0}\n :: Spring Boot ${spring-boot.version}\n :: Profile: ${spring.profiles.active:default}\n :: Java ${java.version}\n',0,'2026-01-16 02:26:14','2026-01-16 02:26:14',NULL),(10,6,'CONFIG','persistence.yml','YAML','Persistence 모듈 공통 설정. DataSource, JPA, Hibernate 기본값 정의. 환경별 설정은 persistence-{profile}.yml에서 오버라이드.','# ============================================================\n# Persistence Module - Common Configuration\n# MySQL + HikariCP + JPA/Hibernate + QueryDSL\n# ============================================================\n\nspring:\n  # ─────────────────────────────────────────────────────────\n  # DataSource 공통 설정\n  # ─────────────────────────────────────────────────────────\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n\n    # HikariCP 공통 설정 (환경별로 오버라이드)\n    hikari:\n      # 풀 이름 (모니터링 식별용)\n      pool-name: ${HIKARI_POOL_NAME:HikariPool-Persistence}\n\n      # 커넥션 자동 커밋 (JPA 트랜잭션 사용 시 false 권장)\n      auto-commit: false\n\n      # 읽기 전용 여부 (기본값)\n      read-only: false\n\n      # 커넥션 카탈로그 (MySQL 데이터베이스 이름)\n      catalog: ${DB_NAME:app}\n\n      # 트랜잭션 격리 수준 (기본값: REPEATABLE_READ for MySQL)\n      transaction-isolation: TRANSACTION_REPEATABLE_READ\n\n      # 커넥션 초기화 SQL (MySQL 세션 설정)\n      connection-init-sql: |\n        SET NAMES utf8mb4 COLLATE utf8mb4_unicode_ci;\n        SET time_zone = \'+09:00\';\n        SET SESSION sql_mode = \'STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION\';\n\n      # 데이터소스 속성 (MySQL JDBC 드라이버 설정)\n      data-source-properties:\n        # PreparedStatement 캐싱\n        cachePrepStmts: true\n        prepStmtCacheSize: 250\n        prepStmtCacheSqlLimit: 2048\n        useServerPrepStmts: true\n\n        # 배치 처리 최적화\n        rewriteBatchedStatements: true\n\n        # 메타데이터 캐싱\n        cacheResultSetMetadata: true\n        cacheServerConfiguration: true\n\n        # 기타 성능 최적화\n        elideSetAutoCommits: true\n        maintainTimeStats: false\n        useLocalSessionState: true\n        useLocalTransactionState: true\n\n  # ─────────────────────────────────────────────────────────\n  # JPA 공통 설정\n  # ─────────────────────────────────────────────────────────\n  jpa:\n    # Hibernate 구현체 사용\n    database-platform: org.hibernate.dialect.MySQLDialect\n\n    # DDL 자동 생성 (운영에서는 반드시 none)\n    hibernate:\n      ddl-auto: ${JPA_DDL_AUTO:none}\n\n    # 지연 로딩 시 세션 열기 (권장하지 않음 - 명시적 fetch 사용)\n    open-in-view: false\n\n    # JPA 속성\n    properties:\n      hibernate:\n        # ─────────────────────────────────────────────────\n        # Dialect 설정\n        # ─────────────────────────────────────────────────\n        dialect: org.hibernate.dialect.MySQLDialect\n\n        # ─────────────────────────────────────────────────\n        # 배치 처리 설정 (벌크 INSERT/UPDATE 최적화)\n        # ─────────────────────────────────────────────────\n        jdbc:\n          batch_size: 50\n          batch_versioned_data: true\n          fetch_size: 100\n        order_inserts: true\n        order_updates: true\n\n        # ─────────────────────────────────────────────────\n        # 식별자 생성 최적화 (MySQL AUTO_INCREMENT)\n        # ─────────────────────────────────────────────────\n        id:\n          new_generator_mappings: true\n          optimizer:\n            pooled:\n              preferred: pooled-lo\n\n        # ─────────────────────────────────────────────────\n        # 2차 캐시 설정 (비활성화 - 필요 시 Redis 사용)\n        # ─────────────────────────────────────────────────\n        cache:\n          use_second_level_cache: false\n          use_query_cache: false\n\n        # ─────────────────────────────────────────────────\n        # 연결 관리\n        # ─────────────────────────────────────────────────\n        connection:\n          provider_disables_autocommit: true\n\n        # ─────────────────────────────────────────────────\n        # 통계 및 로깅 (기본 비활성화)\n        # ─────────────────────────────────────────────────\n        generate_statistics: false\n        session:\n          events:\n            log:\n              LOG_QUERIES_SLOWER_THAN_MS: 0\n\n  # ─────────────────────────────────────────────────────────\n  # Flyway 공통 설정\n  # ─────────────────────────────────────────────────────────\n  flyway:\n    # Flyway 활성화\n    enabled: ${FLYWAY_ENABLED:true}\n\n    # 마이그레이션 위치\n    locations: classpath:db/migration\n\n    # 기본 스키마\n    default-schema: ${DB_NAME:app}\n\n    # 마이그레이션 테이블 이름\n    table: flyway_schema_history\n\n    # 기준선 설정 (기존 DB에 Flyway 적용 시)\n    baseline-on-migrate: false\n    baseline-version: \'1\'\n\n    # 검증 설정\n    validate-on-migrate: true\n\n    # 클린 금지 (운영 보호)\n    clean-disabled: true\n\n    # 순서 외 마이그레이션 허용 (팀 협업 시)\n    out-of-order: false\n\n    # 인코딩\n    encoding: UTF-8\n\n    # 플레이스홀더\n    placeholder-replacement: true\n',1,'2026-01-16 06:52:08','2026-01-16 06:52:08',NULL),(11,6,'CONFIG','persistence-local.yml','YAML','로컬 개발 환경 설정. Docker MySQL 또는 로컬 MySQL 연결. 상세 SQL 로깅, 작은 커넥션 풀.','# ============================================================\n# Persistence Module - Local Development Configuration\n# ============================================================\n\nspring:\n  # ─────────────────────────────────────────────────────────\n  # DataSource 설정 (로컬 MySQL)\n  # ─────────────────────────────────────────────────────────\n  datasource:\n    url: jdbc:mysql://localhost:3306/${DB_NAME:app}?useSSL=false&allowPublicKeyRetrieval=true&serverTimezone=Asia/Seoul&characterEncoding=UTF-8&useUnicode=true&rewriteBatchedStatements=true&cachePrepStmts=true&useServerPrepStmts=true\n    username: ${DB_USERNAME:root}\n    password: ${DB_PASSWORD:root}\n\n    # ─────────────────────────────────────────────────────\n    # HikariCP 설정 (로컬: 최소 설정)\n    # ─────────────────────────────────────────────────────\n    hikari:\n      # 풀 크기 (로컬: 작게)\n      maximum-pool-size: 5\n      minimum-idle: 2\n\n      # 타임아웃 (로컬: 짧게)\n      connection-timeout: 5000        # 커넥션 획득 대기 최대 5초\n      idle-timeout: 300000            # 유휴 커넥션 유지 5분\n      max-lifetime: 600000            # 커넥션 최대 수명 10분\n      validation-timeout: 3000        # 커넥션 유효성 검사 3초\n\n      # 커넥션 테스트 (MySQL 전용)\n      connection-test-query: SELECT 1\n\n      # 커넥션 누수 감지 (개발 시 유용)\n      leak-detection-threshold: 30000  # 30초 이상 반환 안 되면 경고\n\n  # ─────────────────────────────────────────────────────────\n  # JPA 설정 (로컬: DDL 자동 검증)\n  # ─────────────────────────────────────────────────────────\n  jpa:\n    hibernate:\n      ddl-auto: validate    # 스키마 검증만 (Flyway로 관리)\n\n    # SQL 로깅 (개발 편의)\n    show-sql: true\n\n    properties:\n      hibernate:\n        # SQL 포맷팅\n        format_sql: true\n        use_sql_comments: true\n        highlight_sql: true\n\n        # 통계 수집 (개발 시 성능 분석)\n        generate_statistics: true\n\n        # 느린 쿼리 로깅 (100ms 이상)\n        session:\n          events:\n            log:\n              LOG_QUERIES_SLOWER_THAN_MS: 100\n\n  # ─────────────────────────────────────────────────────────\n  # Flyway 설정 (로컬)\n  # ─────────────────────────────────────────────────────────\n  flyway:\n    enabled: true\n    clean-disabled: false    # 로컬에서는 clean 허용\n    baseline-on-migrate: true\n\n# ─────────────────────────────────────────────────────────\n# 로깅 설정 (로컬: 상세 SQL 로깅)\n# ─────────────────────────────────────────────────────────\nlogging:\n  level:\n    # Hibernate SQL 로깅\n    org.hibernate.SQL: DEBUG\n    org.hibernate.type.descriptor.sql.BasicBinder: TRACE\n    org.hibernate.orm.jdbc.bind: TRACE\n\n    # HikariCP 로깅\n    com.zaxxer.hikari: DEBUG\n    com.zaxxer.hikari.HikariConfig: DEBUG\n\n    # Spring Data JPA\n    org.springframework.data.jpa: DEBUG\n\n    # QueryDSL\n    com.querydsl: DEBUG\n\n    # Flyway\n    org.flywaydb: DEBUG\n',1,'2026-01-16 06:52:08','2026-01-16 06:52:08',NULL),(12,6,'CONFIG','persistence-dev.yml','YAML','개발 서버 환경 설정. 팀 공유 개발 DB 연결. 적당한 커넥션 풀, SQL 로깅 활성화.','# ============================================================\n# Persistence Module - Development Server Configuration\n# ============================================================\n\nspring:\n  # ─────────────────────────────────────────────────────────\n  # DataSource 설정 (개발 서버 MySQL)\n  # ─────────────────────────────────────────────────────────\n  datasource:\n    url: jdbc:mysql://${DB_HOST:dev-mysql.internal}:${DB_PORT:3306}/${DB_NAME:app}?useSSL=true&requireSSL=true&verifyServerCertificate=false&serverTimezone=Asia/Seoul&characterEncoding=UTF-8&useUnicode=true&rewriteBatchedStatements=true&cachePrepStmts=true&useServerPrepStmts=true&connectTimeout=5000&socketTimeout=30000\n    username: ${DB_USERNAME}\n    password: ${DB_PASSWORD}\n\n    # ─────────────────────────────────────────────────────\n    # HikariCP 설정 (개발 서버: 중간 설정)\n    # ─────────────────────────────────────────────────────\n    hikari:\n      # 풀 크기 (개발: 중간)\n      maximum-pool-size: 10\n      minimum-idle: 5\n\n      # 타임아웃\n      connection-timeout: 10000       # 커넥션 획득 대기 최대 10초\n      idle-timeout: 600000            # 유휴 커넥션 유지 10분\n      max-lifetime: 1800000           # 커넥션 최대 수명 30분\n      validation-timeout: 5000        # 커넥션 유효성 검사 5초\n\n      # 커넥션 테스트\n      connection-test-query: SELECT 1\n\n      # 커넥션 누수 감지\n      leak-detection-threshold: 60000  # 60초 이상 반환 안 되면 경고\n\n      # 초기화 실패 타임아웃\n      initialization-fail-timeout: 30000\n\n  # ─────────────────────────────────────────────────────────\n  # JPA 설정 (개발 서버)\n  # ─────────────────────────────────────────────────────────\n  jpa:\n    hibernate:\n      ddl-auto: validate\n\n    show-sql: false    # 파일 로깅으로 대체\n\n    properties:\n      hibernate:\n        format_sql: true\n        generate_statistics: true\n\n        session:\n          events:\n            log:\n              LOG_QUERIES_SLOWER_THAN_MS: 500\n\n  # ─────────────────────────────────────────────────────────\n  # Flyway 설정 (개발 서버)\n  # ─────────────────────────────────────────────────────────\n  flyway:\n    enabled: true\n    clean-disabled: true    # 개발 서버에서도 clean 금지\n    out-of-order: true      # 팀 협업으로 순서 외 마이그레이션 허용\n\n# ─────────────────────────────────────────────────────────\n# 로깅 설정 (개발 서버: SQL 로깅)\n# ─────────────────────────────────────────────────────────\nlogging:\n  level:\n    org.hibernate.SQL: DEBUG\n    org.hibernate.orm.jdbc.bind: DEBUG\n    com.zaxxer.hikari: INFO\n    org.flywaydb: INFO\n',1,'2026-01-16 06:52:08','2026-01-16 06:52:08',NULL),(13,6,'CONFIG','persistence-staging.yml','YAML','스테이징 환경 설정. 운영과 유사한 설정으로 사전 검증. SQL 로깅 최소화, 운영급 커넥션 풀.','# ============================================================\n# Persistence Module - Staging Configuration\n# ============================================================\n\nspring:\n  # ─────────────────────────────────────────────────────────\n  # DataSource 설정 (스테이징 MySQL)\n  # ─────────────────────────────────────────────────────────\n  datasource:\n    url: jdbc:mysql://${DB_HOST}:${DB_PORT:3306}/${DB_NAME}?useSSL=true&requireSSL=true&verifyServerCertificate=true&serverTimezone=Asia/Seoul&characterEncoding=UTF-8&useUnicode=true&rewriteBatchedStatements=true&cachePrepStmts=true&useServerPrepStmts=true&connectTimeout=5000&socketTimeout=60000\n    username: ${DB_USERNAME}\n    password: ${DB_PASSWORD}\n\n    # ─────────────────────────────────────────────────────\n    # HikariCP 설정 (스테이징: 운영과 유사)\n    # ─────────────────────────────────────────────────────\n    hikari:\n      # 풀 크기 (운영의 절반 수준)\n      maximum-pool-size: 15\n      minimum-idle: 10\n\n      # 타임아웃 (운영과 동일)\n      connection-timeout: 30000       # 커넥션 획득 대기 최대 30초\n      idle-timeout: 600000            # 유휴 커넥션 유지 10분\n      max-lifetime: 1800000           # 커넥션 최대 수명 30분\n      validation-timeout: 5000        # 커넥션 유효성 검사 5초\n      keepalive-time: 300000          # Keep-alive 5분\n\n      # 커넥션 테스트\n      connection-test-query: SELECT 1\n\n      # 커넥션 누수 감지 (스테이징에서 검증)\n      leak-detection-threshold: 120000  # 2분\n\n      # 초기화 실패 타임아웃\n      initialization-fail-timeout: 60000\n\n  # ─────────────────────────────────────────────────────────\n  # JPA 설정 (스테이징)\n  # ─────────────────────────────────────────────────────────\n  jpa:\n    hibernate:\n      ddl-auto: validate\n\n    show-sql: false\n\n    properties:\n      hibernate:\n        format_sql: false\n        generate_statistics: false\n\n        # 느린 쿼리만 로깅 (1초 이상)\n        session:\n          events:\n            log:\n              LOG_QUERIES_SLOWER_THAN_MS: 1000\n\n  # ─────────────────────────────────────────────────────────\n  # Flyway 설정 (스테이징)\n  # ─────────────────────────────────────────────────────────\n  flyway:\n    enabled: true\n    clean-disabled: true\n    validate-on-migrate: true\n\n# ─────────────────────────────────────────────────────────\n# 로깅 설정 (스테이징: 최소 로깅)\n# ─────────────────────────────────────────────────────────\nlogging:\n  level:\n    org.hibernate.SQL: WARN\n    org.hibernate.orm.jdbc.bind: WARN\n    com.zaxxer.hikari: WARN\n    org.flywaydb: INFO\n',1,'2026-01-16 06:52:08','2026-01-16 06:52:08',NULL),(14,6,'CONFIG','persistence-prod.yml','YAML','운영 환경 설정. 보안 최우선, 성능 최적화, 고가용성. HikariCP 풀 최적화, SSL 필수.','# ============================================================\n# Persistence Module - Production Configuration\n# ============================================================\n\nspring:\n  # ─────────────────────────────────────────────────────────\n  # DataSource 설정 (운영 MySQL - AWS RDS/Aurora 등)\n  # ─────────────────────────────────────────────────────────\n  datasource:\n    # AWS RDS MySQL 예시 (Aurora, RDS 모두 적용 가능)\n    url: jdbc:mysql://${DB_HOST}:${DB_PORT:3306}/${DB_NAME}?useSSL=true&requireSSL=true&verifyServerCertificate=true&enabledTLSProtocols=TLSv1.2,TLSv1.3&serverTimezone=Asia/Seoul&characterEncoding=UTF-8&useUnicode=true&rewriteBatchedStatements=true&cachePrepStmts=true&prepStmtCacheSize=500&prepStmtCacheSqlLimit=4096&useServerPrepStmts=true&connectTimeout=5000&socketTimeout=60000&tcpKeepAlive=true\n    username: ${DB_USERNAME}\n    password: ${DB_PASSWORD}\n\n    # ─────────────────────────────────────────────────────\n    # HikariCP 설정 (운영: 고성능 최적화)\n    # ─────────────────────────────────────────────────────\n    hikari:\n      pool-name: HikariPool-Production\n\n      # ─────────────────────────────────────────────────\n      # 풀 크기 설정\n      # 공식: connections = ((core_count * 2) + effective_spindle_count)\n      # 일반적으로 CPU 코어 수 * 2 ~ 4\n      # ─────────────────────────────────────────────────\n      maximum-pool-size: ${HIKARI_MAX_POOL_SIZE:30}\n      minimum-idle: ${HIKARI_MIN_IDLE:15}\n\n      # ─────────────────────────────────────────────────\n      # 타임아웃 설정 (운영: 안정성 중시)\n      # ─────────────────────────────────────────────────\n\n      # 커넥션 획득 대기 최대 시간 (30초)\n      # 이 시간 내에 커넥션을 얻지 못하면 SQLException 발생\n      connection-timeout: 30000\n\n      # 유휴 커넥션 유지 시간 (10분)\n      # minimum-idle보다 많은 유휴 커넥션은 이 시간 후 제거\n      idle-timeout: 600000\n\n      # 커넥션 최대 수명 (30분)\n      # DB의 wait_timeout보다 짧아야 함 (MySQL 기본 8시간)\n      # 커넥션 재활용으로 메모리 누수 방지\n      max-lifetime: 1800000\n\n      # 커넥션 유효성 검사 타임아웃 (5초)\n      validation-timeout: 5000\n\n      # Keep-Alive 간격 (5분)\n      # 유휴 커넥션이 DB에 의해 끊기지 않도록 유지\n      keepalive-time: 300000\n\n      # ─────────────────────────────────────────────────\n      # 커넥션 검증\n      # ─────────────────────────────────────────────────\n\n      # MySQL 커넥션 테스트 쿼리\n      # JDBC4 드라이버는 isValid() 사용, 설정하지 않아도 됨\n      # 하지만 명시적으로 설정하면 더 확실함\n      connection-test-query: SELECT 1\n\n      # ─────────────────────────────────────────────────\n      # 초기화 설정\n      # ─────────────────────────────────────────────────\n\n      # 초기화 실패 시 즉시 예외 발생 (fail-fast)\n      # 0보다 크면 해당 시간만큼 재시도\n      initialization-fail-timeout: 1\n\n      # ─────────────────────────────────────────────────\n      # 커넥션 누수 감지 (운영에서는 비활성화 또는 높은 값)\n      # 운영에서 오탐 방지를 위해 높은 임계값 또는 비활성화\n      # ─────────────────────────────────────────────────\n      leak-detection-threshold: 0    # 비활성화 (0)\n\n      # ─────────────────────────────────────────────────\n      # 기타 최적화 설정\n      # ─────────────────────────────────────────────────\n      auto-commit: false\n      read-only: false\n\n      # MySQL 드라이버 최적화 속성\n      data-source-properties:\n        # PreparedStatement 캐싱 (성능 향상)\n        cachePrepStmts: true\n        prepStmtCacheSize: 500\n        prepStmtCacheSqlLimit: 4096\n        useServerPrepStmts: true\n\n        # 배치 처리 최적화\n        rewriteBatchedStatements: true\n\n        # 메타데이터 캐싱\n        cacheResultSetMetadata: true\n        cacheServerConfiguration: true\n        elideSetAutoCommits: true\n\n        # 네트워크 최적화\n        tcpKeepAlive: true\n        tcpNoDelay: true\n\n        # 로깅 비활성화 (성능)\n        maintainTimeStats: false\n        enableQueryTimeouts: true\n\n  # ─────────────────────────────────────────────────────────\n  # JPA 설정 (운영)\n  # ─────────────────────────────────────────────────────────\n  jpa:\n    hibernate:\n      ddl-auto: none    # 절대 자동 DDL 금지\n\n    show-sql: false\n    open-in-view: false\n\n    properties:\n      hibernate:\n        format_sql: false\n        use_sql_comments: false\n        generate_statistics: false\n\n        # 배치 처리 (운영: 큰 배치)\n        jdbc:\n          batch_size: 100\n          fetch_size: 200\n\n        # 캐시 비활성화 (Redis로 대체)\n        cache:\n          use_second_level_cache: false\n          use_query_cache: false\n\n        # 느린 쿼리 로깅 비활성화 (APM 도구로 대체)\n        session:\n          events:\n            log:\n              LOG_QUERIES_SLOWER_THAN_MS: 0\n\n  # ─────────────────────────────────────────────────────────\n  # Flyway 설정 (운영)\n  # ─────────────────────────────────────────────────────────\n  flyway:\n    enabled: ${FLYWAY_ENABLED:true}\n    clean-disabled: true    # 절대 clean 금지\n    validate-on-migrate: true\n    out-of-order: false     # 순서 엄격 적용\n\n# ─────────────────────────────────────────────────────────\n# 로깅 설정 (운영: 에러만)\n# ─────────────────────────────────────────────────────────\nlogging:\n  level:\n    org.hibernate: WARN\n    org.hibernate.SQL: WARN\n    org.hibernate.orm.jdbc.bind: OFF\n    com.zaxxer.hikari: WARN\n    org.flywaydb: WARN\n',1,'2026-01-16 06:52:08','2026-01-16 06:52:08',NULL),(15,6,'CONFIG','config/JpaConfig.java','JAVA','JPA 설정 클래스. JPA Auditing, EntityManager, TransactionManager 설정.','package com.{bc}.adapter.out.persistence.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.domain.AuditorAware;\nimport org.springframework.data.jpa.repository.config.EnableJpaAuditing;\nimport org.springframework.data.jpa.repository.config.EnableJpaRepositories;\nimport org.springframework.transaction.annotation.EnableTransactionManagement;\n\nimport java.util.Optional;\n\n/**\n * JPA 설정 클래스\n *\n * <p>기능:</p>\n * <ul>\n *   <li>JPA Auditing 활성화 (@CreatedDate, @LastModifiedDate)</li>\n *   <li>JPA Repository 스캔 경로 지정</li>\n *   <li>트랜잭션 관리 활성화</li>\n * </ul>\n *\n * <p>주의사항:</p>\n * <ul>\n *   <li>auditorProvider는 보안 컨텍스트에서 사용자 ID를 가져오도록 구현</li>\n *   <li>멀티 모듈 프로젝트에서는 basePackages 명시 필수</li>\n * </ul>\n */\n@Configuration\n@EnableJpaAuditing(auditorAwareRef = \"auditorProvider\")\n@EnableJpaRepositories(\n    basePackages = \"com.{bc}.adapter.out.persistence\",\n    // EntityManager 지정 (멀티 DataSource 시)\n    entityManagerFactoryRef = \"entityManagerFactory\",\n    transactionManagerRef = \"transactionManager\"\n)\n@EnableTransactionManagement\npublic class JpaConfig {\n\n    /**\n     * Auditor Provider - 현재 사용자 ID 제공\n     *\n     * <p>@CreatedBy, @LastModifiedBy 필드에 사용자 ID 자동 주입</p>\n     *\n     * <p>구현 방법:</p>\n     * <ul>\n     *   <li>Spring Security: SecurityContextHolder에서 가져오기</li>\n     *   <li>JWT: 토큰에서 사용자 ID 추출</li>\n     *   <li>시스템 작업: \"SYSTEM\" 또는 고정값 반환</li>\n     * </ul>\n     *\n     * @return AuditorAware 구현체\n     */\n    @Bean\n    public AuditorAware<String> auditorProvider() {\n        // 기본 구현: 시스템 사용자\n        // TODO: 실제 구현 시 SecurityContext에서 사용자 ID 추출\n        return () -> Optional.of(\"SYSTEM\");\n\n        // Spring Security 사용 시 예시:\n        // return () -> Optional.ofNullable(SecurityContextHolder.getContext())\n        //     .map(SecurityContext::getAuthentication)\n        //     .filter(Authentication::isAuthenticated)\n        //     .map(Authentication::getName);\n    }\n}',1,'2026-01-16 06:52:08','2026-01-16 06:52:08',NULL),(16,6,'CONFIG','config/QueryDslConfig.java','JAVA','QueryDSL 설정 클래스. JPAQueryFactory Bean 등록.','package com.{bc}.adapter.out.persistence.config;\n\nimport com.querydsl.jpa.impl.JPAQueryFactory;\nimport jakarta.persistence.EntityManager;\nimport jakarta.persistence.PersistenceContext;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n/**\n * QueryDSL 설정 클래스\n *\n * <p>JPAQueryFactory Bean을 등록하여 QueryDslRepository에서 사용</p>\n *\n * <p>사용 예시:</p>\n * <pre>{@code\n * @Repository\n * public class OrderQueryDslRepository {\n *\n *     private final JPAQueryFactory queryFactory;\n *\n *     public OrderQueryDslRepository(JPAQueryFactory queryFactory) {\n *         this.queryFactory = queryFactory;\n *     }\n *\n *     public List<OrderJpaEntity> findByStatus(OrderStatus status) {\n *         return queryFactory\n *             .selectFrom(order)\n *             .where(order.status.eq(status))\n *             .fetch();\n *     }\n * }\n * }</pre>\n *\n * <p>주의사항:</p>\n * <ul>\n *   <li>EntityManager는 요청 스코프이므로 Thread-Safe</li>\n *   <li>JPAQueryFactory는 Singleton Bean으로 등록해도 안전</li>\n *   <li>멀티 DataSource 환경에서는 EntityManager 구분 필요</li>\n * </ul>\n */\n@Configuration\npublic class QueryDslConfig {\n\n    @PersistenceContext\n    private EntityManager entityManager;\n\n    /**\n     * JPAQueryFactory Bean 등록\n     *\n     * <p>QueryDSL의 타입 안전한 쿼리 빌더</p>\n     *\n     * @return JPAQueryFactory 인스턴스\n     */\n    @Bean\n    public JPAQueryFactory jpaQueryFactory() {\n        return new JPAQueryFactory(entityManager);\n    }\n}',1,'2026-01-16 06:52:08','2026-01-16 06:52:08',NULL),(17,6,'CONFIG','config/P6SpyConfig.java','JAVA','P6Spy SQL 로깅 설정 (선택적). 바인딩 파라미터 포함 실제 SQL 출력.','package com.{bc}.adapter.out.persistence.config;\n\nimport com.p6spy.engine.logging.Category;\nimport com.p6spy.engine.spy.P6SpyOptions;\nimport com.p6spy.engine.spy.appender.MessageFormattingStrategy;\nimport jakarta.annotation.PostConstruct;\nimport org.hibernate.engine.jdbc.internal.FormatStyle;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Profile;\n\nimport java.util.Locale;\n\n/**\n * P6Spy SQL 로깅 설정 (선택적)\n *\n * <p>실제 바인딩된 파라미터 값을 포함한 SQL 출력</p>\n *\n * <p>활성화 조건:</p>\n * <ul>\n *   <li>local, dev 프로파일에서만 활성화</li>\n *   <li>운영 환경에서는 비활성화 (성능 영향)</li>\n * </ul>\n *\n * <p>의존성 추가 필요:</p>\n * <pre>{@code\n * implementation \'com.github.gavlyukovskiy:p6spy-spring-boot-starter:1.9.0\'\n * }</pre>\n *\n * <p>application.yml 설정:</p>\n * <pre>{@code\n * decorator:\n *   datasource:\n *     p6spy:\n *       enable-logging: true\n *       multiline: true\n *       logging: slf4j\n * }</pre>\n */\n@Configuration\n@Profile({\"local\", \"dev\"})\npublic class P6SpyConfig {\n\n    @PostConstruct\n    public void setLogMessageFormat() {\n        P6SpyOptions.getActiveInstance().setLogMessageFormat(P6SpySqlFormatStrategy.class.getName());\n    }\n\n    /**\n     * SQL 포맷팅 전략\n     */\n    public static class P6SpySqlFormatStrategy implements MessageFormattingStrategy {\n\n        @Override\n        public String formatMessage(int connectionId, String now, long elapsed,\n                                    String category, String prepared, String sql, String url) {\n            if (sql == null || sql.trim().isEmpty()) {\n                return \"\";\n            }\n\n            String formattedSql = formatSql(category, sql);\n\n            return String.format(\n                \"\n============================================================\n\" +\n                \"  Connection ID: %d\n\" +\n                \"  Execution Time: %d ms\n\" +\n                \"  Category: %s\n\" +\n                \"============================================================\n\" +\n                \"%s\n\" +\n                \"============================================================\",\n                connectionId, elapsed, category, formattedSql\n            );\n        }\n\n        private String formatSql(String category, String sql) {\n            if (sql == null || sql.trim().isEmpty()) {\n                return sql;\n            }\n\n            // DDL과 DML 구분하여 포맷팅\n            if (Category.STATEMENT.getName().equals(category)) {\n                String trimmedSql = sql.trim().toLowerCase(Locale.ROOT);\n                if (trimmedSql.startsWith(\"create\") ||\n                    trimmedSql.startsWith(\"alter\") ||\n                    trimmedSql.startsWith(\"drop\") ||\n                    trimmedSql.startsWith(\"comment\")) {\n                    return FormatStyle.DDL.getFormatter().format(sql);\n                }\n                return FormatStyle.BASIC.getFormatter().format(sql);\n            }\n            return sql;\n        }\n    }\n}',0,'2026-01-16 06:52:08','2026-01-16 06:52:08',NULL),(18,6,'CONFIG','entity/common/BaseAuditEntity.java','JAVA','JPA Auditing 기반 추상 엔티티. createdAt, updatedAt 자동 관리.','package com.{bc}.adapter.out.persistence.entity.common;\n\nimport jakarta.persistence.Column;\nimport jakarta.persistence.EntityListeners;\nimport jakarta.persistence.MappedSuperclass;\nimport org.springframework.data.annotation.CreatedDate;\nimport org.springframework.data.annotation.LastModifiedDate;\nimport org.springframework.data.jpa.domain.support.AuditingEntityListener;\n\nimport java.time.Instant;\n\n/**\n * 감사 기반 추상 엔티티\n *\n * <p>모든 Entity가 상속받아야 하는 기본 클래스</p>\n *\n * <p>제공 기능:</p>\n * <ul>\n *   <li>createdAt: 생성 시각 (INSERT 시 자동 설정, 변경 불가)</li>\n *   <li>updatedAt: 수정 시각 (UPDATE 시 자동 갱신)</li>\n * </ul>\n *\n * <p>주의사항:</p>\n * <ul>\n *   <li>@EnableJpaAuditing 설정 필수</li>\n *   <li>Instant 타입 사용 (타임존 독립적)</li>\n *   <li>Setter 미제공 (JPA Auditing이 자동 설정)</li>\n * </ul>\n *\n * <p>사용 예시:</p>\n * <pre>{@code\n * @Entity\n * @Table(name = \"orders\")\n * public class OrderJpaEntity extends BaseAuditEntity {\n *     // Entity 필드 정의\n * }\n * }</pre>\n */\n@MappedSuperclass\n@EntityListeners(AuditingEntityListener.class)\npublic abstract class BaseAuditEntity {\n\n    @CreatedDate\n    @Column(name = \"created_at\", nullable = false, updatable = false)\n    private Instant createdAt;\n\n    @LastModifiedDate\n    @Column(name = \"updated_at\", nullable = false)\n    private Instant updatedAt;\n\n    // Getter만 제공 (Setter 금지 - Auditing이 자동 설정)\n    public Instant getCreatedAt() {\n        return createdAt;\n    }\n\n    public Instant getUpdatedAt() {\n        return updatedAt;\n    }\n}',1,'2026-01-16 06:52:08','2026-01-16 06:52:08',NULL),(19,6,'CONFIG','entity/common/SoftDeletableEntity.java','JAVA','소프트 삭제 기반 추상 엔티티. deleted, deletedAt 필드 제공.','package com.{bc}.adapter.out.persistence.entity.common;\n\nimport jakarta.persistence.Column;\nimport jakarta.persistence.MappedSuperclass;\n\nimport java.time.Instant;\n\n/**\n * 소프트 삭제 기반 추상 엔티티\n *\n * <p>BaseAuditEntity를 상속하고 소프트 삭제 기능 추가</p>\n *\n * <p>제공 기능:</p>\n * <ul>\n *   <li>deleted: 삭제 여부 플래그</li>\n *   <li>deletedAt: 삭제 시각</li>\n *   <li>softDelete(): 소프트 삭제 실행 메서드</li>\n *   <li>restore(): 복원 메서드</li>\n * </ul>\n *\n * <p>주의사항:</p>\n * <ul>\n *   <li>조회 시 deleted = false 조건 필수</li>\n *   <li>복원 시 deletedAt = null로 초기화</li>\n *   <li>물리적 삭제(DELETE)는 배치 작업으로 별도 처리</li>\n * </ul>\n *\n * <p>QueryDSL 조회 예시:</p>\n * <pre>{@code\n * queryFactory\n *     .selectFrom(order)\n *     .where(order.deleted.isFalse())  // 소프트 삭제되지 않은 것만\n *     .fetch();\n * }</pre>\n */\n@MappedSuperclass\npublic abstract class SoftDeletableEntity extends BaseAuditEntity {\n\n    @Column(name = \"deleted\", nullable = false)\n    private boolean deleted = false;\n\n    @Column(name = \"deleted_at\")\n    private Instant deletedAt;\n\n    // Getter\n    public boolean isDeleted() {\n        return deleted;\n    }\n\n    public Instant getDeletedAt() {\n        return deletedAt;\n    }\n\n    /**\n     * 소프트 삭제 실행\n     *\n     * <p>deleted = true, deletedAt = 현재 시각으로 설정</p>\n     *\n     * @param deletedAt 삭제 시각 (Domain에서 전달)\n     */\n    public void softDelete(Instant deletedAt) {\n        this.deleted = true;\n        this.deletedAt = deletedAt;\n    }\n\n    /**\n     * 복원 (삭제 취소)\n     *\n     * <p>deleted = false, deletedAt = null로 초기화</p>\n     */\n    public void restore() {\n        this.deleted = false;\n        this.deletedAt = null;\n    }\n}',1,'2026-01-16 06:52:08','2026-01-16 06:52:08',NULL),(20,6,'CONFIG','config/FlywayConfig.java','JAVA','Flyway 콜백 설정 (선택적). 마이그레이션 전후 커스텀 로직 실행.','package com.{bc}.adapter.out.persistence.config;\n\nimport org.flywaydb.core.api.callback.Callback;\nimport org.flywaydb.core.api.callback.Context;\nimport org.flywaydb.core.api.callback.Event;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n/**\n * Flyway 콜백 설정 (선택적)\n *\n * <p>마이그레이션 이벤트에 대한 커스텀 로직 실행</p>\n *\n * <p>지원 이벤트:</p>\n * <ul>\n *   <li>BEFORE_MIGRATE: 마이그레이션 시작 전</li>\n *   <li>AFTER_MIGRATE: 마이그레이션 완료 후</li>\n *   <li>AFTER_MIGRATE_ERROR: 마이그레이션 실패 시</li>\n *   <li>BEFORE_EACH_MIGRATE: 각 스크립트 실행 전</li>\n *   <li>AFTER_EACH_MIGRATE: 각 스크립트 실행 후</li>\n * </ul>\n *\n * <p>활용 예시:</p>\n * <ul>\n *   <li>마이그레이션 완료 Slack 알림</li>\n *   <li>마이그레이션 실패 시 롤백 알림</li>\n *   <li>마이그레이션 전후 캐시 초기화</li>\n * </ul>\n */\n@Configuration\npublic class FlywayConfig {\n\n    private static final Logger log = LoggerFactory.getLogger(FlywayConfig.class);\n\n    @Bean\n    public Callback flywayCallback() {\n        return new Callback() {\n\n            @Override\n            public boolean supports(Event event, Context context) {\n                return event == Event.BEFORE_MIGRATE\n                    || event == Event.AFTER_MIGRATE\n                    || event == Event.AFTER_MIGRATE_ERROR;\n            }\n\n            @Override\n            public boolean canHandleInTransaction(Event event, Context context) {\n                return true;\n            }\n\n            @Override\n            public void handle(Event event, Context context) {\n                switch (event) {\n                    case BEFORE_MIGRATE -> log.info(\n                        \"[Flyway] 마이그레이션 시작 - Schema: {}\",\n                        context.getConfiguration().getDefaultSchema()\n                    );\n                    case AFTER_MIGRATE -> log.info(\n                        \"[Flyway] 마이그레이션 완료 - Version: {}\",\n                        context.getMigrationInfo() != null\n                            ? context.getMigrationInfo().getVersion()\n                            : \"N/A\"\n                    );\n                    case AFTER_MIGRATE_ERROR -> log.error(\n                        \"[Flyway] 마이그레이션 실패! 롤백 필요\"\n                    );\n                    default -> { }\n                }\n            }\n\n            @Override\n            public String getCallbackName() {\n                return \"FlywayLoggingCallback\";\n            }\n        };\n    }\n}',0,'2026-01-16 06:52:08','2026-01-16 06:52:08',NULL),(21,6,'CONFIG','config/DataSourceHealthConfig.java','JAVA','DataSource 헬스체크 확장 설정 (선택적). HikariCP 풀 상태 모니터링.','package com.{bc}.adapter.out.persistence.config;\n\nimport com.zaxxer.hikari.HikariDataSource;\nimport com.zaxxer.hikari.HikariPoolMXBean;\nimport org.springframework.boot.actuate.health.Health;\nimport org.springframework.boot.actuate.health.HealthIndicator;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Profile;\n\nimport javax.sql.DataSource;\n\n/**\n * DataSource 헬스체크 확장 설정 (선택적)\n *\n * <p>HikariCP 커넥션 풀 상태를 Actuator 헬스체크에 포함</p>\n *\n * <p>모니터링 항목:</p>\n * <ul>\n *   <li>activeConnections: 현재 사용 중인 커넥션 수</li>\n *   <li>idleConnections: 유휴 커넥션 수</li>\n *   <li>totalConnections: 전체 커넥션 수</li>\n *   <li>threadsAwaitingConnection: 커넥션 대기 중인 스레드 수</li>\n * </ul>\n *\n * <p>Actuator 엔드포인트:</p>\n * <pre>\n * GET /actuator/health/hikariPool\n * </pre>\n */\n@Configuration\n@Profile({\"!test\"})  // 테스트 환경 제외\npublic class DataSourceHealthConfig {\n\n    @Bean\n    public HealthIndicator hikariPoolHealthIndicator(DataSource dataSource) {\n        return () -> {\n            if (!(dataSource instanceof HikariDataSource hikariDataSource)) {\n                return Health.unknown()\n                    .withDetail(\"message\", \"DataSource is not HikariDataSource\")\n                    .build();\n            }\n\n            HikariPoolMXBean poolMXBean = hikariDataSource.getHikariPoolMXBean();\n            if (poolMXBean == null) {\n                return Health.down()\n                    .withDetail(\"message\", \"HikariPool not initialized\")\n                    .build();\n            }\n\n            int activeConnections = poolMXBean.getActiveConnections();\n            int idleConnections = poolMXBean.getIdleConnections();\n            int totalConnections = poolMXBean.getTotalConnections();\n            int threadsAwaiting = poolMXBean.getThreadsAwaitingConnection();\n            int maxPoolSize = hikariDataSource.getMaximumPoolSize();\n\n            // 풀 사용률 계산\n            double poolUsage = (double) activeConnections / maxPoolSize * 100;\n\n            Health.Builder builder;\n            if (poolUsage >= 90) {\n                builder = Health.down()\n                    .withDetail(\"warning\", \"Connection pool usage over 90%\");\n            } else if (poolUsage >= 70) {\n                builder = Health.up()\n                    .withDetail(\"warning\", \"Connection pool usage over 70%\");\n            } else {\n                builder = Health.up();\n            }\n\n            return builder\n                .withDetail(\"poolName\", hikariDataSource.getPoolName())\n                .withDetail(\"activeConnections\", activeConnections)\n                .withDetail(\"idleConnections\", idleConnections)\n                .withDetail(\"totalConnections\", totalConnections)\n                .withDetail(\"maxPoolSize\", maxPoolSize)\n                .withDetail(\"poolUsagePercent\", String.format(\"%.1f%%\", poolUsage))\n                .withDetail(\"threadsAwaitingConnection\", threadsAwaiting)\n                .build();\n        };\n    }\n}',0,'2026-01-16 06:52:08','2026-01-16 06:52:08',NULL);
/*!40000 ALTER TABLE `resource_template` ENABLE KEYS */;
UNLOCK TABLES;

LOCK TABLES `zero_tolerance_rule` WRITE;
/*!40000 ALTER TABLE `zero_tolerance_rule` DISABLE KEYS */;
/*!40000 ALTER TABLE `zero_tolerance_rule` ENABLE KEYS */;
UNLOCK TABLES;

LOCK TABLES `checklist_item` WRITE;
/*!40000 ALTER TABLE `checklist_item` DISABLE KEYS */;
/*!40000 ALTER TABLE `checklist_item` ENABLE KEYS */;
UNLOCK TABLES;

LOCK TABLES `sdk_version` WRITE;
/*!40000 ALTER TABLE `sdk_version` DISABLE KEYS */;
/*!40000 ALTER TABLE `sdk_version` ENABLE KEYS */;
UNLOCK TABLES;

LOCK TABLES `sdk_usage_rule` WRITE;
/*!40000 ALTER TABLE `sdk_usage_rule` DISABLE KEYS */;
/*!40000 ALTER TABLE `sdk_usage_rule` ENABLE KEYS */;
UNLOCK TABLES;

LOCK TABLES `sdk_setup_guide` WRITE;
/*!40000 ALTER TABLE `sdk_setup_guide` DISABLE KEYS */;
/*!40000 ALTER TABLE `sdk_setup_guide` ENABLE KEYS */;
UNLOCK TABLES;

LOCK TABLES `review_feedback` WRITE;
/*!40000 ALTER TABLE `review_feedback` DISABLE KEYS */;
/*!40000 ALTER TABLE `review_feedback` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

