-- Spring Standards Convention Hub - Seed Data
-- Generated from production database
-- Contains: coding rules with rationale, rule examples, templates, and more

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

INSERT INTO `architecture` VALUES (1,1,'hexagonal-multimodule','HEXAGONAL','포트와 어댑터 패턴 기반 멀티모듈 아키텍처. Domain 중심 설계로 외부 의존성을 격리하고, CQRS 패턴을 적용하여 Command/Query를 분리합니다.','[\"DIP\", \"SRP\", \"OCP\", \"ISP\", \"CQRS\", \"DDD\"]',NULL,'2026-01-20 02:11:20.000000','2026-01-20 02:11:20.000000',NULL);
INSERT INTO `archunit_test` VALUES (1,1,'ARCH-DOM-AGG-004','forNew() 팩토리 메서드 필수','Aggregate에 static forNew(..., Instant now) 팩토리 메서드가 있는가?','@Test\n@DisplayName(\"[필수] Aggregate는 forNew() 정적 팩토리 메서드가 있어야 한다\")\nvoid aggregate_MustHaveForNewMethod() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..domain..aggregate..\")\n        .and().areNotInterfaces()\n        .and().areNotEnums()\n        .should(haveStaticMethodWithName(\"forNew\"))\n        .because(\"신규 생성용 팩토리 메서드 필수\");\n    rule.check(domainClasses);\n}','AggregateArchTest','aggregate_MustHaveForNewMethod','BLOCKER','2026-01-24 15:40:19.000000','2026-01-24 15:40:19.000000',NULL),(2,1,'ARCH-DOM-AGG-005','reconstitute() 팩토리 메서드 필수','Aggregate에 static reconstitute(...) 팩토리 메서드가 있는가?','@Test\n@DisplayName(\"[필수] Aggregate는 reconstitute() 정적 팩토리 메서드가 있어야 한다\")\nvoid aggregate_MustHaveReconstituteMethod() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..domain..aggregate..\")\n        .and().areNotInterfaces()\n        .and().areNotEnums()\n        .should(haveStaticMethodWithName(\"reconstitute\"))\n        .because(\"영속성 복원용 팩토리 메서드 필수\");\n    rule.check(domainClasses);\n}','AggregateArchTest','aggregate_MustHaveReconstituteMethod','BLOCKER','2026-01-24 15:40:19.000000','2026-01-24 15:40:19.000000',NULL),(3,1,'ARCH-DOM-AGG-007-01','Aggregate ID는 ID VO 사용','Aggregate의 ID 필드가 전용 ID VO를 사용하는가?','@Test\n@DisplayName(\"[필수] Aggregate ID 필드는 ID VO 타입이어야 한다\")\nvoid aggregate_IdFieldMustBeIdVo() {\n    ArchRule rule = fields()\n        .that().areDeclaredInClassesThat().resideInAPackage(\"..domain..aggregate..\")\n        .and().haveName(\"id\")\n        .should().haveRawType(DescribedPredicate.describe(\n            \"ID VO type ending with Id\",\n            field -> field.getSimpleName().endsWith(\"Id\")))\n        .because(\"Aggregate ID는 전용 ID VO 사용 필수\");\n    rule.check(domainClasses);\n}','AggregateArchTest','aggregate_IdFieldMustBeIdVo','BLOCKER','2026-01-24 15:40:19.000000','2026-01-24 15:40:19.000000',NULL),(4,1,'ARCH-DOM-AGG-007-02','Long 원시 타입 ID 금지','Long 원시 타입 ID를 직접 사용하지 않는가?','@Test\n@DisplayName(\"[금지] Aggregate ID 필드에 Long 원시 타입 사용 금지\")\nvoid aggregate_IdFieldMustNotBeLong() {\n    ArchRule rule = noFields()\n        .that().areDeclaredInClassesThat().resideInAPackage(\"..domain..aggregate..\")\n        .and().haveName(\"id\")\n        .should().haveRawType(Long.class)\n        .because(\"Long 원시 타입 대신 ID VO 사용 필수\");\n    rule.check(domainClasses);\n}','AggregateArchTest','aggregate_IdFieldMustNotBeLong','BLOCKER','2026-01-24 15:40:19.000000','2026-01-24 15:40:19.000000',NULL),(5,1,'ARCH-DOM-AGG-008','isNew() 메서드 필수','Aggregate에 isNew() 메서드가 구현되어 있는가?','@Test\n@DisplayName(\"[필수] Aggregate는 isNew() 메서드가 있어야 한다\")\nvoid aggregate_MustHaveIsNewMethod() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..domain..aggregate..\")\n        .and().areNotInterfaces()\n        .and().areNotEnums()\n        .should(haveMethodWithName(\"isNew\"))\n        .because(\"신규 여부 판단 메서드 필수\");\n    rule.check(domainClasses);\n}','AggregateArchTest','aggregate_MustHaveIsNewMethod','BLOCKER','2026-01-24 15:40:19.000000','2026-01-24 15:40:19.000000',NULL),(6,1,'ARCH-DOM-AGG-009-01','시간 필드는 Instant 타입','시간 필드(createdAt, updatedAt)가 Instant 타입인가?','@Test\n@DisplayName(\"[필수] Aggregate 시간 필드는 Instant 타입이어야 한다\")\nvoid aggregate_TimeFieldsMustBeInstant() {\n    ArchRule rule = fields()\n        .that().areDeclaredInClassesThat().resideInAPackage(\"..domain..aggregate..\")\n        .and().haveNameMatching(\"(createdAt|updatedAt)\")\n        .should().haveRawType(java.time.Instant.class)\n        .because(\"시간 필드는 Instant 사용 (LocalDateTime 금지)\");\n    rule.check(domainClasses);\n}','AggregateArchTest','aggregate_TimeFieldsMustBeInstant','BLOCKER','2026-01-24 15:40:19.000000','2026-01-24 15:40:19.000000',NULL),(7,1,'ARCH-DOM-AGG-009-02','LocalDateTime 사용 금지','LocalDateTime, Date, Calendar 등을 사용하지 않는가?','@Test\n@DisplayName(\"[금지] Aggregate에서 LocalDateTime 사용 금지\")\nvoid aggregate_MustNotUseLocalDateTime() {\n    ArchRule rule = noFields()\n        .that().areDeclaredInClassesThat().resideInAPackage(\"..domain..aggregate..\")\n        .should().haveRawType(java.time.LocalDateTime.class)\n        .orShould().haveRawType(java.util.Date.class)\n        .because(\"시간 필드는 Instant 사용 필수\");\n    rule.check(domainClasses);\n}','AggregateArchTest','aggregate_MustNotUseLocalDateTime','BLOCKER','2026-01-24 15:40:19.000000','2026-01-24 15:40:19.000000',NULL),(8,1,'ARCH-DOM-AGG-010','Instant.now() 금지','Aggregate 내부에서 Instant.now() 직접 호출이 없는가?','@Test\n@DisplayName(\"[금지] Aggregate에서 Instant.now() 직접 호출 금지\")\nvoid aggregate_MustNotCallInstantNow() {\n    ArchRule rule = noClasses()\n        .that().resideInAPackage(\"..domain..aggregate..\")\n        .should().callMethod(java.time.Instant.class, \"now\")\n        .because(\"시간은 외부에서 주입받아야 함 (테스트 용이성)\");\n    rule.check(domainClasses);\n}','AggregateArchTest','aggregate_MustNotCallInstantNow','BLOCKER','2026-01-24 15:40:19.000000','2026-01-24 15:40:19.000000',NULL),(9,1,'ARCH-DOM-AGG-012','Setter 메서드 금지','public void setXxx() 형태의 Setter 메서드가 없는가?','@Test\n@DisplayName(\"[금지] Aggregate에 Setter 메서드 금지\")\nvoid aggregate_MustNotHaveSetterMethods() {\n    ArchRule rule = noMethods()\n        .that().areDeclaredInClassesThat().resideInAPackage(\"..domain..aggregate..\")\n        .and().arePublic()\n        .and().haveNameMatching(\"set[A-Z].*\")\n        .should().beDeclared()\n        .because(\"비즈니스 메서드로 상태 변경\");\n    rule.check(domainClasses);\n}','AggregateArchTest','aggregate_MustNotHaveSetterMethods','BLOCKER','2026-01-24 15:40:19.000000','2026-01-24 15:40:19.000000',NULL),(10,1,'ARCH-DOM-AGG-014','Getter 체이닝 금지','getXxx().getYyy() 형태의 Getter 체이닝이 없는가?','@Test\n@DisplayName(\"[금지] Getter 체이닝 금지 (Law of Demeter)\")\nvoid aggregate_MustNotHaveGetterChaining() {\n    // Note: ArchUnit으로 메서드 체이닝을 직접 감지하기 어려움\n    // 코드 리뷰 또는 정적 분석 도구(PMD)로 보완 필요\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..domain..aggregate..\")\n        .should(notExposeInternalObjects())\n        .because(\"Law of Demeter 준수 - 내부 객체 직접 노출 금지\");\n    rule.check(domainClasses);\n}','AggregateArchTest','aggregate_MustNotHaveGetterChaining','BLOCKER','2026-01-24 15:40:19.000000','2026-01-24 15:40:19.000000',NULL),(11,1,'ARCH-DOM-AGG-018','registerEvent() protected 메서드','registerEvent() 메서드가 protected로 선언되어 있는가?','@Test\n@DisplayName(\"[필수] registerEvent()는 protected여야 한다\")\nvoid aggregate_RegisterEventMustBeProtected() {\n    ArchRule rule = methods()\n        .that().areDeclaredInClassesThat().resideInAPackage(\"..domain..aggregate..\")\n        .and().haveName(\"registerEvent\")\n        .should().beProtected()\n        .allowEmptyShould(true)\n        .because(\"이벤트 등록은 내부에서만 가능\");\n    rule.check(domainClasses);\n}','AggregateArchTest','aggregate_RegisterEventMustBeProtected','MAJOR','2026-01-24 15:40:19.000000','2026-01-24 15:40:19.000000',NULL),(12,1,'ARCH-DOM-AGG-019','pollEvents() public 메서드','pollEvents() 메서드가 public으로 구현되어 있는가?','@Test\n@DisplayName(\"[필수] pollEvents()는 public이어야 한다\")\nvoid aggregate_PollEventsMustBePublic() {\n    ArchRule rule = methods()\n        .that().areDeclaredInClassesThat().resideInAPackage(\"..domain..aggregate..\")\n        .and().haveName(\"pollEvents\")\n        .should().bePublic()\n        .allowEmptyShould(true)\n        .because(\"이벤트 수확은 외부에서 호출\");\n    rule.check(domainClasses);\n}','AggregateArchTest','aggregate_PollEventsMustBePublic','MAJOR','2026-01-24 15:40:19.000000','2026-01-24 15:40:19.000000',NULL),(13,1,'ARCH-DOM-AGG-022','판단 메서드 boolean 반환','is, has, can으로 시작하는 메서드가 boolean을 반환하는가?','@Test\n@DisplayName(\"[필수] 판단 메서드(is/has/can)는 boolean 반환\")\nvoid aggregate_PredicateMethodsMustReturnBoolean() {\n    ArchRule rule = methods()\n        .that().areDeclaredInClassesThat().resideInAPackage(\"..domain..aggregate..\")\n        .and().haveNameMatching(\"(is|has|can)[A-Z].*\")\n        .should().haveRawReturnType(boolean.class)\n        .orShould().haveRawReturnType(Boolean.class)\n        .allowEmptyShould(true)\n        .because(\"판단 메서드는 boolean 반환 필수\");\n    rule.check(domainClasses);\n}','AggregateArchTest','aggregate_PredicateMethodsMustReturnBoolean','MAJOR','2026-01-24 15:40:19.000000','2026-01-24 15:40:19.000000',NULL),(14,1,'ARCH-DOM-CMN-001-01','순수 자바 객체 원칙','도메인 객체가 순수 자바 객체(POJO)인가?','@Test\n@DisplayName(\"[금지] Domain에서 Lombok 어노테이션 사용 금지\")\nvoid domain_MustNotUseLombok() {\n    ArchRule rule = noClasses()\n        .that().resideInAPackage(\"..domain..\")\n        .should().beAnnotatedWith(\"lombok.Data\")\n        .orShould().beAnnotatedWith(\"lombok.Builder\")\n        .orShould().beAnnotatedWith(\"lombok.Getter\")\n        .orShould().beAnnotatedWith(\"lombok.Setter\")\n        .orShould().beAnnotatedWith(\"lombok.AllArgsConstructor\")\n        .orShould().beAnnotatedWith(\"lombok.NoArgsConstructor\")\n        .orShould().beAnnotatedWith(\"lombok.RequiredArgsConstructor\")\n        .because(\"Domain Layer는 Pure Java 원칙\");\n    rule.check(domainClasses);\n}','DomainCommonArchTest','domain_MustNotUseLombok','BLOCKER','2026-01-24 15:40:19.000000','2026-01-24 15:40:19.000000',NULL),(15,1,'ARCH-DOM-CMN-001-02','JPA/Spring 어노테이션 금지','Lombok, JPA, Spring 어노테이션을 사용하지 않는가?','@Test\n@DisplayName(\"[금지] Domain에서 JPA/Spring 어노테이션 사용 금지\")\nvoid domain_MustNotUseJpaOrSpring() {\n    ArchRule rule = noClasses()\n        .that().resideInAPackage(\"..domain..\")\n        .should().beAnnotatedWith(\"jakarta.persistence.Entity\")\n        .orShould().beAnnotatedWith(\"jakarta.persistence.Table\")\n        .orShould().beAnnotatedWith(\"org.springframework.stereotype.Component\")\n        .orShould().beAnnotatedWith(\"org.springframework.stereotype.Service\")\n        .because(\"Domain Layer는 JPA/Spring에 독립적\");\n    rule.check(domainClasses);\n}','DomainCommonArchTest','domain_MustNotUseJpaOrSpring','BLOCKER','2026-01-24 15:40:19.000000','2026-01-24 15:40:19.000000',NULL),(16,1,'ARCH-DOM-CMN-002-01','외부 레이어 의존 금지','도메인 객체가 Application, Persistence, REST API 레이어를 의존하지 않는가?','@Test\n@DisplayName(\"[금지] Domain에서 외부 레이어 의존 금지\")\nvoid domain_MustNotDependOnOuterLayers() {\n    ArchRule rule = noClasses()\n        .that().resideInAPackage(\"..domain..\")\n        .should().dependOnClassesThat().resideInAnyPackage(\n            \"..application..\",\n            \"..adapter..\"\n        )\n        .because(\"헥사고날 아키텍처: Domain은 외부 레이어에 의존 금지\");\n    rule.check(domainClasses);\n}','DomainCommonArchTest','domain_MustNotDependOnOuterLayers','BLOCKER','2026-01-24 15:40:19.000000','2026-01-24 15:40:19.000000',NULL),(17,1,'ARCH-DOM-CMN-002-02','특정 클래스 의존 금지','Repository, Port, Service, Controller, Entity, DTO를 import하지 않는가?','@Test\n@DisplayName(\"[금지] Domain에서 특정 클래스 타입 의존 금지\")\nvoid domain_MustNotDependOnSpecificTypes() {\n    ArchRule rule = noClasses()\n        .that().resideInAPackage(\"..domain..\")\n        .should().dependOnClassesThat().haveNameMatching(\".*Repository\")\n        .orShould().dependOnClassesThat().haveNameMatching(\".*Port\")\n        .orShould().dependOnClassesThat().haveNameMatching(\".*Service\")\n        .orShould().dependOnClassesThat().haveNameMatching(\".*Controller\")\n        .orShould().dependOnClassesThat().haveNameMatching(\".*JpaEntity\")\n        .because(\"Domain은 인프라 클래스에 의존 금지\");\n    rule.check(domainClasses);\n}','DomainCommonArchTest','domain_MustNotDependOnSpecificTypes','BLOCKER','2026-01-24 15:40:19.000000','2026-01-24 15:40:19.000000',NULL),(18,2,'ARCH-DOM-VO-001-01','VO Record 타입 필수','Value Object가 Java Record로 정의되어 있는가?','@Test\n@DisplayName(\"[필수] Value Object는 Record 타입이어야 한다\")\nvoid valueObject_MustBeRecord() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..domain..vo..\")\n        .and().areNotEnums()\n        .should().beRecords()\n        .allowEmptyShould(true)\n        .because(\"Value Object는 불변성 보장을 위해 Record 사용\");\n    rule.check(domainClasses);\n}','ValueObjectArchTest','valueObject_MustBeRecord','BLOCKER','2026-01-24 15:40:19.000000','2026-01-24 15:40:19.000000',NULL),(19,2,'ARCH-DOM-VO-001-02','class 대신 record 키워드','class 대신 record 키워드를 사용하는가?','@Test\n@DisplayName(\"[금지] VO 패키지에 일반 class 금지\")\nvoid valueObject_MustNotBeRegularClass() {\n    ArchRule rule = noClasses()\n        .that().resideInAPackage(\"..domain..vo..\")\n        .and().areNotEnums()\n        .and().areNotRecords()\n        .should().bePublic()\n        .allowEmptyShould(true)\n        .because(\"Value Object는 Record 또는 Enum만 허용\");\n    rule.check(domainClasses);\n}','ValueObjectArchTest','valueObject_MustNotBeRegularClass','BLOCKER','2026-01-24 15:40:19.000000','2026-01-24 15:40:19.000000',NULL),(20,2,'ARCH-DOM-VO-002','of() 정적 팩토리 메서드 필수','Value Object에 of() 정적 팩토리 메서드가 있는가?','@Test\n@DisplayName(\"[필수] Value Object는 of() 정적 팩토리 메서드가 있어야 한다\")\nvoid valueObject_MustHaveOfMethod() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..domain..vo..\")\n        .and().areRecords()\n        .should(haveStaticMethodWithName(\"of\"))\n        .allowEmptyShould(true)\n        .because(\"Value Object 생성은 of() 팩토리 메서드 사용\");\n    rule.check(domainClasses);\n}','ValueObjectArchTest','valueObject_MustHaveOfMethod','BLOCKER','2026-01-24 15:40:19.000000','2026-01-24 15:40:19.000000',NULL),(21,2,'ARCH-DOM-VO-004','Enum VO displayName() 필수','Enum 타입의 VO에 displayName() 메서드가 있는가?','@Test\n@DisplayName(\"[필수] Enum VO는 displayName() 메서드가 있어야 한다\")\nvoid enumVo_MustHaveDisplayNameMethod() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..domain..vo..\")\n        .and().areEnums()\n        .should(haveMethodWithName(\"displayName\"))\n        .allowEmptyShould(true)\n        .because(\"Enum VO는 사용자 표시용 displayName 필수\");\n    rule.check(domainClasses);\n}','ValueObjectArchTest','enumVo_MustHaveDisplayNameMethod','MAJOR','2026-01-24 15:40:19.000000','2026-01-24 15:40:19.000000',NULL),(22,3,'ARCH-DOM-ID-001','ID VO *Id 네이밍 필수','ID VO가 {Domain}Id 형태로 네이밍되어 있는가?','@Test\n@DisplayName(\"[필수] ID VO는 *Id 네이밍이어야 한다\")\nvoid idVo_MustEndWithId() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..domain..id..\")\n        .should().haveSimpleNameEndingWith(\"Id\")\n        .allowEmptyShould(true)\n        .because(\"ID VO는 {Domain}Id 네이밍 규칙 필수\");\n    rule.check(domainClasses);\n}','IdVoArchTest','idVo_MustEndWithId','BLOCKER','2026-01-24 15:40:19.000000','2026-01-24 15:40:19.000000',NULL),(23,3,'ARCH-DOM-ID-002','ID VO Record 타입 필수','ID VO가 Java Record로 정의되어 있는가?','@Test\n@DisplayName(\"[필수] ID VO는 Record 타입이어야 한다\")\nvoid idVo_MustBeRecord() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..domain..id..\")\n        .should().beRecords()\n        .allowEmptyShould(true)\n        .because(\"ID VO는 불변성 보장을 위해 Record 사용\");\n    rule.check(domainClasses);\n}','IdVoArchTest','idVo_MustBeRecord','BLOCKER','2026-01-24 15:40:20.000000','2026-01-24 15:40:20.000000',NULL),(24,3,'ARCH-DOM-ID-003','ID VO of() 정적 팩토리 메서드 필수','ID VO에 of() 정적 팩토리 메서드가 있는가?','@Test\n@DisplayName(\"[필수] ID VO는 of() 정적 팩토리 메서드가 있어야 한다\")\nvoid idVo_MustHaveOfMethod() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..domain..id..\")\n        .should(haveStaticMethodWithName(\"of\"))\n        .allowEmptyShould(true)\n        .because(\"ID VO 생성은 of() 팩토리 메서드 사용\");\n    rule.check(domainClasses);\n}','IdVoArchTest','idVo_MustHaveOfMethod','BLOCKER','2026-01-24 15:40:20.000000','2026-01-24 15:40:20.000000',NULL),(25,3,'ARCH-DOM-ID-004','Long ID forNew() 필수','Long 타입 ID VO에 forNew() 정적 팩토리 메서드가 있는가?','@Test\n@DisplayName(\"[필수] Long ID VO는 forNew() 정적 팩토리 메서드가 있어야 한다\")\nvoid longIdVo_MustHaveForNewMethod() {\n    // Note: Long 타입 ID 여부는 필드 타입으로 판단\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..domain..id..\")\n        .and().containAnyFieldsThat(DescribedPredicate.describe(\n            \"Long type field\",\n            field -> field.getRawType().isEquivalentTo(Long.class)))\n        .should(haveStaticMethodWithName(\"forNew\"))\n        .allowEmptyShould(true)\n        .because(\"Long ID는 신규 생성용 forNew() 필수\");\n    rule.check(domainClasses);\n}','IdVoArchTest','longIdVo_MustHaveForNewMethod','BLOCKER','2026-01-24 15:40:20.000000','2026-01-24 15:40:20.000000',NULL),(26,3,'ARCH-DOM-ID-006','Long ID isNew() 필수','Long 타입 ID VO에 isNew() 메서드가 있는가?','@Test\n@DisplayName(\"[필수] Long ID VO는 isNew() 메서드가 있어야 한다\")\nvoid longIdVo_MustHaveIsNewMethod() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..domain..id..\")\n        .and().containAnyFieldsThat(DescribedPredicate.describe(\n            \"Long type field\",\n            field -> field.getRawType().isEquivalentTo(Long.class)))\n        .should(haveMethodWithName(\"isNew\"))\n        .allowEmptyShould(true)\n        .because(\"Long ID는 신규 여부 판단 isNew() 필수\");\n    rule.check(domainClasses);\n}','IdVoArchTest','longIdVo_MustHaveIsNewMethod','BLOCKER','2026-01-24 15:40:20.000000','2026-01-24 15:40:20.000000',NULL),(27,3,'ARCH-DOM-ID-007','String ID isNew() 금지','String 타입 ID VO에 isNew() 메서드가 없는가?','@Test\n@DisplayName(\"[금지] String ID VO는 isNew() 메서드가 없어야 한다\")\nvoid stringIdVo_MustNotHaveIsNewMethod() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..domain..id..\")\n        .and().containAnyFieldsThat(DescribedPredicate.describe(\n            \"String type field\",\n            field -> field.getRawType().isEquivalentTo(String.class)))\n        .should(notHaveMethodWithName(\"isNew\"))\n        .allowEmptyShould(true)\n        .because(\"String ID는 항상 외부 주입이므로 isNew 불필요\");\n    rule.check(domainClasses);\n}','IdVoArchTest','stringIdVo_MustNotHaveIsNewMethod','BLOCKER','2026-01-24 15:40:20.000000','2026-01-24 15:40:20.000000',NULL),(28,3,'ARCH-DOM-ID-008-02','UUID.randomUUID() 호출 금지','Domain에서 UUID.randomUUID() 호출이 없는가?','@Test\n@DisplayName(\"[금지] Domain에서 UUID.randomUUID() 호출 금지\")\nvoid domain_MustNotCallUuidRandomUuid() {\n    ArchRule rule = noClasses()\n        .that().resideInAPackage(\"..domain..\")\n        .should().callMethod(java.util.UUID.class, \"randomUUID\")\n        .because(\"String ID는 외부(Application Layer)에서 생성해서 주입\");\n    rule.check(domainClasses);\n}','IdVoArchTest','domain_MustNotCallUuidRandomUuid','BLOCKER','2026-01-24 15:40:20.000000','2026-01-24 15:40:20.000000',NULL),(29,7,'ARCH-DOM-EVT-001','DomainEvent 인터페이스 구현 필수','도메인 이벤트가 DomainEvent 인터페이스를 구현하는가?','@Test\n@DisplayName(\"[필수] 도메인 이벤트는 DomainEvent 인터페이스를 구현해야 한다\")\nvoid domainEvent_MustImplementDomainEventInterface() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..domain..event..\")\n        .and().haveSimpleNameEndingWith(\"Event\")\n        .and().areNotInterfaces()\n        .should().implement(DomainEvent.class)\n        .allowEmptyShould(true)\n        .because(\"도메인 이벤트 표준 인터페이스 구현 필수\");\n    rule.check(domainClasses);\n}','DomainEventArchTest','domainEvent_MustImplementDomainEventInterface','BLOCKER','2026-01-24 15:40:20.000000','2026-01-24 15:40:20.000000',NULL),(30,7,'ARCH-DOM-EVT-002','Event Record 타입 필수','도메인 이벤트가 Java Record로 정의되어 있는가?','@Test\n@DisplayName(\"[필수] 도메인 이벤트는 Record 타입이어야 한다\")\nvoid domainEvent_MustBeRecord() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..domain..event..\")\n        .and().haveSimpleNameEndingWith(\"Event\")\n        .and().areNotInterfaces()\n        .should().beRecords()\n        .allowEmptyShould(true)\n        .because(\"도메인 이벤트는 불변성 보장을 위해 Record 사용\");\n    rule.check(domainClasses);\n}','DomainEventArchTest','domainEvent_MustBeRecord','BLOCKER','2026-01-24 15:40:20.000000','2026-01-24 15:40:20.000000',NULL),(31,7,'ARCH-DOM-EVT-003','Event occurredAt 필드 필수','도메인 이벤트에 occurredAt(Instant) 필드가 있는가?','@Test\n@DisplayName(\"[필수] 도메인 이벤트는 occurredAt 필드가 있어야 한다\")\nvoid domainEvent_MustHaveOccurredAtField() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..domain..event..\")\n        .and().haveSimpleNameEndingWith(\"Event\")\n        .and().areRecords()\n        .should(haveFieldWithName(\"occurredAt\"))\n        .allowEmptyShould(true)\n        .because(\"이벤트 발생 시각 기록 필수\");\n    rule.check(domainClasses);\n}','DomainEventArchTest','domainEvent_MustHaveOccurredAtField','BLOCKER','2026-01-24 15:40:20.000000','2026-01-24 15:40:20.000000',NULL),(32,7,'ARCH-DOM-EVT-004','Event from() 팩토리 메서드 필수','도메인 이벤트에 from(Aggregate, Instant) 정적 팩토리 메서드가 있는가?','@Test\n@DisplayName(\"[필수] 도메인 이벤트는 from() 정적 팩토리 메서드가 있어야 한다\")\nvoid domainEvent_MustHaveFromMethod() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..domain..event..\")\n        .and().haveSimpleNameEndingWith(\"Event\")\n        .and().areRecords()\n        .should(haveStaticMethodWithName(\"from\"))\n        .allowEmptyShould(true)\n        .because(\"도메인 이벤트는 from(Aggregate, Instant) 팩토리 메서드 사용\");\n    rule.check(domainClasses);\n}','DomainEventArchTest','domainEvent_MustHaveFromMethod','BLOCKER','2026-01-24 15:40:20.000000','2026-01-24 15:40:20.000000',NULL),(33,7,'ARCH-DOM-EVT-006','Event 패키지 위치','도메인 이벤트가 domain.{bc}.event 패키지에 위치하는가?','@Test\n@DisplayName(\"[필수] 도메인 이벤트는 event 패키지에 위치해야 한다\")\nvoid domainEvent_MustBeInEventPackage() {\n    ArchRule rule = classes()\n        .that().haveSimpleNameEndingWith(\"Event\")\n        .and().areNotInterfaces()\n        .and().resideInAPackage(\"..domain..\")\n        .should().resideInAPackage(\"..event..\")\n        .allowEmptyShould(true)\n        .because(\"도메인 이벤트는 event 패키지에 위치\");\n    rule.check(domainClasses);\n}','DomainEventArchTest','domainEvent_MustBeInEventPackage','BLOCKER','2026-01-24 15:40:20.000000','2026-01-24 15:40:20.000000',NULL),(34,4,'ARCH-DOM-EXC-001','ErrorCode 인터페이스 구현 필수','ErrorCode enum이 ErrorCode 인터페이스를 구현하는가?','@Test\n@DisplayName(\"[필수] ErrorCode enum은 ErrorCode 인터페이스를 구현해야 한다\")\nvoid errorCode_MustImplementErrorCodeInterface() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..domain..exception..\")\n        .and().areEnums()\n        .and().haveSimpleNameEndingWith(\"ErrorCode\")\n        .should().implement(ErrorCode.class)\n        .allowEmptyShould(true)\n        .because(\"ErrorCode 표준 인터페이스 구현 필수\");\n    rule.check(domainClasses);\n}','ExceptionArchTest','errorCode_MustImplementErrorCodeInterface','BLOCKER','2026-01-24 15:40:20.000000','2026-01-24 15:40:20.000000',NULL),(35,4,'ARCH-DOM-EXC-002','ErrorCode 패키지 위치','ErrorCode가 domain.{bc}.exception 패키지에 위치하는가?','@Test\n@DisplayName(\"[필수] ErrorCode는 exception 패키지에 위치해야 한다\")\nvoid errorCode_MustBeInExceptionPackage() {\n    ArchRule rule = classes()\n        .that().haveSimpleNameEndingWith(\"ErrorCode\")\n        .and().areEnums()\n        .should().resideInAPackage(\"..exception..\")\n        .allowEmptyShould(true)\n        .because(\"ErrorCode는 exception 패키지에 위치\");\n    rule.check(domainClasses);\n}','ExceptionArchTest','errorCode_MustBeInExceptionPackage','BLOCKER','2026-01-24 15:40:20.000000','2026-01-24 15:40:20.000000',NULL),(36,4,'ARCH-DOM-EXC-004','Exception Lombok 금지','Exception에서 Lombok을 사용하지 않는가?','@Test\n@DisplayName(\"[금지] Exception에서 Lombok 사용 금지\")\nvoid exception_MustNotUseLombok() {\n    ArchRule rule = noClasses()\n        .that().resideInAPackage(\"..domain..exception..\")\n        .should().beAnnotatedWith(\"lombok.Getter\")\n        .orShould().beAnnotatedWith(\"lombok.Data\")\n        .because(\"Exception은 Plain Java 사용\");\n    rule.check(domainClasses);\n}','ExceptionArchTest','exception_MustNotUseLombok','BLOCKER','2026-01-24 15:40:20.000000','2026-01-24 15:40:20.000000',NULL),(37,4,'ARCH-DOM-EXC-005','ErrorCode getCode() 메서드 필수','ErrorCode에 getCode() 메서드가 있는가?','@Test\n@DisplayName(\"[필수] ErrorCode는 getCode() 메서드가 있어야 한다\")\nvoid errorCode_MustHaveGetCodeMethod() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..domain..exception..\")\n        .and().areEnums()\n        .and().haveSimpleNameEndingWith(\"ErrorCode\")\n        .should(haveMethodWithName(\"getCode\"))\n        .allowEmptyShould(true)\n        .because(\"ErrorCode 식별자 메서드 필수\");\n    rule.check(domainClasses);\n}','ExceptionArchTest','errorCode_MustHaveGetCodeMethod','BLOCKER','2026-01-24 15:40:20.000000','2026-01-24 15:40:20.000000',NULL),(38,4,'ARCH-DOM-EXC-006-01','ErrorCode getHttpStatus() int 반환','ErrorCode의 getHttpStatus()가 int 타입을 반환하는가?','@Test\n@DisplayName(\"[필수] ErrorCode getHttpStatus()는 int 반환\")\nvoid errorCode_GetHttpStatusMustReturnInt() {\n    ArchRule rule = methods()\n        .that().areDeclaredInClassesThat().resideInAPackage(\"..domain..exception..\")\n        .and().areDeclaredInClassesThat().areEnums()\n        .and().haveName(\"getHttpStatus\")\n        .should().haveRawReturnType(int.class)\n        .allowEmptyShould(true)\n        .because(\"HTTP 상태 코드는 int 타입\");\n    rule.check(domainClasses);\n}','ExceptionArchTest','errorCode_GetHttpStatusMustReturnInt','BLOCKER','2026-01-24 15:40:20.000000','2026-01-24 15:40:20.000000',NULL),(39,4,'ARCH-DOM-EXC-006-02','Spring HttpStatus 사용 금지','Spring HttpStatus를 사용하지 않는가?','@Test\n@DisplayName(\"[금지] Domain에서 Spring HttpStatus 사용 금지\")\nvoid domain_MustNotUseSpringHttpStatus() {\n    ArchRule rule = noClasses()\n        .that().resideInAPackage(\"..domain..\")\n        .should().dependOnClassesThat().haveFullyQualifiedName(\"org.springframework.http.HttpStatus\")\n        .because(\"Domain은 Spring에 독립적\");\n    rule.check(domainClasses);\n}','ExceptionArchTest','domain_MustNotUseSpringHttpStatus','BLOCKER','2026-01-24 15:40:20.000000','2026-01-24 15:40:20.000000',NULL),(40,4,'ARCH-DOM-EXC-007','ErrorCode getMessage() 메서드 필수','ErrorCode에 getMessage() 메서드가 있는가?','@Test\n@DisplayName(\"[필수] ErrorCode는 getMessage() 메서드가 있어야 한다\")\nvoid errorCode_MustHaveGetMessageMethod() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..domain..exception..\")\n        .and().areEnums()\n        .and().haveSimpleNameEndingWith(\"ErrorCode\")\n        .should(haveMethodWithName(\"getMessage\"))\n        .allowEmptyShould(true)\n        .because(\"에러 메시지 조회 메서드 필수\");\n    rule.check(domainClasses);\n}','ExceptionArchTest','errorCode_MustHaveGetMessageMethod','BLOCKER','2026-01-24 15:40:20.000000','2026-01-24 15:40:20.000000',NULL),(41,4,'ARCH-DOM-EXC-009','DomainException 상속 필수','도메인 예외 클래스가 DomainException을 상속받는가?','@Test\n@DisplayName(\"[필수] 도메인 예외는 DomainException을 상속해야 한다\")\nvoid domainException_MustExtendDomainException() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..domain..exception..\")\n        .and().haveSimpleNameEndingWith(\"Exception\")\n        .and().areNotInterfaces()\n        .and().doNotHaveSimpleName(\"DomainException\")\n        .should().beAssignableTo(DomainException.class)\n        .allowEmptyShould(true)\n        .because(\"도메인 예외 계층 구조 통일\");\n    rule.check(domainClasses);\n}','ExceptionArchTest','domainException_MustExtendDomainException','BLOCKER','2026-01-24 15:40:20.000000','2026-01-24 15:40:20.000000',NULL),(42,4,'ARCH-DOM-EXC-010','Exception 패키지 위치','도메인 예외가 domain.{bc}.exception 패키지에 위치하는가?','@Test\n@DisplayName(\"[필수] 도메인 예외는 exception 패키지에 위치해야 한다\")\nvoid domainException_MustBeInExceptionPackage() {\n    ArchRule rule = classes()\n        .that().haveSimpleNameEndingWith(\"Exception\")\n        .and().resideInAPackage(\"..domain..\")\n        .and().areNotInterfaces()\n        .should().resideInAPackage(\"..exception..\")\n        .allowEmptyShould(true)\n        .because(\"도메인 예외는 exception 패키지에 위치\");\n    rule.check(domainClasses);\n}','ExceptionArchTest','domainException_MustBeInExceptionPackage','BLOCKER','2026-01-24 15:40:20.000000','2026-01-24 15:40:20.000000',NULL),(43,4,'ARCH-DOM-EXC-014','Exception public 클래스','도메인 예외가 public 클래스로 선언되어 있는가?','@Test\n@DisplayName(\"[필수] 도메인 예외는 public이어야 한다\")\nvoid domainException_MustBePublic() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..domain..exception..\")\n        .and().haveSimpleNameEndingWith(\"Exception\")\n        .should().bePublic()\n        .allowEmptyShould(true)\n        .because(\"다른 레이어에서 사용\");\n    rule.check(domainClasses);\n}','ExceptionArchTest','domainException_MustBePublic','BLOCKER','2026-01-24 15:40:20.000000','2026-01-24 15:40:20.000000',NULL),(44,4,'ARCH-DOM-EXC-015','Exception RuntimeException 계층','도메인 예외가 RuntimeException 계층인가?','@Test\n@DisplayName(\"[필수] 도메인 예외는 RuntimeException 계층이어야 한다\")\nvoid domainException_MustBeRuntimeException() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..domain..exception..\")\n        .and().haveSimpleNameEndingWith(\"Exception\")\n        .should().beAssignableTo(RuntimeException.class)\n        .allowEmptyShould(true)\n        .because(\"Unchecked Exception 사용\");\n    rule.check(domainClasses);\n}','ExceptionArchTest','domainException_MustBeRuntimeException','BLOCKER','2026-01-24 15:40:20.000000','2026-01-24 15:40:20.000000',NULL),(45,6,'ARCH-DOM-EXC-019','DomainException common 패키지','DomainException 추상 클래스가 domain.common.exception 패키지에 있는가?','@Test\n@DisplayName(\"[필수] DomainException은 common.exception 패키지에 위치\")\nvoid domainException_MustBeInCommonPackage() {\n    ArchRule rule = classes()\n        .that().haveSimpleName(\"DomainException\")\n        .should().resideInAPackage(\"..common.exception..\")\n        .allowEmptyShould(true)\n        .because(\"공통 예외 추상 클래스는 common 패키지\");\n    rule.check(domainClasses);\n}','ExceptionArchTest','domainException_MustBeInCommonPackage','BLOCKER','2026-01-24 15:40:20.000000','2026-01-24 15:40:20.000000',NULL),(46,6,'ARCH-DOM-EXC-020','ErrorCode 인터페이스 common 패키지','ErrorCode 인터페이스가 domain.common.exception 패키지에 있는가?','@Test\n@DisplayName(\"[필수] ErrorCode 인터페이스는 common.exception 패키지에 위치\")\nvoid errorCodeInterface_MustBeInCommonPackage() {\n    ArchRule rule = classes()\n        .that().haveSimpleName(\"ErrorCode\")\n        .and().areInterfaces()\n        .should().resideInAPackage(\"..common.exception..\")\n        .allowEmptyShould(true)\n        .because(\"공통 ErrorCode 인터페이스는 common 패키지\");\n    rule.check(domainClasses);\n}','ExceptionArchTest','errorCodeInterface_MustBeInCommonPackage','BLOCKER','2026-01-24 15:40:21.000000','2026-01-24 15:40:21.000000',NULL),(47,8,'ARCH-DOM-CRI-001','Criteria 패키지 위치','Criteria가 domain.{bc}.query.criteria 패키지에 위치하는가?','@Test\n@DisplayName(\"[필수] Criteria는 query 패키지에 위치해야 한다\")\nvoid criteria_MustBeInQueryPackage() {\n    ArchRule rule = classes()\n        .that().haveSimpleNameEndingWith(\"Criteria\")\n        .and().resideInAPackage(\"..domain..\")\n        .should().resideInAPackage(\"..query..\")\n        .allowEmptyShould(true)\n        .because(\"Criteria는 query 패키지에 위치\");\n    rule.check(domainClasses);\n}','CriteriaArchTest','criteria_MustBeInQueryPackage','BLOCKER','2026-01-24 15:40:21.000000','2026-01-24 15:40:21.000000',NULL),(48,8,'ARCH-DOM-CRI-003','Criteria public 접근 제어자','Criteria가 public으로 선언되어 있는가?','@Test\n@DisplayName(\"[필수] Criteria는 public이어야 한다\")\nvoid criteria_MustBePublic() {\n    ArchRule rule = classes()\n        .that().haveSimpleNameEndingWith(\"Criteria\")\n        .and().resideInAPackage(\"..domain..query..\")\n        .should().bePublic()\n        .allowEmptyShould(true)\n        .because(\"다른 레이어에서 사용\");\n    rule.check(domainClasses);\n}','CriteriaArchTest','criteria_MustBePublic','BLOCKER','2026-01-24 15:40:21.000000','2026-01-24 15:40:21.000000',NULL),(49,8,'ARCH-DOM-CRI-004','Criteria Record 타입 필수','Criteria가 Java Record로 정의되어 있는가?','@Test\n@DisplayName(\"[필수] Criteria는 Record 타입이어야 한다\")\nvoid criteria_MustBeRecord() {\n    ArchRule rule = classes()\n        .that().haveSimpleNameEndingWith(\"Criteria\")\n        .and().resideInAPackage(\"..domain..query..\")\n        .should().beRecords()\n        .allowEmptyShould(true)\n        .because(\"Criteria는 불변 조회 조건\");\n    rule.check(domainClasses);\n}','CriteriaArchTest','criteria_MustBeRecord','BLOCKER','2026-01-24 15:40:21.000000','2026-01-24 15:40:21.000000',NULL),(50,8,'ARCH-DOM-CRI-005','Criteria of() 팩토리 메서드 필수','Criteria에 of() 정적 팩토리 메서드가 있는가?','@Test\n@DisplayName(\"[필수] Criteria는 of() 정적 팩토리 메서드가 있어야 한다\")\nvoid criteria_MustHaveOfMethod() {\n    ArchRule rule = classes()\n        .that().haveSimpleNameEndingWith(\"Criteria\")\n        .and().resideInAPackage(\"..domain..query..\")\n        .should(haveStaticMethodWithName(\"of\"))\n        .allowEmptyShould(true)\n        .because(\"Criteria 생성은 of() 팩토리 메서드 사용\");\n    rule.check(domainClasses);\n}','CriteriaArchTest','criteria_MustHaveOfMethod','BLOCKER','2026-01-24 15:40:21.000000','2026-01-24 15:40:21.000000',NULL),(51,8,'ARCH-DOM-CRI-010','Criteria JPA/Spring 어노테이션 금지','Criteria에서 JPA/Spring 어노테이션을 사용하지 않는가?','@Test\n@DisplayName(\"[금지] Criteria에서 JPA/Spring 어노테이션 사용 금지\")\nvoid criteria_MustNotUseJpaOrSpring() {\n    ArchRule rule = noClasses()\n        .that().haveSimpleNameEndingWith(\"Criteria\")\n        .and().resideInAPackage(\"..domain..query..\")\n        .should().beAnnotatedWith(\"jakarta.persistence.Entity\")\n        .orShould().beAnnotatedWith(\"org.springframework.stereotype.Component\")\n        .because(\"Criteria는 순수 자바 객체\");\n    rule.check(domainClasses);\n}','CriteriaArchTest','criteria_MustNotUseJpaOrSpring','BLOCKER','2026-01-24 15:40:21.000000','2026-01-24 15:40:21.000000',NULL),(52,14,'ARCH-APP-TRX-001','Service @Transactional 금지','Service 클래스에 @Transactional 어노테이션이 없는가?','@Test\n@DisplayName(\"[금지] Service에 @Transactional 금지\")\nvoid service_MustNotHaveTransactional() {\n    ArchRule rule = noClasses()\n        .that().resideInAPackage(\"..application..service..\")\n        .and().haveSimpleNameEndingWith(\"Service\")\n        .should().beAnnotatedWith(\"org.springframework.transaction.annotation.Transactional\")\n        .because(\"트랜잭션 경계는 Manager/Facade 책임\");\n    rule.check(applicationClasses);\n}','ApplicationTransactionArchTest','service_MustNotHaveTransactional','BLOCKER','2026-01-24 15:40:21.000000','2026-01-24 15:40:21.000000',NULL),(53,18,'ARCH-APP-TRX-002','Manager @Transactional 필수','CommandManager/QueryManager에 @Transactional이 있는가?','@Test\n@DisplayName(\"[필수] Manager에 @Transactional 필수\")\nvoid manager_MustHaveTransactional() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..application..manager..\")\n        .and().haveSimpleNameEndingWith(\"Manager\")\n        .and().haveSimpleNameNotContaining(\"Client\")\n        .should().beAnnotatedWith(\"org.springframework.transaction.annotation.Transactional\")\n        .allowEmptyShould(true)\n        .because(\"Manager가 트랜잭션 경계\");\n    rule.check(applicationClasses);\n}','ApplicationTransactionArchTest','manager_MustHaveTransactional','BLOCKER','2026-01-24 15:40:21.000000','2026-01-24 15:40:21.000000',NULL),(54,20,'ARCH-APP-TRX-003','ClientManager @Transactional 금지','ClientManager에 @Transactional 어노테이션이 없는가?','@Test\n@DisplayName(\"[금지] ClientManager에 @Transactional 금지\")\nvoid clientManager_MustNotHaveTransactional() {\n    ArchRule rule = noClasses()\n        .that().resideInAPackage(\"..application..manager.client..\")\n        .and().haveSimpleNameEndingWith(\"Manager\")\n        .should().beAnnotatedWith(\"org.springframework.transaction.annotation.Transactional\")\n        .because(\"외부 API 호출은 트랜잭션 밖에서\");\n    rule.check(applicationClasses);\n}','ApplicationTransactionArchTest','clientManager_MustNotHaveTransactional','BLOCKER','2026-01-24 15:40:21.000000','2026-01-24 15:40:21.000000',NULL),(55,17,'ARCH-APP-TRX-005','QueryFacade @Transactional(readOnly=true)','QueryFacade에 @Transactional(readOnly=true)가 있는가?','@Test\n@DisplayName(\"[필수] QueryFacade에 @Transactional(readOnly=true) 필수\")\nvoid queryFacade_MustHaveReadOnlyTransactional() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..application..facade.query..\")\n        .and().haveSimpleNameEndingWith(\"Facade\")\n        .should().beAnnotatedWith(\n            DescribedPredicate.describe(\n                \"@Transactional(readOnly=true)\",\n                annotation -> annotation.getName().contains(\"Transactional\")))\n        .allowEmptyShould(true)\n        .because(\"조회 전용 트랜잭션 최적화\");\n    rule.check(applicationClasses);\n}','ApplicationTransactionArchTest','queryFacade_MustHaveReadOnlyTransactional','MAJOR','2026-01-24 15:40:21.000000','2026-01-24 15:40:21.000000',NULL),(56,27,'ARCH-APP-DTO-001-01','Command/Query Record 필수','Command/Query DTO가 Java Record로 정의되어 있는가?','@Test\n@DisplayName(\"[필수] Command/Query는 Record 타입이어야 한다\")\nvoid commandQuery_MustBeRecord() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..application..dto..\")\n        .and().haveSimpleNameEndingWith(\"Command\")\n        .or().haveSimpleNameEndingWith(\"Query\")\n        .should().beRecords()\n        .allowEmptyShould(true)\n        .because(\"Command/Query DTO는 불변\");\n    rule.check(applicationClasses);\n}','ApplicationDtoArchTest','commandQuery_MustBeRecord','BLOCKER','2026-01-24 15:40:21.000000','2026-01-24 15:40:21.000000',NULL),(57,27,'ARCH-APP-DTO-001-02','Command/Query Lombok 금지','Lombok을 사용하지 않는가?','@Test\n@DisplayName(\"[금지] Command/Query에서 Lombok 사용 금지\")\nvoid commandQuery_MustNotUseLombok() {\n    ArchRule rule = noClasses()\n        .that().resideInAPackage(\"..application..dto..\")\n        .should().beAnnotatedWith(\"lombok.Data\")\n        .orShould().beAnnotatedWith(\"lombok.Builder\")\n        .because(\"Record 사용으로 Lombok 불필요\");\n    rule.check(applicationClasses);\n}','ApplicationDtoArchTest','commandQuery_MustNotUseLombok','BLOCKER','2026-01-24 15:40:21.000000','2026-01-24 15:40:21.000000',NULL),(58,27,'ARCH-APP-DTO-002','Command/Query 인스턴스 메서드 금지','Command/Query에 인스턴스 메서드가 없는가?','@Test\n@DisplayName(\"[금지] Command/Query에 비즈니스 로직 메서드 금지\")\nvoid commandQuery_MustNotHaveBusinessMethods() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..application..dto..\")\n        .and().areRecords()\n        .should(notHaveBusinessLogicMethods())\n        .allowEmptyShould(true)\n        .because(\"Command/Query는 순수 데이터 운반 객체\");\n    rule.check(applicationClasses);\n}','ApplicationDtoArchTest','commandQuery_MustNotHaveBusinessMethods','BLOCKER','2026-01-24 15:40:21.000000','2026-01-24 15:40:21.000000',NULL),(59,14,'ARCH-APP-DEP-001','Service → Facade/Manager 의존','Service가 Facade 또는 Manager에 의존하는가?','@Test\n@DisplayName(\"[필수] Service는 Facade/Manager에 의존\")\nvoid service_MustDependOnFacadeOrManager() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..application..service..\")\n        .and().haveSimpleNameEndingWith(\"Service\")\n        .should().dependOnClassesThat().haveSimpleNameEndingWith(\"Facade\")\n        .orShould().dependOnClassesThat().haveSimpleNameEndingWith(\"Manager\")\n        .allowEmptyShould(true)\n        .because(\"Service는 Facade/Manager를 조율\");\n    rule.check(applicationClasses);\n}','ApplicationDependencyArchTest','service_MustDependOnFacadeOrManager','MAJOR','2026-01-24 15:40:21.000000','2026-01-24 15:40:21.000000',NULL),(60,16,'ARCH-APP-DEP-003','CommandFacade → QueryManager 금지','CommandFacade에서 QueryManager를 의존하지 않는가?','@Test\n@DisplayName(\"[금지] CommandFacade에서 QueryManager 의존 금지 (CQRS)\")\nvoid commandFacade_MustNotDependOnQueryManager() {\n    ArchRule rule = noClasses()\n        .that().resideInAPackage(\"..application..facade.command..\")\n        .should().dependOnClassesThat().resideInAPackage(\"..manager.query..\")\n        .because(\"CQRS 원칙: Command와 Query 분리\");\n    rule.check(applicationClasses);\n}','ApplicationDependencyArchTest','commandFacade_MustNotDependOnQueryManager','BLOCKER','2026-01-24 15:40:21.000000','2026-01-24 15:40:21.000000',NULL),(61,14,'ARCH-APP-EVT-001','ApplicationEventPublisher 직접 주입 금지','Service에 ApplicationEventPublisher가 직접 주입되지 않는가?','@Test\n@DisplayName(\"[금지] Service에 ApplicationEventPublisher 직접 주입 금지\")\nvoid service_MustNotInjectEventPublisher() {\n    ArchRule rule = noClasses()\n        .that().resideInAPackage(\"..application..service..\")\n        .should().dependOnClassesThat().haveFullyQualifiedName(\n            \"org.springframework.context.ApplicationEventPublisher\")\n        .because(\"이벤트 발행은 TransactionEventRegistry 사용\");\n    rule.check(applicationClasses);\n}','ApplicationEventArchTest','service_MustNotInjectEventPublisher','BLOCKER','2026-01-24 15:40:21.000000','2026-01-24 15:40:21.000000',NULL),(62,36,'ARCH-APP-LSN-002-01','EventListener Manager 의존','EventListener가 Manager에 의존하는가?','@Test\n@DisplayName(\"[필수] EventListener는 Manager에 의존\")\nvoid eventListener_MustDependOnManager() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..application..listener..\")\n        .and().haveSimpleNameEndingWith(\"Listener\")\n        .should().dependOnClassesThat().haveSimpleNameEndingWith(\"Manager\")\n        .allowEmptyShould(true)\n        .because(\"EventListener는 Manager를 통해 처리\");\n    rule.check(applicationClasses);\n}','ApplicationEventArchTest','eventListener_MustDependOnManager','MAJOR','2026-01-24 15:40:21.000000','2026-01-24 15:40:21.000000',NULL),(63,36,'ARCH-APP-LSN-002-02','EventListener Port 직접 의존 금지','Port를 직접 의존하지 않는가?','@Test\n@DisplayName(\"[금지] EventListener에서 Port 직접 의존 금지\")\nvoid eventListener_MustNotDependOnPort() {\n    ArchRule rule = noClasses()\n        .that().resideInAPackage(\"..application..listener..\")\n        .should().dependOnClassesThat().haveSimpleNameEndingWith(\"Port\")\n        .because(\"EventListener는 Manager를 통해 Port 접근\");\n    rule.check(applicationClasses);\n}','ApplicationEventArchTest','eventListener_MustNotDependOnPort','MAJOR','2026-01-24 15:40:21.000000','2026-01-24 15:40:21.000000',NULL),(64,12,'ARCH-APP-PRT-002','QueryPort findAll 금지','QueryPort에 findAll() 메서드가 없는가?','@Test\n@DisplayName(\"[금지] QueryPort에 findAll() 금지 (OOM 위험)\")\nvoid queryPort_MustNotHaveFindAll() {\n    ArchRule rule = noMethods()\n        .that().areDeclaredInClassesThat().resideInAPackage(\"..port.out.query..\")\n        .and().areDeclaredInClassesThat().areInterfaces()\n        .and().haveName(\"findAll\")\n        .should().beDeclared()\n        .because(\"전체 조회는 OOM 위험, 페이징 필수\");\n    rule.check(applicationClasses);\n}','ApplicationPortArchTest','queryPort_MustNotHaveFindAll','BLOCKER','2026-01-24 15:40:21.000000','2026-01-24 15:40:21.000000',NULL),(65,14,'ARCH-APP-SVC-001','UseCase 1:1 Service 구현','1 UseCase = 1 Service로 구현되어 있는가?','@Test\n@DisplayName(\"[필수] Service는 UseCase 인터페이스를 구현해야 한다\")\nvoid service_MustImplementUseCase() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..application..service..\")\n        .and().haveSimpleNameEndingWith(\"Service\")\n        .and().areNotInterfaces()\n        .should().implement(\n            DescribedPredicate.describe(\n                \"UseCase interface\",\n                javaClass -> javaClass.getAllRawInterfaces().stream()\n                    .anyMatch(i -> i.getSimpleName().endsWith(\"UseCase\"))))\n        .allowEmptyShould(true)\n        .because(\"Service는 UseCase 구현체\");\n    rule.check(applicationClasses);\n}','ApplicationServiceArchTest','service_MustImplementUseCase','MAJOR','2026-01-24 15:40:21.000000','2026-01-24 15:40:21.000000',NULL),(66,21,'ARCH-APP-TIM-001-01','TimeProvider Factory에서만','TimeProvider.now()가 Factory에서만 호출되는가?','@Test\n@DisplayName(\"[필수] TimeProvider는 Factory에서만 사용\")\nvoid timeProvider_OnlyInFactory() {\n    ArchRule rule = noClasses()\n        .that().resideInAPackage(\"..application..\")\n        .and().haveSimpleNameNotEndingWith(\"Factory\")\n        .should().callMethodWhere(\n            target(name(\"now\")).and(target(owner(name(\"TimeProvider\")))))\n        .allowEmptyShould(true)\n        .because(\"시간 생성은 Factory 책임\");\n    rule.check(applicationClasses);\n}','ApplicationTimeArchTest','timeProvider_OnlyInFactory','BLOCKER','2026-01-24 15:40:23.000000','2026-01-24 15:40:23.000000',NULL),(67,14,'ARCH-APP-TIM-001-02','Service TimeProvider 직접 사용 금지','Service에서 TimeProvider를 직접 사용하지 않는가?','@Test\n@DisplayName(\"[금지] Service에서 TimeProvider 직접 사용 금지\")\nvoid service_MustNotUseTimeProvider() {\n    ArchRule rule = noClasses()\n        .that().resideInAPackage(\"..application..service..\")\n        .should().dependOnClassesThat().haveSimpleName(\"TimeProvider\")\n        .because(\"Service는 Factory가 생성한 시간 사용\");\n    rule.check(applicationClasses);\n}','ApplicationTimeArchTest','service_MustNotUseTimeProvider','BLOCKER','2026-01-24 15:40:23.000000','2026-01-24 15:40:23.000000',NULL),(68,38,'ARCH-PER-ENT-001','JPA 관계 어노테이션 금지','@OneToMany, @ManyToOne 등이 없는가?','@Test\n@DisplayName(\"[금지] JPA Entity에 관계 어노테이션 금지\")\nvoid jpaEntity_MustNotUseRelationshipAnnotations() {\n    ArchRule rule = noFields()\n        .that().areDeclaredInClassesThat().areAnnotatedWith(\"jakarta.persistence.Entity\")\n        .should().beAnnotatedWith(\"jakarta.persistence.ManyToOne\")\n        .orShould().beAnnotatedWith(\"jakarta.persistence.OneToMany\")\n        .orShould().beAnnotatedWith(\"jakarta.persistence.OneToOne\")\n        .orShould().beAnnotatedWith(\"jakarta.persistence.ManyToMany\")\n        .because(\"Long FK 전략 사용 (관계 어노테이션 금지)\");\n    rule.check(persistenceClasses);\n}','PersistenceEntityArchTest','jpaEntity_MustNotUseRelationshipAnnotations','BLOCKER','2026-01-24 15:40:23.000000','2026-01-24 15:40:23.000000',NULL),(69,38,'ARCH-PER-ENT-002','Entity는 BaseAuditEntity 상속','JpaEntity가 BaseAuditEntity를 상속하는가?','@Test\n@DisplayName(\"[필수] JPA Entity는 BaseAuditEntity 상속\")\nvoid jpaEntity_MustExtendBaseAuditEntity() {\n    ArchRule rule = classes()\n        .that().areAnnotatedWith(\"jakarta.persistence.Entity\")\n        .should().beAssignableTo(\n            DescribedPredicate.describe(\n                \"BaseAuditEntity or SoftDeletableEntity\",\n                javaClass -> javaClass.getName().contains(\"BaseAuditEntity\")\n                    || javaClass.getName().contains(\"SoftDeletableEntity\")))\n        .allowEmptyShould(true)\n        .because(\"감사 필드 자동 관리\");\n    rule.check(persistenceClasses);\n}','PersistenceEntityArchTest','jpaEntity_MustExtendBaseAuditEntity','MAJOR','2026-01-24 15:40:23.000000','2026-01-24 15:40:23.000000',NULL),(70,40,'ARCH-PER-REP-001','JpaRepository save/saveAll만 사용','JpaRepository에서 save, saveAll만 사용하는가?','@Test\n@DisplayName(\"[필수] JpaRepository는 save/saveAll만 사용\")\nvoid jpaRepository_OnlySaveMethods() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..persistence..repository..\")\n        .and().haveSimpleNameEndingWith(\"JpaRepository\")\n        .and().areInterfaces()\n        .should(onlyDeclareSaveAndSaveAllMethods())\n        .allowEmptyShould(true)\n        .because(\"조회는 QueryDslRepository 사용\");\n    rule.check(persistenceClasses);\n}','PersistenceRepositoryArchTest','jpaRepository_OnlySaveMethods','BLOCKER','2026-01-24 15:40:23.000000','2026-01-24 15:40:23.000000',NULL),(71,40,'ARCH-PER-REP-002','JpaRepository 커스텀 메서드 금지','@Query, findBy* 등이 없는가?','@Test\n@DisplayName(\"[금지] JpaRepository에 커스텀 쿼리 메서드 금지\")\nvoid jpaRepository_MustNotHaveCustomQueryMethods() {\n    ArchRule rule = noMethods()\n        .that().areDeclaredInClassesThat().resideInAPackage(\"..persistence..repository..\")\n        .and().areDeclaredInClassesThat().haveSimpleNameEndingWith(\"JpaRepository\")\n        .and().haveNameMatching(\"find.*\")\n        .should().beDeclared()\n        .allowEmptyShould(true)\n        .because(\"조회 로직은 QueryDslRepository에서 구현\");\n    rule.check(persistenceClasses);\n}','PersistenceRepositoryArchTest','jpaRepository_MustNotHaveCustomQueryMethods','BLOCKER','2026-01-24 15:40:23.000000','2026-01-24 15:40:23.000000',NULL),(72,40,'ARCH-PER-REP-003','모든 조회는 QueryDslRepository','조회 쿼리가 QueryDslRepository에 구현되어 있는가?','@Test\n@DisplayName(\"[필수] 조회 로직은 QueryDslRepository에 구현\")\nvoid queryLogic_MustBeInQueryDslRepository() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..persistence..repository..\")\n        .and().haveSimpleNameEndingWith(\"QueryDslRepository\")\n        .should().bePublic()\n        .allowEmptyShould(true)\n        .because(\"QueryDsl로 타입 세이프한 쿼리 작성\");\n    rule.check(persistenceClasses);\n}','PersistenceRepositoryArchTest','queryLogic_MustBeInQueryDslRepository','BLOCKER','2026-01-24 15:40:23.000000','2026-01-24 15:40:23.000000',NULL),(73,37,'ARCH-PER-ADP-001-01','CommandAdapter JpaRepository만 의존','CommandAdapter가 JpaRepository만 의존하는가?','@Test\n@DisplayName(\"[필수] CommandAdapter는 JpaRepository만 의존\")\nvoid commandAdapter_OnlyJpaRepository() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..persistence..adapter..\")\n        .and().haveSimpleNameContaining(\"Command\")\n        .and().haveSimpleNameEndingWith(\"Adapter\")\n        .should().dependOnClassesThat().haveSimpleNameEndingWith(\"JpaRepository\")\n        .allowEmptyShould(true)\n        .because(\"CommandAdapter는 저장만 담당\");\n    rule.check(persistenceClasses);\n}','PersistenceAdapterArchTest','commandAdapter_OnlyJpaRepository','BLOCKER','2026-01-24 15:40:23.000000','2026-01-24 15:40:23.000000',NULL),(74,37,'ARCH-PER-ADP-001-02','CommandAdapter QueryDslRepository 금지','QueryDslRepository를 주입받지 않는가?','@Test\n@DisplayName(\"[금지] CommandAdapter에서 QueryDslRepository 금지\")\nvoid commandAdapter_MustNotUseQueryDslRepository() {\n    ArchRule rule = noClasses()\n        .that().resideInAPackage(\"..persistence..adapter..\")\n        .and().haveSimpleNameContaining(\"Command\")\n        .should().dependOnClassesThat().haveSimpleNameEndingWith(\"QueryDslRepository\")\n        .because(\"CommandAdapter는 조회하지 않음 (CQRS)\");\n    rule.check(persistenceClasses);\n}','PersistenceAdapterArchTest','commandAdapter_MustNotUseQueryDslRepository','BLOCKER','2026-01-24 15:40:23.000000','2026-01-24 15:40:23.000000',NULL),(75,37,'ARCH-PER-ADP-002-01','QueryAdapter QueryDslRepository만 의존','QueryAdapter가 QueryDslRepository만 의존하는가?','@Test\n@DisplayName(\"[필수] QueryAdapter는 QueryDslRepository만 의존\")\nvoid queryAdapter_OnlyQueryDslRepository() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..persistence..adapter..\")\n        .and().haveSimpleNameContaining(\"Query\")\n        .and().haveSimpleNameEndingWith(\"Adapter\")\n        .should().dependOnClassesThat().haveSimpleNameEndingWith(\"QueryDslRepository\")\n        .allowEmptyShould(true)\n        .because(\"QueryAdapter는 조회만 담당\");\n    rule.check(persistenceClasses);\n}','PersistenceAdapterArchTest','queryAdapter_OnlyQueryDslRepository','BLOCKER','2026-01-24 15:40:23.000000','2026-01-24 15:40:23.000000',NULL),(76,37,'ARCH-PER-ADP-002-02','QueryAdapter JpaRepository 금지','JpaRepository를 주입받지 않는가?','@Test\n@DisplayName(\"[금지] QueryAdapter에서 JpaRepository 금지\")\nvoid queryAdapter_MustNotUseJpaRepository() {\n    ArchRule rule = noClasses()\n        .that().resideInAPackage(\"..persistence..adapter..\")\n        .and().haveSimpleNameContaining(\"Query\")\n        .should().dependOnClassesThat().haveSimpleNameEndingWith(\"JpaRepository\")\n        .because(\"QueryAdapter는 저장하지 않음 (CQRS)\");\n    rule.check(persistenceClasses);\n}','PersistenceAdapterArchTest','queryAdapter_MustNotUseJpaRepository','BLOCKER','2026-01-24 15:40:23.000000','2026-01-24 15:40:23.000000',NULL),(77,46,'ARCH-PER-ADM-001','Admin 복잡 쿼리 분리','복잡한 쿼리가 admin 모듈에만 있는가?','@Test\n@DisplayName(\"[필수] Admin 복잡 쿼리는 admin 모듈에 위치\")\nvoid complexQuery_MustBeInAdminModule() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..persistence..admin..\")\n        .should().bePublic()\n        .allowEmptyShould(true)\n        .because(\"복잡한 조인/서브쿼리는 admin 모듈 전용\");\n    rule.check(persistenceClasses);\n}','PersistenceAdminArchTest','complexQuery_MustBeInAdminModule','BLOCKER','2026-01-24 15:40:23.000000','2026-01-24 15:40:23.000000',NULL),(78,60,'ARCH-API-CTR-001','@RestController 어노테이션 필수','Controller에 @RestController가 있는가?','@Test\n@DisplayName(\"[필수] Controller는 @RestController 필수\")\nvoid controller_MustHaveRestController() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..rest..controller..\")\n        .and().haveSimpleNameEndingWith(\"Controller\")\n        .should().beAnnotatedWith(\"org.springframework.web.bind.annotation.RestController\")\n        .allowEmptyShould(true)\n        .because(\"REST API Controller 명시\");\n    rule.check(restApiClasses);\n}','RestApiControllerArchTest','controller_MustHaveRestController','MAJOR','2026-01-24 15:40:23.000000','2026-01-24 15:40:23.000000',NULL),(79,60,'ARCH-API-CTR-002','DELETE 메서드 금지','HTTP DELETE를 사용하지 않는가?','@Test\n@DisplayName(\"[금지] Controller에서 @DeleteMapping 금지\")\nvoid controller_MustNotUseDeleteMapping() {\n    ArchRule rule = noMethods()\n        .that().areDeclaredInClassesThat().resideInAPackage(\"..rest..controller..\")\n        .should().beAnnotatedWith(\"org.springframework.web.bind.annotation.DeleteMapping\")\n        .because(\"Soft Delete 정책: DELETE 대신 PATCH 사용\");\n    rule.check(restApiClasses);\n}','RestApiControllerArchTest','controller_MustNotUseDeleteMapping','BLOCKER','2026-01-24 15:40:23.000000','2026-01-24 15:40:23.000000',NULL),(80,60,'ARCH-API-CTR-003-01','UseCase 인터페이스 의존','Controller가 UseCase에 의존하는가?','@Test\n@DisplayName(\"[필수] Controller는 UseCase에 의존\")\nvoid controller_MustDependOnUseCase() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..rest..controller..\")\n        .and().haveSimpleNameEndingWith(\"Controller\")\n        .should().dependOnClassesThat().haveSimpleNameEndingWith(\"UseCase\")\n        .allowEmptyShould(true)\n        .because(\"헥사고날 아키텍처: Port-In 의존\");\n    rule.check(restApiClasses);\n}','RestApiControllerArchTest','controller_MustDependOnUseCase','MAJOR','2026-01-24 15:40:23.000000','2026-01-24 15:40:23.000000',NULL),(81,60,'ARCH-API-CTR-003-02','Service 직접 의존 금지','구체 Service를 직접 의존하지 않는가?','@Test\n@DisplayName(\"[금지] Controller에서 Service 직접 의존 금지\")\nvoid controller_MustNotDependOnService() {\n    ArchRule rule = noClasses()\n        .that().resideInAPackage(\"..rest..controller..\")\n        .should().dependOnClassesThat().haveSimpleNameEndingWith(\"Service\")\n        .because(\"UseCase 인터페이스를 통해 의존\");\n    rule.check(restApiClasses);\n}','RestApiControllerArchTest','controller_MustNotDependOnService','MAJOR','2026-01-24 15:40:23.000000','2026-01-24 15:40:23.000000',NULL),(82,60,'ARCH-API-CTR-005','Controller @Transactional 금지','Controller에 @Transactional이 없는가?','@Test\n@DisplayName(\"[금지] Controller에 @Transactional 금지\")\nvoid controller_MustNotHaveTransactional() {\n    ArchRule rule = noClasses()\n        .that().resideInAPackage(\"..rest..controller..\")\n        .should().beAnnotatedWith(\"org.springframework.transaction.annotation.Transactional\")\n        .because(\"트랜잭션 경계는 Application Layer 책임\");\n    rule.check(restApiClasses);\n}','RestApiControllerArchTest','controller_MustNotHaveTransactional','BLOCKER','2026-01-24 15:40:23.000000','2026-01-24 15:40:23.000000',NULL),(83,60,'ARCH-API-CTR-011','List 직접 반환 금지','목록 조회 시 List를 직접 반환하지 않는가?','@Test\n@DisplayName(\"[금지] Controller에서 List 직접 반환 금지\")\nvoid controller_MustNotReturnListDirectly() {\n    ArchRule rule = noMethods()\n        .that().areDeclaredInClassesThat().resideInAPackage(\"..rest..controller..\")\n        .and().arePublic()\n        .should().haveRawReturnType(java.util.List.class)\n        .because(\"ApiResponse<List<T>> 또는 페이징 응답 사용\");\n    rule.check(restApiClasses);\n}','RestApiControllerArchTest','controller_MustNotReturnListDirectly','BLOCKER','2026-01-24 15:40:23.000000','2026-01-24 15:40:23.000000',NULL),(84,62,'ARCH-API-DTO-001','API DTO Record 타입 필수','Request/Response DTO가 Record인가?','@Test\n@DisplayName(\"[필수] API DTO는 Record 타입\")\nvoid apiDto_MustBeRecord() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..rest..dto..\")\n        .and().haveSimpleNameEndingWith(\"ApiRequest\")\n        .or().haveSimpleNameEndingWith(\"ApiResponse\")\n        .should().beRecords()\n        .allowEmptyShould(true)\n        .because(\"API DTO는 불변 Record 사용\");\n    rule.check(restApiClasses);\n}','RestApiDtoArchTest','apiDto_MustBeRecord','MAJOR','2026-01-24 15:40:23.000000','2026-01-24 15:40:23.000000',NULL),(85,62,'ARCH-API-DTO-002','DTO 불변성 보장','DTO가 불변이고 Setter가 없는가?','@Test\n@DisplayName(\"[금지] API DTO에 Setter 금지\")\nvoid apiDto_MustNotHaveSetter() {\n    ArchRule rule = noMethods()\n        .that().areDeclaredInClassesThat().resideInAPackage(\"..rest..dto..\")\n        .and().haveNameMatching(\"set[A-Z].*\")\n        .should().beDeclared()\n        .because(\"DTO는 불변\");\n    rule.check(restApiClasses);\n}','RestApiDtoArchTest','apiDto_MustNotHaveSetter','MAJOR','2026-01-24 15:40:23.000000','2026-01-24 15:40:23.000000',NULL),(86,53,'ARCH-API-MAP-001','Mapper @Component 필수','Mapper에 @Component가 있는가?','@Test\n@DisplayName(\"[필수] Mapper는 @Component 필수\")\nvoid mapper_MustHaveComponent() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..rest..mapper..\")\n        .and().haveSimpleNameEndingWith(\"Mapper\")\n        .should().beAnnotatedWith(\"org.springframework.stereotype.Component\")\n        .allowEmptyShould(true)\n        .because(\"Spring Bean으로 관리\");\n    rule.check(restApiClasses);\n}','RestApiMapperArchTest','mapper_MustHaveComponent','MAJOR','2026-01-24 15:40:23.000000','2026-01-24 15:40:23.000000',NULL),(87,49,'ARCH-API-END-001','Endpoints final class','Endpoints가 final + private 생성자인가?','@Test\n@DisplayName(\"[필수] Endpoints는 final class\")\nvoid endpoints_MustBeFinalClass() {\n    ArchRule rule = classes()\n        .that().haveSimpleNameEndingWith(\"Endpoints\")\n        .should().haveModifier(JavaModifier.FINAL)\n        .allowEmptyShould(true)\n        .because(\"상수 클래스는 final\");\n    rule.check(restApiClasses);\n}','RestApiEndpointsArchTest','endpoints_MustBeFinalClass','MAJOR','2026-01-24 15:40:24.000000','2026-01-24 15:40:24.000000',NULL),(88,60,'ARCH-API-TST-001','MockMvc 금지','테스트에서 MockMvc를 사용하지 않는가?','@Test\n@DisplayName(\"[금지] 테스트에서 MockMvc 금지\")\nvoid test_MustNotUseMockMvc() {\n    ArchRule rule = noClasses()\n        .that().resideInAPackage(\"..rest..\")\n        .should().dependOnClassesThat().haveFullyQualifiedName(\n            \"org.springframework.test.web.servlet.MockMvc\")\n        .because(\"TestRestTemplate 사용 권장\");\n    rule.check(restApiClasses);\n}','RestApiTestArchTest','test_MustNotUseMockMvc','MAJOR','2026-01-24 15:40:24.000000','2026-01-24 15:40:24.000000',NULL);
INSERT INTO `checklist_item` VALUES (1,27,1,'Aggregate에 static forNew(..., Instant now) 팩토리 메서드가 있는가?','AUTOMATED','archunit','DOM-AGG-004-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:32.000000','2026-01-24 09:23:32.000000',NULL),(2,27,2,'forNew()에서 ID는 null(Long) 또는 외부 주입(String)으로 처리되는가?','REVIEW',NULL,'DOM-AGG-004-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:32.000000','2026-01-24 09:23:32.000000',NULL),(3,28,1,'Aggregate에 static reconstitute(...) 팩토리 메서드가 있는가?','AUTOMATED','archunit','DOM-AGG-005-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:32.000000','2026-01-24 09:23:32.000000',NULL),(4,28,2,'reconstitute()에서 비즈니스 검증 없이 객체를 복원하는가?','REVIEW',NULL,'DOM-AGG-005-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:32.000000','2026-01-24 09:23:32.000000',NULL),(5,29,1,'Aggregate에 protected 기본 생성자가 있는가?','REVIEW',NULL,'DOM-AGG-006-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:32.000000','2026-01-24 09:23:32.000000',NULL),(6,30,1,'Aggregate의 ID 필드가 전용 ID VO(예: OrderId)를 사용하는가?','AUTOMATED','archunit','DOM-AGG-007-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:32.000000','2026-01-24 09:23:32.000000',NULL),(7,30,2,'Long 원시 타입 ID를 직접 사용하지 않는가?','AUTOMATED','archunit','DOM-AGG-007-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:32.000000','2026-01-24 09:23:32.000000',NULL),(8,31,1,'Aggregate에 isNew() 메서드가 구현되어 있는가?','AUTOMATED','archunit','DOM-AGG-008-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:32.000000','2026-01-24 09:23:32.000000',NULL),(9,32,1,'시간 필드(createdAt, updatedAt 등)가 java.time.Instant 타입인가?','AUTOMATED','archunit','DOM-AGG-009-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:32.000000','2026-01-24 09:23:32.000000',NULL),(10,32,2,'LocalDateTime, Date, Calendar 등을 사용하지 않는가?','AUTOMATED','archunit','DOM-AGG-009-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:32.000000','2026-01-24 09:23:32.000000',NULL),(11,33,1,'Aggregate 내부에서 Instant.now() 직접 호출이 없는가?','AUTOMATED','archunit','DOM-AGG-010-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:32.000000','2026-01-24 09:23:32.000000',NULL),(12,33,2,'시간이 필요한 메서드는 Instant 파라미터로 받는가?','REVIEW',NULL,'DOM-AGG-010-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:32.000000','2026-01-24 09:23:32.000000',NULL),(13,34,1,'상태 변경 메서드에서 updatedAt을 갱신하는가?','REVIEW',NULL,'DOM-AGG-011-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:32.000000','2026-01-24 09:23:32.000000',NULL),(14,35,1,'public void setXxx() 형태의 Setter 메서드가 없는가?','AUTOMATED','archunit','DOM-AGG-012-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:32.000000','2026-01-24 09:23:32.000000',NULL),(15,35,2,'상태 변경은 비즈니스 의미가 담긴 메서드(cancel, approve 등)를 통하는가?','REVIEW',NULL,'DOM-AGG-012-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:32.000000','2026-01-24 09:23:32.000000',NULL),(16,36,1,'불필요한 Getter가 없고 Tell, Don\'t Ask 원칙을 따르는가?','REVIEW',NULL,'DOM-AGG-013-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:32.000000','2026-01-24 09:23:32.000000',NULL),(17,37,1,'getXxx().getYyy() 형태의 Getter 체이닝이 없는가?','AUTOMATED','archunit','DOM-AGG-014-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:32.000000','2026-01-24 09:23:32.000000',NULL),(18,37,2,'필요한 정보는 Aggregate가 직접 제공하는 메서드를 통해 접근하는가?','REVIEW',NULL,'DOM-AGG-014-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:32.000000','2026-01-24 09:23:32.000000',NULL),(19,38,1,'외부에서 상태를 물어보고 판단하는 대신 Aggregate에게 판단을 위임하는가?','REVIEW',NULL,'DOM-AGG-015-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:32.000000','2026-01-24 09:23:32.000000',NULL),(20,39,1,'복잡한 비즈니스 규칙이 Value Object로 분리되어 있는가?','REVIEW',NULL,'DOM-AGG-016-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:32.000000','2026-01-24 09:23:32.000000',NULL),(21,40,1,'중요한 상태 변경 시 도메인 이벤트를 발행하는가?','REVIEW',NULL,'DOM-AGG-017-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:32.000000','2026-01-24 09:23:32.000000',NULL),(22,40,2,'registerEvent() 메서드를 통해 이벤트를 등록하는가?','REVIEW',NULL,'DOM-AGG-017-02',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:32.000000','2026-01-24 09:23:32.000000',NULL),(23,41,1,'registerEvent() 메서드가 protected로 선언되어 있는가?','AUTOMATED','archunit','DOM-AGG-018-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:32.000000','2026-01-24 09:23:32.000000',NULL),(24,42,1,'pollEvents() 메서드가 public으로 구현되어 있는가?','AUTOMATED','archunit','DOM-AGG-019-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL),(25,42,2,'pollEvents() 호출 후 내부 이벤트 목록이 비워지는가?','REVIEW',NULL,'DOM-AGG-019-02',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL),(26,43,1,'상태 변경 메서드가 동사로 시작하는가? (cancel, approve, update 등)','REVIEW',NULL,'DOM-AGG-020-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL),(27,44,1,'조회 메서드가 get, is, has, can으로 시작하는가?','REVIEW',NULL,'DOM-AGG-021-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL),(28,45,1,'is, has, can으로 시작하는 메서드가 boolean을 반환하는가?','AUTOMATED','archunit','DOM-AGG-022-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL),(29,48,1,'생성 시점과 상태 변경 시점에 불변식을 검증하는가?','REVIEW',NULL,'DOM-AGG-025-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL),(30,49,1,'equals/hashCode가 ID 필드만을 기반으로 구현되어 있는가?','REVIEW',NULL,'DOM-AGG-026-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL),(31,50,1,'id, createdAt 등 불변 필드가 final로 선언되어 있는가?','REVIEW',NULL,'DOM-AGG-027-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL),(32,51,1,'Value Object가 Java Record로 정의되어 있는가?','AUTOMATED','archunit','DOM-VO-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL),(33,51,2,'class 대신 record 키워드를 사용하는가?','AUTOMATED','archunit','DOM-VO-001-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL),(34,52,1,'Value Object에 of() 정적 팩토리 메서드가 있는가?','AUTOMATED','archunit','DOM-VO-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL),(35,53,1,'Record의 Compact Constructor에서 필수 검증을 수행하는가?','REVIEW',NULL,'DOM-VO-003-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL),(36,53,2,'null 체크, 범위 검증 등이 포함되어 있는가?','REVIEW',NULL,'DOM-VO-003-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL),(37,54,1,'Enum 타입의 VO에 displayName() 메서드가 있는가?','AUTOMATED','archunit','DOM-VO-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL),(38,55,1,'분산락이 필요한 VO가 LockKey 인터페이스를 구현하는가?','REVIEW',NULL,'DOM-VO-005-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL),(39,56,1,'캐싱이 필요한 VO가 CacheKey 인터페이스를 구현하는가?','REVIEW',NULL,'DOM-VO-006-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL),(40,60,1,'ID VO가 {Domain}Id 형태로 네이밍되어 있는가? (OrderId, CustomerId)','AUTOMATED','archunit','DOM-ID-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL),(41,61,1,'ID VO가 Java Record로 정의되어 있는가?','AUTOMATED','archunit','DOM-ID-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL),(42,62,1,'ID VO에 of() 정적 팩토리 메서드가 있는가?','AUTOMATED','archunit','DOM-ID-003-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL),(43,63,1,'Long 타입 ID VO에 forNew() 정적 팩토리 메서드가 있는가?','AUTOMATED','archunit','DOM-ID-004-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL),(44,64,1,'forNew()가 value가 null인 ID를 반환하는가?','REVIEW',NULL,'DOM-ID-005-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL),(45,65,1,'Long 타입 ID VO에 isNew() 메서드가 있는가?','AUTOMATED','archunit','DOM-ID-006-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL),(46,66,1,'String 타입 ID VO에 isNew() 메서드가 없는가?','AUTOMATED','archunit','DOM-ID-007-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL),(47,67,1,'String ID가 Application Layer(Factory)에서 생성되어 주입되는가?','REVIEW',NULL,'DOM-ID-008-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL),(48,67,2,'Domain에서 UUID.randomUUID() 호출이 없는가?','AUTOMATED','archunit','DOM-ID-008-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL),(49,70,1,'도메인 이벤트가 DomainEvent 인터페이스를 구현하는가?','AUTOMATED','archunit','DOM-EVT-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL),(50,71,1,'도메인 이벤트가 Java Record로 정의되어 있는가?','AUTOMATED','archunit','DOM-EVT-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL),(51,72,1,'도메인 이벤트에 occurredAt(Instant) 필드가 있는가?','AUTOMATED','archunit','DOM-EVT-003-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL),(52,73,1,'도메인 이벤트에 from(Aggregate, Instant) 정적 팩토리 메서드가 있는가?','AUTOMATED','archunit','DOM-EVT-004-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL),(53,74,1,'도메인 이벤트가 과거형으로 네이밍되어 있는가? (OrderCreatedEvent)','REVIEW',NULL,'DOM-EVT-005-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL),(54,75,1,'도메인 이벤트가 domain.{bc}.event 패키지에 위치하는가?','AUTOMATED','archunit','DOM-EVT-006-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL),(55,81,1,'ErrorCode enum이 ErrorCode 인터페이스를 구현하는가?','AUTOMATED','archunit','DOM-EXC-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL),(56,82,1,'ErrorCode가 domain.{bc}.exception 패키지에 위치하는가?','AUTOMATED','archunit','DOM-EXC-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL),(57,84,1,'Exception에서 Lombok(@Getter 등)을 사용하지 않는가?','AUTOMATED','archunit','DOM-EXC-004-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL),(58,85,1,'ErrorCode에 getCode() 메서드가 있는가?','AUTOMATED','archunit','DOM-EXC-005-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL),(59,85,2,'getCode() 반환 형식이 {DOMAIN}-{NUMBER}인가? (ORD-001)','REVIEW',NULL,'DOM-EXC-005-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL),(60,86,1,'ErrorCode의 getHttpStatus()가 int 타입을 반환하는가?','AUTOMATED','archunit','DOM-EXC-006-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL),(61,86,2,'Spring HttpStatus를 사용하지 않는가?','AUTOMATED','archunit','DOM-EXC-006-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL),(62,87,1,'ErrorCode에 getMessage() 메서드가 있는가?','AUTOMATED','archunit','DOM-EXC-007-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL),(63,89,1,'도메인 예외 클래스가 DomainException을 상속받는가?','AUTOMATED','archunit','DOM-EXC-009-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL),(64,90,1,'도메인 예외가 domain.{bc}.exception 패키지에 위치하는가?','AUTOMATED','archunit','DOM-EXC-010-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL),(65,94,1,'도메인 예외가 public 클래스로 선언되어 있는가?','AUTOMATED','archunit','DOM-EXC-014-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL),(66,95,1,'도메인 예외가 RuntimeException 계층인가?','AUTOMATED','archunit','DOM-EXC-015-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL),(67,95,2,'Checked Exception을 사용하지 않는가?','REVIEW',NULL,'DOM-EXC-015-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL),(68,98,1,'도메인 예외가 비즈니스 의미가 명확한 이름인가? (OrderNotFoundException)','REVIEW',NULL,'DOM-EXC-018-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL),(69,99,1,'DomainException 추상 클래스가 domain.common.exception 패키지에 있는가?','AUTOMATED','archunit','DOM-EXC-019-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL),(70,100,1,'ErrorCode 인터페이스가 domain.common.exception 패키지에 있는가?','AUTOMATED','archunit','DOM-EXC-020-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL),(71,101,1,'Criteria가 domain.{bc}.query.criteria 패키지에 위치하는가?','AUTOMATED','archunit','DOM-CRI-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL),(72,102,1,'Criteria가 {Domain}SliceCriteria 또는 {Domain}SearchCriteria 형태인가?','REVIEW',NULL,'DOM-CRI-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL),(73,103,1,'Criteria가 public으로 선언되어 있는가?','AUTOMATED','archunit','DOM-CRI-003-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL),(74,104,1,'Criteria가 Java Record로 정의되어 있는가?','AUTOMATED','archunit','DOM-CRI-004-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL),(75,105,1,'Criteria에 of() 정적 팩토리 메서드가 있는가?','AUTOMATED','archunit','DOM-CRI-005-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL),(76,110,1,'Criteria에서 JPA/Spring 어노테이션을 사용하지 않는가?','AUTOMATED','archunit','DOM-CRI-010-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL),(77,110,2,'DateRange, CursorQueryContext 등 공통 VO를 활용하는가?','REVIEW',NULL,'DOM-CRI-010-02',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL),(78,111,1,'도메인 객체가 순수 자바 객체(POJO)인가?','AUTOMATED','archunit','DOM-CMN-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL),(79,111,2,'Lombok, JPA, Spring 어노테이션을 사용하지 않는가?','AUTOMATED','archunit','DOM-CMN-001-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL),(80,112,1,'도메인 객체가 Application, Persistence, REST API 레이어를 의존하지 않는가?','AUTOMATED','archunit','DOM-CMN-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL),(81,112,2,'Repository, Port, Service, Controller, Entity, DTO를 import하지 않는가?','AUTOMATED','archunit','DOM-CMN-002-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL),(82,115,1,'Service 클래스에 @Transactional 어노테이션이 없는가?','AUTOMATED','archunit','APP-TRX-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL),(83,116,1,'CommandManager/QueryManager에 @Transactional이 있는가?','AUTOMATED','archunit','APP-TRX-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL),(84,116,2,'QueryManager는 @Transactional(readOnly=true)를 사용하는가?','REVIEW',NULL,'APP-TRX-002-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL),(85,117,1,'ClientManager에 @Transactional 어노테이션이 없는가?','AUTOMATED','archunit','APP-TRX-003-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL),(86,118,1,'CommandFacade에서 DB 원자성 필요 시에만 @Transactional을 사용하는가?','REVIEW',NULL,'APP-TRX-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL),(87,119,1,'QueryFacade에 @Transactional(readOnly=true)가 있는가?','AUTOMATED','archunit','APP-TRX-005-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL),(88,120,1,'Service가 Facade 또는 Manager에 의존하는가?','AUTOMATED','archunit','APP-DEP-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL),(89,120,2,'Manager 2개 이상 조합 시 Facade를 사용하는가?','REVIEW',NULL,'APP-DEP-001-02',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL),(90,121,1,'Facade가 같은 CQRS 범위의 Manager만 의존하는가?','AUTOMATED','archunit','APP-DEP-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL),(91,121,2,'CommandFacade가 CommandManager만 의존하는가?','AUTOMATED','archunit','APP-DEP-002-02',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL),(92,122,1,'CommandFacade에서 QueryManager를 의존하지 않는가?','AUTOMATED','archunit','APP-DEP-003-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL),(93,123,1,'Validator가 자기 도메인의 ReadManager만 의존하는가?','AUTOMATED','archunit','APP-DEP-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL),(94,124,1,'Calculator, Resolver 등이 Manager를 통해 데이터에 접근하는가?','AUTOMATED','archunit','APP-DEP-005-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL),(95,124,2,'Port를 직접 의존하지 않는가?','AUTOMATED','archunit','APP-DEP-005-02',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL),(96,125,1,'Command/Query DTO가 Java Record로 정의되어 있는가?','AUTOMATED','archunit','APP-DTO-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL),(97,125,2,'Lombok(@Data, @Builder 등)을 사용하지 않는가?','AUTOMATED','archunit','APP-DTO-001-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL),(98,126,1,'Command/Query에 인스턴스 메서드가 없는가?','AUTOMATED','archunit','APP-DTO-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL),(99,126,2,'Compact Constructor에 로직이 없는가?','REVIEW',NULL,'APP-DTO-002-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL),(100,127,1,'*SearchParams가 CommonSearchParams를 포함하는가?','REVIEW',NULL,'APP-DTO-003-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL),(101,128,1,'*CursorParams가 CommonCursorParams를 포함하는가?','REVIEW',NULL,'APP-DTO-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL),(102,129,1,'Bundle DTO에 withId() 메서드가 있는가?','REVIEW',NULL,'APP-DTO-005-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL),(103,130,1,'CommandPort에 persist, persistAll 메서드만 있는가?','AUTOMATED','archunit','APP-PRT-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL),(104,130,2,'update 메서드가 없는가? (Dirty Checking 사용)','REVIEW',NULL,'APP-PRT-001-02',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL),(105,131,1,'QueryPort에 findAll() 메서드가 없는가?','AUTOMATED','archunit','APP-PRT-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL),(106,131,2,'전체 데이터 로딩 대신 findBySliceCriteria를 사용하는가?','REVIEW',NULL,'APP-PRT-002-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL),(107,132,1,'QueryPort 메서드가 findById, findBy*, existsBy*, countBy* 패턴을 따르는가?','REVIEW',NULL,'APP-PRT-003-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL),(108,210,1,'Port 파라미터가 원시타입 대신 Domain VO를 사용하는가?','REVIEW',NULL,'APP-PRT-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL),(109,133,1,'Service에 ApplicationEventPublisher가 직접 주입되지 않는가?','AUTOMATED','archunit','APP-EVT-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL),(110,134,1,'도메인 이벤트 발행 시 TransactionEventRegistry를 사용하는가?','REVIEW',NULL,'APP-EVT-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL),(111,135,1,'TimeProvider.now()가 Factory에서만 호출되는가?','AUTOMATED','archunit','APP-TIM-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL),(112,135,2,'Service에서 TimeProvider를 직접 사용하지 않는가?','AUTOMATED','archunit','APP-TIM-001-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL),(113,136,1,'Factory가 복잡한 객체 생성과 TimeProvider 필요 작업에만 사용되는가?','REVIEW',NULL,'APP-FAC-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL),(114,137,1,'Validator의 validate*Exists 메서드가 Domain 객체를 반환하는가?','REVIEW',NULL,'APP-VAL-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL),(115,138,1,'Validator가 도메인 전용 예외(OrderNotFoundException 등)를 발생시키는가?','REVIEW',NULL,'APP-VAL-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL),(116,139,1,'Assembler가 도메인별 구체 Result 클래스(OrderSliceResult)를 반환하는가?','REVIEW',NULL,'APP-ASM-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL),(117,139,2,'제네릭 래퍼(SliceResult<T>)를 사용하지 않는가?','REVIEW',NULL,'APP-ASM-001-02',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL),(118,140,1,'생성(Create) UseCase가 원시타입(Long)만 반환하는가?','REVIEW',NULL,'APP-ASM-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL),(119,141,1,'1 UseCase = 1 Service로 구현되어 있는가?','AUTOMATED','archunit','APP-SVC-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL),(120,142,1,'UseCase 네이밍이 Create*, Update*, Get*, Search* 패턴을 따르는가?','REVIEW',NULL,'APP-SVC-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL),(121,143,1,'범용 예외 클래스(EntityNotFoundException) 대신 도메인 전용 예외를 사용하는가?','REVIEW',NULL,'APP-EXC-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL),(122,144,1,'DomainException을 직접 throw하지 않고 상속 클래스를 사용하는가?','REVIEW',NULL,'APP-EXC-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL),(123,145,1,'EventListener에 @Async가 있는가?','REVIEW',NULL,'APP-LSN-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL),(124,146,1,'EventListener가 Manager에 의존하는가?','AUTOMATED','archunit','APP-LSN-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL),(125,146,2,'Port를 직접 의존하지 않는가?','AUTOMATED','archunit','APP-LSN-002-02',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL),(126,213,1,'커서 기반 조회가 Search{Domain}ByCursorUseCase 네이밍인가?','REVIEW',NULL,'APP-UC-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL),(127,214,1,'Delete 네이밍 대신 Archive/Deactivate/Disable을 사용하는가?','REVIEW',NULL,'APP-UC-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL),(128,215,1,'Factory 메서드에 DTO를 통째로 전달하는가?','REVIEW',NULL,'FAC-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL),(129,215,2,'개별 파라미터로 풀어서 전달하지 않는가?','REVIEW',NULL,'FAC-002-02',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL),(130,216,1,'Factory에서 UpdateContext(id, updateData, changedAt)를 한 번에 생성하는가?','REVIEW',NULL,'FAC-008-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL),(131,147,1,'JpaRepository에서 save, saveAll 메서드만 사용하는가?','AUTOMATED','archunit','PER-REP-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL),(132,148,1,'JpaRepository에 커스텀 쿼리 메서드(@Query, findBy* 등)가 없는가?','AUTOMATED','archunit','PER-REP-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL),(133,149,1,'모든 조회 쿼리가 QueryDslRepository에서 구현되어 있는가?','AUTOMATED','archunit','PER-REP-003-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL),(134,149,2,'JPQL, Native Query를 사용하지 않는가?','REVIEW',NULL,'PER-REP-003-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL),(135,150,1,'CommandAdapter가 JpaRepository만 의존하는가?','AUTOMATED','archunit','PER-ADP-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL),(136,150,2,'QueryDslRepository를 주입받지 않는가?','AUTOMATED','archunit','PER-ADP-001-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL),(137,151,1,'QueryAdapter가 QueryDslRepository만 의존하는가?','AUTOMATED','archunit','PER-ADP-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL),(138,151,2,'JpaRepository를 주입받지 않는가?','AUTOMATED','archunit','PER-ADP-002-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL),(139,152,1,'@OneToMany, @ManyToOne, @OneToOne, @ManyToMany 어노테이션이 없는가?','AUTOMATED','archunit','PER-ENT-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL),(140,152,2,'FK는 Long 타입으로 관리하는가?','REVIEW',NULL,'PER-ENT-001-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL),(141,153,1,'JpaEntity가 BaseAuditEntity 또는 SoftDeletableEntity를 상속하는가?','AUTOMATED','archunit','PER-ENT-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL),(142,154,1,'spring.jpa.open-in-view=false 설정이 있는가?','MANUAL',NULL,'PER-CFG-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL),(143,155,1,'spring.jpa.hibernate.ddl-auto=validate 설정이 있는가?','MANUAL',NULL,'PER-CFG-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL),(144,155,2,'create, update, create-drop을 사용하지 않는가?','MANUAL',NULL,'PER-CFG-002-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL),(145,156,1,'QueryDslRepository의 where절 조건이 ConditionBuilder로 분리되어 있는가?','REVIEW',NULL,'PER-CND-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL),(146,157,1,'Soft Delete 테이블 조회 시 deletedAt IS NULL 조건이 있는가?','REVIEW',NULL,'PER-CND-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL),(147,158,1,'EntityMapper에 toDomain(Entity), toEntity(Domain) 양방향 변환 메서드가 있는가?','REVIEW',NULL,'PER-MAP-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL),(148,159,1,'MySQL MATCH AGAINST 사용 시 Hibernate FunctionContributor가 등록되어 있는가?','MANUAL',NULL,'PER-FTS-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL),(149,160,1,'조인, 서브쿼리 등 복잡한 쿼리가 persistence-mysql-admin 모듈에만 있는가?','AUTOMATED','archunit','PER-ADM-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL),(150,160,2,'도메인용 persistence-mysql에서는 단일 테이블 쿼리만 사용하는가?','REVIEW',NULL,'PER-ADM-001-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL),(151,161,1,'persistence-mysql-admin 모듈에서 조인 사용 시 DTO Projection을 사용하는가?','REVIEW',NULL,'PER-ADM-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL),(152,165,1,'Controller 클래스에 @RestController 어노테이션이 있는가?','AUTOMATED','archunit','API-CTR-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL),(153,166,1,'HTTP DELETE 메서드를 사용하지 않는가?','AUTOMATED','archunit','API-CTR-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL),(154,166,2,'soft delete는 PATCH /{id}/delete로 구현되어 있는가?','REVIEW',NULL,'API-CTR-002-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL),(155,167,1,'Controller가 UseCase(Port-In) 인터페이스에만 의존하는가?','AUTOMATED','archunit','API-CTR-003-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL),(156,167,2,'구체 Service 클래스를 직접 의존하지 않는가?','AUTOMATED','archunit','API-CTR-003-02',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL),(157,168,1,'모든 응답이 ResponseEntity<ApiResponse<T>> 형태로 래핑되어 있는가?','REVIEW',NULL,'API-CTR-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL),(158,169,1,'Controller에 @Transactional 어노테이션이 없는가?','AUTOMATED','archunit','API-CTR-005-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL),(159,170,1,'@Tag, @Operation, @ApiResponses 어노테이션이 있는가?','REVIEW',NULL,'API-CTR-006-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL),(160,171,1,'Controller에 비즈니스 로직이 없고 Mapper에 위임하는가?','REVIEW',NULL,'API-CTR-007-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL),(161,172,1,'경로를 하드코딩하지 않고 *ApiEndpoints 상수 클래스를 사용하는가?','REVIEW',NULL,'API-CTR-008-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL),(162,173,1,'Request DTO 파라미터에 @Valid 어노테이션이 있는가?','REVIEW',NULL,'API-CTR-009-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL),(163,174,1,'Command(CUD)와 Query(R) Controller가 별도 클래스로 분리되어 있는가?','REVIEW',NULL,'API-CTR-010-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL),(164,175,1,'목록 조회 시 List를 직접 반환하지 않는가?','AUTOMATED','archunit','API-CTR-011-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL),(165,175,2,'SliceApiResponse 또는 PageApiResponse를 사용하는가?','REVIEW',NULL,'API-CTR-011-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL),(166,176,1,'URL 경로가 소문자 + 복수형을 사용하는가? (/conventions, /modules)','REVIEW',NULL,'API-CTR-012-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL),(167,211,1,'조회 메서드가 search{Bc}, search{Bc}ByCursor, list{Bc} 패턴을 따르는가?','REVIEW',NULL,'API-CTR-013-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL),(168,177,1,'Request/Response DTO가 Java Record로 정의되어 있는가?','AUTOMATED','archunit','API-DTO-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL),(169,178,1,'DTO가 불변 객체이고 Setter가 없는가?','AUTOMATED','archunit','API-DTO-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL),(170,179,1,'Request DTO에 Jakarta Validation 어노테이션(@NotNull, @NotBlank 등)이 있는가?','REVIEW',NULL,'API-DTO-003-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL),(171,180,1,'Response DTO에 createdAt, updatedAt 필드가 있는가?','REVIEW',NULL,'API-DTO-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL),(172,181,1,'Instant 타입이 DateTimeFormatUtils.formatIso8601()로 String 변환되는가?','REVIEW',NULL,'API-DTO-005-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL),(173,182,1,'복잡한 구조가 중첩 Record로 표현되어 있는가?','REVIEW',NULL,'API-DTO-006-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL),(174,183,1,'OpenAPI 문서화를 위해 @Schema 어노테이션이 있는가?','REVIEW',NULL,'API-DTO-007-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL),(175,184,1,'Optional 대신 @Nullable 또는 기본값을 사용하는가?','REVIEW',NULL,'API-DTO-008-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL),(176,185,1,'List 필드가 생성자에서 List.copyOf()로 방어적 복사되는가?','REVIEW',NULL,'API-DTO-009-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL),(177,212,1,'Request DTO가 Search{Bc}ApiRequest, Search{Bc}CursorApiRequest, List{Bc}ApiRequest 패턴을 따르는가?','REVIEW',NULL,'API-DTO-010-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL),(178,186,1,'Mapper 클래스에 @Component 어노테이션이 있는가?','AUTOMATED','archunit','API-MAP-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL),(179,187,1,'Mapper가 Request→Query/Command, Result→Response 양방향 변환을 지원하는가?','REVIEW',NULL,'API-MAP-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL),(180,188,1,'Mapper에서 DateTimeFormatUtils.formatIso8601()로 날짜를 포맷팅하는가?','REVIEW',NULL,'API-MAP-003-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL),(181,189,1,'Mapper에 SliceResult/PageResult를 SliceApiResponse/PageApiResponse로 변환하는 메서드가 있는가?','REVIEW',NULL,'API-MAP-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL),(182,190,1,'Mapper가 순수 변환 로직만 담당하고 비즈니스 로직이 없는가?','REVIEW',NULL,'API-MAP-005-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL),(183,191,1,'Request에서 null인 필드의 기본값 처리를 Mapper에서 수행하는가?','REVIEW',NULL,'API-MAP-006-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:39.000000','2026-01-24 09:23:39.000000',NULL),(184,192,1,'도메인별 ErrorMapper가 구현되어 있는가?','REVIEW',NULL,'API-ERR-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:39.000000','2026-01-24 09:23:39.000000',NULL),(185,192,2,'ErrorMapper가 supports() + map() 메서드를 구현하는가?','REVIEW',NULL,'API-ERR-001-02',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:39.000000','2026-01-24 09:23:39.000000',NULL),(186,193,1,'에러 응답이 RFC 7807 ProblemDetail 형식을 사용하는가?','REVIEW',NULL,'API-ERR-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:39.000000','2026-01-24 09:23:39.000000',NULL),(187,194,1,'ProblemDetail에 x-error-code 확장 헤더가 있는가?','REVIEW',NULL,'API-ERR-003-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:39.000000','2026-01-24 09:23:39.000000',NULL),(188,195,1,'GlobalExceptionHandler를 통한 전역 예외 처리가 있는가?','REVIEW',NULL,'API-ERR-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:39.000000','2026-01-24 09:23:39.000000',NULL),(189,196,1,'에러 응답의 Content-Type이 application/problem+json인가?','REVIEW',NULL,'API-ERR-005-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:39.000000','2026-01-24 09:23:39.000000',NULL),(190,197,1,'JacksonConfig에 SNAKE_CASE, JavaTimeModule이 설정되어 있는가?','MANUAL',NULL,'API-CFG-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:39.000000','2026-01-24 09:23:39.000000',NULL),(191,198,1,'OpenApiConfig에 GroupedOpenApi가 설정되어 있는가?','MANUAL',NULL,'API-CFG-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:39.000000','2026-01-24 09:23:39.000000',NULL),(192,199,1,'WebMvcConfig에 CORS, Interceptor, ArgumentResolver가 설정되어 있는가?','MANUAL',NULL,'API-CFG-003-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:39.000000','2026-01-24 09:23:39.000000',NULL),(193,200,1,'server.servlet.context-path가 설정되어 있는가?','MANUAL',NULL,'API-CFG-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:39.000000','2026-01-24 09:23:39.000000',NULL),(194,201,1,'Endpoints 상수 클래스가 final class + private 생성자인가?','AUTOMATED','archunit','API-END-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:39.000000','2026-01-24 09:23:39.000000',NULL),(195,202,1,'모든 경로 상수가 public static final String으로 선언되어 있는가?','REVIEW',NULL,'API-END-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:39.000000','2026-01-24 09:23:39.000000',NULL),(196,203,1,'PathVariable 이름도 상수로 관리되는가?','REVIEW',NULL,'API-END-003-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:39.000000','2026-01-24 09:23:39.000000',NULL),(197,204,1,'각 도메인별로 별도의 *ApiEndpoints 클래스가 있는가?','REVIEW',NULL,'API-END-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:39.000000','2026-01-24 09:23:39.000000',NULL),(198,205,1,'테스트에서 MockMvc를 사용하지 않는가?','AUTOMATED','archunit','API-TST-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:39.000000','2026-01-24 09:23:39.000000',NULL),(199,206,1,'@SpringBootTest(webEnvironment = RANDOM_PORT) + TestRestTemplate을 사용하는가?','REVIEW',NULL,'API-TST-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:39.000000','2026-01-24 09:23:39.000000',NULL),(200,207,1,'ApiResponse<T> 역직렬화 시 ParameterizedTypeReference를 사용하는가?','REVIEW',NULL,'API-TST-003-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:39.000000','2026-01-24 09:23:39.000000',NULL),(201,208,1,'테스트 데이터 생성이 *Fixture 클래스의 static factory 메서드로 제공되는가?','REVIEW',NULL,'API-TST-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:39.000000','2026-01-24 09:23:39.000000',NULL),(202,209,1,'ErrorMapper에 supports() + map() 메서드 단위 테스트가 있는가?','REVIEW',NULL,'API-TST-005-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:39.000000','2026-01-24 09:23:39.000000',NULL),(203,27,1,'Aggregate에 static forNew(..., Instant now) 팩토리 메서드가 있는가?','AUTOMATED','archunit','DOM-AGG-004-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(204,27,2,'forNew()에서 ID는 null(Long) 또는 외부 주입(String)으로 처리되는가?','REVIEW',NULL,'DOM-AGG-004-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(205,28,1,'Aggregate에 static reconstitute(...) 팩토리 메서드가 있는가?','AUTOMATED','archunit','DOM-AGG-005-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(206,28,2,'reconstitute()에서 비즈니스 검증 없이 객체를 복원하는가?','REVIEW',NULL,'DOM-AGG-005-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(207,29,1,'Aggregate에 protected 기본 생성자가 있는가?','REVIEW',NULL,'DOM-AGG-006-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(208,30,1,'Aggregate의 ID 필드가 전용 ID VO(예: OrderId)를 사용하는가?','AUTOMATED','archunit','DOM-AGG-007-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(209,30,2,'Long 원시 타입 ID를 직접 사용하지 않는가?','AUTOMATED','archunit','DOM-AGG-007-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(210,31,1,'Aggregate에 isNew() 메서드가 구현되어 있는가?','AUTOMATED','archunit','DOM-AGG-008-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(211,32,1,'시간 필드(createdAt, updatedAt 등)가 java.time.Instant 타입인가?','AUTOMATED','archunit','DOM-AGG-009-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(212,32,2,'LocalDateTime, Date, Calendar 등을 사용하지 않는가?','AUTOMATED','archunit','DOM-AGG-009-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(213,33,1,'Aggregate 내부에서 Instant.now() 직접 호출이 없는가?','AUTOMATED','archunit','DOM-AGG-010-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(214,33,2,'시간이 필요한 메서드는 Instant 파라미터로 받는가?','REVIEW',NULL,'DOM-AGG-010-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(215,34,1,'상태 변경 메서드에서 updatedAt을 갱신하는가?','REVIEW',NULL,'DOM-AGG-011-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(216,35,1,'public void setXxx() 형태의 Setter 메서드가 없는가?','AUTOMATED','archunit','DOM-AGG-012-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(217,35,2,'상태 변경은 비즈니스 의미가 담긴 메서드(cancel, approve 등)를 통하는가?','REVIEW',NULL,'DOM-AGG-012-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(218,36,1,'불필요한 Getter가 없고 Tell, Don\'t Ask 원칙을 따르는가?','REVIEW',NULL,'DOM-AGG-013-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(219,37,1,'getXxx().getYyy() 형태의 Getter 체이닝이 없는가?','AUTOMATED','archunit','DOM-AGG-014-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(220,37,2,'필요한 정보는 Aggregate가 직접 제공하는 메서드를 통해 접근하는가?','REVIEW',NULL,'DOM-AGG-014-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(221,38,1,'외부에서 상태를 물어보고 판단하는 대신 Aggregate에게 판단을 위임하는가?','REVIEW',NULL,'DOM-AGG-015-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(222,39,1,'복잡한 비즈니스 규칙이 Value Object로 분리되어 있는가?','REVIEW',NULL,'DOM-AGG-016-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(223,40,1,'중요한 상태 변경 시 도메인 이벤트를 발행하는가?','REVIEW',NULL,'DOM-AGG-017-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(224,40,2,'registerEvent() 메서드를 통해 이벤트를 등록하는가?','REVIEW',NULL,'DOM-AGG-017-02',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(225,41,1,'registerEvent() 메서드가 protected로 선언되어 있는가?','AUTOMATED','archunit','DOM-AGG-018-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(226,42,1,'pollEvents() 메서드가 public으로 구현되어 있는가?','AUTOMATED','archunit','DOM-AGG-019-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(227,42,2,'pollEvents() 호출 후 내부 이벤트 목록이 비워지는가?','REVIEW',NULL,'DOM-AGG-019-02',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(228,43,1,'상태 변경 메서드가 동사로 시작하는가? (cancel, approve, update 등)','REVIEW',NULL,'DOM-AGG-020-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(229,44,1,'조회 메서드가 get, is, has, can으로 시작하는가?','REVIEW',NULL,'DOM-AGG-021-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(230,45,1,'is, has, can으로 시작하는 메서드가 boolean을 반환하는가?','AUTOMATED','archunit','DOM-AGG-022-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(231,48,1,'생성 시점과 상태 변경 시점에 불변식을 검증하는가?','REVIEW',NULL,'DOM-AGG-025-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(232,49,1,'equals/hashCode가 ID 필드만을 기반으로 구현되어 있는가?','REVIEW',NULL,'DOM-AGG-026-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(233,50,1,'id, createdAt 등 불변 필드가 final로 선언되어 있는가?','REVIEW',NULL,'DOM-AGG-027-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(234,51,1,'Value Object가 Java Record로 정의되어 있는가?','AUTOMATED','archunit','DOM-VO-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(235,51,2,'class 대신 record 키워드를 사용하는가?','AUTOMATED','archunit','DOM-VO-001-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(236,52,1,'Value Object에 of() 정적 팩토리 메서드가 있는가?','AUTOMATED','archunit','DOM-VO-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(237,53,1,'Record의 Compact Constructor에서 필수 검증을 수행하는가?','REVIEW',NULL,'DOM-VO-003-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(238,53,2,'null 체크, 범위 검증 등이 포함되어 있는가?','REVIEW',NULL,'DOM-VO-003-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(239,54,1,'Enum 타입의 VO에 displayName() 메서드가 있는가?','AUTOMATED','archunit','DOM-VO-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(240,55,1,'분산락이 필요한 VO가 LockKey 인터페이스를 구현하는가?','REVIEW',NULL,'DOM-VO-005-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(241,56,1,'캐싱이 필요한 VO가 CacheKey 인터페이스를 구현하는가?','REVIEW',NULL,'DOM-VO-006-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(242,60,1,'ID VO가 {Domain}Id 형태로 네이밍되어 있는가? (OrderId, CustomerId)','AUTOMATED','archunit','DOM-ID-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(243,61,1,'ID VO가 Java Record로 정의되어 있는가?','AUTOMATED','archunit','DOM-ID-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(244,62,1,'ID VO에 of() 정적 팩토리 메서드가 있는가?','AUTOMATED','archunit','DOM-ID-003-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(245,63,1,'Long 타입 ID VO에 forNew() 정적 팩토리 메서드가 있는가?','AUTOMATED','archunit','DOM-ID-004-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(246,64,1,'forNew()가 value가 null인 ID를 반환하는가?','REVIEW',NULL,'DOM-ID-005-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(247,65,1,'Long 타입 ID VO에 isNew() 메서드가 있는가?','AUTOMATED','archunit','DOM-ID-006-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(248,66,1,'String 타입 ID VO에 isNew() 메서드가 없는가?','AUTOMATED','archunit','DOM-ID-007-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(249,67,1,'String ID가 Application Layer(Factory)에서 생성되어 주입되는가?','REVIEW',NULL,'DOM-ID-008-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(250,67,2,'Domain에서 UUID.randomUUID() 호출이 없는가?','AUTOMATED','archunit','DOM-ID-008-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(251,70,1,'도메인 이벤트가 DomainEvent 인터페이스를 구현하는가?','AUTOMATED','archunit','DOM-EVT-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(252,71,1,'도메인 이벤트가 Java Record로 정의되어 있는가?','AUTOMATED','archunit','DOM-EVT-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(253,72,1,'도메인 이벤트에 occurredAt(Instant) 필드가 있는가?','AUTOMATED','archunit','DOM-EVT-003-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(254,73,1,'도메인 이벤트에 from(Aggregate, Instant) 정적 팩토리 메서드가 있는가?','AUTOMATED','archunit','DOM-EVT-004-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(255,74,1,'도메인 이벤트가 과거형으로 네이밍되어 있는가? (OrderCreatedEvent)','REVIEW',NULL,'DOM-EVT-005-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(256,75,1,'도메인 이벤트가 domain.{bc}.event 패키지에 위치하는가?','AUTOMATED','archunit','DOM-EVT-006-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(257,81,1,'ErrorCode enum이 ErrorCode 인터페이스를 구현하는가?','AUTOMATED','archunit','DOM-EXC-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(258,82,1,'ErrorCode가 domain.{bc}.exception 패키지에 위치하는가?','AUTOMATED','archunit','DOM-EXC-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(259,84,1,'Exception에서 Lombok(@Getter 등)을 사용하지 않는가?','AUTOMATED','archunit','DOM-EXC-004-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(260,85,1,'ErrorCode에 getCode() 메서드가 있는가?','AUTOMATED','archunit','DOM-EXC-005-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL),(261,85,2,'getCode() 반환 형식이 {DOMAIN}-{NUMBER}인가? (ORD-001)','REVIEW',NULL,'DOM-EXC-005-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(262,86,1,'ErrorCode의 getHttpStatus()가 int 타입을 반환하는가?','AUTOMATED','archunit','DOM-EXC-006-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(263,86,2,'Spring HttpStatus를 사용하지 않는가?','AUTOMATED','archunit','DOM-EXC-006-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(264,87,1,'ErrorCode에 getMessage() 메서드가 있는가?','AUTOMATED','archunit','DOM-EXC-007-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(265,89,1,'도메인 예외 클래스가 DomainException을 상속받는가?','AUTOMATED','archunit','DOM-EXC-009-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(266,90,1,'도메인 예외가 domain.{bc}.exception 패키지에 위치하는가?','AUTOMATED','archunit','DOM-EXC-010-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(267,94,1,'도메인 예외가 public 클래스로 선언되어 있는가?','AUTOMATED','archunit','DOM-EXC-014-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(268,95,1,'도메인 예외가 RuntimeException 계층인가?','AUTOMATED','archunit','DOM-EXC-015-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(269,95,2,'Checked Exception을 사용하지 않는가?','REVIEW',NULL,'DOM-EXC-015-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(270,98,1,'도메인 예외가 비즈니스 의미가 명확한 이름인가? (OrderNotFoundException)','REVIEW',NULL,'DOM-EXC-018-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(271,99,1,'DomainException 추상 클래스가 domain.common.exception 패키지에 있는가?','AUTOMATED','archunit','DOM-EXC-019-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(272,100,1,'ErrorCode 인터페이스가 domain.common.exception 패키지에 있는가?','AUTOMATED','archunit','DOM-EXC-020-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(273,101,1,'Criteria가 domain.{bc}.query.criteria 패키지에 위치하는가?','AUTOMATED','archunit','DOM-CRI-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(274,102,1,'Criteria가 {Domain}SliceCriteria 또는 {Domain}SearchCriteria 형태인가?','REVIEW',NULL,'DOM-CRI-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(275,103,1,'Criteria가 public으로 선언되어 있는가?','AUTOMATED','archunit','DOM-CRI-003-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(276,104,1,'Criteria가 Java Record로 정의되어 있는가?','AUTOMATED','archunit','DOM-CRI-004-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(277,105,1,'Criteria에 of() 정적 팩토리 메서드가 있는가?','AUTOMATED','archunit','DOM-CRI-005-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(278,110,1,'Criteria에서 JPA/Spring 어노테이션을 사용하지 않는가?','AUTOMATED','archunit','DOM-CRI-010-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(279,110,2,'DateRange, CursorQueryContext 등 공통 VO를 활용하는가?','REVIEW',NULL,'DOM-CRI-010-02',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(280,111,1,'도메인 객체가 순수 자바 객체(POJO)인가?','AUTOMATED','archunit','DOM-CMN-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(281,111,2,'Lombok, JPA, Spring 어노테이션을 사용하지 않는가?','AUTOMATED','archunit','DOM-CMN-001-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(282,112,1,'도메인 객체가 Application, Persistence, REST API 레이어를 의존하지 않는가?','AUTOMATED','archunit','DOM-CMN-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(283,112,2,'Repository, Port, Service, Controller, Entity, DTO를 import하지 않는가?','AUTOMATED','archunit','DOM-CMN-002-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(284,115,1,'Service 클래스에 @Transactional 어노테이션이 없는가?','AUTOMATED','archunit','APP-TRX-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(285,116,1,'CommandManager/QueryManager에 @Transactional이 있는가?','AUTOMATED','archunit','APP-TRX-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(286,116,2,'QueryManager는 @Transactional(readOnly=true)를 사용하는가?','REVIEW',NULL,'APP-TRX-002-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(287,117,1,'ClientManager에 @Transactional 어노테이션이 없는가?','AUTOMATED','archunit','APP-TRX-003-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(288,118,1,'CommandFacade에서 DB 원자성 필요 시에만 @Transactional을 사용하는가?','REVIEW',NULL,'APP-TRX-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(289,119,1,'QueryFacade에 @Transactional(readOnly=true)가 있는가?','AUTOMATED','archunit','APP-TRX-005-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(290,120,1,'Service가 Facade 또는 Manager에 의존하는가?','AUTOMATED','archunit','APP-DEP-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(291,120,2,'Manager 2개 이상 조합 시 Facade를 사용하는가?','REVIEW',NULL,'APP-DEP-001-02',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(292,121,1,'Facade가 같은 CQRS 범위의 Manager만 의존하는가?','AUTOMATED','archunit','APP-DEP-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(293,121,2,'CommandFacade가 CommandManager만 의존하는가?','AUTOMATED','archunit','APP-DEP-002-02',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(294,122,1,'CommandFacade에서 QueryManager를 의존하지 않는가?','AUTOMATED','archunit','APP-DEP-003-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(295,123,1,'Validator가 자기 도메인의 ReadManager만 의존하는가?','AUTOMATED','archunit','APP-DEP-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(296,124,1,'Calculator, Resolver 등이 Manager를 통해 데이터에 접근하는가?','AUTOMATED','archunit','APP-DEP-005-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(297,124,2,'Port를 직접 의존하지 않는가?','AUTOMATED','archunit','APP-DEP-005-02',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(298,125,1,'Command/Query DTO가 Java Record로 정의되어 있는가?','AUTOMATED','archunit','APP-DTO-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(299,125,2,'Lombok(@Data, @Builder 등)을 사용하지 않는가?','AUTOMATED','archunit','APP-DTO-001-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(300,126,1,'Command/Query에 인스턴스 메서드가 없는가?','AUTOMATED','archunit','APP-DTO-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(301,126,2,'Compact Constructor에 로직이 없는가?','REVIEW',NULL,'APP-DTO-002-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(302,127,1,'*SearchParams가 CommonSearchParams를 포함하는가?','REVIEW',NULL,'APP-DTO-003-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(303,128,1,'*CursorParams가 CommonCursorParams를 포함하는가?','REVIEW',NULL,'APP-DTO-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(304,129,1,'Bundle DTO에 withId() 메서드가 있는가?','REVIEW',NULL,'APP-DTO-005-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(305,130,1,'CommandPort에 persist, persistAll 메서드만 있는가?','AUTOMATED','archunit','APP-PRT-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(306,130,2,'update 메서드가 없는가? (Dirty Checking 사용)','REVIEW',NULL,'APP-PRT-001-02',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(307,131,1,'QueryPort에 findAll() 메서드가 없는가?','AUTOMATED','archunit','APP-PRT-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(308,131,2,'전체 데이터 로딩 대신 findBySliceCriteria를 사용하는가?','REVIEW',NULL,'APP-PRT-002-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(309,132,1,'QueryPort 메서드가 findById, findBy*, existsBy*, countBy* 패턴을 따르는가?','REVIEW',NULL,'APP-PRT-003-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(310,210,1,'Port 파라미터가 원시타입 대신 Domain VO를 사용하는가?','REVIEW',NULL,'APP-PRT-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(311,133,1,'Service에 ApplicationEventPublisher가 직접 주입되지 않는가?','AUTOMATED','archunit','APP-EVT-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(312,134,1,'도메인 이벤트 발행 시 TransactionEventRegistry를 사용하는가?','REVIEW',NULL,'APP-EVT-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(313,135,1,'TimeProvider.now()가 Factory에서만 호출되는가?','AUTOMATED','archunit','APP-TIM-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(314,135,2,'Service에서 TimeProvider를 직접 사용하지 않는가?','AUTOMATED','archunit','APP-TIM-001-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(315,136,1,'Factory가 복잡한 객체 생성과 TimeProvider 필요 작업에만 사용되는가?','REVIEW',NULL,'APP-FAC-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(316,137,1,'Validator의 validate*Exists 메서드가 Domain 객체를 반환하는가?','REVIEW',NULL,'APP-VAL-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(317,138,1,'Validator가 도메인 전용 예외(OrderNotFoundException 등)를 발생시키는가?','REVIEW',NULL,'APP-VAL-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(318,139,1,'Assembler가 도메인별 구체 Result 클래스(OrderSliceResult)를 반환하는가?','REVIEW',NULL,'APP-ASM-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(319,139,2,'제네릭 래퍼(SliceResult<T>)를 사용하지 않는가?','REVIEW',NULL,'APP-ASM-001-02',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(320,140,1,'생성(Create) UseCase가 원시타입(Long)만 반환하는가?','REVIEW',NULL,'APP-ASM-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(321,141,1,'1 UseCase = 1 Service로 구현되어 있는가?','AUTOMATED','archunit','APP-SVC-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(322,142,1,'UseCase 네이밍이 Create*, Update*, Get*, Search* 패턴을 따르는가?','REVIEW',NULL,'APP-SVC-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(323,143,1,'범용 예외 클래스(EntityNotFoundException) 대신 도메인 전용 예외를 사용하는가?','REVIEW',NULL,'APP-EXC-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(324,144,1,'DomainException을 직접 throw하지 않고 상속 클래스를 사용하는가?','REVIEW',NULL,'APP-EXC-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(325,145,1,'EventListener에 @Async가 있는가?','REVIEW',NULL,'APP-LSN-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(326,146,1,'EventListener가 Manager에 의존하는가?','AUTOMATED','archunit','APP-LSN-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(327,146,2,'Port를 직접 의존하지 않는가?','AUTOMATED','archunit','APP-LSN-002-02',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(328,213,1,'커서 기반 조회가 Search{Domain}ByCursorUseCase 네이밍인가?','REVIEW',NULL,'APP-UC-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(329,214,1,'Delete 네이밍 대신 Archive/Deactivate/Disable을 사용하는가?','REVIEW',NULL,'APP-UC-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(330,215,1,'Factory 메서드에 DTO를 통째로 전달하는가?','REVIEW',NULL,'FAC-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(331,215,2,'개별 파라미터로 풀어서 전달하지 않는가?','REVIEW',NULL,'FAC-002-02',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(332,216,1,'Factory에서 UpdateContext(id, updateData, changedAt)를 한 번에 생성하는가?','REVIEW',NULL,'FAC-008-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(333,147,1,'JpaRepository에서 save, saveAll 메서드만 사용하는가?','AUTOMATED','archunit','PER-REP-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(334,148,1,'JpaRepository에 커스텀 쿼리 메서드(@Query, findBy* 등)가 없는가?','AUTOMATED','archunit','PER-REP-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(335,149,1,'모든 조회 쿼리가 QueryDslRepository에서 구현되어 있는가?','AUTOMATED','archunit','PER-REP-003-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(336,149,2,'JPQL, Native Query를 사용하지 않는가?','REVIEW',NULL,'PER-REP-003-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(337,150,1,'CommandAdapter가 JpaRepository만 의존하는가?','AUTOMATED','archunit','PER-ADP-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(338,150,2,'QueryDslRepository를 주입받지 않는가?','AUTOMATED','archunit','PER-ADP-001-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(339,151,1,'QueryAdapter가 QueryDslRepository만 의존하는가?','AUTOMATED','archunit','PER-ADP-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(340,151,2,'JpaRepository를 주입받지 않는가?','AUTOMATED','archunit','PER-ADP-002-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(341,152,1,'@OneToMany, @ManyToOne, @OneToOne, @ManyToMany 어노테이션이 없는가?','AUTOMATED','archunit','PER-ENT-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(342,152,2,'FK는 Long 타입으로 관리하는가?','REVIEW',NULL,'PER-ENT-001-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(343,153,1,'JpaEntity가 BaseAuditEntity 또는 SoftDeletableEntity를 상속하는가?','AUTOMATED','archunit','PER-ENT-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(344,154,1,'spring.jpa.open-in-view=false 설정이 있는가?','MANUAL',NULL,'PER-CFG-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(345,155,1,'spring.jpa.hibernate.ddl-auto=validate 설정이 있는가?','MANUAL',NULL,'PER-CFG-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(346,155,2,'create, update, create-drop을 사용하지 않는가?','MANUAL',NULL,'PER-CFG-002-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(347,156,1,'QueryDslRepository의 where절 조건이 ConditionBuilder로 분리되어 있는가?','REVIEW',NULL,'PER-CND-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(348,157,1,'Soft Delete 테이블 조회 시 deletedAt IS NULL 조건이 있는가?','REVIEW',NULL,'PER-CND-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(349,158,1,'EntityMapper에 toDomain(Entity), toEntity(Domain) 양방향 변환 메서드가 있는가?','REVIEW',NULL,'PER-MAP-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(350,159,1,'MySQL MATCH AGAINST 사용 시 Hibernate FunctionContributor가 등록되어 있는가?','MANUAL',NULL,'PER-FTS-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(351,160,1,'조인, 서브쿼리 등 복잡한 쿼리가 persistence-mysql-admin 모듈에만 있는가?','AUTOMATED','archunit','PER-ADM-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(352,160,2,'도메인용 persistence-mysql에서는 단일 테이블 쿼리만 사용하는가?','REVIEW',NULL,'PER-ADM-001-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(353,161,1,'persistence-mysql-admin 모듈에서 조인 사용 시 DTO Projection을 사용하는가?','REVIEW',NULL,'PER-ADM-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(354,165,1,'Controller 클래스에 @RestController 어노테이션이 있는가?','AUTOMATED','archunit','API-CTR-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(355,166,1,'HTTP DELETE 메서드를 사용하지 않는가?','AUTOMATED','archunit','API-CTR-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(356,166,2,'soft delete는 PATCH /{id}/delete로 구현되어 있는가?','REVIEW',NULL,'API-CTR-002-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(357,167,1,'Controller가 UseCase(Port-In) 인터페이스에만 의존하는가?','AUTOMATED','archunit','API-CTR-003-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(358,167,2,'구체 Service 클래스를 직접 의존하지 않는가?','AUTOMATED','archunit','API-CTR-003-02',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(359,168,1,'모든 응답이 ResponseEntity<ApiResponse<T>> 형태로 래핑되어 있는가?','REVIEW',NULL,'API-CTR-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(360,169,1,'Controller에 @Transactional 어노테이션이 없는가?','AUTOMATED','archunit','API-CTR-005-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(361,170,1,'@Tag, @Operation, @ApiResponses 어노테이션이 있는가?','REVIEW',NULL,'API-CTR-006-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(362,171,1,'Controller에 비즈니스 로직이 없고 Mapper에 위임하는가?','REVIEW',NULL,'API-CTR-007-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(363,172,1,'경로를 하드코딩하지 않고 *ApiEndpoints 상수 클래스를 사용하는가?','REVIEW',NULL,'API-CTR-008-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(364,173,1,'Request DTO 파라미터에 @Valid 어노테이션이 있는가?','REVIEW',NULL,'API-CTR-009-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(365,174,1,'Command(CUD)와 Query(R) Controller가 별도 클래스로 분리되어 있는가?','REVIEW',NULL,'API-CTR-010-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(366,175,1,'목록 조회 시 List를 직접 반환하지 않는가?','AUTOMATED','archunit','API-CTR-011-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(367,175,2,'SliceApiResponse 또는 PageApiResponse를 사용하는가?','REVIEW',NULL,'API-CTR-011-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(368,176,1,'URL 경로가 소문자 + 복수형을 사용하는가? (/conventions, /modules)','REVIEW',NULL,'API-CTR-012-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(369,211,1,'조회 메서드가 search{Bc}, search{Bc}ByCursor, list{Bc} 패턴을 따르는가?','REVIEW',NULL,'API-CTR-013-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(370,177,1,'Request/Response DTO가 Java Record로 정의되어 있는가?','AUTOMATED','archunit','API-DTO-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(371,178,1,'DTO가 불변 객체이고 Setter가 없는가?','AUTOMATED','archunit','API-DTO-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(372,179,1,'Request DTO에 Jakarta Validation 어노테이션(@NotNull, @NotBlank 등)이 있는가?','REVIEW',NULL,'API-DTO-003-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(373,180,1,'Response DTO에 createdAt, updatedAt 필드가 있는가?','REVIEW',NULL,'API-DTO-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(374,181,1,'Instant 타입이 DateTimeFormatUtils.formatIso8601()로 String 변환되는가?','REVIEW',NULL,'API-DTO-005-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(375,182,1,'복잡한 구조가 중첩 Record로 표현되어 있는가?','REVIEW',NULL,'API-DTO-006-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(376,183,1,'OpenAPI 문서화를 위해 @Schema 어노테이션이 있는가?','REVIEW',NULL,'API-DTO-007-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(377,184,1,'Optional 대신 @Nullable 또는 기본값을 사용하는가?','REVIEW',NULL,'API-DTO-008-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(378,185,1,'List 필드가 생성자에서 List.copyOf()로 방어적 복사되는가?','REVIEW',NULL,'API-DTO-009-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(379,212,1,'Request DTO가 Search{Bc}ApiRequest, Search{Bc}CursorApiRequest, List{Bc}ApiRequest 패턴을 따르는가?','REVIEW',NULL,'API-DTO-010-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(380,186,1,'Mapper 클래스에 @Component 어노테이션이 있는가?','AUTOMATED','archunit','API-MAP-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(381,187,1,'Mapper가 Request→Query/Command, Result→Response 양방향 변환을 지원하는가?','REVIEW',NULL,'API-MAP-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(382,188,1,'Mapper에서 DateTimeFormatUtils.formatIso8601()로 날짜를 포맷팅하는가?','REVIEW',NULL,'API-MAP-003-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(383,189,1,'Mapper에 SliceResult/PageResult를 SliceApiResponse/PageApiResponse로 변환하는 메서드가 있는가?','REVIEW',NULL,'API-MAP-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(384,190,1,'Mapper가 순수 변환 로직만 담당하고 비즈니스 로직이 없는가?','REVIEW',NULL,'API-MAP-005-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(385,191,1,'Request에서 null인 필드의 기본값 처리를 Mapper에서 수행하는가?','REVIEW',NULL,'API-MAP-006-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(386,192,1,'도메인별 ErrorMapper가 구현되어 있는가?','REVIEW',NULL,'API-ERR-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(387,192,2,'ErrorMapper가 supports() + map() 메서드를 구현하는가?','REVIEW',NULL,'API-ERR-001-02',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(388,193,1,'에러 응답이 RFC 7807 ProblemDetail 형식을 사용하는가?','REVIEW',NULL,'API-ERR-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(389,194,1,'ProblemDetail에 x-error-code 확장 헤더가 있는가?','REVIEW',NULL,'API-ERR-003-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(390,195,1,'GlobalExceptionHandler를 통한 전역 예외 처리가 있는가?','REVIEW',NULL,'API-ERR-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(391,196,1,'에러 응답의 Content-Type이 application/problem+json인가?','REVIEW',NULL,'API-ERR-005-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(392,197,1,'JacksonConfig에 SNAKE_CASE, JavaTimeModule이 설정되어 있는가?','MANUAL',NULL,'API-CFG-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(393,198,1,'OpenApiConfig에 GroupedOpenApi가 설정되어 있는가?','MANUAL',NULL,'API-CFG-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(394,199,1,'WebMvcConfig에 CORS, Interceptor, ArgumentResolver가 설정되어 있는가?','MANUAL',NULL,'API-CFG-003-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(395,200,1,'server.servlet.context-path가 설정되어 있는가?','MANUAL',NULL,'API-CFG-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(396,201,1,'Endpoints 상수 클래스가 final class + private 생성자인가?','AUTOMATED','archunit','API-END-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(397,202,1,'모든 경로 상수가 public static final String으로 선언되어 있는가?','REVIEW',NULL,'API-END-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(398,203,1,'PathVariable 이름도 상수로 관리되는가?','REVIEW',NULL,'API-END-003-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(399,204,1,'각 도메인별로 별도의 *ApiEndpoints 클래스가 있는가?','REVIEW',NULL,'API-END-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(400,205,1,'테스트에서 MockMvc를 사용하지 않는가?','AUTOMATED','archunit','API-TST-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(401,206,1,'@SpringBootTest(webEnvironment = RANDOM_PORT) + TestRestTemplate을 사용하는가?','REVIEW',NULL,'API-TST-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(402,207,1,'ApiResponse<T> 역직렬화 시 ParameterizedTypeReference를 사용하는가?','REVIEW',NULL,'API-TST-003-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(403,208,1,'테스트 데이터 생성이 *Fixture 클래스의 static factory 메서드로 제공되는가?','REVIEW',NULL,'API-TST-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL),(404,209,1,'ErrorMapper에 supports() + map() 메서드 단위 테스트가 있는가?','REVIEW',NULL,'API-TST-005-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `class_template` VALUES (5,6,9,'/**\n * ErrorCode - 도메인 에러 코드 인터페이스\n *\n * 모든 도메인별 ErrorCode enum은 이 인터페이스를 구현해야 합니다.\n *\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic interface ErrorCode {\n    String getCode();\n    int getHttpStatus();\n    String getMessage();\n}','ErrorCode',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"getCode\", \"getHttpStatus\", \"getMessage\"]','ErrorCode 인터페이스 - 도메인별 예외 코드 정의를 위한 기본 인터페이스','2026-01-20 07:36:31.000000','2026-01-27 11:30:22.000000',NULL),(6,6,6,'/**\n * DomainException - 도메인 예외 기본 클래스\n *\n * 모든 도메인 예외의 부모 클래스입니다.\n * ErrorCode를 통해 구조화된 예외 정보를 제공합니다.\n *\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic class DomainException extends RuntimeException {\n\n    private final ErrorCode errorCode;\n    private final Map<String, Object> args;\n\n    protected DomainException(ErrorCode errorCode) {\n        super(errorCode.getMessage());\n        this.errorCode = errorCode;\n        this.args = Collections.emptyMap();\n    }\n\n    protected DomainException(ErrorCode errorCode, String message) {\n        super(message);\n        this.errorCode = errorCode;\n        this.args = Collections.emptyMap();\n    }\n\n    protected DomainException(ErrorCode errorCode, String message, Map<String, Object> args) {\n        super(message);\n        this.errorCode = errorCode;\n        this.args = args != null ? Map.copyOf(args) : Collections.emptyMap();\n    }\n\n    public ErrorCode getErrorCode() {\n        return errorCode;\n    }\n\n    public Map<String, Object> getArgs() {\n        return args;\n    }\n}','{Domain}Exception',NULL,'[\"lombok.*\"]',NULL,'[\"DomainException\"]','[\"getErrorCode\", \"code\", \"httpStatus\", \"args\"]','DomainException 클래스 - 모든 도메인 예외의 부모 클래스','2026-01-20 07:36:41.000000','2026-01-27 11:29:56.000000',NULL),(7,7,5,'/**\n * DomainEvent - 도메인 이벤트 마커 인터페이스\n *\n * 모든 도메인 이벤트가 구현해야 하는 기본 인터페이스입니다.\n * 이벤트 발생 시각과 이벤트 타입을 제공합니다.\n *\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic interface DomainEvent {\n\n    /**\n     * 이벤트 발생 시각을 반환합니다.\n     *\n     * @return 이벤트가 발생한 시각 (UTC)\n     */\n    Instant occurredAt();\n\n    /**\n     * 이벤트 타입을 반환합니다.\n     *\n     * @return 이벤트 타입 문자열\n     */\n    default String eventType() {\n        return this.getClass().getSimpleName();\n    }\n}','DomainEvent',NULL,'[\"lombok.*\"]','[\"DomainEvent\"]',NULL,'[\"occurredAt\", \"eventType\"]','DomainEvent 인터페이스 - 모든 도메인 이벤트가 구현해야 하는 마커 인터페이스','2026-01-20 07:36:50.000000','2026-01-27 11:30:42.000000',NULL),(8,5,41,'/**\n * CacheKey - Redis 캐시 키 인터페이스\n *\n * <p>캐시 키 값을 제공하는 Value Object가 구현해야 하는 인터페이스입니다.\n * 각 도메인별 캐시 키는 이 인터페이스를 구현한 record로 정의합니다.\n *\n * <p>키 패턴: {@code cache:{domain}:{entity}:{id}}\n *\n * <p>구현 예시:\n * <pre>{@code\n * public record OrderCacheKey(Long orderId) implements CacheKey {\n *     @Override\n *     public String value() {\n *         return String.format(\"cache:order:order:%d\", orderId);\n *     }\n * }\n * }</pre>\n *\n * <p>VO-001: Value Object는 불변이어야 합니다.\n *\n * <p>VO-002: Lombok 사용이 금지됩니다.\n *\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic interface CacheKey {\n\n    /**\n     * 캐시 키 값을 반환합니다.\n     *\n     * <p>키 형식: {@code cache:{domain}:{entity}:{identifier}}\n     *\n     * @return Redis 캐시에서 사용할 키 문자열\n     */\n    String value();\n}','{Domain}CacheKey',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"value\"]',NULL,'2026-01-20 07:10:53.000000','2026-01-20 07:10:53.000000',NULL),(9,5,42,'/**\n * LockKey - 분산 락 키 인터페이스\n *\n * <p>분산 락 키 값을 제공하는 Value Object가 구현해야 하는 인터페이스입니다.\n * 각 도메인별 락 키는 이 인터페이스를 구현한 record로 정의합니다.\n *\n * <p>키 패턴: {@code lock:{domain}:{entity}:{id}}\n *\n * <p>구현 예시:\n * <pre>{@code\n * public record OrderLockKey(Long orderId) implements LockKey {\n *     @Override\n *     public String value() {\n *         return String.format(\"lock:order:order:%d\", orderId);\n *     }\n * }\n * }</pre>\n *\n * <p>VO-001: Value Object는 불변이어야 합니다.\n *\n * <p>VO-002: Lombok 사용이 금지됩니다.\n *\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic interface LockKey {\n\n    /**\n     * 분산 락 키 값을 반환합니다.\n     *\n     * <p>키 형식: {@code lock:{domain}:{entity}:{identifier}}\n     *\n     * @return Redis 분산 락에서 사용할 키 문자열\n     */\n    String value();\n}','{Domain}LockKey',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"value\"]',NULL,'2026-01-20 07:10:53.000000','2026-01-20 07:10:53.000000',NULL),(10,5,43,'/**\n * SortKey - 정렬 키 마커 인터페이스\n *\n * <p>정렬 가능한 필드를 나타내는 enum이 구현해야 하는 마커 인터페이스입니다.\n * 각 BC(Bounded Context)별로 고유한 정렬 키 enum을 정의합니다.\n *\n * <p>구현 예시:\n * <pre>{@code\n * public enum OrderSortKey implements SortKey {\n *     ID(\"id\"),\n *     CREATED_AT(\"createdAt\"),\n *     TOTAL_AMOUNT(\"totalAmount\");\n *\n *     private final String fieldName;\n *\n *     OrderSortKey(String fieldName) {\n *         this.fieldName = fieldName;\n *     }\n *\n *     @Override\n *     public String fieldName() {\n *         return fieldName;\n *     }\n * }\n * }</pre>\n *\n * <p>VO-002: Lombok 사용이 금지됩니다.\n *\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic interface SortKey {\n\n    /**\n     * 정렬에 사용될 실제 필드명을 반환합니다.\n     *\n     * <p>이 값은 QueryDSL이나 JPA에서 정렬 시 사용됩니다.\n     *\n     * @return 엔티티의 실제 필드명\n     */\n    String fieldName();\n\n    /**\n     * 정렬 키의 이름을 반환합니다.\n     *\n     * <p>기본 구현은 enum의 name()을 반환합니다.\n     *\n     * @return 정렬 키 이름 (enum name)\n     */\n    default String name() {\n        return this.toString();\n    }\n}','{Domain}SortKey',NULL,'[\"lombok.*\"]','[\"SortKey\"]',NULL,'[\"fieldName\"]',NULL,'2026-01-20 07:10:53.000000','2026-01-20 07:10:53.000000',NULL),(11,5,44,'/**\n * SortDirection - 정렬 방향 enum\n *\n * <p>정렬 방향(오름차순/내림차순)을 나타내는 공통 enum입니다.\n * 모든 도메인에서 재사용됩니다.\n *\n * <p>사용 예시:\n * <pre>{@code\n * SortDirection direction = SortDirection.fromString(\"desc\");\n * boolean isAsc = direction.isAscending();\n * SortDirection reversed = direction.reverse();\n * }</pre>\n *\n * <p>VO-002: Lombok 사용이 금지됩니다.\n *\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic enum SortDirection {\n\n    /** 오름차순 정렬 */\n    ASC,\n\n    /** 내림차순 정렬 */\n    DESC;\n\n    /**\n     * 기본 정렬 방향을 반환합니다.\n     *\n     * @return DESC (내림차순)\n     */\n    public static SortDirection defaultDirection() {\n        return DESC;\n    }\n\n    /**\n     * 오름차순인지 확인합니다.\n     *\n     * @return 오름차순이면 true\n     */\n    public boolean isAscending() {\n        return this == ASC;\n    }\n\n    /**\n     * 내림차순인지 확인합니다.\n     *\n     * @return 내림차순이면 true\n     */\n    public boolean isDescending() {\n        return this == DESC;\n    }\n\n    /**\n     * 반대 방향을 반환합니다.\n     *\n     * @return ASC면 DESC, DESC면 ASC\n     */\n    public SortDirection reverse() {\n        return this == ASC ? DESC : ASC;\n    }\n\n    /**\n     * 문자열에서 SortDirection을 파싱합니다.\n     *\n     * <p>대소문자를 구분하지 않습니다.\n     *\n     * @param value 파싱할 문자열 (\"asc\", \"ASC\", \"desc\", \"DESC\")\n     * @return 해당하는 SortDirection, null이거나 빈 문자열이면 기본값(DESC)\n     * @throws IllegalArgumentException 유효하지 않은 값인 경우\n     */\n    public static SortDirection fromString(String value) {\n        if (value == null || value.isBlank()) {\n            return defaultDirection();\n        }\n        try {\n            return valueOf(value.toUpperCase());\n        } catch (IllegalArgumentException e) {\n            throw new IllegalArgumentException(\n                    \"Invalid sort direction: \" + value + \". Use ASC or DESC.\");\n        }\n    }\n\n    /**\n     * 표시용 이름을 반환합니다.\n     *\n     * @return \"Ascending\" 또는 \"Descending\"\n     */\n    public String displayName() {\n        return this == ASC ? \"Ascending\" : \"Descending\";\n    }\n}','SortDirection',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"isAscending\", \"isDescending\", \"reverse\", \"fromString\"]',NULL,'2026-01-20 07:10:53.000000','2026-01-20 07:10:53.000000',NULL),(12,5,45,'/**\n * PageRequest - 오프셋 기반 페이지네이션 요청 VO\n *\n * <p>전통적인 오프셋 기반 페이지네이션을 위한 요청 정보를 담는 불변 Value Object입니다.\n *\n * <p>사용 예시:\n * <pre>{@code\n * PageRequest request = PageRequest.of(0, 20);\n * long offset = request.offset();\n * PageRequest next = request.next();\n * }</pre>\n *\n * <p>VO-001: Value Object는 불변이어야 합니다.\n *\n * <p>VO-002: Lombok 사용이 금지됩니다.\n *\n * @param page 0-based 페이지 번호\n * @param size 페이지 당 항목 수\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic record PageRequest(int page, int size) {\n\n    /** 기본 페이지 크기 */\n    public static final int DEFAULT_SIZE = 20;\n\n    /** 최대 페이지 크기 */\n    public static final int MAX_SIZE = 100;\n\n    /**\n     * Compact constructor - 유효성 검증\n     */\n    public PageRequest {\n        if (page < 0) {\n            throw new IllegalArgumentException(\"Page must be non-negative\");\n        }\n        if (size < 1) {\n            throw new IllegalArgumentException(\"Size must be positive\");\n        }\n        if (size > MAX_SIZE) {\n            size = MAX_SIZE;\n        }\n    }\n\n    /**\n     * 페이지 번호와 크기로 PageRequest를 생성합니다.\n     *\n     * @param page 0-based 페이지 번호\n     * @param size 페이지 당 항목 수\n     * @return PageRequest 인스턴스\n     */\n    public static PageRequest of(int page, int size) {\n        return new PageRequest(page, size);\n    }\n\n    /**\n     * 첫 페이지 요청을 생성합니다.\n     *\n     * @param size 페이지 당 항목 수\n     * @return 첫 페이지 PageRequest\n     */\n    public static PageRequest first(int size) {\n        return new PageRequest(0, size);\n    }\n\n    /**\n     * 기본 설정의 첫 페이지 요청을 생성합니다.\n     *\n     * @return 기본 크기의 첫 페이지 PageRequest\n     */\n    public static PageRequest defaultPage() {\n        return new PageRequest(0, DEFAULT_SIZE);\n    }\n\n    /**\n     * SQL OFFSET 값을 계산합니다.\n     *\n     * @return 오프셋 값\n     */\n    public long offset() {\n        return (long) page * size;\n    }\n\n    /**\n     * 다음 페이지 요청을 반환합니다.\n     *\n     * @return 다음 페이지 PageRequest\n     */\n    public PageRequest next() {\n        return new PageRequest(page + 1, size);\n    }\n\n    /**\n     * 이전 페이지 요청을 반환합니다.\n     *\n     * @return 이전 페이지 PageRequest, 첫 페이지면 자기 자신\n     */\n    public PageRequest previous() {\n        return page == 0 ? this : new PageRequest(page - 1, size);\n    }\n\n    /**\n     * 첫 페이지인지 확인합니다.\n     *\n     * @return 첫 페이지면 true\n     */\n    public boolean isFirst() {\n        return page == 0;\n    }\n\n    /**\n     * 전체 페이지 수를 계산합니다.\n     *\n     * @param totalElements 전체 항목 수\n     * @return 전체 페이지 수\n     */\n    public int totalPages(long totalElements) {\n        return (int) Math.ceil((double) totalElements / size);\n    }\n\n    /**\n     * 마지막 페이지인지 확인합니다.\n     *\n     * @param totalElements 전체 항목 수\n     * @return 마지막 페이지면 true\n     */\n    public boolean isLast(long totalElements) {\n        return page >= totalPages(totalElements) - 1;\n    }\n}','PageRequest',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"of\", \"first\", \"offset\", \"next\", \"previous\", \"isFirst\"]',NULL,'2026-01-20 07:10:53.000000','2026-01-20 07:10:53.000000',NULL),(13,5,46,'/**\n * PageMeta - 오프셋 기반 페이지네이션 메타데이터 VO\n *\n * <p>페이지네이션 결과의 메타 정보를 담는 불변 Value Object입니다.\n *\n * <p>사용 예시:\n * <pre>{@code\n * PageMeta meta = PageMeta.of(0, 20, 150);\n * boolean hasNext = meta.hasNext();\n * int totalPages = meta.totalPages();\n * }</pre>\n *\n * <p>VO-001: Value Object는 불변이어야 합니다.\n *\n * <p>VO-002: Lombok 사용이 금지됩니다.\n *\n * @param page 현재 페이지 번호 (0-based)\n * @param size 페이지 당 항목 수\n * @param totalElements 전체 항목 수\n * @param totalPages 전체 페이지 수\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic record PageMeta(int page, int size, long totalElements, int totalPages) {\n\n    /**\n     * Compact constructor - 유효성 검증\n     */\n    public PageMeta {\n        if (page < 0) {\n            throw new IllegalArgumentException(\"Page must be non-negative\");\n        }\n        if (size < 1) {\n            throw new IllegalArgumentException(\"Size must be positive\");\n        }\n        if (totalElements < 0) {\n            throw new IllegalArgumentException(\"Total elements must be non-negative\");\n        }\n        if (totalPages < 0) {\n            throw new IllegalArgumentException(\"Total pages must be non-negative\");\n        }\n    }\n\n    /**\n     * 페이지 정보로 PageMeta를 생성합니다.\n     *\n     * <p>totalPages는 자동으로 계산됩니다.\n     *\n     * @param page 현재 페이지 번호\n     * @param size 페이지 당 항목 수\n     * @param totalElements 전체 항목 수\n     * @return PageMeta 인스턴스\n     */\n    public static PageMeta of(int page, int size, long totalElements) {\n        int totalPages = size == 0 ? 0 : (int) Math.ceil((double) totalElements / size);\n        return new PageMeta(page, size, totalElements, totalPages);\n    }\n\n    /**\n     * 빈 결과를 위한 PageMeta를 생성합니다.\n     *\n     * @param size 요청된 페이지 크기\n     * @return 빈 PageMeta\n     */\n    public static PageMeta empty(int size) {\n        return new PageMeta(0, size, 0, 0);\n    }\n\n    /**\n     * 다음 페이지가 있는지 확인합니다.\n     *\n     * @return 다음 페이지가 있으면 true\n     */\n    public boolean hasNext() {\n        return page < totalPages - 1;\n    }\n\n    /**\n     * 이전 페이지가 있는지 확인합니다.\n     *\n     * @return 이전 페이지가 있으면 true\n     */\n    public boolean hasPrevious() {\n        return page > 0;\n    }\n\n    /**\n     * 첫 페이지인지 확인합니다.\n     *\n     * @return 첫 페이지면 true\n     */\n    public boolean isFirst() {\n        return page == 0;\n    }\n\n    /**\n     * 마지막 페이지인지 확인합니다.\n     *\n     * @return 마지막 페이지면 true\n     */\n    public boolean isLast() {\n        return page >= totalPages - 1;\n    }\n\n    /**\n     * 결과가 비어있는지 확인합니다.\n     *\n     * @return 비어있으면 true\n     */\n    public boolean isEmpty() {\n        return totalElements == 0;\n    }\n\n    /**\n     * 현재 페이지의 시작 항목 번호를 반환합니다 (1-based).\n     *\n     * @return 시작 항목 번호\n     */\n    public long startElement() {\n        return isEmpty() ? 0 : (long) page * size + 1;\n    }\n\n    /**\n     * 현재 페이지의 마지막 항목 번호를 반환합니다 (1-based).\n     *\n     * @return 마지막 항목 번호\n     */\n    public long endElement() {\n        return isEmpty() ? 0 : Math.min((long) (page + 1) * size, totalElements);\n    }\n\n    /**\n     * SQL OFFSET 값을 계산합니다.\n     *\n     * @return 오프셋 값\n     */\n    public long offset() {\n        return (long) page * size;\n    }\n}','PageMeta',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"of\", \"empty\", \"hasNext\", \"hasPrevious\", \"isFirst\", \"isLast\", \"isEmpty\"]',NULL,'2026-01-20 07:10:54.000000','2026-01-20 07:10:54.000000',NULL),(14,5,48,'/**\n * SliceMeta - 커서 기반 페이지네이션 메타데이터 VO\n *\n * <p>무한 스크롤 등 커서 기반 페이지네이션 결과의 메타 정보를 담는 불변 Value Object입니다.\n *\n * <p>사용 예시:\n * <pre>{@code\n * SliceMeta meta = SliceMeta.of(20, true, \"cursor123\", 20);\n * boolean hasNext = meta.hasNext();\n * String nextCursor = meta.cursor();\n * }</pre>\n *\n * <p>VO-001: Value Object는 불변이어야 합니다.\n *\n * <p>VO-002: Lombok 사용이 금지됩니다.\n *\n * @param size 요청된 페이지 크기\n * @param hasNext 다음 페이지 존재 여부\n * @param cursor 다음 페이지를 위한 커서 (nullable)\n * @param count 현재 페이지의 항목 수\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic record SliceMeta(int size, boolean hasNext, String cursor, int count) {\n\n    /**\n     * Compact constructor - 유효성 검증\n     */\n    public SliceMeta {\n        if (size < 1) {\n            throw new IllegalArgumentException(\"Size must be positive\");\n        }\n        if (count < 0) {\n            throw new IllegalArgumentException(\"Count must be non-negative\");\n        }\n    }\n\n    /**\n     * SliceMeta를 생성합니다.\n     *\n     * @param size 요청된 페이지 크기\n     * @param hasNext 다음 페이지 존재 여부\n     * @param cursor 다음 페이지 커서\n     * @param count 현재 페이지 항목 수\n     * @return SliceMeta 인스턴스\n     */\n    public static SliceMeta of(int size, boolean hasNext, String cursor, int count) {\n        return new SliceMeta(size, hasNext, cursor, count);\n    }\n\n    /**\n     * 커서 없이 SliceMeta를 생성합니다.\n     *\n     * @param size 요청된 페이지 크기\n     * @param hasNext 다음 페이지 존재 여부\n     * @param count 현재 페이지 항목 수\n     * @return SliceMeta 인스턴스\n     */\n    public static SliceMeta withCursor(int size, boolean hasNext, int count) {\n        return new SliceMeta(size, hasNext, null, count);\n    }\n\n    /**\n     * 빈 결과를 위한 SliceMeta를 생성합니다.\n     *\n     * @param size 요청된 페이지 크기\n     * @return 빈 SliceMeta\n     */\n    public static SliceMeta empty(int size) {\n        return new SliceMeta(size, false, null, 0);\n    }\n\n    /**\n     * 커서가 있는지 확인합니다.\n     *\n     * @return 커서가 있으면 true\n     */\n    public boolean hasCursor() {\n        return cursor != null && !cursor.isBlank();\n    }\n\n    /**\n     * 마지막 페이지인지 확인합니다.\n     *\n     * @return 마지막 페이지면 true\n     */\n    public boolean isLast() {\n        return !hasNext;\n    }\n\n    /**\n     * 결과가 비어있는지 확인합니다.\n     *\n     * @return 비어있으면 true\n     */\n    public boolean isEmpty() {\n        return count == 0;\n    }\n\n    /**\n     * 커서를 Long으로 파싱합니다.\n     *\n     * @return 파싱된 Long 값, 커서가 없으면 null\n     * @throws NumberFormatException 숫자로 변환 불가능한 경우\n     */\n    public Long cursorAsLong() {\n        return hasCursor() ? Long.valueOf(cursor) : null;\n    }\n\n    /**\n     * 다음 페이지 정보를 위한 SliceMeta를 생성합니다.\n     *\n     * @param newCursor 새 커서\n     * @param newCount 새 항목 수\n     * @param newHasNext 다음 페이지 존재 여부\n     * @return 새 SliceMeta\n     */\n    public SliceMeta next(String newCursor, int newCount, boolean newHasNext) {\n        return new SliceMeta(size, newHasNext, newCursor, newCount);\n    }\n}','SliceMeta',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"of\", \"empty\", \"hasCursor\", \"isLast\", \"isEmpty\"]',NULL,'2026-01-20 07:10:54.000000','2026-01-20 07:10:54.000000',NULL),(15,5,53,'/**\n * DateRange - 날짜 범위 VO\n *\n * <p>시작일과 종료일로 구성된 날짜 범위를 나타내는 불변 Value Object입니다.\n * 조회 조건에서 기간 필터링에 사용됩니다.\n *\n * <p>사용 예시:\n * <pre>{@code\n * DateRange range = DateRange.lastDays(7);\n * DateRange thisMonth = DateRange.thisMonth();\n * boolean contains = range.contains(LocalDate.now());\n * }</pre>\n *\n * <p>VO-001: Value Object는 불변이어야 합니다.\n *\n * <p>VO-002: Lombok 사용이 금지됩니다.\n *\n * @param startDate 시작일 (nullable - null이면 시작 제한 없음)\n * @param endDate 종료일 (nullable - null이면 종료 제한 없음)\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic record DateRange(LocalDate startDate, LocalDate endDate) {\n\n    /**\n     * Compact constructor - 유효성 검증\n     */\n    public DateRange {\n        if (startDate != null && endDate != null && startDate.isAfter(endDate)) {\n            throw new IllegalArgumentException(\"Start date must not be after end date\");\n        }\n    }\n\n    /**\n     * 시작일과 종료일로 DateRange를 생성합니다.\n     *\n     * @param startDate 시작일\n     * @param endDate 종료일\n     * @return DateRange 인스턴스\n     */\n    public static DateRange of(LocalDate startDate, LocalDate endDate) {\n        return new DateRange(startDate, endDate);\n    }\n\n    /**\n     * 최근 N일 범위를 생성합니다.\n     *\n     * @param days 일 수\n     * @return 최근 N일 DateRange\n     */\n    public static DateRange lastDays(int days) {\n        LocalDate today = LocalDate.now();\n        return new DateRange(today.minusDays(days), today);\n    }\n\n    /**\n     * 이번 달 범위를 생성합니다.\n     *\n     * @return 이번 달 DateRange\n     */\n    public static DateRange thisMonth() {\n        LocalDate today = LocalDate.now();\n        return new DateRange(today.withDayOfMonth(1), today);\n    }\n\n    /**\n     * 지난 달 범위를 생성합니다.\n     *\n     * @return 지난 달 DateRange\n     */\n    public static DateRange lastMonth() {\n        LocalDate today = LocalDate.now();\n        LocalDate firstDayLastMonth = today.minusMonths(1).withDayOfMonth(1);\n        LocalDate lastDayLastMonth = today.withDayOfMonth(1).minusDays(1);\n        return new DateRange(firstDayLastMonth, lastDayLastMonth);\n    }\n\n    /**\n     * 종료일만 지정된 범위를 생성합니다.\n     *\n     * @param endDate 종료일\n     * @return 시작 제한 없는 DateRange\n     */\n    public static DateRange until(LocalDate endDate) {\n        return new DateRange(null, endDate);\n    }\n\n    /**\n     * 시작일만 지정된 범위를 생성합니다.\n     *\n     * @param startDate 시작일\n     * @return 종료 제한 없는 DateRange\n     */\n    public static DateRange from(LocalDate startDate) {\n        return new DateRange(startDate, null);\n    }\n\n    /**\n     * 시작일을 Instant로 변환합니다 (00:00:00 UTC).\n     *\n     * @return Instant, startDate가 null이면 null\n     */\n    public Instant startInstant() {\n        return startDate != null ? startDate.atStartOfDay(ZoneOffset.UTC).toInstant() : null;\n    }\n\n    /**\n     * 종료일을 Instant로 변환합니다 (다음날 00:00:00 UTC - exclusive).\n     *\n     * @return Instant, endDate가 null이면 null\n     */\n    public Instant endInstant() {\n        return endDate != null ? endDate.plusDays(1).atStartOfDay(ZoneOffset.UTC).toInstant() : null;\n    }\n\n    /**\n     * 범위가 비어있는지 (둘 다 null인지) 확인합니다.\n     *\n     * @return 비어있으면 true\n     */\n    public boolean isEmpty() {\n        return startDate == null && endDate == null;\n    }\n\n    /**\n     * 특정 날짜가 범위 내에 있는지 확인합니다.\n     *\n     * @param date 확인할 날짜\n     * @return 범위 내에 있으면 true\n     */\n    public boolean contains(LocalDate date) {\n        if (date == null) {\n            return false;\n        }\n        boolean afterStart = startDate == null || !date.isBefore(startDate);\n        boolean beforeEnd = endDate == null || !date.isAfter(endDate);\n        return afterStart && beforeEnd;\n    }\n}','DateRange',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"of\", \"lastDays\", \"thisMonth\", \"isEmpty\", \"contains\"]',NULL,'2026-01-20 07:10:54.000000','2026-01-20 07:10:54.000000',NULL),(16,5,40,'/**\n * DeletionStatus - 소프트 삭제 상태 VO\n *\n * <p>엔티티의 삭제 상태(소프트 삭제)를 나타내는 불변 Value Object입니다.\n *\n * <p>사용 예시:\n * <pre>{@code\n * DeletionStatus active = DeletionStatus.active();\n * DeletionStatus deleted = DeletionStatus.deletedAt(timeProvider.now()); // 또는 외부 주입\n * boolean isDeleted = status.isDeleted();\n * }</pre>\n *\n * <p>VO-001: Value Object는 불변이어야 합니다.\n *\n * <p>VO-002: Lombok 사용이 금지됩니다.\n *\n * @param deleted 삭제 여부\n * @param deletedAt 삭제 시각 (삭제되지 않았으면 null)\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic record DeletionStatus(boolean deleted, Instant deletedAt) {\n\n    /**\n     * Compact constructor - 유효성 검증\n     */\n    public DeletionStatus {\n        if (deleted && deletedAt == null) {\n            throw new IllegalArgumentException(\"Deleted status requires deletedAt timestamp\");\n        }\n        if (!deleted && deletedAt != null) {\n            throw new IllegalArgumentException(\"Active status should not have deletedAt timestamp\");\n        }\n    }\n\n    /**\n     * 활성 상태를 생성합니다.\n     *\n     * @return 활성 DeletionStatus\n     */\n    public static DeletionStatus active() {\n        return new DeletionStatus(false, null);\n    }\n\n    /**\n     * 삭제 상태를 생성합니다.\n     *\n     * @param deletedAt 삭제 시각\n     * @return 삭제된 DeletionStatus\n     */\n    public static DeletionStatus deletedAt(Instant deletedAt) {\n        return new DeletionStatus(true, deletedAt);\n    }\n\n    /**\n     * DB에서 복원할 때 사용합니다.\n     *\n     * @param deleted 삭제 여부\n     * @param deletedAt 삭제 시각\n     * @return DeletionStatus 인스턴스\n     */\n    public static DeletionStatus reconstitute(boolean deleted, Instant deletedAt) {\n        if (!deleted) {\n            return active();\n        }\n        return deletedAt(deletedAt);\n    }\n\n    /**\n     * 삭제되었는지 확인합니다.\n     *\n     * @return 삭제되었으면 true\n     */\n    public boolean isDeleted() {\n        return deleted;\n    }\n\n    /**\n     * 활성 상태인지 확인합니다.\n     *\n     * @return 활성 상태면 true\n     */\n    public boolean isActive() {\n        return !deleted;\n    }\n}','DeletionStatus',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"active\", \"deletedAt\", \"reconstitute\", \"isDeleted\", \"isActive\"]',NULL,'2026-01-20 07:10:54.000000','2026-01-21 14:58:35.000000',NULL),(17,5,49,'/**\n * CursorPageRequest - 제네릭 커서 기반 페이지네이션 요청 VO\n *\n * <p>타입 안전한 커서 기반 페이지네이션을 위한 요청 정보를 담는 불변 Value Object입니다.\n * 커서 타입을 제네릭으로 지정하여 다양한 타입의 커서를 지원합니다.\n *\n * <p>사용 예시:\n * <pre>{@code\n * CursorPageRequest<Long> request = CursorPageRequest.afterId(100L);\n * CursorPageRequest<String> strRequest = CursorPageRequest.ofString(\"cursor123\", 20);\n * boolean isFirst = request.isFirstPage();\n * }</pre>\n *\n * <p>VO-001: Value Object는 불변이어야 합니다.\n *\n * <p>VO-002: Lombok 사용이 금지됩니다.\n *\n * @param <C> 커서 타입\n * @param cursor 현재 커서 값 (nullable - null이면 첫 페이지)\n * @param size 페이지 당 항목 수\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic record CursorPageRequest<C>(C cursor, int size) {\n\n    /** 기본 페이지 크기 */\n    public static final int DEFAULT_SIZE = 20;\n\n    /** 최대 페이지 크기 */\n    public static final int MAX_SIZE = 100;\n\n    /**\n     * Compact constructor - 유효성 검증\n     */\n    public CursorPageRequest {\n        if (size < 1) {\n            throw new IllegalArgumentException(\"Size must be positive\");\n        }\n        if (size > MAX_SIZE) {\n            size = MAX_SIZE;\n        }\n    }\n\n    /**\n     * 커서와 크기로 CursorPageRequest를 생성합니다.\n     *\n     * @param <C> 커서 타입\n     * @param cursor 커서 값\n     * @param size 페이지 크기\n     * @return CursorPageRequest 인스턴스\n     */\n    public static <C> CursorPageRequest<C> of(C cursor, int size) {\n        return new CursorPageRequest<>(cursor, size);\n    }\n\n    /**\n     * 첫 페이지 요청을 생성합니다.\n     *\n     * @param <C> 커서 타입\n     * @param size 페이지 크기\n     * @return 첫 페이지 CursorPageRequest\n     */\n    public static <C> CursorPageRequest<C> first(int size) {\n        return new CursorPageRequest<>(null, size);\n    }\n\n    /**\n     * 기본 설정의 첫 페이지 요청을 생성합니다.\n     *\n     * @param <C> 커서 타입\n     * @return 기본 크기의 첫 페이지 CursorPageRequest\n     */\n    public static <C> CursorPageRequest<C> defaultPage() {\n        return new CursorPageRequest<>(null, DEFAULT_SIZE);\n    }\n\n    /**\n     * Long ID 기반 커서 요청을 생성합니다.\n     *\n     * @param afterId 이 ID 이후 항목 조회\n     * @return Long 커서 CursorPageRequest\n     */\n    public static CursorPageRequest<Long> afterId(Long afterId) {\n        return new CursorPageRequest<>(afterId, DEFAULT_SIZE);\n    }\n\n    /**\n     * String 커서 기반 요청을 생성합니다.\n     *\n     * @param cursor 문자열 커서\n     * @param size 페이지 크기\n     * @return String 커서 CursorPageRequest\n     */\n    public static CursorPageRequest<String> ofString(String cursor, int size) {\n        return new CursorPageRequest<>(cursor, size);\n    }\n\n    /**\n     * 첫 페이지인지 확인합니다.\n     *\n     * @return 커서가 없으면 true\n     */\n    public boolean isFirstPage() {\n        return cursor == null;\n    }\n\n    /**\n     * 커서가 있는지 확인합니다.\n     *\n     * @return 커서가 있으면 true\n     */\n    public boolean hasCursor() {\n        return cursor != null;\n    }\n\n    /**\n     * 다음 페이지 요청을 생성합니다.\n     *\n     * @param nextCursor 다음 커서\n     * @return 다음 페이지 CursorPageRequest\n     */\n    public CursorPageRequest<C> next(C nextCursor) {\n        return new CursorPageRequest<>(nextCursor, size);\n    }\n\n    /**\n     * 실제 조회할 크기를 반환합니다 (hasNext 판단을 위해 +1).\n     *\n     * @return size + 1\n     */\n    public int fetchSize() {\n        return size + 1;\n    }\n}','CursorPageRequest',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"of\", \"first\", \"afterId\", \"isFirstPage\", \"hasCursor\", \"next\", \"fetchSize\"]',NULL,'2026-01-20 07:10:54.000000','2026-01-20 07:10:54.000000',NULL),(18,5,52,'/**\n * QueryContext - 제네릭 조회 컨텍스트 VO\n *\n * <p>정렬 + 페이지네이션 정보를 결합한 조회 컨텍스트를 나타내는 불변 Value Object입니다.\n * SortKey 타입을 제네릭으로 지정하여 도메인별 정렬 키를 지원합니다.\n *\n * <p>사용 예시:\n * <pre>{@code\n * QueryContext<OrderSortKey> context = QueryContext.of(\n *     OrderSortKey.CREATED_AT,\n *     SortDirection.DESC,\n *     PageRequest.of(0, 20)\n * );\n * long offset = context.offset();\n * boolean isAsc = context.isAscending();\n * }</pre>\n *\n * <p>VO-001: Value Object는 불변이어야 합니다.\n *\n * <p>VO-002: Lombok 사용이 금지됩니다.\n *\n * @param <K> SortKey를 구현하는 정렬 키 타입\n * @param sortKey 정렬 키\n * @param sortDirection 정렬 방향\n * @param pageRequest 페이지 요청\n * @param includeDeleted 삭제된 항목 포함 여부\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic record QueryContext<K extends SortKey>(\n        K sortKey,\n        SortDirection sortDirection,\n        PageRequest pageRequest,\n        boolean includeDeleted) {\n\n    /**\n     * Compact constructor - 유효성 검증\n     */\n    public QueryContext {\n        if (sortKey == null) {\n            throw new IllegalArgumentException(\"SortKey must not be null\");\n        }\n        if (sortDirection == null) {\n            sortDirection = SortDirection.defaultDirection();\n        }\n        if (pageRequest == null) {\n            pageRequest = PageRequest.defaultPage();\n        }\n    }\n\n    /**\n     * 모든 파라미터로 QueryContext를 생성합니다.\n     *\n     * @param <K> 정렬 키 타입\n     * @param sortKey 정렬 키\n     * @param sortDirection 정렬 방향\n     * @param pageRequest 페이지 요청\n     * @param includeDeleted 삭제 항목 포함 여부\n     * @return QueryContext 인스턴스\n     */\n    public static <K extends SortKey> QueryContext<K> of(\n            K sortKey, SortDirection sortDirection, PageRequest pageRequest, boolean includeDeleted) {\n        return new QueryContext<>(sortKey, sortDirection, pageRequest, includeDeleted);\n    }\n\n    /**\n     * 기본 설정으로 QueryContext를 생성합니다.\n     *\n     * @param <K> 정렬 키 타입\n     * @param sortKey 정렬 키\n     * @param sortDirection 정렬 방향\n     * @param pageRequest 페이지 요청\n     * @return 삭제 항목 미포함 QueryContext\n     */\n    public static <K extends SortKey> QueryContext<K> of(\n            K sortKey, SortDirection sortDirection, PageRequest pageRequest) {\n        return new QueryContext<>(sortKey, sortDirection, pageRequest, false);\n    }\n\n    /**\n     * 기본 정렬 방향과 첫 페이지로 QueryContext를 생성합니다.\n     *\n     * @param <K> 정렬 키 타입\n     * @param sortKey 정렬 키\n     * @return 기본 설정 QueryContext\n     */\n    public static <K extends SortKey> QueryContext<K> defaultOf(K sortKey) {\n        return new QueryContext<>(sortKey, SortDirection.defaultDirection(), PageRequest.defaultPage(), false);\n    }\n\n    /**\n     * 첫 페이지 QueryContext를 생성합니다.\n     *\n     * @param <K> 정렬 키 타입\n     * @param sortKey 정렬 키\n     * @param sortDirection 정렬 방향\n     * @param size 페이지 크기\n     * @return 첫 페이지 QueryContext\n     */\n    public static <K extends SortKey> QueryContext<K> firstPage(\n            K sortKey, SortDirection sortDirection, int size) {\n        return new QueryContext<>(sortKey, sortDirection, PageRequest.first(size), false);\n    }\n\n    /**\n     * 다음 페이지 QueryContext를 반환합니다.\n     *\n     * @return 다음 페이지 QueryContext\n     */\n    public QueryContext<K> nextPage() {\n        return new QueryContext<>(sortKey, sortDirection, pageRequest.next(), includeDeleted);\n    }\n\n    /**\n     * 이전 페이지 QueryContext를 반환합니다.\n     *\n     * @return 이전 페이지 QueryContext\n     */\n    public QueryContext<K> previousPage() {\n        return new QueryContext<>(sortKey, sortDirection, pageRequest.previous(), includeDeleted);\n    }\n\n    /**\n     * 정렬 방향을 반전한 QueryContext를 반환합니다.\n     *\n     * @return 정렬 방향 반전 QueryContext\n     */\n    public QueryContext<K> reverseSortDirection() {\n        return new QueryContext<>(sortKey, sortDirection.reverse(), pageRequest, includeDeleted);\n    }\n\n    /**\n     * 정렬 키를 변경한 QueryContext를 반환합니다.\n     *\n     * @param newSortKey 새 정렬 키\n     * @return 정렬 키 변경 QueryContext\n     */\n    public QueryContext<K> withSortKey(K newSortKey) {\n        return new QueryContext<>(newSortKey, sortDirection, pageRequest, includeDeleted);\n    }\n\n    /**\n     * 페이지 크기를 변경한 QueryContext를 반환합니다.\n     *\n     * @param newSize 새 페이지 크기\n     * @return 페이지 크기 변경 QueryContext\n     */\n    public QueryContext<K> withPageSize(int newSize) {\n        return new QueryContext<>(sortKey, sortDirection, PageRequest.of(pageRequest.page(), newSize), includeDeleted);\n    }\n\n    /**\n     * 삭제 항목 포함 여부를 변경한 QueryContext를 반환합니다.\n     *\n     * @param include 삭제 항목 포함 여부\n     * @return 삭제 항목 포함 여부 변경 QueryContext\n     */\n    public QueryContext<K> withIncludeDeleted(boolean include) {\n        return new QueryContext<>(sortKey, sortDirection, pageRequest, include);\n    }\n\n    /**\n     * SQL OFFSET 값을 반환합니다.\n     *\n     * @return 오프셋 값\n     */\n    public long offset() {\n        return pageRequest.offset();\n    }\n\n    /**\n     * 페이지 크기를 반환합니다.\n     *\n     * @return 페이지 크기\n     */\n    public int size() {\n        return pageRequest.size();\n    }\n\n    /**\n     * 현재 페이지 번호를 반환합니다.\n     *\n     * @return 페이지 번호\n     */\n    public int page() {\n        return pageRequest.page();\n    }\n\n    /**\n     * 첫 페이지인지 확인합니다.\n     *\n     * @return 첫 페이지면 true\n     */\n    public boolean isFirstPage() {\n        return pageRequest.isFirst();\n    }\n\n    /**\n     * 오름차순인지 확인합니다.\n     *\n     * @return 오름차순이면 true\n     */\n    public boolean isAscending() {\n        return sortDirection.isAscending();\n    }\n}','{Domain}QueryContext',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"of\", \"defaultOf\", \"firstPage\", \"nextPage\", \"previousPage\", \"offset\", \"size\", \"page\", \"isFirstPage\", \"isAscending\"]',NULL,'2026-01-20 07:10:54.000000','2026-01-20 07:10:54.000000',NULL),(19,5,51,'/**\n * CursorQueryContext - 커서 기반 조회 컨텍스트 VO\n *\n * <p>정렬 + 커서 페이지네이션 정보를 결합한 조회 컨텍스트를 나타내는 불변 Value Object입니다.\n * SortKey 타입과 Cursor 타입을 제네릭으로 지정하여 도메인별 정렬 키와 커서를 지원합니다.\n *\n * <p>사용 예시:\n * <pre>{@code\n * CursorQueryContext<OrderSortKey, Long> context = CursorQueryContext.of(\n *     OrderSortKey.CREATED_AT,\n *     SortDirection.DESC,\n *     CursorPageRequest.afterId(100L)\n * );\n * boolean isFirst = context.isFirstPage();\n * }</pre>\n *\n * <p>VO-001: Value Object는 불변이어야 합니다.\n *\n * <p>VO-002: Lombok 사용이 금지됩니다.\n *\n * @param <K> SortKey를 구현하는 정렬 키 타입\n * @param <C> 커서 타입\n * @param sortKey 정렬 키\n * @param sortDirection 정렬 방향\n * @param cursorPageRequest 커서 페이지 요청\n * @param includeDeleted 삭제된 항목 포함 여부\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic record CursorQueryContext<K extends SortKey, C>(\n        K sortKey,\n        SortDirection sortDirection,\n        CursorPageRequest<C> cursorPageRequest,\n        boolean includeDeleted) {\n\n    public CursorQueryContext {\n        if (sortKey == null) {\n            throw new IllegalArgumentException(\"SortKey must not be null\");\n        }\n        if (sortDirection == null) {\n            sortDirection = SortDirection.defaultDirection();\n        }\n        if (cursorPageRequest == null) {\n            cursorPageRequest = CursorPageRequest.defaultPage();\n        }\n    }\n\n    public static <K extends SortKey, C> CursorQueryContext<K, C> of(\n            K sortKey, SortDirection sortDirection, CursorPageRequest<C> cursorPageRequest, boolean includeDeleted) {\n        return new CursorQueryContext<>(sortKey, sortDirection, cursorPageRequest, includeDeleted);\n    }\n\n    public static <K extends SortKey, C> CursorQueryContext<K, C> of(\n            K sortKey, SortDirection sortDirection, CursorPageRequest<C> cursorPageRequest) {\n        return new CursorQueryContext<>(sortKey, sortDirection, cursorPageRequest, false);\n    }\n\n    public static <K extends SortKey, C> CursorQueryContext<K, C> defaultOf(K sortKey) {\n        return new CursorQueryContext<>(sortKey, SortDirection.defaultDirection(), CursorPageRequest.defaultPage(), false);\n    }\n\n    public CursorQueryContext<K, C> nextPage(C nextCursor) {\n        return new CursorQueryContext<>(sortKey, sortDirection, cursorPageRequest.next(nextCursor), includeDeleted);\n    }\n\n    public boolean isFirstPage() { return cursorPageRequest.isFirstPage(); }\n    public boolean hasCursor() { return cursorPageRequest.hasCursor(); }\n    public C cursor() { return cursorPageRequest.cursor(); }\n    public int size() { return cursorPageRequest.size(); }\n    public int fetchSize() { return cursorPageRequest.fetchSize(); }\n    public boolean isAscending() { return sortDirection.isAscending(); }\n}','CursorQueryContext',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"sortKey\", \"sortDirection\", \"cursorPageRequest\", \"isFirstPage\", \"hasCursor\", \"cursor\", \"size\"]','CursorQueryContext - 커서 기반 조회 컨텍스트. CursorPageRequest를 포함합니다.','2026-01-20 07:57:44.000000','2026-01-20 07:57:44.000000',NULL),(20,8,47,'/**\n * {Domain}PageCriteria - 페이지 기반 조회 조건 VO\n *\n * <p>페이지 기반 조회를 위한 조건을 담는 불변 Value Object입니다.\n * QueryContext를 필수로 포함하며, 도메인별 필터 조건을 추가합니다.\n *\n * <p>사용 예시:\n * <pre>{@code\n * OrderPageCriteria criteria = OrderPageCriteria.of(\n *     queryContext,\n *     OrderStatus.COMPLETED,\n *     DateRange.lastDays(30)\n * );\n * }</pre>\n *\n * <p>QRY-001: Criteria는 반드시 QueryContext 또는 CursorQueryContext를 포함해야 합니다.\n *\n * <p>QRY-002: 날짜 범위 필터는 반드시 DateRange VO를 사용해야 합니다.\n *\n * <p>VO-001: Value Object는 불변이어야 합니다.\n *\n * <p>VO-002: Lombok 사용이 금지됩니다.\n *\n * @param queryContext 조회 컨텍스트 (정렬 + 페이지네이션)\n * @param status 상태 필터 (선택)\n * @param dateRange 날짜 범위 필터 (선택)\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic record {Domain}PageCriteria<K extends SortKey>(\n        QueryContext<K> queryContext,\n        {Domain}Status status,\n        DateRange dateRange) {\n\n    public {Domain}PageCriteria {\n        if (queryContext == null) {\n            throw new IllegalArgumentException(\"QueryContext must not be null\");\n        }\n    }\n\n    public static <K extends SortKey> {Domain}PageCriteria<K> of(QueryContext<K> queryContext) {\n        return new {Domain}PageCriteria<>(queryContext, null, null);\n    }\n\n    public static <K extends SortKey> {Domain}PageCriteria<K> of(\n            QueryContext<K> queryContext, {Domain}Status status, DateRange dateRange) {\n        return new {Domain}PageCriteria<>(queryContext, status, dateRange);\n    }\n\n    public boolean hasStatusFilter() { return status != null; }\n    public boolean hasDateRangeFilter() { return dateRange != null; }\n\n    public long offset() { return queryContext.offset(); }\n    public int size() { return queryContext.size(); }\n    public int page() { return queryContext.page(); }\n    public boolean isFirstPage() { return queryContext.isFirstPage(); }\n    public boolean isAscending() { return queryContext.isAscending(); }\n}','{Domain}PageCriteria',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"queryContext\"]','PageCriteria 템플릿 - 페이지 기반 조회 조건. QueryContext를 필수로 포함합니다.','2026-01-20 07:57:58.000000','2026-01-20 07:57:58.000000',NULL),(21,8,50,'/**\n * {Domain}CursorCriteria - 커서 기반 조회 조건 VO\n *\n * <p>커서 기반 조회를 위한 조건을 담는 불변 Value Object입니다.\n * CursorQueryContext를 필수로 포함하며, 도메인별 필터 조건을 추가합니다.\n *\n * <p>사용 예시:\n * <pre>{@code\n * OrderCursorCriteria criteria = OrderCursorCriteria.of(\n *     cursorQueryContext,\n *     OrderStatus.PENDING,\n *     DateRange.lastWeek()\n * );\n * }</pre>\n *\n * <p>QRY-001: Criteria는 반드시 QueryContext 또는 CursorQueryContext를 포함해야 합니다.\n *\n * <p>QRY-002: 날짜 범위 필터는 반드시 DateRange VO를 사용해야 합니다.\n *\n * <p>VO-001: Value Object는 불변이어야 합니다.\n *\n * <p>VO-002: Lombok 사용이 금지됩니다.\n *\n * @param cursorQueryContext 커서 조회 컨텍스트 (정렬 + 커서 페이지네이션)\n * @param status 상태 필터 (선택)\n * @param dateRange 날짜 범위 필터 (선택)\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic record {Domain}CursorCriteria<K extends SortKey, C>(\n        CursorQueryContext<K, C> cursorQueryContext,\n        {Domain}Status status,\n        DateRange dateRange) {\n\n    public {Domain}CursorCriteria {\n        if (cursorQueryContext == null) {\n            throw new IllegalArgumentException(\"CursorQueryContext must not be null\");\n        }\n    }\n\n    public static <K extends SortKey, C> {Domain}CursorCriteria<K, C> of(\n            CursorQueryContext<K, C> cursorQueryContext) {\n        return new {Domain}CursorCriteria<>(cursorQueryContext, null, null);\n    }\n\n    public static <K extends SortKey, C> {Domain}CursorCriteria<K, C> of(\n            CursorQueryContext<K, C> cursorQueryContext, {Domain}Status status, DateRange dateRange) {\n        return new {Domain}CursorCriteria<>(cursorQueryContext, status, dateRange);\n    }\n\n    public boolean hasStatusFilter() { return status != null; }\n    public boolean hasDateRangeFilter() { return dateRange != null; }\n\n    public boolean isFirstPage() { return cursorQueryContext.isFirstPage(); }\n    public boolean hasCursor() { return cursorQueryContext.hasCursor(); }\n    public C cursor() { return cursorQueryContext.cursor(); }\n    public int size() { return cursorQueryContext.size(); }\n    public int fetchSize() { return cursorQueryContext.fetchSize(); }\n    public boolean isAscending() { return cursorQueryContext.isAscending(); }\n}','{Domain}CursorCriteria',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"cursorQueryContext\"]','CursorCriteria 템플릿 - 커서 기반 조회 조건. CursorQueryContext를 필수로 포함합니다.','2026-01-20 07:58:09.000000','2026-01-20 07:58:09.000000',NULL),(22,1,2,'/**\n * {Domain} - {Domain} Aggregate Root\n *\n * <p>도메인의 핵심 비즈니스 로직을 캡슐화하는 Aggregate Root입니다.\n *\n * <p><strong>설계 원칙:</strong>\n * <ul>\n *   <li>AGG-001: Lombok 사용 금지 - 모든 필드와 메서드를 명시적으로 작성\n *   <li>AGG-002: 불변성 우선 - 필드는 final, 상태 변경은 새 인스턴스 반환 또는 명시적 메서드\n *   <li>AGG-014: Law of Demeter - 체이닝 금지, convenience 메서드 제공\n *   <li>DOM-AGG-015: Tell, Don\'t Ask - 상태 조회 후 외부 결정 금지, 객체가 스스로 판단\n *   <li>DOM-AGG-016: 팩토리 메서드 필수 - forNew(), of(), reconstitute()\n *   <li>DOM-AGG-017: 생성자 접근 제한 - private/protected, new 직접 호출 금지\n *   <li>DOM-AGG-018: 시간 필드 규칙 - Instant 타입, At 접미사 (createdAt, updatedAt)\n *   <li>DOM-AGG-019: DeletionStatus 필수 - 소프트 삭제 상태 관리\n *   <li>DOM-AGG-020: Aggregate 참조 규칙 - 다른 Aggregate는 ID로만 참조\n *   <li>DOM-AGG-021: 컬렉션 불변 반환 - List.copyOf() 또는 Collections.unmodifiableList()\n *   <li>DOM-AGG-022: 시간 외부 주입 - Instant.now() 금지, 파라미터로 주입\n *   <li>DOM-AGG-023: 이벤트 내부 발행 - 비즈니스 메서드 내에서 이벤트 생성 및 저장\n * </ul>\n *\n * <p><strong>팩토리 메서드:</strong>\n * <ul>\n *   <li>{@link #forNew} - 새 엔티티 생성 (ID 없음, Auto-increment용)\n *   <li>{@link #of} - 기존 엔티티 (ID 있음)\n *   <li>{@link #reconstitute} - 영속성 레이어에서 복원\n * </ul>\n *\n * <p><strong>이벤트 발행:</strong>\n * <ul>\n *   <li>비즈니스 메서드 내에서 이벤트 생성 후 events 컬렉션에 저장\n *   <li>Application 레이어에서 pollEvents()로 이벤트 수집 후 발행\n *   <li>이벤트 생성 시 occurredAt은 비즈니스 메서드 파라미터로 주입받음\n * </ul>\n *\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic class {Domain} {\n\n    private final {Domain}Id id;\n    // 다른 Aggregate 참조 시 ID만 보유 (DOM-AGG-020)\n    // 예: private final OtherAggregateId otherAggregateId;\n    \n    // Value Object 필드들\n    private DeletionStatus deletionStatus;\n    private final Instant createdAt;\n    private Instant updatedAt;\n    \n    // 도메인 이벤트 컬렉션 (DOM-AGG-023)\n    private final List<DomainEvent> events = new ArrayList<>();\n\n    /**\n     * Framework 전용 기본 생성자\n     *\n     * <p>JPA/Hibernate 프록시 생성용으로만 사용됩니다.\n     * 직접 호출하지 마세요.\n     */\n    protected {Domain}() {\n        this.id = null;\n        this.deletionStatus = DeletionStatus.active();\n        this.createdAt = null;\n        this.updatedAt = null;\n    }\n\n    /**\n     * 전체 필드 초기화 생성자 (private)\n     *\n     * <p>팩토리 메서드를 통해서만 인스턴스를 생성합니다.\n     * 외부에서 new 키워드로 직접 호출 불가 (DOM-AGG-017)\n     */\n    private {Domain}(\n            {Domain}Id id,\n            // 다른 필드들...\n            DeletionStatus deletionStatus,\n            Instant createdAt,\n            Instant updatedAt) {\n        this.id = id;\n        this.deletionStatus = deletionStatus;\n        this.createdAt = createdAt;\n        this.updatedAt = updatedAt;\n    }\n\n    /**\n     * 새 {Domain} 생성 (Auto-increment ID용)\n     *\n     * <p>아직 영속화되지 않은 새 엔티티를 생성합니다.\n     * ID는 영속화 시점에 DB에서 할당됩니다.\n     *\n     * <p>시간은 외부에서 주입받습니다 (DOM-AGG-022).\n     * Instant.now() 직접 호출 금지.\n     *\n     * @param occurredAt 생성 시각 (외부 주입)\n     * @param ... 생성에 필요한 파라미터들\n     * @return 새 {Domain} 인스턴스\n     */\n    public static {Domain} forNew(\n            /* 필요한 파라미터들, */\n            Instant occurredAt) {\n        return new {Domain}(\n                {Domain}Id.forNew(),\n                // 다른 필드들...\n                DeletionStatus.active(),\n                occurredAt,\n                occurredAt);\n    }\n\n    /**\n     * 기존 {Domain} 조회/복원\n     *\n     * <p>이미 영속화된 엔티티를 ID로 참조할 때 사용합니다.\n     *\n     * @param id 기존 엔티티 ID\n     * @param occurredAt 생성/수정 시각 (외부 주입)\n     * @param ... 다른 필드들\n     * @return {Domain} 인스턴스\n     */\n    public static {Domain} of(\n            {Domain}Id id,\n            /* 다른 필드들, */\n            Instant occurredAt) {\n        return new {Domain}(\n                id,\n                // 다른 필드들...\n                DeletionStatus.active(),\n                occurredAt,\n                occurredAt);\n    }\n\n    /**\n     * 영속성 레이어에서 {Domain} 복원\n     *\n     * <p>JPA Entity → Domain Aggregate 변환 시 사용합니다.\n     * 모든 필드를 그대로 복원합니다.\n     *\n     * @param ... 모든 필드\n     * @return 복원된 {Domain} 인스턴스\n     */\n    public static {Domain} reconstitute(\n            {Domain}Id id,\n            // 모든 필드들...\n            DeletionStatus deletionStatus,\n            Instant createdAt,\n            Instant updatedAt) {\n        return new {Domain}(\n                id,\n                // 모든 필드들...\n                deletionStatus,\n                createdAt,\n                updatedAt);\n    }\n\n    // ==========================================\n    // Convenience 메서드 (Law of Demeter 준수)\n    // ==========================================\n\n    /**\n     * ID 값 반환 (Law of Demeter 준수)\n     *\n     * @return ID의 Long 값\n     */\n    public Long idValue() {\n        return id != null ? id.value() : null;\n    }\n\n    /**\n     * 새 엔티티인지 확인\n     *\n     * @return ID가 없으면 true\n     */\n    public boolean isNew() {\n        return id == null || id.isNew();\n    }\n\n    /**\n     * 삭제되었는지 확인 (Tell, Don\'t Ask - DOM-AGG-015)\n     *\n     * <p>외부에서 deletionStatus().isDeleted() 체이닝 금지.\n     * Aggregate가 직접 판단하여 결과 반환.\n     *\n     * @return 삭제 상태이면 true\n     */\n    public boolean isDeleted() {\n        return deletionStatus.isDeleted();\n    }\n\n    // ==========================================\n    // 비즈니스 메서드 (Tell, Don\'t Ask + 이벤트 발행)\n    // ==========================================\n\n    /**\n     * 엔티티 업데이트\n     *\n     * <p>비즈니스 규칙을 검증하고 상태를 변경합니다.\n     * 시간은 외부에서 주입받습니다 (DOM-AGG-022).\n     *\n     * @param updateData 업데이트 데이터\n     * @param occurredAt 업데이트 시각 (외부 주입)\n     */\n    public void update({Domain}UpdateData updateData, Instant occurredAt) {\n        // 비즈니스 규칙 검증\n        // 필드 업데이트\n        this.updatedAt = occurredAt;\n        \n        // 이벤트 발행이 필요한 경우 (DOM-AGG-023)\n        // events.add(new {Domain}UpdatedEvent(this.id, ..., occurredAt));\n    }\n\n    /**\n     * 소프트 삭제\n     *\n     * <p>물리적 삭제 대신 삭제 상태로 표시합니다.\n     * DeletionStatus의 팩토리 메서드를 사용합니다.\n     *\n     * @param occurredAt 삭제 시각 (외부 주입)\n     */\n    public void delete(Instant occurredAt) {\n        this.deletionStatus = DeletionStatus.deletedAt(occurredAt);\n        this.updatedAt = occurredAt;\n        \n        // 이벤트 발행이 필요한 경우 (DOM-AGG-023)\n        // events.add(new {Domain}DeletedEvent(this.id, occurredAt));\n    }\n\n    /**\n     * 비즈니스 액션 예시 (이벤트 발행 포함)\n     *\n     * <p>비즈니스 로직 수행 후 도메인 이벤트를 생성하여 저장합니다.\n     * Application 레이어에서 pollEvents()로 수집 후 발행합니다.\n     *\n     * @param ... 비즈니스 로직에 필요한 파라미터\n     * @param occurredAt 이벤트 발생 시각 (외부 주입)\n     */\n    public void complete(/* 필요한 파라미터, */ Instant occurredAt) {\n        // 비즈니스 규칙 검증\n        // if (!canComplete()) {\n        //     throw new DomainException({Domain}ErrorCode.CANNOT_COMPLETE, ...);\n        // }\n        \n        // 상태 변경\n        // this.status = {Domain}Status.COMPLETED;\n        this.updatedAt = occurredAt;\n        \n        // 도메인 이벤트 생성 및 저장 (DOM-AGG-023)\n        // 이벤트는 비즈니스 메서드 내부에서 생성\n        events.add(new {Domain}CompletedEvent(\n                this.id,\n                // 이벤트에 필요한 데이터...\n                occurredAt));\n    }\n\n    // ==========================================\n    // 도메인 이벤트 관리 (DOM-AGG-023)\n    // ==========================================\n\n    /**\n     * 발행 대기 중인 도메인 이벤트 수집 및 초기화\n     *\n     * <p>Application 레이어에서 호출하여 이벤트를 수집합니다.\n     * 호출 후 내부 이벤트 목록은 초기화됩니다.\n     *\n     * @return 발행 대기 중인 이벤트 목록 (불변)\n     */\n    public List<DomainEvent> pollEvents() {\n        List<DomainEvent> polledEvents = List.copyOf(events);\n        events.clear();\n        return polledEvents;\n    }\n\n    /**\n     * 발행 대기 중인 이벤트가 있는지 확인\n     *\n     * @return 이벤트가 있으면 true\n     */\n    public boolean hasEvents() {\n        return !events.isEmpty();\n    }\n\n    // ==========================================\n    // Getter (필요한 경우에만)\n    // ==========================================\n\n    public {Domain}Id id() {\n        return id;\n    }\n\n    public DeletionStatus deletionStatus() {\n        return deletionStatus;\n    }\n\n    public Instant createdAt() {\n        return createdAt;\n    }\n\n    public Instant updatedAt() {\n        return updatedAt;\n    }\n}','{Domain}',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"forNew\", \"of\", \"reconstitute\", \"isNew\", \"assignId\", \"update\", \"delete\", \"restore\", \"isDeleted\", \"idValue\"]','Aggregate Root 클래스 - 도메인의 핵심 비즈니스 로직을 캡슐화하는 루트 엔티티. forNew/of/reconstitute 팩토리 메서드 필수.','2026-01-20 08:29:58.000000','2026-01-27 11:27:50.000000',NULL),(23,1,39,'/**\n * {Domain}UpdateData - {Domain} 업데이트 데이터\n *\n * <p>Aggregate Root의 update() 메서드에 전달되는 불변 데이터 객체입니다.\n *\n * <p><strong>설계 원칙:</strong>\n * <ul>\n *   <li>Record로 정의하여 불변성 보장\n *   <li>Compact Constructor에서 필수 필드 검증\n *   <li>null 허용 필드는 Optional 대신 nullable로 표현\n * </ul>\n *\n * <p><strong>사용 예시:</strong>\n * <pre>{@code\n * {Domain}UpdateData updateData = new {Domain}UpdateData(\n *     newName,\n *     newDescription\n * );\n * aggregate.update(updateData);\n * }</pre>\n *\n * @param ... 업데이트할 필드들\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic record {Domain}UpdateData(\n        // 업데이트 가능한 필드들 (Value Object 타입 사용)\n        // 예: {Domain}Name name,\n        // 예: {Domain}Description description\n) {\n\n    /**\n     * Compact Constructor - 필수 필드 검증\n     */\n    public {Domain}UpdateData {\n        // 필수 필드 검증\n        // if (name == null) {\n        //     throw new IllegalArgumentException(\"name must not be null\");\n        // }\n    }\n}','{Domain}UpdateData',NULL,'[\"lombok.*\"]',NULL,NULL,NULL,'UpdateData Record - Aggregate Root update() 메서드에 전달되는 불변 데이터 객체. Compact Constructor에서 검증 수행.','2026-01-20 08:29:59.000000','2026-01-20 08:29:59.000000',NULL),(24,2,3,'/**\n * {ValueObject} - {Description} Value Object\n *\n * <p>불변 값 객체로, 동등성은 값으로 판단합니다.\n *\n * <p><strong>설계 원칙:</strong>\n * <ul>\n *   <li>Record로 정의하여 불변성과 equals/hashCode 자동 생성\n *   <li>Compact Constructor에서 유효성 검증 수행\n *   <li>정적 팩토리 메서드 of() 제공\n *   <li>Lombok 사용 금지\n * </ul>\n *\n * <p><strong>사용 예시:</strong>\n * <pre>{@code\n * {ValueObject} vo = {ValueObject}.of(\"value\");\n * String value = vo.value();\n * }</pre>\n *\n * @param value 값\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic record {ValueObject}(String value) {\n\n    /**\n     * 최대 길이 상수 (필요한 경우)\n     */\n    private static final int MAX_LENGTH = 100;\n\n    /**\n     * Compact Constructor - 유효성 검증\n     *\n     * <p>null, 빈 값, 최대 길이 등을 검증합니다.\n     */\n    public {ValueObject} {\n        if (value == null || value.isBlank()) {\n            throw new IllegalArgumentException(\"{ValueObject} must not be blank\");\n        }\n        if (value.length() > MAX_LENGTH) {\n            throw new IllegalArgumentException(\n                    String.format(\"{ValueObject} must not exceed %d characters, but was %d\",\n                            MAX_LENGTH, value.length()));\n        }\n    }\n\n    /**\n     * 정적 팩토리 메서드\n     *\n     * @param value 값\n     * @return {ValueObject} 인스턴스\n     * @throws IllegalArgumentException 유효성 검증 실패 시\n     */\n    public static {ValueObject} of(String value) {\n        return new {ValueObject}(value);\n    }\n}','{Name}',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"of\"]','Value Object Record - 불변 값 객체. Compact Constructor에서 검증, of() 정적 팩토리 메서드 필수.','2026-01-20 08:29:59.000000','2026-01-27 11:28:41.000000',NULL),(25,3,36,'/**\n * {Domain}Id - {Domain} 식별자 Value Object (Auto-increment)\n *\n * <p>DB Auto-increment로 생성되는 ID를 타입 안전하게 표현합니다.\n *\n * <p><strong>설계 원칙:</strong>\n * <ul>\n *   <li>Record로 정의하여 불변성 보장\n *   <li>forNew() - 새 엔티티용 (null 값, DB에서 생성)\n *   <li>of(Long) - 기존 엔티티용 (non-null 필수)\n *   <li>isNew() - 새 엔티티 여부 확인\n * </ul>\n *\n * <p><strong>사용 시점:</strong>\n * <ul>\n *   <li>RDS Auto-increment PK 사용 시\n *   <li>ID 생성을 DB에 위임하는 경우\n * </ul>\n *\n * @param value ID 값 (새 엔티티는 null, 영속화 후 DB에서 할당)\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic record {Domain}Id(Long value) {\n\n    /**\n     * 새 엔티티용 ID 생성\n     *\n     * <p>아직 영속화되지 않은 새 엔티티에 사용됩니다.\n     * 실제 ID는 DB 영속화 시점에 Auto-increment로 할당됩니다.\n     *\n     * @return null 값을 가진 {Domain}Id\n     */\n    public static {Domain}Id forNew() {\n        return new {Domain}Id(null);\n    }\n\n    /**\n     * 기존 엔티티용 ID 생성\n     *\n     * @param value ID 값 (non-null)\n     * @return {Domain}Id 인스턴스\n     * @throws IllegalArgumentException value가 null인 경우\n     */\n    public static {Domain}Id of(Long value) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"{Domain}Id value must not be null for existing entity\");\n        }\n        return new {Domain}Id(value);\n    }\n\n    /**\n     * 새 엔티티인지 확인\n     *\n     * @return value가 null이면 true\n     */\n    public boolean isNew() {\n        return value == null;\n    }\n}','{Domain}Id',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"forNew\", \"of\", \"isNew\"]','Auto-increment Long ID - DB에서 ID 생성 (forNew() 시 null 반환)','2026-01-20 08:29:59.000000','2026-01-20 08:41:05.000000',NULL),(26,4,8,'/**\n * {Domain}ErrorCode - {Domain} 도메인 에러 코드\n *\n * <p>해당 도메인에서 발생하는 모든 예외의 에러 코드를 정의합니다.\n *\n * <p><strong>코드 형식:</strong> {DOMAIN_PREFIX}-{NUMBER}\n * <ul>\n *   <li>예: ORD-001, PAY-002, USR-003\n * </ul>\n *\n * <p><strong>HTTP 상태 코드 가이드:</strong>\n * <ul>\n *   <li>400 - 잘못된 요청 (유효성 검증 실패)\n *   <li>404 - 리소스 없음\n *   <li>409 - 충돌 (중복, 상태 불일치)\n *   <li>422 - 처리 불가 (비즈니스 규칙 위반)\n *   <li>500 - 서버 오류\n * </ul>\n *\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic enum {Domain}ErrorCode implements ErrorCode {\n\n    /**\n     * {Domain}을(를) 찾을 수 없음\n     */\n    {DOMAIN}_NOT_FOUND(\"{PREFIX}-001\", 404, \"{Domain}을(를) 찾을 수 없습니다\"),\n\n    /**\n     * {Domain} 중복\n     */\n    {DOMAIN}_DUPLICATE(\"{PREFIX}-002\", 409, \"이미 존재하는 {Domain}입니다\"),\n\n    /**\n     * 유효하지 않은 {Domain} 상태\n     */\n    INVALID_{DOMAIN}_STATUS(\"{PREFIX}-003\", 422, \"유효하지 않은 {Domain} 상태입니다\");\n\n    private final String code;\n    private final int httpStatus;\n    private final String message;\n\n    {Domain}ErrorCode(String code, int httpStatus, String message) {\n        this.code = code;\n        this.httpStatus = httpStatus;\n        this.message = message;\n    }\n\n    @Override\n    public String getCode() {\n        return code;\n    }\n\n    @Override\n    public int getHttpStatus() {\n        return httpStatus;\n    }\n\n    @Override\n    public String getMessage() {\n        return message;\n    }\n}','{Domain}ErrorCode',NULL,'[\"lombok.*\"]','[\"ErrorCode\"]',NULL,'[\"getCode\", \"getHttpStatus\", \"getMessage\"]','ErrorCode Enum - 도메인별 에러 코드. ErrorCode 인터페이스 구현 필수.','2026-01-20 08:29:59.000000','2026-01-20 08:29:59.000000',NULL),(27,4,6,'/**\n * {Domain}NotFoundException - {Domain} 조회 실패 예외\n *\n * <p>요청한 {Domain}을(를) 찾을 수 없을 때 발생합니다.\n *\n * <p><strong>사용 예시:</strong>\n * <pre>{@code\n * {Domain} domain = repository.findById(id)\n *     .orElseThrow(() -> new {Domain}NotFoundException(id));\n * }</pre>\n *\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic class {Domain}NotFoundException extends DomainException {\n\n    /**\n     * ID로 조회 실패 시 생성\n     *\n     * @param {domain}Id 조회 실패한 {Domain} ID\n     */\n    public {Domain}NotFoundException(Long {domain}Id) {\n        super(\n                {Domain}ErrorCode.{DOMAIN}_NOT_FOUND,\n                String.format(\"{Domain} not found: %d\", {domain}Id),\n                Map.of(\"{domain}Id\", {domain}Id));\n    }\n\n    /**\n     * 다른 식별자로 조회 실패 시 생성\n     *\n     * @param identifier 조회에 사용된 식별자\n     * @param identifierName 식별자 이름 (예: \"code\", \"name\")\n     */\n    public {Domain}NotFoundException(String identifier, String identifierName) {\n        super(\n                {Domain}ErrorCode.{DOMAIN}_NOT_FOUND,\n                String.format(\"{Domain} not found by %s: %s\", identifierName, identifier),\n                Map.of(identifierName, identifier));\n    }\n}','{Domain}*Exception',NULL,'[\"lombok.*\"]',NULL,'[\"DomainException\"]',NULL,'Domain Exception 클래스 - DomainException 상속 필수. ErrorCode와 args Map 전달.','2026-01-20 08:29:59.000000','2026-01-20 08:29:59.000000','2026-01-27 11:29:56.000000'),(28,3,37,'/**\n * {Domain}Id - {Domain} 식별자 Value Object (외부 생성 Long)\n *\n * <p>Snowflake, TSID 등 외부에서 생성된 Long ID를 타입 안전하게 표현합니다.\n *\n * <p><strong>설계 원칙:</strong>\n * <ul>\n *   <li>Record로 정의하여 불변성 보장\n *   <li>forNew() 없음 - 도메인에서 ID 생성 금지\n *   <li>of(Long) - Factory에서 IdGenerator 통해 생성된 값을 받음\n *   <li>ID는 항상 non-null (생성 시점에 이미 결정됨)\n * </ul>\n *\n * <p><strong>사용 시점:</strong>\n * <ul>\n *   <li>Snowflake, TSID 등 분산 ID 생성기 사용 시\n *   <li>시간 기반 정렬이 필요한 Long ID\n *   <li>Application Factory에서 IdGenerator로 생성 후 주입\n * </ul>\n *\n * <p><strong>Factory 사용 예시:</strong>\n * <pre>{@code\n * // Application Factory\n * public class {Domain}Factory {\n *     private final IdGenerator idGenerator;\n *\n *     public {Domain} create(Create{Domain}Command cmd) {\n *         {Domain}Id id = {Domain}Id.of(idGenerator.nextId());\n *         return {Domain}.forNew(id, ...);\n *     }\n * }\n * }</pre>\n *\n * @param value ID 값 (non-null, 외부에서 생성됨)\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic record {Domain}Id(Long value) {\n\n    /** Compact Constructor - null 검증 */\n    public {Domain}Id {\n        if (value == null) {\n            throw new IllegalArgumentException(\"{Domain}Id value must not be null\");\n        }\n    }\n\n    /**\n     * ID 생성\n     *\n     * <p>IdGenerator에서 생성된 값을 받아 ID를 생성합니다.\n     *\n     * @param value IdGenerator에서 생성된 ID 값\n     * @return {Domain}Id 인스턴스\n     * @throws IllegalArgumentException value가 null인 경우\n     */\n    public static {Domain}Id of(Long value) {\n        return new {Domain}Id(value);\n    }\n}','{Domain}Id',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"of\"]','Generated Long ID - Snowflake/TSID 등 외부 생성 Long ID (forNew 없음, Factory에서 IdGenerator 통해 주입)','2026-01-20 08:41:21.000000','2026-01-20 08:41:21.000000',NULL),(29,3,38,'/**\n * {Domain}Id - {Domain} 식별자 Value Object (외부 생성 String)\n *\n * <p>UUIDv7, ULID 등 외부에서 생성된 String ID를 타입 안전하게 표현합니다.\n *\n * <p><strong>설계 원칙:</strong>\n * <ul>\n *   <li>Record로 정의하여 불변성 보장\n *   <li>forNew() 없음 - 도메인에서 ID 생성 금지 (UUID.randomUUID() 호출 금지)\n *   <li>of(String) - Factory에서 IdGenerator 통해 생성된 값을 받음\n *   <li>ID는 항상 non-null, non-blank (생성 시점에 이미 결정됨)\n * </ul>\n *\n * <p><strong>사용 시점:</strong>\n * <ul>\n *   <li>UUIDv7, ULID 등 시간 기반 정렬 가능한 String ID\n *   <li>외부 노출용으로 추측 불가능한 ID가 필요한 경우\n *   <li>Application Factory에서 IdGenerator로 생성 후 주입\n * </ul>\n *\n * <p><strong>Factory 사용 예시:</strong>\n * <pre>{@code\n * // Application Factory\n * public class {Domain}Factory {\n *     private final IdGenerator idGenerator;\n *\n *     public {Domain} create(Create{Domain}Command cmd) {\n *         {Domain}Id id = {Domain}Id.of(idGenerator.nextStringId());\n *         return {Domain}.forNew(id, ...);\n *     }\n * }\n * }</pre>\n *\n * @param value ID 값 (non-null, non-blank, 외부에서 생성됨)\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic record {Domain}Id(String value) {\n\n    /** Compact Constructor - null/blank 검증 */\n    public {Domain}Id {\n        if (value == null || value.isBlank()) {\n            throw new IllegalArgumentException(\"{Domain}Id value must not be null or blank\");\n        }\n    }\n\n    /**\n     * ID 생성\n     *\n     * <p>IdGenerator에서 생성된 값을 받아 ID를 생성합니다.\n     *\n     * @param value IdGenerator에서 생성된 ID 값 (UUIDv7, ULID 등)\n     * @return {Domain}Id 인스턴스\n     * @throws IllegalArgumentException value가 null이거나 blank인 경우\n     */\n    public static {Domain}Id of(String value) {\n        return new {Domain}Id(value);\n    }\n}','{Domain}Id',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"of\"]','Generated String ID - UUIDv7/ULID 등 외부 생성 String ID (forNew 없음, Factory에서 IdGenerator 통해 주입)','2026-01-20 08:41:33.000000','2026-01-20 08:41:33.000000',NULL),(30,9,0,'/**\n * {UseCase} - {Description}\n *\n * <p>단일 책임: {Responsibility}\n *\n * @author ryu-qqq\n */\npublic interface {UseCase} {\n\n    /**\n     * UseCase 실행\n     *\n     * @param command {Command} 커맨드\n     * @return 생성된 ID (생성의 경우) 또는 void\n     */\n    Long execute({Command} command);\n}',NULL,NULL,NULL,NULL,NULL,NULL,NULL,'2026-01-21 05:27:30.000000','2026-01-21 05:27:30.000000','2026-01-28 03:03:30.000000'),(31,10,0,'/**\n * {UseCase} - {Description}\n *\n * <p>단일 책임: {Responsibility}\n *\n * @author ryu-qqq\n */\npublic interface {UseCase} {\n\n    /**\n     * UseCase 실행\n     *\n     * @param query {Query} 쿼리\n     * @return {Result} 조회 결과\n     */\n    {Result} execute({Query} query);\n}',NULL,NULL,NULL,NULL,NULL,NULL,NULL,'2026-01-21 05:27:30.000000','2026-01-21 05:27:30.000000','2026-01-28 03:03:30.000000'),(32,11,0,'/**\n * {Domain}CommandPort - {Domain} 명령 Port\n *\n * <p>영속성 계층으로의 {Domain} CUD 아웃바운드 포트입니다.\n *\n * <p>CPRT-002: CommandPort는 persist(Domain) 메서드만 제공합니다.\n *\n * @author ryu-qqq\n */\npublic interface {Domain}CommandPort {\n\n    /**\n     * {Domain} 영속화 (생성/수정/삭제)\n     *\n     * @param {domain} 영속화할 {Domain}\n     * @return 영속화된 {Domain} ID\n     */\n    Long persist({Domain} {domain});\n}',NULL,NULL,NULL,NULL,NULL,NULL,NULL,'2026-01-21 05:27:30.000000','2026-01-21 05:27:30.000000','2026-01-28 03:03:30.000000'),(33,12,0,'/**\n * {Domain}QueryPort - {Domain} 조회 Port\n *\n * <p>영속성 계층으로의 {Domain} 조회 아웃바운드 포트입니다.\n *\n * <p>QPRT-002: 표준 메서드를 제공합니다.\n *\n * <p>QPRT-003: Unique 필드 조회 메서드를 추가 제공합니다.\n *\n * <p>QPRT-004: 원시타입 대신 VO를 파라미터로 사용합니다.\n *\n * @author ryu-qqq\n */\npublic interface {Domain}QueryPort {\n\n    /**\n     * ID로 {Domain} 조회\n     *\n     * @param id {Domain} ID (VO)\n     * @return {Domain} (Optional)\n     */\n    Optional<{Domain}> findById({Domain}Id id);\n\n    /**\n     * ID로 존재 여부 확인\n     *\n     * @param id {Domain} ID (VO)\n     * @return 존재 여부\n     */\n    boolean existsById({Domain}Id id);\n\n    /**\n     * 커서 기반 슬라이스 조건으로 {Domain} 목록 조회\n     *\n     * @param criteria 슬라이스 조건 (커서 기반)\n     * @return {Domain} 목록\n     */\n    List<{Domain}> findBySliceCriteria({Domain}SliceCriteria criteria);\n}',NULL,NULL,NULL,NULL,NULL,NULL,NULL,'2026-01-21 05:27:30.000000','2026-01-21 05:27:30.000000','2026-01-28 03:03:30.000000'),(34,13,0,'/**\n * {Client}ClientPort - {Client} 외부 연동 Port\n *\n * <p>외부 시스템({Client})과의 연동을 위한 아웃바운드 포트입니다.\n *\n * @author ryu-qqq\n */\npublic interface {Client}ClientPort {\n\n    /**\n     * {Operation} 요청\n     *\n     * @param request 요청 데이터\n     * @return 응답 결과\n     */\n    {Response} {operation}({Request} request);\n}',NULL,NULL,NULL,NULL,NULL,NULL,NULL,'2026-01-21 05:27:30.000000','2026-01-21 05:27:30.000000','2026-01-28 03:03:30.000000'),(35,14,11,'/**\n * {Service} - {UseCase} 구현체\n *\n * <p>{Responsibility}\n *\n * <p>SVC-001: Service에서 @Transactional 금지\n *\n * @author ryu-qqq\n */\n@Service\npublic class {Service} implements {UseCase} {\n\n    private final {Factory} {factory};\n    private final {Facade} {facade};\n\n    public {Service}({Factory} {factory}, {Facade} {facade}) {\n        this.{factory} = {factory};\n        this.{facade} = {facade};\n    }\n\n    @Override\n    public Long execute({Command} command) {\n        // 1. Factory: Command → Bundle/Context\n        {Bundle} bundle = {factory}.create(command);\n        \n        // 2. Facade/Manager: 저장\n        return {facade}.create(bundle);\n    }\n}','{Action}{Domain}Service','[\"@Service\"]','[\"@Transactional\", \"lombok.*\"]','[\"UseCase\"]',NULL,'[\"execute\"]','Command Service - UseCase 구현체. @Service 필수, @Transactional 금지, Factory/Manager 사용.','2026-01-21 05:27:30.000000','2026-01-27 11:32:54.000000',NULL),(36,15,12,'/**\n * {Service} - {UseCase} 구현체\n *\n * <p>{Responsibility}\n *\n * @author ryu-qqq\n */\n@Service\npublic class {Service} implements {UseCase} {\n\n    private final {Factory} {factory};\n    private final {Facade} {facade};\n    private final {Assembler} {assembler};\n\n    public {Service}({Factory} {factory}, {Facade} {facade}, {Assembler} {assembler}) {\n        this.{factory} = {factory};\n        this.{facade} = {facade};\n        this.{assembler} = {assembler};\n    }\n\n    @Override\n    public {Result} execute({Query} query) {\n        // 1. Factory: Query → Criteria\n        {Criteria} criteria = {factory}.create(query);\n        \n        // 2. Facade: 조회\n        List<{Domain}> domains = {facade}.findBySliceCriteria(criteria);\n        \n        // 3. Assembler: Domain → Response\n        return {assembler}.toSliceResult(domains, criteria.sliceMeta());\n    }\n}','{Action}{Domain}Service','[\"@Service\"]','[\"@Transactional\", \"lombok.*\"]','[\"UseCase\"]',NULL,'[\"execute\"]','Query Service - UseCase 구현체. @Service 필수, Assembler로 응답 변환.','2026-01-21 05:27:30.000000','2026-01-27 11:32:55.000000',NULL),(37,16,0,'/**\n * {Facade} - {Domain} 쓰기 Facade\n *\n * <p>Manager 2개 이상 조합 시 사용합니다.\n *\n * <p>FAC-001: CommandFacade → QueryManager 의존 금지 (CQRS)\n *\n * @author ryu-qqq\n */\n@Component\npublic class {Facade} {\n\n    private final {MainManager} {mainManager};\n    private final {SubManager} {subManager};\n\n    public {Facade}({MainManager} {mainManager}, {SubManager} {subManager}) {\n        this.{mainManager} = {mainManager};\n        this.{subManager} = {subManager};\n    }\n\n    @Transactional\n    public Long create({Bundle} bundle) {\n        Long id = {mainManager}.persist(bundle.main());\n        {Bundle} withId = bundle.withId(id);\n        {subManager}.persistAll(withId.subs());\n        return id;\n    }\n}',NULL,'[\"@Component\"]',NULL,NULL,NULL,NULL,NULL,'2026-01-21 05:27:30.000000','2026-01-21 05:27:30.000000','2026-01-28 03:03:30.000000'),(38,17,0,'/**\n * {Facade} - {Domain} 읽기 Facade\n *\n * <p>Manager 2개 이상 조합하여 복합 조회 수행.\n *\n * @author ryu-qqq\n */\n@Component\npublic class {Facade} {\n\n    private final {MainManager} {mainManager};\n    private final {SubManager} {subManager};\n\n    public {Facade}({MainManager} {mainManager}, {SubManager} {subManager}) {\n        this.{mainManager} = {mainManager};\n        this.{subManager} = {subManager};\n    }\n\n    @Transactional(readOnly = true)\n    public List<{Domain}> findBySliceCriteria({Criteria} criteria) {\n        return {mainManager}.findBySliceCriteria(criteria);\n    }\n}',NULL,'[\"@Component\"]',NULL,NULL,NULL,NULL,NULL,'2026-01-21 05:27:30.000000','2026-01-21 05:27:30.000000','2026-01-28 03:03:30.000000'),(39,18,0,'package {package};\n\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\n/**\n * {ClassName} - {도메인} 명령 매니저\n *\n * <p>단일 Aggregate의 생성/수정/삭제 트랜잭션을 관리합니다.\n *\n * @author {author}\n */\n@Service\n@Transactional\npublic class {ClassName} {\n\n    private final {AggregateRoot}CommandPort {aggregateRoot}CommandPort;\n\n    public {ClassName}({AggregateRoot}CommandPort {aggregateRoot}CommandPort) {\n        this.{aggregateRoot}CommandPort = {aggregateRoot}CommandPort;\n    }\n\n    public Long create({AggregateRoot} {aggregateRoot}) {\n        return {aggregateRoot}CommandPort.persist({aggregateRoot});\n    }\n\n    public void update({AggregateRoot} {aggregateRoot}) {\n        {aggregateRoot}CommandPort.persist({aggregateRoot});\n    }\n}','*Manager','[\"@Service\", \"@Transactional\"]','[\"@Transactional(readOnly = true)\"]',NULL,NULL,NULL,'단일 Aggregate의 생성/수정/삭제 트랜잭션을 관리하는 매니저 클래스 템플릿','2026-01-21 05:29:19.000000','2026-01-21 05:29:19.000000','2026-01-28 03:03:30.000000'),(40,19,0,'package {package};\n\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\nimport java.util.Optional;\n\n/**\n * {ClassName} - {도메인} 조회 매니저\n *\n * <p>단일 Aggregate의 조회를 담당합니다.\n *\n * @author {author}\n */\n@Service\n@Transactional(readOnly = true)\npublic class {ClassName} {\n\n    private final {AggregateRoot}QueryPort {aggregateRoot}QueryPort;\n\n    public {ClassName}({AggregateRoot}QueryPort {aggregateRoot}QueryPort) {\n        this.{aggregateRoot}QueryPort = {aggregateRoot}QueryPort;\n    }\n\n    public Optional<{AggregateRoot}> findById({AggregateRoot}Id id) {\n        return {aggregateRoot}QueryPort.findById(id);\n    }\n\n    public {AggregateRoot} getById({AggregateRoot}Id id) {\n        return findById(id)\n            .orElseThrow(() -> new DomainException({AggregateRoot}ErrorCode.NOT_FOUND, id));\n    }\n}','*Manager','[\"@Service\", \"@Transactional(readOnly = true)\"]','[\"@Transactional\"]',NULL,NULL,NULL,'단일 Aggregate의 조회를 담당하는 매니저 클래스 템플릿','2026-01-21 05:29:19.000000','2026-01-21 05:29:19.000000','2026-01-28 03:03:30.000000'),(41,20,0,'package {package};\n\nimport org.springframework.stereotype.Service;\n\n/**\n * {ClassName} - {외부시스템} 클라이언트 매니저\n *\n * <p>외부 시스템 연동을 담당합니다. 트랜잭션 없음 (외부 호출).\n *\n * @author {author}\n */\n@Service\npublic class {ClassName} {\n\n    private final {ExternalSystem}ClientPort {externalSystem}ClientPort;\n\n    public {ClassName}({ExternalSystem}ClientPort {externalSystem}ClientPort) {\n        this.{externalSystem}ClientPort = {externalSystem}ClientPort;\n    }\n\n    public {Response} call{Operation}({Request} request) {\n        return {externalSystem}ClientPort.{operation}(request);\n    }\n}','*Manager','[\"@Service\"]','[\"@Transactional\"]',NULL,NULL,NULL,'외부 시스템 연동을 담당하는 클라이언트 매니저 클래스 템플릿. 트랜잭션 어노테이션 금지.','2026-01-21 05:29:19.000000','2026-01-21 05:29:19.000000','2026-01-28 03:03:30.000000'),(42,21,0,'package {package};\n\nimport com.ryuqq.application.common.dto.command.UpdateContext;\nimport com.ryuqq.application.common.time.TimeProvider;\nimport org.springframework.stereotype.Component;\nimport java.time.Instant;\n\n/**\n * {ClassName} - {도메인} Command Factory\n *\n * <p>Command DTO를 Domain 객체로 변환합니다.\n *\n * <p>C-006: 시간/ID 생성은 Factory에서만 허용됩니다.\n *\n * <p>SVC-003: Service에서 Domain 객체 직접 생성 금지 → Factory에 위임.\n *\n * <p>FAC-008: createUpdateContext()로 ID, UpdateData, changedAt 한 번에 생성.\n *\n * @author {author}\n */\n@Component\npublic class {ClassName} {\n\n    private final TimeProvider timeProvider;\n\n    public {ClassName}(TimeProvider timeProvider) {\n        this.timeProvider = timeProvider;\n    }\n\n    // ==================== Domain 객체 생성 ====================\n\n    /**\n     * Create Command로부터 Domain 객체 생성\n     *\n     * @param command 생성 Command\n     * @return Domain 객체\n     */\n    public {AggregateRoot} create(Create{AggregateRoot}Command command) {\n        Instant now = timeProvider.now();\n        return {AggregateRoot}.forNew(\n            // command 필드들을 VO로 변환하여 전달\n            now\n        );\n    }\n\n    /**\n     * Update Command로부터 UpdateData 생성\n     *\n     * @param command 수정 Command\n     * @return UpdateData\n     */\n    public {AggregateRoot}UpdateData createUpdateData(Update{AggregateRoot}Command command) {\n        return new {AggregateRoot}UpdateData(\n            // command 필드들을 VO로 변환하여 전달\n        );\n    }\n\n    /**\n     * Update Command로부터 UpdateContext 생성\n     *\n     * <p>FAC-008: ID, UpdateData, changedAt을 한 번에 생성합니다.\n     *\n     * @param command 수정 Command\n     * @return UpdateContext (id, updateData, changedAt)\n     */\n    public UpdateContext<{AggregateRoot}Id, {AggregateRoot}UpdateData> createUpdateContext(\n            Update{AggregateRoot}Command command) {\n        {AggregateRoot}Id id = {AggregateRoot}Id.of(command.id());\n        {AggregateRoot}UpdateData updateData = createUpdateData(command);\n        Instant changedAt = timeProvider.now();\n        return new UpdateContext<>(id, updateData, changedAt);\n    }\n\n    // ==================== VO 생성 ====================\n\n    public {AggregateRoot}Id createId(Long id) {\n        return {AggregateRoot}Id.of(id);\n    }\n}','*Factory','[\"@Component\"]',NULL,NULL,NULL,'[\"create*\"]','도메인 객체 생성을 담당하는 팩토리 클래스 템플릿. TimeProvider를 주입받아 시간 값 생성.','2026-01-21 05:29:34.000000','2026-01-22 03:18:16.000000','2026-01-28 03:03:30.000000'),(43,22,0,'package {package};\n\nimport org.springframework.stereotype.Component;\n\n/**\n * {ClassName} - {도메인} 조회 팩토리\n *\n * <p>조회 조건 및 검색 DTO 생성을 담당합니다.\n *\n * @author {author}\n */\n@Component\npublic class {ClassName} {\n\n    public {Domain}SearchCondition createSearchCondition({Domain}Query query) {\n        return {Domain}SearchCondition.builder()\n            .keyword(query.keyword())\n            .status(query.status())\n            .build();\n    }\n\n    public {Domain}SliceCriteria createSliceCriteria({Domain}Query query) {\n        return new {Domain}SliceCriteria(\n            query.cursor(),\n            query.size()\n        );\n    }\n}','*Factory','[\"@Component\"]',NULL,NULL,NULL,'[\"create*\"]','조회 조건 및 검색 DTO 생성을 담당하는 팩토리 클래스 템플릿','2026-01-21 05:29:34.000000','2026-01-21 05:29:34.000000','2026-01-28 03:03:30.000000'),(44,23,18,'package {package};\n\nimport org.springframework.stereotype.Component;\nimport java.util.List;\n\n/**\n * {ClassName} - {도메인} 어셈블러\n *\n * <p>도메인 객체를 응답 DTO로 변환합니다.\n *\n * @author {author}\n */\n@Component\npublic class {ClassName} {\n\n    public {AggregateRoot}Response toResponse({AggregateRoot} aggregate) {\n        return new {AggregateRoot}Response(\n            aggregate.getId().value(),\n            aggregate.getName(),\n            aggregate.getStatus().name()\n        );\n    }\n\n    public List<{AggregateRoot}Response> toResponseList(List<{AggregateRoot}> aggregates) {\n        return aggregates.stream()\n            .map(this::toResponse)\n            .toList();\n    }\n}','*Assembler','[\"@Component\"]',NULL,NULL,NULL,'[\"toResponse*\", \"toResponseList*\"]','도메인 객체를 응답 DTO로 변환하는 어셈블러 클래스 템플릿','2026-01-21 05:29:34.000000','2026-01-21 05:29:34.000000',NULL),(45,24,0,'package {package};\n\nimport org.springframework.stereotype.Component;\n\n/**\n * {ClassName} - {도메인} 검증기\n *\n * <p>비즈니스 규칙 검증을 담당합니다.\n *\n * @author {author}\n */\n@Component\npublic class {ClassName} {\n\n    public void validate{Operation}({Command} command) {\n        if (command.{field}() == null) {\n            throw new DomainException({ErrorCode}.INVALID_{FIELD});\n        }\n        // 추가 검증 로직\n    }\n\n    public void validateBusinessRule({AggregateRoot} aggregate, {Context} context) {\n        // 비즈니스 규칙 검증\n    }\n}','*Validator','[\"@Component\"]',NULL,NULL,NULL,'[\"validate*\"]','비즈니스 규칙 검증을 담당하는 검증기 클래스 템플릿','2026-01-21 05:29:49.000000','2026-01-21 05:29:49.000000','2026-01-27 11:33:46.000000'),(48,27,0,'package {package};\n\n/**\n * {ClassName} - {도메인} 명령 DTO\n *\n * <p>UseCase/Service의 파라미터로 사용되는 명령 DTO입니다.\n * 반드시 record로 정의하며, 인스턴스 메서드를 포함하지 않습니다.\n *\n * @author {author}\n */\npublic record {ClassName}(\n    Long {field1},\n    String {field2},\n    {Type} {field3}\n) {\n    // 인스턴스 메서드 금지 - 정적 팩토리만 허용\n    public static {ClassName} of(Long {field1}, String {field2}) {\n        return new {ClassName}({field1}, {field2}, null);\n    }\n}','*Command',NULL,'[\"@Data\", \"@Builder\", \"@Getter\", \"@Setter\"]',NULL,NULL,NULL,'UseCase/Service 파라미터로 사용되는 명령 DTO 템플릿. record 필수, 인스턴스 메서드 금지.','2026-01-21 05:30:06.000000','2026-01-21 05:30:06.000000','2026-01-28 03:03:30.000000'),(49,28,0,'package {package};\n\nimport com.ryuqq.application.common.dto.query.CommonCursorParams;\n\n/**\n * {ClassName} - {도메인} 조회 Query DTO\n *\n * <p>조회 요청 파라미터를 담는 Query DTO입니다.\n * 반드시 record로 정의하며, CommonCursorParams를 포함합니다.\n *\n * <p>APP-DTO-001: Query DTO는 Record로 정의.\n * <p>APP-DTO-004: 목록 조회 Query는 CommonCursorParams 포함 필수.\n *\n * @param keyword 검색 키워드 (null이면 전체 조회)\n * @param status 상태 필터 (null이면 전체 조회)\n * @param cursorParams 커서 기반 페이징 파라미터\n * @author {author}\n */\npublic record {ClassName}(\n    String keyword,\n    {StatusType} status,\n    CommonCursorParams cursorParams\n) {\n\n    public static {ClassName} of(CommonCursorParams cursorParams) {\n        return new {ClassName}(null, null, cursorParams);\n    }\n\n    public static {ClassName} of(String keyword, {StatusType} status, CommonCursorParams cursorParams) {\n        return new {ClassName}(keyword, status, cursorParams);\n    }\n\n    // ==================== Delegate Methods ====================\n\n    /** 커서 값 반환 (delegate) */\n    public Long cursor() {\n        return cursorParams.cursor();\n    }\n\n    /** 페이지 크기 반환 (delegate) */\n    public Integer size() {\n        return cursorParams.size();\n    }\n\n    /** 첫 페이지인지 확인 (delegate) */\n    public boolean isFirstPage() {\n        return cursorParams.isFirstPage();\n    }\n}','*Query',NULL,'[\"@Data\", \"@Builder\", \"@Getter\", \"@Setter\"]',NULL,NULL,NULL,'조회 요청 파라미터를 담는 DTO 템플릿. record 필수.','2026-01-21 05:30:06.000000','2026-01-21 05:30:06.000000','2026-01-28 03:03:30.000000'),(50,29,31,'package {package};\n\nimport java.time.Instant;\n\n/**\n * {ClassName} - {도메인} 조회 결과 DTO\n *\n * <p>Application Layer에서 사용하는 불변 결과 객체입니다.\n *\n * <p>APP-DTO-001: Response DTO는 Record로 정의.\n * <p>RDTO-008: Response DTO는 Domain 타입 의존 금지.\n *\n * @param id ID\n * @param name 이름\n * @param status 상태\n * @param createdAt 생성 시각\n * @param updatedAt 수정 시각\n * @author {author}\n */\npublic record {ClassName}(\n    Long id,\n    String name,\n    String status,\n    Instant createdAt,\n    Instant updatedAt\n) {}','*Result',NULL,'[\"@Data\", \"@Builder\", \"@Getter\", \"@Setter\"]',NULL,NULL,NULL,'Application 레이어 조회 결과 Result DTO 템플릿. record 필수.','2026-01-21 05:30:06.000000','2026-01-21 05:30:06.000000',NULL),(51,30,0,'package {package};\n\nimport java.util.List;\n\n/**\n * {ClassName} - {도메인} 번들 DTO\n *\n * <p>여러 도메인 데이터를 묶어서 반환하는 DTO입니다.\n * 복잡한 조회 결과를 하나의 객체로 묶습니다.\n *\n * @author {author}\n */\npublic record {ClassName}(\n    {MainEntity}Response main,\n    List<{RelatedEntity}Response> related,\n    {SummaryData} summary\n) {\n    public static {ClassName} of({MainEntity}Response main, List<{RelatedEntity}Response> related) {\n        return new {ClassName}(main, related, null);\n    }\n}','*Bundle',NULL,'[\"@Data\", \"@Builder\", \"@Getter\", \"@Setter\"]',NULL,NULL,NULL,'여러 도메인 데이터를 묶어서 반환하는 번들 DTO 템플릿. record 필수.','2026-01-21 05:30:06.000000','2026-01-21 05:30:06.000000','2026-01-28 03:03:30.000000'),(52,31,0,'package {package};\n\n/**\n * {ClassName} - 공통 조회 DTO\n *\n * <p>여러 도메인에서 공통으로 사용하는 조회 조건 DTO입니다.\n * 페이징, 정렬 등 공통 조회 조건을 정의합니다.\n *\n * @author {author}\n */\npublic record {ClassName}(\n    Long cursor,\n    int size,\n    String sortField,\n    String sortDirection\n) {\n    public static {ClassName} defaultPaging() {\n        return new {ClassName}(null, 20, \"id\", \"DESC\");\n    }\n\n    public static {ClassName} of(Long cursor, int size) {\n        return new {ClassName}(cursor, size, \"id\", \"DESC\");\n    }\n}','*Query | *Criteria | *Condition',NULL,'[\"@Data\", \"@Builder\", \"@Getter\", \"@Setter\"]',NULL,NULL,NULL,'여러 도메인에서 공통으로 사용하는 조회 조건 DTO 템플릿. record 필수.','2026-01-21 05:30:22.000000','2026-01-21 05:30:22.000000','2026-01-28 03:03:30.000000'),(54,33,0,'package {package};\n\nimport org.springframework.stereotype.Component;\n\n/**\n * {ClassName} - 공통 팩토리\n *\n * <p>여러 도메인에서 공통으로 사용하는 객체 생성 로직을 담당합니다.\n * TimeProvider를 주입받아 시간 관련 필드를 설정합니다.\n *\n * @author {author}\n */\n@Component\npublic class {ClassName} {\n\n    private final TimeProvider timeProvider;\n\n    public {ClassName}(TimeProvider timeProvider) {\n        this.timeProvider = timeProvider;\n    }\n\n    public ExecutionContext createExecutionContext(Long userId, String role) {\n        return ExecutionContext.user(userId, role, timeProvider.now());\n    }\n\n    public ExecutionContext createSystemContext() {\n        return ExecutionContext.system(timeProvider.now());\n    }\n}','*Factory','[\"@Component\"]',NULL,NULL,NULL,'[\"create*\"]','여러 도메인에서 공통으로 사용하는 객체 생성 팩토리 템플릿. TimeProvider 주입 필수.','2026-01-21 05:30:22.000000','2026-01-21 05:30:22.000000','2026-01-28 03:03:30.000000'),(55,25,0,'package {package};\n\nimport org.springframework.stereotype.Component;\n\n/**\n * {ClassName} - 내부 헬퍼 컴포넌트\n *\n * <p>Manager에서만 사용하는 내부 헬퍼입니다.\n * package-private으로 외부 노출을 제한합니다.\n *\n * @author {author}\n */\n@Component\nclass {ClassName} {\n\n    {ReturnType} {operation}({Parameters} params) {\n        // 헬퍼 로직\n        return result;\n    }\n}','*Calculator | *Resolver | *Converter | *Helper','[\"@Component\"]',NULL,NULL,NULL,NULL,'내부 헬퍼 컴포넌트 템플릿. package-private으로 Manager에서만 사용.','2026-01-21 05:39:01.000000','2026-01-21 05:39:01.000000','2026-01-28 03:03:30.000000'),(56,32,0,'package {package};\n\n/**\n * {ClassName} - 공통 Command 컨텍스트\n *\n * <p>여러 도메인에서 공통으로 사용하는 Command DTO입니다.\n *\n * @author {author}\n */\npublic record {ClassName}(\n    Long actorId,\n    String actorType,\n    String reason,\n    java.time.Instant occurredAt\n) {\n    public static {ClassName} system(String reason, java.time.Instant now) {\n        return new {ClassName}(0L, \"SYSTEM\", reason, now);\n    }\n\n    public static {ClassName} user(Long userId, String reason, java.time.Instant now) {\n        return new {ClassName}(userId, \"USER\", reason, now);\n    }\n}','*Context',NULL,NULL,NULL,NULL,NULL,'공통 Command 컨텍스트 DTO 템플릿. StatusChangeContext 등.','2026-01-21 05:39:01.000000','2026-01-21 05:39:01.000000','2026-01-28 03:03:30.000000'),(57,34,0,'package {package};\n\nimport org.springframework.stereotype.Component;\n\n/**\n * {ClassName} - 공통 내부 헬퍼\n *\n * <p>여러 도메인에서 공유하는 내부 헬퍼 컴포넌트입니다.\n *\n * @author {author}\n */\n@Component\npublic class {ClassName} {\n\n    public {ReturnType} {operation}({Parameters} params) {\n        // 공통 헬퍼 로직\n        return result;\n    }\n}','*Calculator | *Resolver | *Converter | *Helper','[\"@Component\"]',NULL,NULL,NULL,NULL,'여러 도메인에서 공유하는 공통 내부 헬퍼 템플릿','2026-01-21 05:39:16.000000','2026-01-21 05:39:16.000000','2026-01-28 03:03:30.000000'),(58,35,0,'package {package};\n\nimport org.springframework.context.ApplicationEventPublisher;\nimport org.springframework.stereotype.Component;\nimport org.springframework.transaction.support.TransactionSynchronization;\nimport org.springframework.transaction.support.TransactionSynchronizationManager;\n\n/**\n * TransactionEventRegistry - 트랜잭션 이벤트 레지스트리\n *\n * <p>트랜잭션 커밋 후 이벤트를 발행합니다.\n * Manager에서 이 컴포넌트를 통해 이벤트를 등록합니다.\n *\n * @author {author}\n */\n@Component\npublic class TransactionEventRegistry {\n\n    private final ApplicationEventPublisher eventPublisher;\n\n    public TransactionEventRegistry(ApplicationEventPublisher eventPublisher) {\n        this.eventPublisher = eventPublisher;\n    }\n\n    public void register(Object event) {\n        TransactionSynchronizationManager.registerSynchronization(\n            new TransactionSynchronization() {\n                @Override\n                public void afterCommit() {\n                    eventPublisher.publishEvent(event);\n                }\n            }\n        );\n    }\n}','*Registry | *Publisher','[\"@Component\"]',NULL,NULL,NULL,NULL,'트랜잭션 커밋 후 이벤트 발행을 위한 레지스트리 템플릿','2026-01-21 05:39:16.000000','2026-01-21 05:39:16.000000','2026-01-28 03:03:30.000000'),(59,36,19,'package {package};\n\nimport org.springframework.context.event.EventListener;\nimport org.springframework.scheduling.annotation.Async;\nimport org.springframework.stereotype.Component;\n\n/**\n * {ClassName} - {도메인} 이벤트 리스너\n *\n * <p>도메인 이벤트를 수신하여 후속 처리를 수행합니다.\n *\n * @author {author}\n */\n@Component\npublic class {ClassName} {\n\n    private final {DependencyManager} {dependencyManager};\n\n    public {ClassName}({DependencyManager} {dependencyManager}) {\n        this.{dependencyManager} = {dependencyManager};\n    }\n\n    @Async\n    @EventListener\n    public void handle({DomainEvent} event) {\n        // 이벤트 처리 로직\n    }\n}','*EventListener','[\"@Component\"]',NULL,NULL,NULL,NULL,'도메인 이벤트를 처리하는 리스너 템플릿. @Async + @EventListener 사용.','2026-01-21 05:39:16.000000','2026-01-21 05:39:16.000000',NULL),(60,37,24,'@Repository\npublic class {Entity}CommandAdapter implements {Entity}CommandPort {\n\n    private final {Entity}JpaRepository jpaRepository;\n    private final {Entity}EntityMapper mapper;\n\n    public {Entity}CommandAdapter({Entity}JpaRepository jpaRepository, {Entity}EntityMapper mapper) {\n        this.jpaRepository = jpaRepository;\n        this.mapper = mapper;\n    }\n\n    @Override\n    public Long persist({Entity} domain) {\n        {Entity}JpaEntity entity = mapper.toEntity(domain);\n        return jpaRepository.save(entity).getId();\n    }\n}','{Entity}CommandAdapter','[\"@Repository\"]',NULL,'[\"{Entity}CommandPort\"]',NULL,NULL,'CommandPort 구현체. JpaRepository만 의존, 커스텀 메서드 추가 금지','2026-01-21 07:43:17.000000','2026-01-21 07:43:17.000000',NULL),(61,37,25,'@Repository\npublic class {Entity}QueryAdapter implements {Entity}QueryPort {\n\n    private final {Entity}QueryDslRepository queryDslRepository;\n    private final {Entity}EntityMapper mapper;\n\n    public {Entity}QueryAdapter({Entity}QueryDslRepository queryDslRepository, {Entity}EntityMapper mapper) {\n        this.queryDslRepository = queryDslRepository;\n        this.mapper = mapper;\n    }\n\n    @Override\n    public Optional<{Entity}> findById({Entity}Id id) {\n        return queryDslRepository.findById(id.value())\n            .map(mapper::toDomain);\n    }\n}','{Entity}QueryAdapter','[\"@Repository\"]',NULL,'[\"{Entity}QueryPort\"]',NULL,NULL,'QueryPort 구현체. QueryDslRepository만 의존','2026-01-21 07:43:17.000000','2026-01-21 07:43:17.000000',NULL),(62,38,0,'@Entity\n@Table(name = \"{table_name}\")\npublic class {Entity}JpaEntity extends SoftDeletableEntity {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    // Long FK 전략 (JPA 관계 어노테이션 금지)\n    @Column(name = \"{fk_column}_id\", nullable = false)\n    private Long {fk}Id;\n\n    // 비즈니스 필드\n    @Column(name = \"{column}\", nullable = false)\n    private {Type} {field};\n\n    protected {Entity}JpaEntity() {}\n\n    public {Entity}JpaEntity(Long id, Long {fk}Id, {Type} {field}, \n                             Instant createdAt, Instant updatedAt, Instant deletedAt) {\n        super(createdAt, updatedAt, deletedAt);\n        this.id = id;\n        this.{fk}Id = {fk}Id;\n        this.{field} = {field};\n    }\n\n    public Long getId() { return id; }\n    public Long get{Fk}Id() { return {fk}Id; }\n    public {Type} get{Field}() { return {field}; }\n}','{Entity}JpaEntity','[\"@Entity\", \"@Table\"]','[\"@OneToMany\", \"@ManyToOne\", \"@OneToOne\", \"@ManyToMany\", \"@JoinColumn\"]',NULL,NULL,NULL,'JPA 엔티티. Long FK 전략 필수. JPA 관계 어노테이션 금지','2026-01-21 07:43:26.000000','2026-01-21 07:43:26.000000','2026-01-28 03:03:30.000000'),(63,39,26,'@Component\npublic class {Entity}EntityMapper {\n\n    /**\n     * Domain → Entity 변환\n     */\n    public {Entity}JpaEntity toEntity({Entity} domain) {\n        return new {Entity}JpaEntity(\n            domain.getId().value(),\n            domain.get{Fk}Id().value(),\n            domain.get{Field}(),\n            domain.getCreatedAt(),\n            domain.getUpdatedAt(),\n            domain.getDeletedAt()\n        );\n    }\n\n    /**\n     * Entity → Domain 변환\n     */\n    public {Entity} toDomain({Entity}JpaEntity entity) {\n        return {Entity}.reconstitute(\n            new {Entity}Id(entity.getId()),\n            new {Fk}Id(entity.get{Fk}Id()),\n            entity.get{Field}(),\n            entity.getCreatedAt(),\n            entity.getUpdatedAt(),\n            entity.getDeletedAt()\n        );\n    }\n\n    /**\n     * Entity 리스트 → Domain 리스트 변환\n     */\n    public List<{Entity}> toDomains(List<{Entity}JpaEntity> entities) {\n        return entities.stream()\n            .map(this::toDomain)\n            .toList();\n    }\n}','{Entity}EntityMapper','[\"@Component\"]',NULL,NULL,NULL,NULL,'Domain ↔ Entity 변환. Component로 DI 지원','2026-01-21 07:43:34.000000','2026-01-21 07:43:34.000000',NULL),(64,40,22,'/**\n * {Entity}JpaRepository - Command용 JPA Repository\n *\n * <p>⚠️ save, saveAll만 사용. 커스텀 메서드 추가 금지!\n * <p>조회는 QueryDslRepository에서 수행\n */\npublic interface {Entity}JpaRepository extends JpaRepository<{Entity}JpaEntity, Long> {\n    // ❌ 커스텀 메서드 추가 금지\n    // ✅ save(), saveAll()만 사용\n}','{Entity}JpaRepository',NULL,NULL,'[\"JpaRepository<{Entity}JpaEntity, Long>\"]',NULL,NULL,'Command용. save/saveAll만 사용. 커스텀 메서드 추가 절대 금지','2026-01-21 07:43:45.000000','2026-01-21 07:43:45.000000',NULL),(65,40,23,'@Repository\npublic class {Entity}QueryDslRepository {\n\n    private final JPAQueryFactory queryFactory;\n    private final {Entity}ConditionBuilder conditionBuilder;\n\n    public {Entity}QueryDslRepository(JPAQueryFactory queryFactory, \n                                       {Entity}ConditionBuilder conditionBuilder) {\n        this.queryFactory = queryFactory;\n        this.conditionBuilder = conditionBuilder;\n    }\n\n    public Optional<{Entity}JpaEntity> findById(Long id) {\n        {Entity}JpaEntity entity = queryFactory\n            .selectFrom({entity}JpaEntity)\n            .where(\n                {entity}JpaEntity.id.eq(id),\n                conditionBuilder.deletedAtIsNull()\n            )\n            .fetchOne();\n        return Optional.ofNullable(entity);\n    }\n\n    public List<{Entity}JpaEntity> findBySliceCriteria({Entity}SliceCriteria criteria) {\n        return queryFactory\n            .selectFrom({entity}JpaEntity)\n            .where(conditionBuilder.buildFromCriteria(criteria))\n            .orderBy({entity}JpaEntity.id.desc())\n            .limit(criteria.size())\n            .fetch();\n    }\n}','{Entity}QueryDslRepository',NULL,NULL,NULL,NULL,NULL,'Query용. 모든 조회 담당. ConditionBuilder 주입','2026-01-21 07:43:45.000000','2026-01-21 07:43:45.000000',NULL),(66,41,0,'import static {base_package}.{domain}.entity.Q{Entity}JpaEntity.{entity}JpaEntity;\n\n@Component\npublic class {Entity}ConditionBuilder {\n\n    public BooleanExpression deletedAtIsNull() {\n        return {entity}JpaEntity.deletedAt.isNull();\n    }\n\n    public BooleanExpression idEq(Long id) {\n        return id != null ? {entity}JpaEntity.id.eq(id) : null;\n    }\n\n    public BooleanExpression cursorLt(Long cursor) {\n        return cursor != null ? {entity}JpaEntity.id.lt(cursor) : null;\n    }\n\n    public BooleanBuilder buildFromCriteria({Entity}SliceCriteria criteria) {\n        BooleanBuilder builder = new BooleanBuilder();\n        builder.and(deletedAtIsNull());\n        builder.and(cursorLt(criteria.cursor()));\n        // 추가 조건...\n        return builder;\n    }\n\n    /**\n     * 풀텍스트 검색 조건 (MySQL MATCH AGAINST)\n     */\n    public BooleanExpression fullTextSearch(String keyword) {\n        if (keyword == null || keyword.isBlank()) {\n            return null;\n        }\n        return Expressions.numberTemplate(\n            Double.class,\n            \"function(\'match_against\', {0}, {1})\",\n            {entity}JpaEntity.name,\n            \"+\" + keyword + \"*\"\n        ).gt(0);\n    }\n}','{Entity}ConditionBuilder','[\"@Component\"]',NULL,NULL,NULL,NULL,'BooleanExpression/BooleanBuilder 생성 전담. FullText 검색 지원','2026-01-21 07:43:56.000000','2026-01-21 07:43:56.000000','2026-01-28 03:03:30.000000'),(67,42,0,'@MappedSuperclass\npublic abstract class BaseAuditEntity {\n\n    @Column(name = \"created_at\", nullable = false, updatable = false)\n    private Instant createdAt;\n\n    @Column(name = \"updated_at\", nullable = false)\n    private Instant updatedAt;\n\n    protected BaseAuditEntity() {}\n\n    protected BaseAuditEntity(Instant createdAt, Instant updatedAt) {\n        this.createdAt = createdAt;\n        this.updatedAt = updatedAt;\n    }\n\n    public Instant getCreatedAt() { return createdAt; }\n    public Instant getUpdatedAt() { return updatedAt; }\n}','BaseAuditEntity','[\"@MappedSuperclass\"]',NULL,NULL,NULL,NULL,'감사 필드 제공. 모든 Entity의 상위 클래스','2026-01-21 07:44:05.000000','2026-01-21 07:44:05.000000','2026-01-28 03:03:30.000000'),(68,42,0,'@MappedSuperclass\npublic abstract class SoftDeletableEntity extends BaseAuditEntity {\n\n    @Column(name = \"deleted_at\")\n    private Instant deletedAt;\n\n    protected SoftDeletableEntity() { super(); }\n\n    protected SoftDeletableEntity(Instant createdAt, Instant updatedAt) {\n        super(createdAt, updatedAt);\n        this.deletedAt = null;\n    }\n\n    protected SoftDeletableEntity(Instant createdAt, Instant updatedAt, Instant deletedAt) {\n        super(createdAt, updatedAt);\n        this.deletedAt = deletedAt;\n    }\n\n    public Instant getDeletedAt() { return deletedAt; }\n    public boolean isDeleted() { return deletedAt != null; }\n    public boolean isActive() { return deletedAt == null; }\n}','SoftDeletableEntity','[\"@MappedSuperclass\"]',NULL,NULL,NULL,NULL,'소프트 삭제 지원. BaseAuditEntity 상속','2026-01-21 07:44:05.000000','2026-01-21 07:44:05.000000','2026-01-28 03:03:30.000000'),(69,43,0,'@Configuration\n@EntityScan(basePackages = \"{base_package}\")\n@EnableJpaRepositories(basePackages = \"{base_package}\")\n@EnableJpaAuditing\n@EnableTransactionManagement\npublic class JpaConfig {\n\n    @Bean\n    public JPAQueryFactory jpaQueryFactory(EntityManager entityManager) {\n        return new JPAQueryFactory(entityManager);\n    }\n\n    @Bean(name = \"persistenceJsonObjectMapper\")\n    public ObjectMapper persistenceJsonObjectMapper() {\n        ObjectMapper objectMapper = new ObjectMapper();\n        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n        return objectMapper;\n    }\n}','JpaConfig','[\"@Configuration\", \"@EntityScan\", \"@EnableJpaRepositories\", \"@EnableJpaAuditing\", \"@EnableTransactionManagement\"]',NULL,NULL,NULL,NULL,'JPA/QueryDSL/ObjectMapper 설정','2026-01-21 07:44:16.000000','2026-01-21 07:44:16.000000','2026-01-28 03:03:30.000000'),(70,43,0,'@Component\npublic class PersistenceObjectMapper {\n\n    private static final TypeReference<List<String>> LIST_STRING_TYPE = new TypeReference<>() {};\n    private final ObjectMapper objectMapper;\n\n    public PersistenceObjectMapper(\n            @Qualifier(\"persistenceJsonObjectMapper\") ObjectMapper objectMapper) {\n        this.objectMapper = objectMapper;\n    }\n\n    public <T> T readValue(String json, TypeReference<T> typeReference) {\n        if (json == null || json.isBlank()) {\n            throw new IllegalArgumentException(\"JSON string cannot be null or blank\");\n        }\n        try {\n            return objectMapper.readValue(json, typeReference);\n        } catch (JsonProcessingException e) {\n            throw new IllegalArgumentException(\"Failed to parse JSON: \" + e.getMessage(), e);\n        }\n    }\n\n    public List<String> readValueAsStringList(String json) {\n        if (json == null || json.isBlank()) return List.of();\n        try {\n            return objectMapper.readValue(json, LIST_STRING_TYPE);\n        } catch (JsonProcessingException e) {\n            throw new IllegalArgumentException(\"Failed to parse JSON array: \" + e.getMessage(), e);\n        }\n    }\n\n    public <T> String writeValueAsString(T value) {\n        if (value == null) return \"null\";\n        try {\n            return objectMapper.writeValueAsString(value);\n        } catch (JsonProcessingException e) {\n            throw new IllegalArgumentException(\"Failed to serialize: \" + e.getMessage(), e);\n        }\n    }\n}','PersistenceObjectMapper','[\"@Component\"]',NULL,NULL,NULL,NULL,'JSON 파싱 래퍼. 에러 처리 중앙화','2026-01-21 07:44:16.000000','2026-01-21 07:44:16.000000','2026-01-28 03:03:30.000000'),(71,44,0,'/**\n * SliceCriteria - 커서 기반 페이징 조건\n *\n * @param cursor 마지막 조회 ID (nullable, 첫 페이지면 null)\n * @param size 조회 크기\n * @param direction 정렬 방향 (기본: DESC)\n */\npublic record SliceCriteria(\n    Long cursor,\n    int size,\n    SortDirection direction\n) {\n    public SliceCriteria {\n        if (size <= 0) {\n            throw new IllegalArgumentException(\"Size must be positive\");\n        }\n        if (direction == null) {\n            direction = SortDirection.DESC;\n        }\n    }\n\n    public static SliceCriteria of(Long cursor, int size) {\n        return new SliceCriteria(cursor, size, SortDirection.DESC);\n    }\n\n    public enum SortDirection { ASC, DESC }\n}','SliceCriteria',NULL,NULL,NULL,NULL,NULL,'커서 기반 페이징 조건. Persistence DTO','2026-01-21 07:44:28.000000','2026-01-21 07:44:28.000000','2026-01-28 03:03:30.000000'),(72,44,0,'/**\n * SortCriteria - 정렬 조건\n *\n * @param field 정렬 필드명\n * @param direction 정렬 방향\n */\npublic record SortCriteria(\n    String field,\n    SortDirection direction\n) {\n    public SortCriteria {\n        if (field == null || field.isBlank()) {\n            throw new IllegalArgumentException(\"Sort field cannot be blank\");\n        }\n        if (direction == null) {\n            direction = SortDirection.DESC;\n        }\n    }\n\n    public enum SortDirection { ASC, DESC }\n}','SortCriteria',NULL,NULL,NULL,NULL,NULL,'정렬 조건. Persistence DTO','2026-01-21 07:44:28.000000','2026-01-21 07:44:28.000000','2026-01-28 03:03:30.000000'),(73,44,0,'/**\n * SearchCriteria - 검색 조건\n *\n * @param keyword 검색어\n * @param searchType 검색 타입 (LIKE / FULL_TEXT)\n */\npublic record SearchCriteria(\n    String keyword,\n    SearchType searchType\n) {\n    public SearchCriteria {\n        if (searchType == null) {\n            searchType = SearchType.LIKE;\n        }\n    }\n\n    public static SearchCriteria fullText(String keyword) {\n        return new SearchCriteria(keyword, SearchType.FULL_TEXT);\n    }\n\n    public static SearchCriteria like(String keyword) {\n        return new SearchCriteria(keyword, SearchType.LIKE);\n    }\n\n    public enum SearchType { LIKE, FULL_TEXT }\n}','SearchCriteria',NULL,NULL,NULL,NULL,NULL,'검색 조건. FullText 검색 지원. Persistence DTO','2026-01-21 07:44:28.000000','2026-01-21 07:44:28.000000','2026-01-28 03:03:30.000000'),(74,45,0,'import org.hibernate.boot.model.FunctionContributions;\nimport org.hibernate.boot.model.FunctionContributor;\nimport org.hibernate.type.BasicTypeRegistry;\nimport org.hibernate.type.StandardBasicTypes;\n\n/**\n * MatchAgainstFunctionContributor - MySQL MATCH AGAINST 함수 등록\n *\n * <p>Hibernate 6에서 커스텀 SQL 함수를 등록합니다.\n *\n * <p>사용: resources/META-INF/services/org.hibernate.boot.model.FunctionContributor\n *       에 FQCN 등록 필요\n */\npublic class MatchAgainstFunctionContributor implements FunctionContributor {\n\n    @Override\n    public void contributeFunctions(FunctionContributions functionContributions) {\n        functionContributions.getFunctionRegistry().registerPattern(\n            \"match_against\",\n            \"MATCH(?1) AGAINST(?2 IN BOOLEAN MODE)\",\n            functionContributions.getTypeConfiguration()\n                .getBasicTypeRegistry()\n                .resolve(StandardBasicTypes.DOUBLE)\n        );\n    }\n}','MatchAgainstFunctionContributor',NULL,NULL,'[\"FunctionContributor\"]',NULL,NULL,'MySQL MATCH AGAINST 함수 등록. META-INF/services 등록 필요','2026-01-21 07:44:38.000000','2026-01-21 07:44:38.000000','2026-01-28 03:03:30.000000'),(75,46,0,'@Component\npublic class {Entity}AdminQueryAdapter implements {Entity}AdminQueryPort {\n    \n    private final {Entity}AdminQueryDslRepository adminQueryDslRepository;\n    private final {Entity}EntityMapper mapper;\n    \n    public {Entity}AdminQueryAdapter(\n            {Entity}AdminQueryDslRepository adminQueryDslRepository,\n            {Entity}EntityMapper mapper) {\n        this.adminQueryDslRepository = adminQueryDslRepository;\n        this.mapper = mapper;\n    }\n    \n    // Admin용 복잡 조회 메서드 구현\n    // 조인, 서브쿼리 등 허용\n}','{Entity}AdminQueryAdapter','[\"@Component\"]',NULL,NULL,NULL,NULL,'Admin용 QueryPort 구현체. AdminQueryDslRepository만 의존.','2026-01-21 07:58:32.000000','2026-01-21 07:58:32.000000','2026-01-28 03:03:30.000000'),(76,46,0,'@Repository\npublic class {Entity}AdminQueryDslRepository {\n    \n    private final JPAQueryFactory queryFactory;\n    \n    public {Entity}AdminQueryDslRepository(JPAQueryFactory queryFactory) {\n        this.queryFactory = queryFactory;\n    }\n    \n    // 조인 허용\n    public List<{Entity}WithDetailDto> findWithDetails(Long id) {\n        return queryFactory\n            .select(Projections.constructor({Entity}WithDetailDto.class,\n                entity.id,\n                entity.name,\n                detail.value\n            ))\n            .from(entity)\n            .leftJoin(detail).on(detail.entityId.eq(entity.id))\n            .where(entity.id.eq(id))\n            .fetch();\n    }\n    \n    // 서브쿼리 허용\n    // 복잡한 통계 쿼리 허용\n}','{Entity}AdminQueryDslRepository','[\"@Repository\"]',NULL,NULL,NULL,NULL,'Admin용 복잡 쿼리 처리. 조인/서브쿼리 허용.','2026-01-21 07:58:32.000000','2026-01-21 07:58:32.000000','2026-01-28 03:03:30.000000'),(77,47,0,'/**\n * Admin용 Projection DTO\n * 여러 테이블 조인 결과를 담는 DTO\n */\npublic record {Purpose}Dto(\n    Long id,\n    String name,\n    // 조인된 테이블 데이터\n    String relatedValue,\n    Long relatedCount\n) {\n    // 정적 팩토리 메서드 (필요시)\n    public static {Purpose}Dto of(Long id, String name, String relatedValue, Long relatedCount) {\n        return new {Purpose}Dto(id, name, relatedValue, relatedCount);\n    }\n}','{Purpose}Dto',NULL,NULL,NULL,NULL,NULL,'조인 결과를 담는 Admin DTO. Record 사용 권장.','2026-01-21 07:58:32.000000','2026-01-21 07:58:32.000000','2026-01-28 03:03:30.000000'),(78,48,0,'@Configuration\npublic class AdminJpaConfig {\n    \n    // Read Replica DataSource 설정 (필요시)\n    // @Bean\n    // @Qualifier(\"adminDataSource\")\n    // public DataSource adminDataSource() { ... }\n    \n    // Admin 전용 EntityManagerFactory 설정 (필요시)\n    // Admin 전용 TransactionManager 설정 (필요시)\n}','AdminJpaConfig','[\"@Configuration\"]',NULL,NULL,NULL,NULL,'Admin 전용 JPA 설정. Read Replica 연결 등.','2026-01-21 07:58:32.000000','2026-01-21 07:58:32.000000','2026-01-28 03:03:30.000000'),(79,60,28,'/**\n * {Domain}CommandController - {Domain} 커맨드 API\n *\n * <p>생성, 수정, 삭제 등 상태 변경 엔드포인트를 제공합니다.\n *\n * <p>CTR-001: @RestController 어노테이션 필수\n * <p>CTR-003: UseCase(Port-In) 인터페이스 의존\n * <p>CTR-010: CQRS Controller 분리\n *\n * @author ryu-qqq\n */\n@Tag(name = \"{Domain}\", description = \"{Domain} 커맨드 API\")\n@RestController\n@RequestMapping({Domain}ApiEndpoints.{DOMAIN}S)\npublic class {Domain}CommandController {\n\n    private final Create{Domain}UseCase create{Domain}UseCase;\n    private final Update{Domain}UseCase update{Domain}UseCase;\n    private final Delete{Domain}UseCase delete{Domain}UseCase;\n    private final {Domain}CommandApiMapper mapper;\n\n    public {Domain}CommandController(\n            Create{Domain}UseCase create{Domain}UseCase,\n            Update{Domain}UseCase update{Domain}UseCase,\n            Delete{Domain}UseCase delete{Domain}UseCase,\n            {Domain}CommandApiMapper mapper) {\n        this.create{Domain}UseCase = create{Domain}UseCase;\n        this.update{Domain}UseCase = update{Domain}UseCase;\n        this.delete{Domain}UseCase = delete{Domain}UseCase;\n        this.mapper = mapper;\n    }\n\n    @Operation(summary = \"{Domain} 생성\")\n    @PostMapping\n    public ResponseEntity<ApiResponse<{Domain}IdApiResponse>> create(\n            @Valid @RequestBody Create{Domain}ApiRequest request) {\n        Create{Domain}Command command = mapper.toCommand(request);\n        Long id = create{Domain}UseCase.execute(command);\n        return ResponseEntity.status(HttpStatus.CREATED)\n                .body(ApiResponse.of({Domain}IdApiResponse.from(id)));\n    }\n\n    @Operation(summary = \"{Domain} 수정\")\n    @PutMapping({Domain}ApiEndpoints.{DOMAIN}_ID)\n    public ResponseEntity<ApiResponse<Void>> update(\n            @PathVariable({Domain}ApiEndpoints.PATH_{DOMAIN}_ID) Long {domain}Id,\n            @Valid @RequestBody Update{Domain}ApiRequest request) {\n        Update{Domain}Command command = mapper.toCommand({domain}Id, request);\n        update{Domain}UseCase.execute(command);\n        return ResponseEntity.ok(ApiResponse.empty());\n    }\n\n    @Operation(summary = \"{Domain} 삭제 (Soft Delete)\")\n    @PatchMapping({Domain}ApiEndpoints.{DOMAIN}_ID + \"/delete\")\n    public ResponseEntity<ApiResponse<Void>> delete(\n            @PathVariable({Domain}ApiEndpoints.PATH_{DOMAIN}_ID) Long {domain}Id) {\n        delete{Domain}UseCase.execute({domain}Id);\n        return ResponseEntity.ok(ApiResponse.empty());\n    }\n}','{Domain}CommandController','[\"@RestController\", \"@RequestMapping\", \"@Tag\"]','[\"@Transactional\", \"@Service\"]',NULL,NULL,'[\"create\", \"update\", \"delete\"]','CQRS 패턴의 커맨드 컨트롤러. POST/PUT/PATCH 엔드포인트 담당. DELETE 메서드 금지.','2026-01-21 13:29:19.000000','2026-01-21 13:29:19.000000',NULL),(80,61,29,'/**\n * {Domain}QueryController - {Domain} 조회 API\n *\n * <p>단건 조회, 목록 조회 등 읽기 엔드포인트를 제공합니다.\n *\n * <p>CTR-001: @RestController 어노테이션 필수\n * <p>CTR-003: UseCase(Port-In) 인터페이스 의존\n * <p>CTR-011: List 직접 반환 금지 -> SliceApiResponse 페이징 필수\n *\n * @author ryu-qqq\n */\n@Tag(name = \"{Domain}\", description = \"{Domain} 조회 API\")\n@RestController\n@RequestMapping({Domain}ApiEndpoints.{DOMAIN}S)\npublic class {Domain}QueryController {\n\n    private final Get{Domain}ByIdUseCase get{Domain}ByIdUseCase;\n    private final GetAll{Domain}sUseCase getAll{Domain}sUseCase;\n    private final {Domain}QueryApiMapper mapper;\n\n    public {Domain}QueryController(\n            Get{Domain}ByIdUseCase get{Domain}ByIdUseCase,\n            GetAll{Domain}sUseCase getAll{Domain}sUseCase,\n            {Domain}QueryApiMapper mapper) {\n        this.get{Domain}ByIdUseCase = get{Domain}ByIdUseCase;\n        this.getAll{Domain}sUseCase = getAll{Domain}sUseCase;\n        this.mapper = mapper;\n    }\n\n    @Operation(summary = \"{Domain} 목록 조회\")\n    @GetMapping\n    public ResponseEntity<ApiResponse<SliceApiResponse<{Domain}ApiResponse>>> findAll(\n            @Valid GetAll{Domain}sApiRequest request) {\n        GetAll{Domain}sQuery query = mapper.toQuery(request);\n        {Domain}SliceResult sliceResult = getAll{Domain}sUseCase.execute(query);\n        SliceApiResponse<{Domain}ApiResponse> response = mapper.toSliceResponse(sliceResult);\n        return ResponseEntity.ok(ApiResponse.of(response));\n    }\n\n    @Operation(summary = \"{Domain} 단건 조회\")\n    @GetMapping({Domain}ApiEndpoints.{DOMAIN}_ID)\n    public ResponseEntity<ApiResponse<{Domain}ApiResponse>> findById(\n            @PathVariable({Domain}ApiEndpoints.PATH_{DOMAIN}_ID) Long {domain}Id) {\n        {Domain}Result result = get{Domain}ByIdUseCase.execute({domain}Id);\n        {Domain}ApiResponse response = mapper.toResponse(result);\n        return ResponseEntity.ok(ApiResponse.of(response));\n    }\n}','{Domain}QueryController','[\"@RestController\", \"@RequestMapping\", \"@Tag\"]','[\"@Transactional\", \"@Service\"]',NULL,NULL,'[\"findAll\", \"findById\"]','CQRS 패턴의 쿼리 컨트롤러. GET 엔드포인트 담당. List 직접 반환 금지.','2026-01-21 13:29:30.000000','2026-01-21 13:29:30.000000',NULL),(81,53,0,'/**\n * {Domain}CommandApiMapper - {Domain} 커맨드 API 매퍼\n *\n * <p>API Request → Application Command 변환을 담당합니다.\n *\n * <p>MAP-001: @Component 필수\n * <p>MAP-005: 순수 변환 로직만 포함\n * <p>MAP-006: 기본값 처리 담당\n *\n * @author ryu-qqq\n */\n@Component\npublic class {Domain}CommandApiMapper {\n\n    public Create{Domain}Command toCommand(Create{Domain}ApiRequest request) {\n        return Create{Domain}Command.of(\n                request.name(),\n                request.description()\n        );\n    }\n\n    public Update{Domain}Command toCommand(Long {domain}Id, Update{Domain}ApiRequest request) {\n        return Update{Domain}Command.of(\n                {domain}Id,\n                request.name(),\n                request.description()\n        );\n    }\n}','{Domain}CommandApiMapper','[\"@Component\"]','[\"@Service\", \"@Repository\", \"@Transactional\"]',NULL,NULL,'[\"toCommand\"]','커맨드 API 매퍼. Request DTO → Command 변환. 기본값 처리 담당.','2026-01-21 13:29:39.000000','2026-01-21 13:29:39.000000','2026-01-28 03:03:30.000000'),(82,53,0,'/**\n * {Domain}QueryApiMapper - {Domain} 쿼리 API 매퍼\n *\n * <p>Request → Query 변환 및 Result → Response 변환을 담당합니다.\n *\n * <p>MAP-001: @Component 필수\n * <p>MAP-003: 날짜 포맷팅 담당 (Instant → String)\n * <p>MAP-004: Slice/Page 변환 지원\n * <p>MAP-006: 기본값 처리 담당\n *\n * @author ryu-qqq\n */\n@Component\npublic class {Domain}QueryApiMapper {\n\n    private static final int DEFAULT_SIZE = 20;\n\n    public GetAll{Domain}sQuery toQuery(GetAll{Domain}sApiRequest request) {\n        Long cursor = request.cursor();\n        int size = request.size() != null && request.size() > 0 \n                ? request.size() \n                : DEFAULT_SIZE;\n        CommonCursorParams cursorParams = CommonCursorParams.of(cursor, size);\n        return GetAll{Domain}sQuery.of(request.filterField(), cursorParams);\n    }\n\n    public SliceApiResponse<{Domain}ApiResponse> toSliceResponse({Domain}SliceResult sliceResult) {\n        List<{Domain}ApiResponse> content = sliceResult.content().stream()\n                .map(this::toResponse)\n                .toList();\n        SliceMeta sliceMeta = sliceResult.sliceMeta();\n        return SliceApiResponse.of(content, sliceMeta.size(), sliceMeta.hasNext(), sliceMeta.cursor());\n    }\n\n    public {Domain}ApiResponse toResponse({Domain}Result result) {\n        return {Domain}ApiResponse.of(\n                result.id(),\n                result.name(),\n                result.description(),\n                DateTimeFormatUtils.toIso8601(result.createdAt()),\n                DateTimeFormatUtils.toIso8601(result.updatedAt())\n        );\n    }\n}','{Domain}QueryApiMapper','[\"@Component\"]','[\"@Service\", \"@Repository\", \"@Transactional\"]',NULL,NULL,'[\"toQuery\", \"toSliceResponse\", \"toResponse\"]','쿼리 API 매퍼. Request → Query, Result → Response 변환. 날짜 포맷팅 및 기본값 처리 담당.','2026-01-21 13:29:50.000000','2026-01-21 13:29:50.000000','2026-01-28 03:03:30.000000'),(83,62,0,'/**\n * Create{Domain}ApiRequest - {Domain} 생성 요청 DTO\n *\n * <p>DTO-001: Record 타입 필수\n * <p>DTO-003: Validation 어노테이션 필수\n *\n * @author ryu-qqq\n */\n@Schema(description = \"{Domain} 생성 요청\")\npublic record Create{Domain}ApiRequest(\n        @Schema(description = \"이름\", example = \"예시 이름\")\n        @NotBlank(message = \"이름은 필수입니다\")\n        String name,\n\n        @Schema(description = \"설명\", example = \"예시 설명\")\n        String description\n) {\n    public static Create{Domain}ApiRequest of(String name, String description) {\n        return new Create{Domain}ApiRequest(name, description);\n    }\n}','Create{Domain}ApiRequest','[\"@Schema\"]','[\"@Data\", \"@Getter\", \"@Setter\", \"@Builder\"]',NULL,NULL,NULL,'API 요청 DTO. Record 타입 + Validation 어노테이션 필수.','2026-01-21 13:30:01.000000','2026-01-21 13:30:01.000000','2026-01-28 03:03:30.000000'),(84,63,0,'/**\n * {Domain}ApiResponse - {Domain} 응답 DTO\n *\n * <p>DTO-001: Record 타입 필수\n * <p>DTO-004: createdAt/updatedAt 필수\n * <p>DTO-005: 날짜 String 변환 필수 (Mapper에서 처리)\n *\n * @author ryu-qqq\n */\n@Schema(description = \"{Domain} 응답\")\npublic record {Domain}ApiResponse(\n        @Schema(description = \"ID\")\n        Long id,\n\n        @Schema(description = \"이름\")\n        String name,\n\n        @Schema(description = \"설명\")\n        String description,\n\n        @Schema(description = \"생성일시\", example = \"2024-01-01T00:00:00Z\")\n        String createdAt,\n\n        @Schema(description = \"수정일시\", example = \"2024-01-01T00:00:00Z\")\n        String updatedAt\n) {\n    public static {Domain}ApiResponse of(\n            Long id, String name, String description, \n            String createdAt, String updatedAt) {\n        return new {Domain}ApiResponse(id, name, description, createdAt, updatedAt);\n    }\n}','{Domain}ApiResponse','[\"@Schema\"]','[\"@Data\", \"@Getter\", \"@Setter\", \"@Builder\"]',NULL,NULL,'[\"of\"]','API 응답 DTO. Record 타입 + createdAt/updatedAt 필수. 날짜는 ISO8601 String.','2026-01-21 13:30:09.000000','2026-01-21 13:30:09.000000','2026-01-28 03:03:30.000000'),(85,52,0,'/**\n * {Domain}ErrorMapper - {Domain} 예외 매핑\n *\n * <p>도메인 예외를 HTTP 응답으로 변환합니다.\n *\n * <p>API-ERR-001: ErrorMapper 패턴\n * <p>API-ERR-002: ProblemDetail 응답 (RFC 7807)\n *\n * @author ryu-qqq\n */\n@Component\npublic class {Domain}ErrorMapper implements ErrorMapper {\n\n    @Override\n    public boolean supports(DomainException ex) {\n        return ex instanceof {Domain}NotFoundException\n                || ex instanceof {Domain}DuplicateException;\n    }\n\n    @Override\n    public MappedError map(DomainException ex, Locale locale) {\n        if (ex instanceof {Domain}NotFoundException) {\n            return MappedError.of(\n                    HttpStatus.NOT_FOUND,\n                    \"{Domain} Not Found\",\n                    ex.getMessage(),\n                    URI.create(\"/errors/{domain}/not-found\")\n            );\n        }\n        if (ex instanceof {Domain}DuplicateException) {\n            return MappedError.of(\n                    HttpStatus.CONFLICT,\n                    \"{Domain} Duplicate\",\n                    ex.getMessage(),\n                    URI.create(\"/errors/{domain}/duplicate\")\n            );\n        }\n        throw new IllegalArgumentException(\"Unsupported exception: \" + ex.getClass());\n    }\n}','{Domain}ErrorMapper','[\"@Component\"]','[\"@Service\", \"@Repository\"]','[\"ErrorMapper\"]',NULL,'[\"supports\", \"map\"]','도메인 예외 매퍼. DomainException → ProblemDetail(RFC 7807) 변환.','2026-01-21 13:30:18.000000','2026-01-21 13:30:18.000000','2026-01-28 03:03:30.000000'),(86,49,0,'/**\n * {Domain}ApiEndpoints - {Domain} API 엔드포인트 상수\n *\n * <p>API-END-001: final class로 선언\n * <p>API-END-002: static final 상수\n * <p>API-END-003: Path Variable 상수\n *\n * @author ryu-qqq\n */\npublic final class {Domain}ApiEndpoints {\n\n    private {Domain}ApiEndpoints() {\n        // 인스턴스화 방지\n    }\n\n    /** 기본 경로: /{domain}s */\n    public static final String {DOMAIN}S = \"/{domain}s\";\n\n    /** 단건 경로: /{domain}s/{id} */\n    public static final String {DOMAIN}_ID = \"/{\" + PATH_{DOMAIN}_ID + \"}\";\n\n    /** Path Variable: {domain}Id */\n    public static final String PATH_{DOMAIN}_ID = \"{domain}Id\";\n}','{Domain}ApiEndpoints',NULL,'[\"@Component\", \"@Service\", \"@Repository\"]',NULL,NULL,NULL,'API 엔드포인트 상수 클래스. final class + private 생성자 + static final 상수.','2026-01-21 13:30:27.000000','2026-01-21 13:30:27.000000','2026-01-28 03:03:30.000000'),(87,5,0,'/**\n * DateField - 날짜 필드 마커 인터페이스\n *\n * <p>각 Bounded Context에서 날짜 범위 필터링에 사용할 수 있는 날짜 필드를 enum으로 정의할 때 구현합니다.\n *\n * <p><strong>설계 원칙:</strong>\n *\n * <ul>\n *   <li>각 BC는 자신만의 DateField enum을 정의\n *   <li>날짜 범위 필터링 가능한 필드만 enum 값으로 노출\n *   <li>DB 컬럼명은 Adapter에서 매핑 (도메인 언어 유지)\n * </ul>\n *\n * <p><strong>구현 예시:</strong>\n *\n * <pre>{@code\n * public enum OrderDateField implements DateField {\n *     ORDER_DATE(\"orderDate\"), PAYMENT_DATE(\"paymentDate\"), DELIVERY_DATE(\"deliveryDate\");\n *\n *     private final String fieldName;\n *\n *     OrderDateField(String fieldName) {\n *         this.fieldName = fieldName;\n *     }\n *\n *     @Override\n *     public String fieldName() {\n *         return fieldName;\n *     }\n * }\n * }</pre>\n *\n * <p>VO-002: Lombok 사용이 금지됩니다.\n *\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic interface DateField {\n\n    /**\n     * 날짜 필드명 반환\n     *\n     * @return 필드명 (예: \"orderDate\", \"createdAt\")\n     */\n    String fieldName();\n\n    /**\n     * enum 이름 반환 (기본 구현)\n     *\n     * @return enum 상수 이름\n     */\n    default String name() {\n        return this.toString();\n    }\n}','{Domain}DateField',NULL,'[\"lombok.*\"]','[\"DateField\"]',NULL,'[\"fieldName\"]','DateField - 날짜 필드 마커 인터페이스. BC별 날짜 필드 enum이 구현합니다.','2026-01-25 10:55:41.000000','2026-01-25 10:55:41.000000','2026-01-28 03:03:30.000000'),(88,5,0,'/**\n * SearchField - 검색 필드 마커 인터페이스\n *\n * <p>각 Bounded Context에서 검색 가능한 필드를 enum으로 정의할 때 구현합니다.\n *\n * <p><strong>설계 원칙:</strong>\n *\n * <ul>\n *   <li>각 BC는 자신만의 SearchField enum을 정의\n *   <li>검색 가능한 필드만 enum 값으로 노출\n *   <li>DB 컬럼명은 Adapter에서 매핑 (도메인 언어 유지)\n * </ul>\n *\n * <p><strong>구현 예시:</strong>\n *\n * <pre>{@code\n * public enum OrderSearchField implements SearchField {\n *     ORDER_NUMBER(\"orderNumber\"), CUSTOMER_NAME(\"customerName\");\n *\n *     private final String fieldName;\n *\n *     OrderSearchField(String fieldName) {\n *         this.fieldName = fieldName;\n *     }\n *\n *     @Override\n *     public String fieldName() {\n *         return fieldName;\n *     }\n * }\n * }</pre>\n *\n * <p>VO-002: Lombok 사용이 금지됩니다.\n *\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic interface SearchField {\n\n    /**\n     * 검색 필드명 반환\n     *\n     * @return 필드명 (예: \"code\", \"name\")\n     */\n    String fieldName();\n\n    /**\n     * enum 이름 반환 (기본 구현)\n     *\n     * @return enum 상수 이름\n     */\n    default String name() {\n        return this.toString();\n    }\n}','{Domain}SearchField',NULL,'[\"lombok.*\"]','[\"SearchField\"]',NULL,'[\"fieldName\"]','SearchField - 검색 필드 마커 인터페이스. BC별 검색 필드 enum이 구현합니다.','2026-01-25 10:55:53.000000','2026-01-25 10:55:53.000000','2026-01-28 03:03:30.000000'),(89,5,9,'/**\n * ErrorCode - 비즈니스 예외 에러 코드 인터페이스\n *\n * <p>모든 비즈니스 예외는 ErrorCode를 구현하여 일관된 에러 정보를 제공합니다.\n *\n * <p><strong>설계 원칙:</strong>\n *\n * <ul>\n *   <li>Bounded Context별 ErrorCode enum 구현\n *   <li>HTTP Status와 에러 코드 매핑\n *   <li>명확한 에러 메시지 제공\n * </ul>\n *\n * <p><strong>구현 예시:</strong>\n *\n * <pre>{@code\n * public enum OrderErrorCode implements ErrorCode {\n *     ORDER_NOT_FOUND(\"ORDER-001\", 404, \"Order not found\"),\n *     INVALID_ORDER_STATUS(\"ORDER-002\", 400, \"Invalid order status\");\n *\n *     private final String code;\n *     private final int httpStatus;\n *     private final String message;\n *\n *     OrderErrorCode(String code, int httpStatus, String message) {\n *         this.code = code;\n *         this.httpStatus = httpStatus;\n *         this.message = message;\n *     }\n *\n *     @Override public String getCode() { return code; }\n *     @Override public int getHttpStatus() { return httpStatus; }\n *     @Override public String getMessage() { return message; }\n * }\n * }</pre>\n *\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic interface ErrorCode {\n\n    /**\n     * 에러 코드 반환\n     *\n     * <p>형식: {CONTEXT}-{NUMBER} (예: ORDER-001)\n     *\n     * @return 에러 코드 문자열\n     */\n    String getCode();\n\n    /**\n     * HTTP 상태 코드 반환\n     *\n     * @return HTTP 상태 코드 (예: 404, 400, 500)\n     */\n    int getHttpStatus();\n\n    /**\n     * 에러 메시지 반환\n     *\n     * @return 에러 메시지 문자열\n     */\n    String getMessage();\n}','{Domain}ErrorCode',NULL,'[\"lombok.*\"]','[\"ErrorCode\"]',NULL,'[\"getCode\", \"getHttpStatus\", \"getMessage\"]','ErrorCode - 비즈니스 예외 에러 코드 인터페이스. BC별 ErrorCode enum이 구현합니다.','2026-01-25 10:56:07.000000','2026-01-25 10:56:07.000000','2026-01-27 11:30:22.000000'),(90,5,0,'/**\n * DomainException - Domain Layer 예외의 최상위 클래스\n *\n * <p>모든 비즈니스 예외는 이 클래스를 상속해야 합니다.\n *\n * <p><strong>설계 원칙:</strong>\n *\n * <ul>\n *   <li>Spring 의존성 금지 (HttpStatus 대신 int 사용)\n *   <li>ErrorCode 객체 기반 (에러 코드, HTTP 상태, 메시지 캡슐화)\n *   <li>RuntimeException 상속 (Unchecked Exception)\n * </ul>\n *\n * <p><strong>사용 예시:</strong>\n *\n * <pre>{@code\n * public class OrderNotFoundException extends DomainException {\n *     public OrderNotFoundException(Long orderId) {\n *         super(\n *             OrderErrorCode.ORDER_NOT_FOUND,\n *             String.format(\"Order not found: %d\", orderId),\n *             Map.of(\"orderId\", orderId)\n *         );\n *     }\n * }\n * }</pre>\n *\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic class DomainException extends RuntimeException {\n\n    private final ErrorCode errorCode;\n    private final Map<String, Object> args;\n\n    protected DomainException(ErrorCode errorCode) {\n        super(errorCode.getMessage());\n        this.errorCode = errorCode;\n        this.args = Collections.emptyMap();\n    }\n\n    protected DomainException(ErrorCode errorCode, String message) {\n        super(message);\n        this.errorCode = errorCode;\n        this.args = Collections.emptyMap();\n    }\n\n    protected DomainException(ErrorCode errorCode, String message, Map<String, Object> args) {\n        super(message);\n        this.errorCode = errorCode;\n        this.args = args != null ? Map.copyOf(args) : Collections.emptyMap();\n    }\n\n    public ErrorCode getErrorCode() { return errorCode; }\n    public String code() { return errorCode.getCode(); }\n    public int httpStatus() { return errorCode.getHttpStatus(); }\n    public Map<String, Object> args() { return args; }\n}','{Domain}Exception',NULL,'[\"lombok.*\", \"org.springframework.*\"]',NULL,'[\"RuntimeException\"]','[\"getErrorCode\", \"code\", \"httpStatus\", \"args\"]','DomainException - Domain Layer 예외의 최상위 클래스. 모든 비즈니스 예외가 상속합니다.','2026-01-25 10:56:21.000000','2026-01-25 10:56:21.000000','2026-01-28 03:03:30.000000'),(91,5,5,'/**\n * DomainEvent - 도메인 이벤트 인터페이스\n *\n * <p>모든 도메인 이벤트는 이 인터페이스를 구현해야 합니다.\n *\n * <p><strong>구현 규칙</strong>:\n *\n * <ul>\n *   <li>Record 타입으로 구현 (불변성 보장)\n *   <li>occurredAt 필드 필수 (Instant 타입)\n *   <li>모든 필드는 Value Object 타입 사용\n *   <li>from(Aggregate, Instant) 정적 팩토리 메서드 제공\n * </ul>\n *\n * <p><strong>구현 예시</strong>:\n *\n * <pre>{@code\n * public record OrderCreatedEvent(\n *     OrderId orderId,\n *     MemberId memberId,\n *     Money totalAmount,\n *     Instant occurredAt\n * ) implements DomainEvent {\n *\n *     public static OrderCreatedEvent from(Order order, Instant occurredAt) {\n *         return new OrderCreatedEvent(\n *             order.id(),\n *             order.memberId(),\n *             order.totalAmount(),\n *             occurredAt\n *         );\n *     }\n * }\n * }</pre>\n *\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic interface DomainEvent {\n\n    /**\n     * 이벤트 발생 시각\n     *\n     * @return 이벤트가 생성된 시각\n     */\n    Instant occurredAt();\n\n    /**\n     * 이벤트 타입 식별자\n     *\n     * @return 이벤트 타입 문자열\n     */\n    default String eventType() {\n        return this.getClass().getSimpleName();\n    }\n}','{Domain}Event',NULL,'[\"lombok.*\"]','[\"DomainEvent\"]',NULL,'[\"occurredAt\"]','DomainEvent - 도메인 이벤트 인터페이스. Record로 구현하며 occurredAt 필수입니다.','2026-01-25 10:56:35.000000','2026-01-25 10:56:35.000000','2026-01-27 11:30:42.000000'),(92,64,0,'/**\n * ApplicationJsonConfig - Application 레이어 JSON 설정\n *\n * <p>Application 레이어에서 사용하는 ObjectMapper 빈을 등록합니다.\n *\n * @author ryu-qqq\n */\n@Configuration\npublic class ApplicationJsonConfig {\n\n    @Bean\n    @Primary\n    public ObjectMapper applicationObjectMapper() {\n        ObjectMapper objectMapper = new ObjectMapper();\n        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n        return objectMapper;\n    }\n}','*Config','[\"org.springframework.context.annotation.Configuration\"]','[\"lombok.*\"]',NULL,NULL,NULL,'ApplicationJsonConfig - Application 레이어 공통 설정 클래스.','2026-01-25 15:55:17.000000','2026-01-25 15:55:17.000000','2026-01-28 03:03:30.000000'),(93,65,0,'/**\n * Cache Port (출력 포트)\n *\n * <p>캐시 저장/조회/무효화를 위한 포트입니다.\n *\n * <p><strong>Cache-Aside 패턴:</strong>\n *\n * <ol>\n *   <li>Cache 조회 (CachePort.get)\n *   <li>Cache Miss → DB 조회 (QueryPort)\n *   <li>Cache 저장 (CachePort.set)\n * </ol>\n *\n * @param <T> 캐시 대상 타입\n * @author Development Team\n * @since 1.0.0\n * @see CacheKey\n */\npublic interface CachePort<T> {\n\n    /**\n     * 캐시 저장 (기본 TTL)\n     */\n    void set(CacheKey key, T value);\n\n    /**\n     * 캐시 저장 (TTL 지정)\n     */\n    void set(CacheKey key, T value, Duration ttl);\n\n    /**\n     * 캐시 조회\n     */\n    Optional<T> get(CacheKey key);\n\n    /**\n     * 캐시 무효화\n     */\n    void evict(CacheKey key);\n}','CachePort',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"set\", \"get\", \"evict\"]','CachePort - 캐시 저장/조회/무효화를 위한 공통 출력 포트.','2026-01-25 15:55:28.000000','2026-01-25 15:55:28.000000','2026-01-28 03:03:30.000000'),(94,65,0,'/**\n * 분산락 포트 (출력 포트)\n *\n * <p>Redisson 기반 분산락 추상화입니다.\n *\n * <p><strong>사용 예시:</strong>\n *\n * <pre>{@code\n * OrderLockKey lockKey = new OrderLockKey(orderId);\n * boolean acquired = lockPort.tryLock(lockKey, 10, 30, TimeUnit.SECONDS);\n *\n * if (!acquired) {\n *     throw new LockAcquisitionException(\"Lock 획득 실패\");\n * }\n *\n * try {\n *     // 비즈니스 로직\n * } finally {\n *     lockPort.unlock(lockKey);\n * }\n * }</pre>\n *\n * @author Development Team\n * @since 1.0.0\n * @see LockKey\n */\npublic interface DistributedLockPort {\n\n    /**\n     * 분산락 획득 시도\n     */\n    boolean tryLock(LockKey key, long waitTime, long leaseTime, TimeUnit unit);\n\n    /**\n     * 분산락 해제\n     */\n    void unlock(LockKey key);\n}','DistributedLockPort',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"tryLock\", \"unlock\"]','DistributedLockPort - Redisson 기반 분산락 공통 출력 포트.','2026-01-25 15:55:44.000000','2026-01-25 15:55:44.000000','2026-01-28 03:03:30.000000'),(95,65,0,'/**\n * ID 생성 Port (Outbound)\n *\n * <p>도메인 Aggregate ID 생성을 위한 Port입니다. \n * UUIDv7 기반의 시간 순서가 보장되는 고유 ID를 생성합니다.\n *\n * <p>구현체는 Adapter Layer에서 제공합니다.\n *\n * @author development-team\n * @since 1.0.0\n */\npublic interface IdGeneratorPort {\n\n    /**\n     * 새 ID 생성\n     *\n     * <p>UUIDv7 형식의 시간 순서가 보장되는 고유 ID를 생성합니다.\n     *\n     * @return 생성된 ID 문자열\n     */\n    String generate();\n}','IdGeneratorPort',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"generate\"]','IdGeneratorPort - UUIDv7 기반 ID 생성 공통 출력 포트.','2026-01-25 15:55:44.000000','2026-01-25 15:55:44.000000','2026-01-28 03:03:30.000000'),(96,66,0,'/**\n * 시간 제공자\n *\n * <p>시스템 시간을 제공하는 공통 컴포넌트입니다. \n * Clock을 캡슐화하여 테스트 용이성을 보장합니다.\n *\n * <p><strong>책임:</strong>\n *\n * <ul>\n *   <li>현재 시간(Instant) 제공\n *   <li>Clock 의존성 캡슐화\n * </ul>\n *\n * <p><strong>사용 예시:</strong>\n *\n * <pre>{@code\n * @Service\n * public class UpdateService {\n *     private final TimeProvider timeProvider;\n *\n *     public void execute(Command command) {\n *         aggregate.update(data, timeProvider.now());\n *     }\n * }\n * }</pre>\n *\n * @author development-team\n * @since 1.0.0\n */\n@Component\npublic class TimeProvider {\n\n    private final Clock clock;\n\n    public TimeProvider(Clock clock) {\n        this.clock = clock;\n    }\n\n    /**\n     * 현재 시간 반환\n     *\n     * @return 현재 Instant\n     */\n    public Instant now() {\n        return clock.instant();\n    }\n}','TimeProvider','[\"org.springframework.stereotype.Component\"]','[\"lombok.*\"]',NULL,NULL,'[\"now\"]','TimeProvider - Clock 기반 시간 제공 공통 컴포넌트.','2026-01-25 15:55:54.000000','2026-01-25 15:55:54.000000','2026-01-28 03:03:30.000000'),(97,31,0,'/**\n * 공통 커서 기반 페이징 파라미터\n *\n * <p>모든 Cursor Query에서 공통으로 사용하는 파라미터입니다. \n * Composition 방식으로 사용되며, SearchParams DTO는 delegate 메서드를 통해\n * 이 파라미터들을 노출해야 합니다.\n *\n * <p><strong>사용 규칙:</strong>\n *\n * <ul>\n *   <li>SearchParams는 이 record를 필드로 포함해야 함\n *   <li>SearchParams는 delegate 메서드를 제공하여 직접 접근 허용\n *   <li>중첩 접근(params.cursorParams().cursor()) 금지 - delegate 사용\n * </ul>\n *\n * <p><strong>기본값:</strong>\n *\n * <ul>\n *   <li>cursor: null (첫 페이지)\n *   <li>size: 20\n * </ul>\n *\n * @param cursor 커서 값 (null이면 첫 페이지)\n * @param size 페이지 크기 (기본: 20)\n * @author development-team\n * @since 1.0.0\n */\npublic record CommonCursorParams(String cursor, Integer size) {\n\n    private static final Integer DEFAULT_SIZE = 20;\n    private static final int MAX_SIZE = 100;\n\n    public CommonCursorParams {\n        if (size == null) {\n            size = DEFAULT_SIZE;\n        }\n        if (size <= 0) {\n            size = DEFAULT_SIZE;\n        }\n        if (size > MAX_SIZE) {\n            size = MAX_SIZE;\n        }\n    }\n\n    public boolean isFirstPage() {\n        return cursor == null || cursor.isBlank();\n    }\n}','CommonCursorParams',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"cursor\", \"size\", \"isFirstPage\"]','CommonCursorParams - 공통 커서 기반 페이징 파라미터 DTO.','2026-01-25 15:56:16.000000','2026-01-25 15:56:16.000000','2026-01-28 03:03:30.000000'),(98,31,0,'/**\n * 공통 검색 파라미터\n *\n * <p>모든 Search Query에서 공통으로 사용하는 파라미터입니다. \n * Composition 방식으로 사용되며, Query DTO는 delegate 메서드를 통해 이\n * 파라미터들을 노출해야 합니다.\n *\n * <p><strong>사용 규칙:</strong>\n *\n * <ul>\n *   <li>SearchQuery는 이 record를 필드로 포함해야 함\n *   <li>SearchQuery는 delegate 메서드를 제공하여 직접 접근 허용\n *   <li>중첩 접근(query.searchParams().page()) 금지 - delegate 사용\n * </ul>\n *\n * <p><strong>기본값:</strong>\n *\n * <ul>\n *   <li>includeDeleted: false\n *   <li>sortKey: \"createdAt\"\n *   <li>sortDirection: \"DESC\"\n *   <li>page: 0\n *   <li>size: 20\n * </ul>\n *\n * @param includeDeleted 삭제된 항목 포함 여부\n * @param startDate 조회 시작일\n * @param endDate 조회 종료일\n * @param sortKey 정렬 기준\n * @param sortDirection 정렬 방향\n * @param page 페이지 번호\n * @param size 페이지 크기\n * @author development-team\n * @since 1.0.0\n */\npublic record CommonSearchParams(\n        Boolean includeDeleted,\n        LocalDate startDate,\n        LocalDate endDate,\n        String sortKey,\n        String sortDirection,\n        Integer page,\n        Integer size) {\n\n    private static final Boolean DEFAULT_INCLUDE_DELETED = false;\n    private static final String DEFAULT_SORT_KEY = \"createdAt\";\n    private static final String DEFAULT_SORT_DIRECTION = \"DESC\";\n    private static final Integer DEFAULT_PAGE = 0;\n    private static final Integer DEFAULT_SIZE = 20;\n\n    public CommonSearchParams {\n        if (includeDeleted == null) includeDeleted = DEFAULT_INCLUDE_DELETED;\n        if (sortKey == null || sortKey.isBlank()) sortKey = DEFAULT_SORT_KEY;\n        if (sortDirection == null || sortDirection.isBlank()) sortDirection = DEFAULT_SORT_DIRECTION;\n        if (page == null || page < 0) page = DEFAULT_PAGE;\n        if (size == null || size <= 0) size = DEFAULT_SIZE;\n    }\n}','CommonSearchParams',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"includeDeleted\", \"startDate\", \"endDate\", \"sortKey\", \"sortDirection\", \"page\", \"size\"]','CommonSearchParams - 공통 검색 파라미터 DTO.','2026-01-25 15:56:16.000000','2026-01-25 15:56:16.000000','2026-01-28 03:03:30.000000'),(99,67,0,'/**\n * ApiPaths - 서비스 공통 API 경로 상수\n *\n * <p>모든 API 경로의 기본이 되는 상수들을 정의합니다.\n *\n * @author ryu-qqq\n */\npublic final class ApiPaths {\n\n    private ApiPaths() {\n        // Utility class\n    }\n\n    /** API 버전 */\n    public static final String API_VERSION = \"/api/v1\";\n\n    /** 서비스 기본 경로 */\n    public static final String SERVICE_BASE = API_VERSION + \"/standards\";\n\n    /** MCP 경로 */\n    public static final String MCP = API_VERSION + \"/mcp\";\n\n    /** API 문서 경로 */\n    public static final String DOCS = \"/docs\";\n    public static final String DOCS_PATTERN = \"/docs/**\";\n}','ApiPaths',NULL,'[\"lombok.*\"]',NULL,NULL,NULL,'ApiPaths - REST API 공통 경로 상수 클래스.','2026-01-25 16:01:21.000000','2026-01-25 16:01:21.000000','2026-01-28 03:03:30.000000'),(100,68,0,'/**\n * API 문서 컨트롤러\n *\n * <p>Spring REST Docs 기반 API 문서 리다이렉트를 처리합니다.\n *\n * @author ryu-qqq\n */\n@Controller\npublic class ApiDocsController {\n\n    @GetMapping(ApiPaths.DOCS)\n    public String redirectToDocs() {\n        return \"redirect:\" + ApiPaths.DOCS + \"/index.html\";\n    }\n}','ApiDocsController','[\"org.springframework.stereotype.Controller\"]','[\"lombok.*\"]',NULL,NULL,'[\"redirectToDocs\"]','ApiDocsController - API 문서 리다이렉트 컨트롤러.','2026-01-25 16:01:21.000000','2026-01-25 16:01:21.000000','2026-01-28 03:03:30.000000'),(101,69,0,'/**\n * ApiResponse - 공통 API 응답 래퍼\n *\n * <p>모든 API 응답을 일관된 형식으로 래핑합니다.\n *\n * @param <T> 응답 데이터 타입\n * @author ryu-qqq\n */\npublic record ApiResponse<T>(\n    boolean success,\n    T data,\n    String message,\n    String errorCode\n) {\n\n    public static <T> ApiResponse<T> success(T data) {\n        return new ApiResponse<>(true, data, null, null);\n    }\n\n    public static <T> ApiResponse<T> success(T data, String message) {\n        return new ApiResponse<>(true, data, message, null);\n    }\n\n    public static <T> ApiResponse<T> error(String message, String errorCode) {\n        return new ApiResponse<>(false, null, message, errorCode);\n    }\n}','ApiResponse',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"success\", \"error\"]','ApiResponse - 공통 API 응답 래퍼 클래스.','2026-01-25 16:01:37.000000','2026-01-25 16:01:37.000000','2026-01-28 03:03:30.000000'),(102,69,0,'/**\n * PageApiResponse - 페이지 기반 API 응답\n *\n * <p>오프셋 기반 페이지네이션 결과를 담는 응답 클래스입니다.\n *\n * @param <T> 데이터 항목 타입\n * @author ryu-qqq\n */\npublic record PageApiResponse<T>(\n    List<T> content,\n    int page,\n    int size,\n    long totalElements,\n    int totalPages,\n    boolean hasNext,\n    boolean hasPrevious\n) {\n\n    public static <T> PageApiResponse<T> of(List<T> content, PageMeta meta) {\n        return new PageApiResponse<>(\n            content,\n            meta.page(),\n            meta.size(),\n            meta.totalElements(),\n            meta.totalPages(),\n            meta.hasNext(),\n            meta.hasPrevious()\n        );\n    }\n}','PageApiResponse',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"of\"]','PageApiResponse - 페이지 기반 API 응답 클래스.','2026-01-25 16:01:37.000000','2026-01-25 16:01:37.000000','2026-01-28 03:03:30.000000'),(103,69,0,'/**\n * SliceApiResponse - 커서 기반 API 응답\n *\n * <p>커서 기반 페이지네이션 결과를 담는 응답 클래스입니다.\n *\n * @param <T> 데이터 항목 타입\n * @author ryu-qqq\n */\npublic record SliceApiResponse<T>(\n    List<T> content,\n    int size,\n    boolean hasNext,\n    String cursor,\n    int count\n) {\n\n    public static <T> SliceApiResponse<T> of(List<T> content, SliceMeta meta) {\n        return new SliceApiResponse<>(\n            content,\n            meta.size(),\n            meta.hasNext(),\n            meta.cursor(),\n            meta.count()\n        );\n    }\n}','SliceApiResponse',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"of\"]','SliceApiResponse - 커서 기반 API 응답 클래스.','2026-01-25 16:01:37.000000','2026-01-25 16:01:37.000000','2026-01-28 03:03:30.000000'),(104,70,0,'/**\n * ErrorMapper - 에러 매핑 인터페이스\n *\n * <p>도메인 예외를 API 응답으로 변환하는 매퍼 인터페이스입니다.\n *\n * @author ryu-qqq\n */\npublic interface ErrorMapper {\n\n    /**\n     * 지원하는 예외 타입 반환\n     */\n    Class<? extends DomainException> supportedType();\n\n    /**\n     * 예외를 API 응답으로 변환\n     */\n    ApiResponse<?> toResponse(DomainException exception);\n}','ErrorMapper',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"supportedType\", \"toResponse\"]','ErrorMapper - 도메인 예외를 API 응답으로 변환하는 인터페이스.','2026-01-25 16:01:57.000000','2026-01-25 16:01:57.000000','2026-01-28 03:03:30.000000'),(105,70,0,'/**\n * ErrorMapperRegistry - 에러 매퍼 레지스트리\n *\n * <p>모든 ErrorMapper를 등록하고 예외 타입에 맞는 매퍼를 찾습니다.\n *\n * @author ryu-qqq\n */\n@Component\npublic class ErrorMapperRegistry {\n\n    private final Map<Class<? extends DomainException>, ErrorMapper> mappers;\n\n    public ErrorMapperRegistry(List<ErrorMapper> errorMappers) {\n        this.mappers = errorMappers.stream()\n            .collect(Collectors.toMap(\n                ErrorMapper::supportedType,\n                Function.identity()\n            ));\n    }\n\n    public Optional<ErrorMapper> findMapper(Class<? extends DomainException> exceptionType) {\n        return Optional.ofNullable(mappers.get(exceptionType));\n    }\n}','ErrorMapperRegistry','[\"org.springframework.stereotype.Component\"]','[\"lombok.*\"]',NULL,NULL,'[\"findMapper\"]','ErrorMapperRegistry - 예외 타입별 ErrorMapper 레지스트리.','2026-01-25 16:01:57.000000','2026-01-25 16:01:57.000000','2026-01-28 03:03:30.000000'),(106,70,0,'/**\n * GlobalExceptionHandler - 전역 예외 핸들러\n *\n * <p>모든 예외를 일관된 API 응답으로 변환합니다.\n *\n * @author ryu-qqq\n */\n@RestControllerAdvice\npublic class GlobalExceptionHandler {\n\n    private final ErrorMapperRegistry errorMapperRegistry;\n\n    public GlobalExceptionHandler(ErrorMapperRegistry errorMapperRegistry) {\n        this.errorMapperRegistry = errorMapperRegistry;\n    }\n\n    @ExceptionHandler(DomainException.class)\n    public ResponseEntity<ApiResponse<?>> handleDomainException(DomainException ex) {\n        return errorMapperRegistry.findMapper(ex.getClass())\n            .map(mapper -> ResponseEntity\n                .status(ex.httpStatus())\n                .body(mapper.toResponse(ex)))\n            .orElseGet(() -> ResponseEntity\n                .status(ex.httpStatus())\n                .body(ApiResponse.error(ex.getMessage(), ex.code())));\n    }\n}','GlobalExceptionHandler','[\"org.springframework.web.bind.annotation.RestControllerAdvice\"]','[\"lombok.*\"]',NULL,NULL,'[\"handleDomainException\"]','GlobalExceptionHandler - 전역 예외 핸들러.','2026-01-25 16:01:57.000000','2026-01-25 16:01:57.000000','2026-01-28 03:03:30.000000'),(107,71,0,'/**\n * DateTimeFormatUtils - 날짜/시간 포맷 유틸리티\n *\n * <p>API 요청/응답에서 사용하는 날짜/시간 포맷 상수를 정의합니다.\n *\n * @author ryu-qqq\n */\npublic final class DateTimeFormatUtils {\n\n    private DateTimeFormatUtils() {\n        // Utility class\n    }\n\n    /** ISO 8601 날짜 포맷 */\n    public static final String DATE_FORMAT = \"yyyy-MM-dd\";\n\n    /** ISO 8601 날짜시간 포맷 */\n    public static final String DATETIME_FORMAT = \"yyyy-MM-dd\'T\'HH:mm:ss\";\n\n    /** ISO 8601 날짜시간 + 타임존 포맷 */\n    public static final String DATETIME_WITH_ZONE_FORMAT = \"yyyy-MM-dd\'T\'HH:mm:ssXXX\";\n}','*Utils',NULL,'[\"lombok.*\"]',NULL,NULL,NULL,'DateTimeFormatUtils - 날짜/시간 포맷 유틸리티 클래스.','2026-01-25 16:01:57.000000','2026-01-25 16:01:57.000000','2026-01-28 03:03:30.000000'),(108,3,82,'/**\n * {Domain}Id - {Domain} 식별자 Value Object\n *\n * <p>Long 타입 ID로 forNew()/isNew() 패턴 적용.\n * Auto-increment ID를 위한 신규 엔티티 구분 패턴입니다.\n *\n * <p><strong>설계 원칙:</strong>\n * <ul>\n *   <li>Record로 정의하여 불변성과 equals/hashCode 자동 생성\n *   <li>forNew() - 신규 엔티티용, null ID 반환\n *   <li>of() - 기존 엔티티용, null 불허\n *   <li>isNew() - 신규 여부 판단\n *   <li>Lombok 사용 금지\n * </ul>\n *\n * <p><strong>사용 예시:</strong>\n * <pre>{@code\n * // Aggregate에서 신규 엔티티 생성\n * public static {Domain} forNew(...) {\n *     return new {Domain}({Domain}Id.forNew(), ...);\n * }\n *\n * // 신규 여부 확인\n * public boolean isNew() {\n *     return id.isNew();\n * }\n * }</pre>\n *\n * @param value ID 값 (신규인 경우 null)\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic record {Domain}Id(Long value) {\n\n    /**\n     * 신규 엔티티용 ID 생성\n     *\n     * <p>Auto-increment 컬럼 사용 시, 영속화 전까지 ID가 없음을 표현합니다.\n     *\n     * @return null 값을 가진 {Domain}Id\n     */\n    public static {Domain}Id forNew() {\n        return new {Domain}Id(null);\n    }\n\n    /**\n     * 기존 엔티티용 ID 생성\n     *\n     * <p>이미 영속화된 엔티티의 ID를 래핑합니다.\n     *\n     * @param value ID 값 (not null)\n     * @return 값이 있는 {Domain}Id\n     * @throws IllegalArgumentException value가 null인 경우\n     */\n    public static {Domain}Id of(Long value) {\n        if (value == null) {\n            throw new IllegalArgumentException(\n                    \"{Domain}Id value must not be null for existing entity\");\n        }\n        return new {Domain}Id(value);\n    }\n\n    /**\n     * 신규 엔티티 여부 확인\n     *\n     * @return ID 값이 null이면 true\n     */\n    public boolean isNew() {\n        return value == null;\n    }\n}','{Domain}Id',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"forNew\", \"of\", \"isNew\"]','Domain ID 클래스 - Aggregate의 식별자로 사용되는 불변 값 객체. forNew/isNew 패턴으로 Auto-increment ID 지원.','2026-01-27 11:29:20.000000','2026-01-27 11:29:20.000000',NULL),(109,8,83,'/**\n * {Domain}SliceCriteria - {Domain} 슬라이스 조회 조건 (커서 기반)\n *\n * <p>{Domain} 목록을 커서 기반으로 조회할 때 사용하는 조건입니다.\n *\n * <p><strong>설계 원칙:</strong>\n * <ul>\n *   <li>Record 타입으로 불변성 보장\n *   <li>CursorPageRequest 필드 필수\n *   <li>정적 팩토리 메서드 제공 (first, afterId, of)\n *   <li>편의 메서드 제공 (has*, isFirstPage, size, fetchSize)\n * </ul>\n *\n * @param cursorPageRequest 커서 기반 페이징 요청\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic record {Domain}SliceCriteria(\n        // 필터 필드들...\n        CursorPageRequest<Long> cursorPageRequest) {\n\n    public {Domain}SliceCriteria {\n        if (cursorPageRequest == null) {\n            throw new IllegalArgumentException(\"cursorPageRequest must not be null\");\n        }\n    }\n\n    /** 기본 슬라이스 조건 (첫 페이지) */\n    public static {Domain}SliceCriteria first(int size) {\n        return new {Domain}SliceCriteria(CursorPageRequest.first(size));\n    }\n\n    /** ID 기반 커서로 슬라이스 조건 생성 */\n    public static {Domain}SliceCriteria afterId(Long cursorId, int size) {\n        return new {Domain}SliceCriteria(CursorPageRequest.afterId(cursorId, size));\n    }\n\n    /** 정적 팩토리 메서드 */\n    public static {Domain}SliceCriteria of(CursorPageRequest<Long> cursorPageRequest) {\n        return new {Domain}SliceCriteria(cursorPageRequest);\n    }\n\n    /** 첫 페이지 요청인지 확인 */\n    public boolean isFirstPage() {\n        return cursorPageRequest.cursor() == null;\n    }\n\n    /** 슬라이스 크기 반환 */\n    public int size() {\n        return cursorPageRequest.size();\n    }\n\n    /** 실제 조회 크기 반환 (hasNext 판단용 +1) */\n    public int fetchSize() {\n        return cursorPageRequest.fetchSize();\n    }\n}','{Domain}SliceCriteria',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"first\", \"afterId\", \"of\", \"isFirstPage\", \"size\", \"fetchSize\"]','Domain Criteria 클래스 - 도메인 조회 조건을 캡슐화하는 record. 커서 기반 페이징 지원.','2026-01-27 11:31:28.000000','2026-01-27 11:50:33.000000',NULL),(110,7,4,'/**\n * {Domain}{Action}Event - {Domain} {Action} 이벤트\n *\n * <p>{Domain} Aggregate에서 {Action} 동작 수행 시 발행되는 도메인 이벤트입니다.\n *\n * <p><strong>설계 원칙:</strong>\n * <ul>\n *   <li>Record 타입으로 불변성 보장\n *   <li>DomainEvent 인터페이스 구현\n *   <li>occurredAt 필드 필수 (Instant 타입)\n *   <li>모든 필드는 Value Object 타입 사용\n *   <li>from(Aggregate, Instant) 정적 팩토리 메서드 제공\n * </ul>\n *\n * @param {domain}Id {Domain} 식별자\n * @param occurredAt 이벤트 발생 시각\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic record {Domain}{Action}Event(\n        {Domain}Id {domain}Id,\n        // 이벤트에 필요한 데이터 필드들...\n        Instant occurredAt\n) implements DomainEvent {\n\n    /**\n     * Aggregate로부터 이벤트 생성\n     *\n     * @param {domain} {Domain} Aggregate\n     * @param occurredAt 이벤트 발생 시각\n     * @return {Domain}{Action}Event 인스턴스\n     */\n    public static {Domain}{Action}Event from({Domain} {domain}, Instant occurredAt) {\n        return new {Domain}{Action}Event(\n                {domain}.id(),\n                // 필요한 데이터 추출...\n                occurredAt);\n    }\n}','{Domain}{Action}Event',NULL,'[\"lombok.*\"]','[\"DomainEvent\"]',NULL,'[\"from\", \"occurredAt\"]','Domain Event 클래스 - Aggregate 상태 변경 시 발행되는 도메인 이벤트. DomainEvent 인터페이스 구현 필수.','2026-01-27 11:31:42.000000','2026-01-27 11:31:42.000000',NULL),(111,77,10,'/**\n * {Action}{Domain}UseCase - {Action} {Domain} 유스케이스\n *\n * <p>Application Layer의 Port-In 인터페이스입니다.\n *\n * <p><strong>설계 원칙:</strong>\n * <ul>\n *   <li>UC-001: 단일 public 메서드 execute() 필수\n *   <li>UC-002: 입력은 Command/Query DTO\n *   <li>UC-003: 출력은 원시값 또는 Response DTO\n * </ul>\n *\n * @author ryu-qqq\n */\npublic interface {Action}{Domain}UseCase {\n\n    /**\n     * 유스케이스 실행\n     *\n     * @param command 커맨드 DTO\n     * @return 결과 (ID 또는 Response DTO)\n     */\n    {ReturnType} execute({CommandType} command);\n}','{Action}{Domain}UseCase',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"execute\"]','UseCase 인터페이스 (Port-In) - 단일 execute() 메서드로 애플리케이션 경계 정의.','2026-01-27 11:33:20.000000','2026-01-27 11:33:20.000000',NULL),(112,80,16,'/**\n * {Domain}PersistenceManager - {Domain} 영속성 관리자\n *\n * <p>Service와 Port-Out 사이의 조정 역할을 담당합니다.\n *\n * <p><strong>설계 원칙:</strong>\n * <ul>\n *   <li>MGR-001: @Component 또는 @Service 어노테이션 필수\n *   <li>MGR-002: @Transactional은 여기서 처리\n *   <li>MGR-003: Port-Out을 주입받아 영속성 처리\n *   <li>MGR-004: TimeProvider 주입 금지 (Factory에서 처리)\n * </ul>\n *\n * @author ryu-qqq\n */\n@Component\npublic class {Domain}PersistenceManager {\n\n    private final {Domain}CommandPort {domain}CommandPort;\n\n    public {Domain}PersistenceManager({Domain}CommandPort {domain}CommandPort) {\n        this.{domain}CommandPort = {domain}CommandPort;\n    }\n\n    @Transactional\n    public {Domain}Id persist({Domain} {domain}) {\n        return {domain}CommandPort.save({domain});\n    }\n\n    @Transactional\n    public void update({Domain} {domain}) {\n        {domain}CommandPort.save({domain});\n    }\n}','{Domain}PersistenceManager','[\"@Component\"]','[\"lombok.*\"]',NULL,NULL,'[\"persist\", \"update\"]','Manager 클래스 - Service와 Port 사이 조정. @Transactional 처리 담당.','2026-01-27 11:33:20.000000','2026-01-27 11:33:20.000000',NULL),(113,21,17,'/**\n * {Domain}CommandFactory - {Domain} 커맨드 팩토리\n *\n * <p>Command DTO로부터 Domain 객체를 생성합니다.\n *\n * <p><strong>설계 원칙:</strong>\n * <ul>\n *   <li>FAC-001: @Component 어노테이션 필수\n *   <li>FAC-002: TimeProvider 주입하여 시간 처리\n *   <li>FAC-003: Domain 생성 로직 캡슐화\n * </ul>\n *\n * @author ryu-qqq\n */\n@Component\npublic class {Domain}CommandFactory {\n\n    private final TimeProvider timeProvider;\n\n    public {Domain}CommandFactory(TimeProvider timeProvider) {\n        this.timeProvider = timeProvider;\n    }\n\n    public {Domain} create(Create{Domain}Command command) {\n        Instant now = timeProvider.now();\n        return {Domain}.forNew(\n                // command fields mapping...\n                now);\n    }\n}','{Domain}CommandFactory','[\"@Component\"]','[\"lombok.*\"]',NULL,NULL,'[\"create\"]','Factory 클래스 - Domain 객체 생성. TimeProvider 주입 필수.','2026-01-27 11:33:38.000000','2026-01-27 11:33:38.000000',NULL),(114,24,71,'/**\n * {Domain}Validator - {Domain} 비즈니스 규칙 검증자\n *\n * <p>도메인 비즈니스 규칙을 검증합니다.\n *\n * <p><strong>설계 원칙:</strong>\n * <ul>\n *   <li>VAL-001: @Component 어노테이션 필수\n *   <li>VAL-002: validate* 메서드로 검증 로직 캡슐화\n *   <li>VAL-003: 검증 실패 시 DomainException throw\n * </ul>\n *\n * @author ryu-qqq\n */\n@Component\npublic class {Domain}Validator {\n\n    private final {Domain}QueryPort {domain}QueryPort;\n\n    public {Domain}Validator({Domain}QueryPort {domain}QueryPort) {\n        this.{domain}QueryPort = {domain}QueryPort;\n    }\n\n    public void validateNotDuplicate(/* validation params */) {\n        // check for duplicates using QueryPort\n        // throw DomainException if duplicate\n    }\n\n    public void validateExists({Domain}Id id) {\n        // check existence using QueryPort\n        // throw DomainException if not found\n    }\n}','{Domain}Validator','[\"@Component\"]','[\"lombok.*\"]',NULL,NULL,'[\"validate*\"]','Validator 클래스 - 비즈니스 규칙 검증. DomainException throw.','2026-01-27 11:33:38.000000','2026-01-27 11:33:38.000000',NULL),(115,8,85,'/**\n * {Domain}PageCriteria - 오프셋 기반 페이징 조회 조건\n *\n * <p>전통적인 페이지 번호 기반 페이징을 위한 조회 조건입니다.\n * 총 개수 계산이 필요하고, 특정 페이지로 직접 이동이 필요한 경우 사용합니다.\n *\n * @rule DOM-CRITERIA-002\n * @author ryu-qqq\n */\npublic record {Domain}PageCriteria(\n    int page,\n    int size,\n    {Domain}SortKey sortKey,\n    SortDirection sortDirection,\n    // 검색 조건 필드들\n    String keyword,\n    {Domain}SearchField searchField,\n    {Domain}DateField dateField,\n    DateRange dateRange\n) {\n    public static {Domain}PageCriteria of(\n            int page,\n            int size,\n            {Domain}SortKey sortKey,\n            SortDirection sortDirection) {\n        return new {Domain}PageCriteria(\n            page, size, sortKey, sortDirection,\n            null, null, null, null\n        );\n    }\n    \n    public static {Domain}PageCriteria firstPage(int size) {\n        return of(0, size, {Domain}SortKey.defaultKey(), SortDirection.defaultDirection());\n    }\n    \n    public long offset() {\n        return (long) page * size;\n    }\n    \n    public boolean isFirstPage() {\n        return page == 0;\n    }\n}','{Domain}PageCriteria','[]','[]',NULL,NULL,'[\"of\", \"firstPage\", \"offset\", \"isFirstPage\"]','오프셋 기반 페이징을 위한 도메인 조회 조건 record','2026-01-27 11:50:33.000000','2026-01-27 11:50:33.000000',NULL),(116,2,84,'/**\n * {Domain}SortKey - 도메인 정렬 키\n *\n * <p>해당 도메인의 정렬 가능한 필드를 정의하는 Enum입니다.\n * SortKey 마커 인터페이스를 구현하여 타입 안전한 정렬 조건을 제공합니다.\n *\n * @rule DOM-VO-003\n * @author ryu-qqq\n */\npublic enum {Domain}SortKey implements SortKey {\n    ID(\"id\"),\n    CREATED_AT(\"createdAt\"),\n    UPDATED_AT(\"updatedAt\"),\n    // 도메인별 정렬 필드 추가\n    ;\n\n    private final String fieldName;\n\n    {Domain}SortKey(String fieldName) {\n        this.fieldName = fieldName;\n    }\n\n    @Override\n    public String fieldName() {\n        return fieldName;\n    }\n\n    public static {Domain}SortKey defaultKey() {\n        return CREATED_AT;\n    }\n}','{Domain}SortKey','[]','[]','[\"SortKey\"]',NULL,'[\"fieldName\", \"defaultKey\"]','도메인별 정렬 키를 정의하는 Enum. SortKey 인터페이스를 구현합니다.','2026-01-27 11:50:44.000000','2026-01-27 11:50:44.000000',NULL),(117,2,86,'/**\n * {Domain}DateField - 도메인 날짜 필터링 필드\n *\n * <p>해당 도메인에서 날짜 범위 검색이 가능한 필드를 정의하는 Enum입니다.\n * DateField 마커 인터페이스를 구현합니다.\n *\n * @rule DOM-VO-004\n * @author ryu-qqq\n */\npublic enum {Domain}DateField implements DateField {\n    CREATED_AT(\"createdAt\"),\n    UPDATED_AT(\"updatedAt\"),\n    // 도메인별 날짜 필드 추가\n    ;\n\n    private final String fieldName;\n\n    {Domain}DateField(String fieldName) {\n        this.fieldName = fieldName;\n    }\n\n    @Override\n    public String fieldName() {\n        return fieldName;\n    }\n}','{Domain}DateField','[]','[]','[\"DateField\"]',NULL,'[\"fieldName\"]','도메인별 날짜 필터링 필드를 정의하는 Enum. DateField 인터페이스를 구현합니다.','2026-01-27 11:51:29.000000','2026-01-27 11:51:29.000000',NULL),(118,2,87,'/**\n * {Domain}SearchField - 도메인 검색 필드\n *\n * <p>해당 도메인에서 키워드 검색이 가능한 필드를 정의하는 Enum입니다.\n * SearchField 마커 인터페이스를 구현합니다.\n *\n * @rule DOM-VO-005\n * @author ryu-qqq\n */\npublic enum {Domain}SearchField implements SearchField {\n    NAME(\"name\"),\n    DESCRIPTION(\"description\"),\n    // 도메인별 검색 필드 추가\n    ;\n\n    private final String fieldName;\n\n    {Domain}SearchField(String fieldName) {\n        this.fieldName = fieldName;\n    }\n\n    @Override\n    public String fieldName() {\n        return fieldName;\n    }\n}','{Domain}SearchField','[]','[]','[\"SearchField\"]',NULL,'[\"fieldName\"]','도메인별 검색 필드를 정의하는 Enum. SearchField 인터페이스를 구현합니다.','2026-01-27 11:51:38.000000','2026-01-27 11:51:38.000000',NULL),(119,78,14,'/**\n * {Domain}CommandPort - 영속성 명령 포트\n *\n * <p>도메인 객체의 CUD 작업을 위한 아웃바운드 포트입니다.\n * Persistence Adapter에서 구현합니다.\n *\n * @rule APP-PORT-001\n * @author ryu-qqq\n */\npublic interface {Domain}CommandPort {\n    \n    {Domain}Id persist({Domain} aggregate);\n    \n    void delete({Domain}Id id);\n}','{Domain}CommandPort','[]','[\"@Component\", \"@Service\", \"@Repository\"]',NULL,NULL,'[\"persist\"]','영속성 명령 작업을 위한 Port-Out 인터페이스. Adapter에서 구현합니다.','2026-01-27 11:57:31.000000','2026-01-27 11:57:31.000000',NULL),(120,21,72,'/**\n * Create{Domain}Command - 생성 명령 DTO\n *\n * <p>도메인 객체 생성을 위한 명령 데이터를 전달합니다.\n * 모든 필드는 원시 타입 또는 String을 사용합니다.\n *\n * @rule APP-DTO-001\n * @author ryu-qqq\n */\npublic record Create{Domain}Command(\n    // 필수 필드\n    String name,\n    String description,\n    // 선택 필드\n    String optionalField\n) {\n    // 팩토리 메서드는 Factory 클래스에서 제공\n}','Create{Domain}Command','[]','[\"@Data\", \"@Getter\", \"@Setter\"]',NULL,NULL,'[]','도메인 객체 생성을 위한 Command DTO. 원시 타입/String만 사용합니다.','2026-01-27 11:57:31.000000','2026-01-27 11:57:31.000000',NULL),(121,22,73,'/**\n * {Domain}SearchParams - 조회 파라미터 DTO\n *\n * <p>도메인 객체 목록 조회를 위한 검색 조건을 전달합니다.\n * CommonCursorParams를 포함하여 페이징을 지원합니다.\n *\n * @rule APP-DTO-002\n * @author ryu-qqq\n */\npublic record {Domain}SearchParams(\n    CommonCursorParams cursorParams,\n    // 검색 조건 필드\n    String keyword,\n    List<String> categories\n) {\n    public static {Domain}SearchParams of(CommonCursorParams cursorParams) {\n        return new {Domain}SearchParams(cursorParams, null, null);\n    }\n    \n    // delegate methods\n    public String cursor() {\n        return cursorParams.cursor();\n    }\n    \n    public int size() {\n        return cursorParams.size();\n    }\n    \n    // helper methods\n    public boolean hasKeyword() {\n        return keyword != null && !keyword.isBlank();\n    }\n}','{Domain}SearchParams','[]','[\"@Data\", \"@Getter\", \"@Setter\"]',NULL,NULL,'[\"of\", \"cursor\", \"size\"]','도메인 객체 목록 조회를 위한 Query DTO. CommonCursorParams를 포함합니다.','2026-01-27 11:57:48.000000','2026-01-27 11:57:48.000000',NULL),(122,23,74,'/**\n * {Domain}Result - 응답 DTO\n *\n * <p>도메인 객체를 외부로 전달하기 위한 응답 DTO입니다.\n * from() 팩토리 메서드를 통해 도메인 객체에서 변환합니다.\n *\n * @rule APP-DTO-003\n * @author ryu-qqq\n */\npublic record {Domain}Result(\n    Long id,\n    String name,\n    String description,\n    Instant createdAt,\n    Instant updatedAt\n) {\n    public static {Domain}Result from({Domain} domain) {\n        return new {Domain}Result(\n            domain.idValue(),\n            domain.nameValue(),\n            domain.descriptionValue(),\n            domain.createdAt(),\n            domain.updatedAt()\n        );\n    }\n}','{Domain}Result','[]','[\"@Data\", \"@Getter\", \"@Setter\"]',NULL,NULL,'[\"from\"]','도메인 객체를 외부로 전달하기 위한 Response DTO. from() 팩토리 메서드 필수.','2026-01-27 11:57:48.000000','2026-01-27 11:57:48.000000',NULL),(123,24,78,'/**\n * {Concept}Resolver - 전략 해결자\n *\n * <p>타입에 따라 적절한 구현체를 동적으로 선택하는 Resolver입니다.\n * 전략 패턴의 Context 역할을 수행합니다.\n *\n * @rule APP-INT-001\n * @author ryu-qqq\n */\n@Component\npublic class {Concept}Resolver {\n\n    private final Map<{Type}, {Strategy}> strategyMap;\n\n    public {Concept}Resolver(List<{Strategy}> strategies) {\n        this.strategyMap = strategies.stream()\n                .collect(Collectors.toMap(\n                        {Strategy}::supportedType,\n                        Function.identity()));\n    }\n\n    public {Strategy} resolve({Type} type) {\n        {Strategy} strategy = strategyMap.get(type);\n        if (strategy == null) {\n            throw new IllegalArgumentException(\n                    \"No strategy found for type: \" + type);\n        }\n        return strategy;\n    }\n}','{Concept}Resolver','[\"@Component\"]','[]',NULL,NULL,'[\"resolve\"]','전략 패턴의 구현체를 동적으로 선택하는 Resolver. @Component 필수.','2026-01-27 11:58:04.000000','2026-01-27 11:58:04.000000',NULL),(124,81,76,'/**\n * {Name}Registry - 공통 컴포넌트\n *\n * <p>도메인 독립적인 공통 기능을 제공하는 컴포넌트입니다.\n * 트랜잭션, 이벤트, 캐싱 등의 인프라 관심사를 처리합니다.\n *\n * @rule APP-COM-001\n * @author ryu-qqq\n */\n@Component\npublic class {Name}Registry {\n\n    private final SomeDependency dependency;\n\n    public {Name}Registry(SomeDependency dependency) {\n        this.dependency = dependency;\n    }\n\n    public void register(Object item) {\n        // 등록 로직\n    }\n    \n    public Optional<Object> get(Object key) {\n        // 조회 로직\n        return Optional.empty();\n    }\n}','{Name}Registry','[\"@Component\"]','[\"@Service\"]',NULL,NULL,'[]','도메인 독립적인 공통 기능을 제공하는 Component. @Component 필수.','2026-01-27 11:58:04.000000','2026-01-27 11:58:04.000000',NULL),(125,38,21,'/**\n * {Domain}JpaEntity - JPA 엔티티\n *\n * <p>도메인 객체를 데이터베이스에 매핑하는 JPA 엔티티입니다.\n * SoftDeletableEntity를 상속하여 감사 정보와 소프트 딜리트를 지원합니다.\n *\n * @rule PER-ENT-001\n * @author ryu-qqq\n */\n@Entity\n@Table(name = \"{table_name}\")\npublic class {Domain}JpaEntity extends SoftDeletableEntity {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"id\")\n    private Long id;\n\n    @Column(name = \"name\", nullable = false)\n    private String name;\n\n    protected {Domain}JpaEntity() {\n    }\n\n    private {Domain}JpaEntity(Long id, String name, Instant createdAt, Instant updatedAt) {\n        super(createdAt, updatedAt);\n        this.id = id;\n        this.name = name;\n    }\n\n    public static {Domain}JpaEntity of(Long id, String name, Instant createdAt, Instant updatedAt) {\n        return new {Domain}JpaEntity(id, name, createdAt, updatedAt);\n    }\n\n    // Getters\n    public Long id() { return id; }\n    public String name() { return name; }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof {Domain}JpaEntity that)) return false;\n        return id != null && id.equals(that.id);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(id);\n    }\n}','{Domain}JpaEntity','[\"@Entity\", \"@Table\"]','[\"@Data\", \"@Getter\", \"@Setter\"]',NULL,'[\"SoftDeletableEntity\"]','[\"of\", \"equals\", \"hashCode\"]','JPA 엔티티. SoftDeletableEntity 상속, @Entity @Table 필수.','2026-01-27 12:00:44.000000','2026-01-27 12:00:44.000000',NULL),(126,42,64,'/**\n * BaseAuditEntity - 감사 정보 베이스 엔티티\n *\n * <p>모든 엔티티가 공통으로 상속받는 추상 클래스입니다.\n * 생성일시, 수정일시 감사 정보를 제공합니다.\n *\n * @rule PER-ENT-002\n * @author ryu-qqq\n */\n@MappedSuperclass\npublic abstract class BaseAuditEntity {\n\n    @Column(name = \"created_at\", nullable = false, updatable = false)\n    private Instant createdAt;\n\n    @Column(name = \"updated_at\", nullable = false)\n    private Instant updatedAt;\n\n    protected BaseAuditEntity() {\n    }\n\n    protected BaseAuditEntity(Instant createdAt, Instant updatedAt) {\n        this.createdAt = createdAt;\n        this.updatedAt = updatedAt;\n    }\n\n    public Instant createdAt() { return createdAt; }\n    public Instant updatedAt() { return updatedAt; }\n}','BaseAuditEntity','[\"@MappedSuperclass\"]','[\"@Entity\"]',NULL,NULL,'[\"createdAt\", \"updatedAt\"]','감사 정보 제공 추상 클래스. @MappedSuperclass 필수.','2026-01-27 12:00:44.000000','2026-01-27 12:00:44.000000',NULL),(127,41,63,'/**\n * {Domain}ConditionBuilder - QueryDSL 조건 빌더\n *\n * <p>재사용 가능한 QueryDSL 조건을 생성하는 빌더 클래스입니다.\n * BooleanExpression을 반환하여 조합 가능한 조건을 제공합니다.\n *\n * @rule PER-REP-003\n * @author ryu-qqq\n */\n@Component\npublic class {Domain}ConditionBuilder {\n\n    public BooleanExpression deletedAtIsNull() {\n        return {domain}JpaEntity.deletedAt.isNull();\n    }\n\n    public BooleanExpression idEq(Long id) {\n        return id != null ? {domain}JpaEntity.id.eq(id) : null;\n    }\n\n    public BooleanExpression nameLike(String name) {\n        return name != null && !name.isBlank() \n            ? {domain}JpaEntity.name.containsIgnoreCase(name) \n            : null;\n    }\n}','{Domain}ConditionBuilder','[\"@Component\"]','[]',NULL,NULL,'[\"deletedAtIsNull\"]','QueryDSL 조건 빌더. BooleanExpression 반환, @Component 필수.','2026-01-27 12:01:04.000000','2026-01-27 12:01:04.000000',NULL),(128,43,66,'/**\n * JpaConfig - JPA 설정 클래스\n *\n * <p>JPA 및 QueryDSL 관련 설정을 정의합니다.\n * EntityScan, Repository 스캔, 트랜잭션 관리 등을 설정합니다.\n *\n * @rule PER-CFG-001\n * @author ryu-qqq\n */\n@Configuration\n@EntityScan(basePackages = \"com.ryuqq.adapter.out.persistence\")\n@EnableJpaRepositories(basePackages = \"com.ryuqq.adapter.out.persistence\")\n@EnableJpaAuditing\n@EnableTransactionManagement\npublic class JpaConfig {\n\n    @Bean\n    public JPAQueryFactory jpaQueryFactory(EntityManager entityManager) {\n        return new JPAQueryFactory(entityManager);\n    }\n}','JpaConfig','[\"@Configuration\", \"@EnableJpaRepositories\"]','[]',NULL,NULL,'[\"jpaQueryFactory\"]','JPA/QueryDSL 설정 클래스. @Configuration, @EnableJpaRepositories 필수.','2026-01-27 12:01:05.000000','2026-01-27 12:01:05.000000',NULL),(129,76,68,'/**\n * {QueryResult}Row - Projection DTO\n *\n * <p>CompositeRepository의 JOIN 쿼리 결과를 담는 Projection DTO입니다.\n * 필요한 필드만 포함하여 성능을 최적화합니다.\n *\n * <p><strong>네이밍 가이드:</strong>\n * <ul>\n *   <li>단순 조회: {Entity}Row (예: CodingRuleRow)</li>\n *   <li>복합 조회: {Main}With{Related}Row (예: ModuleWithConventionRow)</li>\n *   <li>용도 특화: {Purpose}{Entity}Row (예: ValidationRuleSummaryRow)</li>\n * </ul>\n *\n * @rule PER-DTO-001\n * @author ryu-qqq\n */\npublic record {QueryResult}Row(\n    Long id,\n    String name,\n    // JOIN된 필드들\n    Long relatedId,\n    String relatedName\n) {\n}','{QueryResult}Row','[]','[\"@Data\", \"@Getter\"]',NULL,NULL,'[]','CompositeRepository의 JOIN 쿼리 결과를 담는 Projection DTO. record 사용, 조회 전용.','2026-01-27 12:01:05.000000','2026-01-28 00:56:18.000000',NULL),(130,42,65,'/**\n * SoftDeletableEntity - 소프트 딜리트 지원 추상 클래스\n *\n * <p>BaseAuditEntity를 상속하여 소프트 딜리트 필드(deletedAt)를 제공합니다.\n * 삭제 여부 판단은 Domain Layer에서 수행하며, 이 클래스는 데이터 컨테이너입니다.\n *\n * @rule PER-ENT-003\n * @author ryu-qqq\n */\n@MappedSuperclass\npublic abstract class SoftDeletableEntity extends BaseAuditEntity {\n\n    @Column(name = \"deleted_at\")\n    private Instant deletedAt;\n\n    protected SoftDeletableEntity() {\n        super();\n    }\n\n    protected SoftDeletableEntity(Instant createdAt, Instant updatedAt) {\n        super(createdAt, updatedAt);\n        this.deletedAt = null;\n    }\n\n    protected SoftDeletableEntity(Instant createdAt, Instant updatedAt, Instant deletedAt) {\n        super(createdAt, updatedAt);\n        this.deletedAt = deletedAt;\n    }\n\n    public Instant getDeletedAt() { return deletedAt; }\n    public boolean isDeleted() { return deletedAt != null; }\n    public boolean isActive() { return deletedAt == null; }\n}','SoftDeletableEntity','[\"@MappedSuperclass\"]','[\"@Entity\"]',NULL,'[\"BaseAuditEntity\"]','[\"getDeletedAt\", \"isDeleted\", \"isActive\"]','소프트 딜리트 지원 추상 클래스. BaseAuditEntity 상속, @MappedSuperclass 필수.','2026-01-27 12:01:27.000000','2026-01-27 12:01:27.000000',NULL),(131,43,67,'/**\n * PersistenceObjectMapper - Persistence Layer 전용 ObjectMapper 래퍼\n *\n * <p>Persistence Layer에서 JSON 파싱/직렬화를 위한 중앙 관리 ObjectMapper입니다.\n * JSON 파싱 에러 처리를 중앙화하고 일관된 예외 처리를 제공합니다.\n *\n * @rule PER-CFG-002\n * @author ryu-qqq\n */\n@Component\npublic class PersistenceObjectMapper {\n\n    private static final TypeReference<List<String>> LIST_STRING_TYPE = new TypeReference<>() {};\n\n    private final ObjectMapper objectMapper;\n\n    public PersistenceObjectMapper(\n            @Qualifier(\"persistenceJsonObjectMapper\") ObjectMapper objectMapper) {\n        this.objectMapper = objectMapper;\n    }\n\n    public <T> T readValue(String json, TypeReference<T> typeReference) {\n        // JSON 파싱 로직\n    }\n\n    public List<String> readValueAsStringList(String json) {\n        // List<String> 파싱 편의 메서드\n    }\n\n    public <T> String writeValueAsString(T value) {\n        // JSON 직렬화 로직\n    }\n}','PersistenceObjectMapper','[\"@Component\"]','[]',NULL,NULL,'[\"readValue\", \"readValueAsStringList\", \"writeValueAsString\"]','Persistence Layer 전용 ObjectMapper 래퍼. @Component 필수.','2026-01-27 12:01:55.000000','2026-01-27 12:01:55.000000',NULL),(132,49,54,'/**\n * {Domain}ApiEndpoints - API 경로 상수\n *\n * <p>도메인 관련 API 경로를 상수로 정의합니다.\n * 컨트롤러와 테스트에서 일관된 경로를 사용할 수 있도록 합니다.\n *\n * @rule API-END-001\n * @author ryu-qqq\n */\npublic final class {Domain}ApiEndpoints {\n    private {Domain}ApiEndpoints() { }\n    \n    public static final String BASE = ApiPaths.SERVICE_BASE + \"/{domain}s\";\n    public static final String ID = \"/{id}\";\n    public static final String BY_ID = BASE + ID;\n    public static final String PATH_ID = \"id\";\n}','{Domain}ApiEndpoints','[]','[\"@Component\", \"@Service\"]',NULL,NULL,'[]','API 경로 상수 클래스. final class, private 생성자 필수.','2026-01-27 12:04:05.000000','2026-01-27 12:04:05.000000',NULL),(133,62,30,'/**\n * Create{Domain}ApiRequest - API 요청 DTO\n *\n * <p>REST API 요청 데이터를 전달하는 record입니다.\n * Bean Validation 어노테이션으로 입력값을 검증합니다.\n *\n * @rule API-DTO-001\n * @author ryu-qqq\n */\n@Schema(description = \"{Domain} 생성 요청 DTO\")\npublic record Create{Domain}ApiRequest(\n    @Schema(description = \"이름\", example = \"example\")\n    @NotBlank(message = \"name은 필수입니다\")\n    @Size(max = 100, message = \"name은 100자 이내여야 합니다\")\n    String name,\n    \n    @Schema(description = \"설명\", nullable = true)\n    String description\n) {\n}','Create{Domain}ApiRequest','[]','[\"@Data\", \"@Getter\"]',NULL,NULL,'[]','API 요청 DTO. record 사용, @Schema, Bean Validation 필수.','2026-01-27 12:04:05.000000','2026-01-27 12:04:05.000000',NULL),(134,56,59,'/**\n * ApiResponse - 표준 API 응답 래퍼\n *\n * <p>모든 API 응답을 래핑하는 표준 응답 형식입니다.\n * timestamp와 requestId를 자동으로 포함합니다.\n *\n * @rule API-RES-001\n * @author ryu-qqq\n */\n@Schema(description = \"표준 API 성공 응답\")\npublic record ApiResponse<T>(\n    @Schema(description = \"응답 데이터\", nullable = true)\n    T data,\n    \n    @Schema(description = \"응답 시간 (ISO 8601 형식)\")\n    String timestamp,\n    \n    @Schema(description = \"요청 ID (traceId 또는 UUID)\")\n    String requestId\n) {\n    public static <T> ApiResponse<T> of(T data) {\n        return new ApiResponse<>(data, DateTimeFormatUtils.nowIso8601(), generateRequestId());\n    }\n    \n    public static <T> ApiResponse<T> of() {\n        return of(null);\n    }\n    \n    private static String generateRequestId() {\n        String traceId = MDC.get(\"traceId\");\n        return traceId != null && !traceId.isBlank() ? traceId : UUID.randomUUID().toString();\n    }\n}','ApiResponse','[]','[]',NULL,NULL,'[\"of\"]','표준 API 응답 래퍼. record 사용, of() 팩토리 메서드 필수.','2026-01-27 12:04:26.000000','2026-01-27 12:04:26.000000',NULL),(135,56,60,'/**\n * PageApiResponse - 페이지 조회 응답\n *\n * <p>오프셋 기반 페이징 조회 응답을 위한 표준 형식입니다.\n * content를 방어적 복사하여 불변성을 보장합니다.\n *\n * @rule API-RES-002\n * @author ryu-qqq\n */\n@Schema(description = \"페이지 조회 응답 (Offset 기반)\")\npublic record PageApiResponse<T>(\n    @Schema(description = \"현재 페이지의 데이터 목록\")\n    List<T> content,\n    \n    @Schema(description = \"현재 페이지 번호 (0부터 시작)\")\n    int page,\n    \n    @Schema(description = \"페이지 크기\")\n    int size,\n    \n    @Schema(description = \"전체 데이터 개수\")\n    long totalElements,\n    \n    @Schema(description = \"전체 페이지 수\")\n    int totalPages,\n    \n    @Schema(description = \"첫 페이지 여부\")\n    boolean first,\n    \n    @Schema(description = \"마지막 페이지 여부\")\n    boolean last\n) {\n    public PageApiResponse {\n        content = List.copyOf(content);\n    }\n    \n    public static <T> PageApiResponse<T> of(\n        List<T> content, int page, int size, long totalElements, int totalPages, boolean first, boolean last\n    ) {\n        return new PageApiResponse<>(content, page, size, totalElements, totalPages, first, last);\n    }\n}','PageApiResponse','[]','[]',NULL,NULL,'[\"of\"]','페이지 조회 응답. record 사용, Compact Constructor로 방어적 복사.','2026-01-27 12:04:26.000000','2026-01-27 12:04:26.000000',NULL),(136,53,32,'/**\n * {Domain}ApiMapper - API 매퍼\n *\n * <p>API Request/Response와 Application DTO 간의 변환을 담당합니다.\n * 필드 매핑만 수행하며, 비즈니스 로직은 포함하지 않습니다.\n *\n * @rule API-MAP-001\n * @author ryu-qqq\n */\n@Component\npublic class {Domain}ApiMapper {\n\n    public Create{Domain}Command toCommand(Create{Domain}ApiRequest request) {\n        return new Create{Domain}Command(\n            request.name(),\n            request.description()\n        );\n    }\n    \n    public Update{Domain}Command toCommand(Long id, Update{Domain}ApiRequest request) {\n        return new Update{Domain}Command(\n            id,\n            request.name(),\n            request.description()\n        );\n    }\n    \n    public {Domain}ApiResponse toResponse({Domain}Result result) {\n        return new {Domain}ApiResponse(\n            result.id(),\n            result.name()\n        );\n    }\n}','{Domain}ApiMapper','[\"@Component\"]','[]',NULL,NULL,'[\"toCommand\", \"toResponse\"]','API 매퍼. @Component 필수, to{Type}() 메서드로 변환.','2026-01-27 12:04:49.000000','2026-01-27 12:04:49.000000',NULL),(137,57,57,'/**\n * GlobalExceptionHandler - 전역 예외 처리기\n *\n * <p>모든 REST API 예외를 RFC 7807 Problem Details 형식으로 처리합니다.\n * @RestControllerAdvice를 사용하여 전역으로 적용됩니다.\n *\n * @rule API-ERR-001\n * @author ryu-qqq\n */\n@RestControllerAdvice\npublic class GlobalExceptionHandler {\n\n    private final ErrorMapperRegistry errorMapperRegistry;\n\n    public GlobalExceptionHandler(ErrorMapperRegistry errorMapperRegistry) {\n        this.errorMapperRegistry = errorMapperRegistry;\n    }\n\n    @ExceptionHandler(MethodArgumentNotValidException.class)\n    public ResponseEntity<ProblemDetail> handleValidationException(\n            MethodArgumentNotValidException ex, HttpServletRequest req) {\n        return build(HttpStatus.BAD_REQUEST, \"Validation Failed\", \n                    ex.getBindingResult().getFieldErrors().toString(), \n                    \"VALIDATION_FAILED\", req);\n    }\n\n    @ExceptionHandler(DomainException.class)\n    public ResponseEntity<ProblemDetail> handleDomainException(\n            DomainException ex, HttpServletRequest req) {\n        var mapped = errorMapperRegistry.map(ex);\n        return build(mapped.status(), mapped.title(), mapped.detail(), ex.code(), req);\n    }\n\n    private ResponseEntity<ProblemDetail> build(\n            HttpStatus status, String title, String detail, String errorCode, HttpServletRequest req) {\n        ProblemDetail pd = ProblemDetail.forStatusAndDetail(status, detail);\n        pd.setTitle(title);\n        pd.setProperty(\"code\", errorCode);\n        pd.setProperty(\"timestamp\", Instant.now().toString());\n        return ResponseEntity.status(status)\n                .contentType(MediaType.APPLICATION_PROBLEM_JSON)\n                .body(pd);\n    }\n}','GlobalExceptionHandler','[\"@RestControllerAdvice\"]','[]',NULL,NULL,'[\"handleValidationException\", \"handleDomainException\"]','전역 예외 처리기. @RestControllerAdvice 필수, RFC 7807 준수.','2026-01-27 12:04:49.000000','2026-01-27 12:04:49.000000',NULL),(138,75,70,'/**\n * {Feature}CompositeRepository - 복합 조회 Repository\n *\n * <p>다중 도메인 JOIN을 허용하는 성능 최적화 Repository입니다.\n * 특정 기능/유스케이스를 위한 크로스 도메인 복합 쿼리를 제공합니다.\n *\n * <p><strong>주의: 읽기 전용 Repository입니다.</strong>\n * <ul>\n *   <li>CUD 작업은 각 도메인별 Adapter에서 수행</li>\n *   <li>Projection DTO (*Row)로 반환하여 Entity 직접 노출 방지</li>\n *   <li>JOIN 허용 범위를 문서화할 것</li>\n * </ul>\n *\n * @rule PER-REP-004\n * @author ryu-qqq\n */\n@Repository\npublic class {Feature}CompositeRepository {\n\n    private final JPAQueryFactory queryFactory;\n\n    public {Feature}CompositeRepository(JPAQueryFactory queryFactory) {\n        this.queryFactory = queryFactory;\n    }\n\n    /**\n     * 복합 조회 - 다중 테이블 JOIN\n     *\n     * @param id 조회 조건 ID\n     * @return Projection DTO 목록\n     */\n    public List<{QueryResult}Row> findWithJoin(Long id) {\n        return queryFactory\n                .select(Projections.constructor({QueryResult}Row.class,\n                        // 필드 매핑\n                        ))\n                .from(mainEntity)\n                .join(relatedEntity).on(mainEntity.relatedId.eq(relatedEntity.id))\n                .where(mainEntity.id.eq(id), mainEntity.deletedAt.isNull())\n                .fetch();\n    }\n}','{Feature}CompositeRepository','[\"@Repository\"]','[\"@Component\", \"@Service\"]',NULL,NULL,'[]','다중 도메인 JOIN 허용 복합 조회 Repository. @Repository 필수, 읽기 전용. 특정 Feature/UseCase 단위로 생성.','2026-01-28 00:45:22.000000','2026-01-28 00:56:18.000000',NULL),(139,80,16,'/**\n * {Domain}ReadManager - {Domain} 조회 관리자\n *\n * <p>조회 트랜잭션을 관리합니다. 읽기 전용 트랜잭션 적용.\n *\n * <p><strong>설계 원칙:</strong>\n * <ul>\n *   <li>MGR-001: @Transactional(readOnly = true) 메서드에 적용\n *   <li>MGR-002: QueryPort만 주입 (CommandPort 금지)\n *   <li>MGR-003: 파라미터는 VO(Value Object)만 사용\n * </ul>\n *\n * @author ryu-qqq\n */\n@Component\npublic class {Domain}ReadManager {\n\n    private final {Domain}QueryPort {domain}QueryPort;\n\n    public {Domain}ReadManager({Domain}QueryPort {domain}QueryPort) {\n        this.{domain}QueryPort = {domain}QueryPort;\n    }\n\n    @Transactional(readOnly = true)\n    public Optional<{Domain}> findById({Domain}Id id) {\n        return {domain}QueryPort.findById(id);\n    }\n\n    @Transactional(readOnly = true)\n    public boolean existsById({Domain}Id id) {\n        return {domain}QueryPort.existsById(id);\n    }\n\n    @Transactional(readOnly = true)\n    public List<{Domain}> findBySliceCriteria({Domain}SliceCriteria criteria) {\n        return {domain}QueryPort.findBySliceCriteria(criteria);\n    }\n}','{Domain}ReadManager','[\"@Component\"]',NULL,NULL,NULL,'[\"findById\", \"existsById\"]','ReadManager 클래스 - 조회 트랜잭션 관리. @Transactional(readOnly = true) 처리.','2026-01-28 01:16:32.000000','2026-01-28 01:16:32.000000',NULL),(140,25,15,'/**\n * {Context}PersistenceFacade - {Context} 크로스 도메인 영속화 파사드\n *\n * <p>여러 도메인의 PersistenceManager를 조율하여 단일 트랜잭션으로 처리합니다.\n *\n * <p><strong>설계 원칙:</strong>\n * <ul>\n *   <li>FCD-001: @Transactional 메서드 단위로 적용\n *   <li>FCD-002: PersistenceManager만 주입 (ReadManager 금지)\n *   <li>FCD-003: 여러 도메인의 영속화를 하나의 트랜잭션으로 묶음\n *   <li>FCD-004: 비즈니스 로직 금지 (조율만 담당)\n * </ul>\n *\n * @author ryu-qqq\n */\n@Component\npublic class {Context}PersistenceFacade {\n\n    private final {Domain1}PersistenceManager {domain1}PersistenceManager;\n    private final {Domain2}PersistenceManager {domain2}PersistenceManager;\n\n    public {Context}PersistenceFacade(\n            {Domain1}PersistenceManager {domain1}PersistenceManager,\n            {Domain2}PersistenceManager {domain2}PersistenceManager) {\n        this.{domain1}PersistenceManager = {domain1}PersistenceManager;\n        this.{domain2}PersistenceManager = {domain2}PersistenceManager;\n    }\n\n    @Transactional\n    public void persistAll({Domain1} {domain1}, {Domain2} {domain2}) {\n        {domain1}PersistenceManager.persist({domain1});\n        {domain2}PersistenceManager.persist({domain2});\n    }\n}','{Context}PersistenceFacade','[\"@Component\"]',NULL,NULL,NULL,NULL,'PersistenceFacade - 여러 도메인의 PersistenceManager를 단일 트랜잭션으로 조율. ReadManager 주입 금지.','2026-01-28 01:18:41.000000','2026-01-28 01:18:41.000000',NULL),(141,25,15,'/**\n * {Context}ReadFacade - {Context} 크로스 도메인 조회 파사드\n *\n * <p>여러 도메인의 ReadManager를 조율하여 조회를 처리합니다.\n *\n * <p><strong>설계 원칙:</strong>\n * <ul>\n *   <li>FCD-001: @Transactional(readOnly = true) 메서드 단위로 적용\n *   <li>FCD-002: ReadManager만 주입 (PersistenceManager 금지)\n *   <li>FCD-003: 여러 도메인의 조회를 조합\n *   <li>FCD-004: 비즈니스 로직 금지 (조율만 담당)\n * </ul>\n *\n * @author ryu-qqq\n */\n@Component\npublic class {Context}ReadFacade {\n\n    private final {Domain1}ReadManager {domain1}ReadManager;\n    private final {Domain2}ReadManager {domain2}ReadManager;\n\n    public {Context}ReadFacade(\n            {Domain1}ReadManager {domain1}ReadManager,\n            {Domain2}ReadManager {domain2}ReadManager) {\n        this.{domain1}ReadManager = {domain1}ReadManager;\n        this.{domain2}ReadManager = {domain2}ReadManager;\n    }\n\n    @Transactional(readOnly = true)\n    public {ResponseDto} findCombined({Domain1}Id {domain1}Id) {\n        var {domain1} = {domain1}ReadManager.findById({domain1}Id)\n                .orElseThrow(() -> new {Domain1}NotFoundException({domain1}Id));\n        var {domain2}List = {domain2}ReadManager.findBy{Domain1}Id({domain1}Id);\n        return new {ResponseDto}({domain1}, {domain2}List);\n    }\n}','{Context}ReadFacade','[\"@Component\"]',NULL,NULL,NULL,NULL,'ReadFacade - 여러 도메인의 ReadManager를 조합하여 조회. PersistenceManager 주입 금지.','2026-01-28 01:18:53.000000','2026-01-28 01:18:53.000000',NULL),(142,25,77,'/**\n * {Action}{Domain}Coordinator - {Action} {Domain} 코디네이터\n *\n * <p>크로스 도메인 작업의 검증과 실행을 조율합니다.\n *\n * <p><strong>설계 원칙:</strong>\n * <ul>\n *   <li>CRD-001: @Transactional 사용 금지 (Facade에서 처리)</li>\n *   <li>CRD-002: Validator들로 검증 후 Facade 호출</li>\n *   <li>CRD-003: 비즈니스 로직 금지 (조율만 담당)</li>\n *   <li>CRD-004: CommandFacade만 주입 (ReadFacade 금지)</li>\n * </ul>\n *\n * @author ryu-qqq\n */\n@Component\npublic class {Action}{Domain}Coordinator {\n\n    private final {Domain}Validator {domain}Validator;\n    private final {Related}Validator {related}Validator;\n    private final {Domain}CommandFacade commandFacade;\n\n    public {Action}{Domain}Coordinator(\n            {Domain}Validator {domain}Validator,\n            {Related}Validator {related}Validator,\n            {Domain}CommandFacade commandFacade) {\n        this.{domain}Validator = {domain}Validator;\n        this.{related}Validator = {related}Validator;\n        this.commandFacade = commandFacade;\n    }\n\n    public {ReturnType} {action}({Action}{Domain}Bundle bundle) {\n        validateBefore{Action}(bundle);\n        return commandFacade.{action}(bundle);\n    }\n\n    private void validateBefore{Action}({Action}{Domain}Bundle bundle) {\n        {domain}Validator.validate{Domain}(bundle);\n        {related}Validator.validate{Related}(bundle);\n    }\n}','{Action}{Domain}Coordinator','[\"@Component\"]','[\"@Transactional\"]',NULL,NULL,NULL,'Coordinator - 크로스 도메인 검증 및 Facade 호출 조율. @Transactional 금지.','2026-01-28 02:04:22.000000','2026-01-28 02:04:22.000000',NULL),(143,30,75,'/**\n * {Action}{Domain}Bundle - {Action} {Domain} 번들\n *\n * <p>크로스 도메인 Command 작업에 필요한 여러 도메인 객체를 묶습니다.\n *\n * <p><strong>설계 원칙:</strong>\n * <ul>\n *   <li>BDL-001: Command 전용 (Query에서 사용 금지)</li>\n *   <li>BDL-002: 여러 Domain Aggregate를 포함</li>\n *   <li>BDL-003: 편의 메서드로 값 추출 제공</li>\n *   <li>BDL-004: withXxx() 메서드로 ID 설정 지원</li>\n * </ul>\n *\n * @author ryu-qqq\n */\npublic class {Action}{Domain}Bundle {\n\n    private final {Domain1} {domain1};\n    private final {Domain2} {domain2};\n\n    public {Action}{Domain}Bundle({Domain1} {domain1}, {Domain2} {domain2}) {\n        this.{domain1} = {domain1};\n        this.{domain2} = {domain2};\n    }\n\n    /**\n     * ID 설정 (persist 후 호출)\n     */\n    public void with{Domain1}Id({Domain1}Id id) {\n        {domain2}.assign{Domain1}Id(id);\n    }\n\n    // === 편의 메서드 ===\n\n    public String {domain1}NameValue() {\n        return {domain1}.nameValue();\n    }\n\n    // === Getter ===\n\n    public {Domain1} {domain1}() {\n        return {domain1};\n    }\n\n    public {Domain2} {domain2}() {\n        return {domain2};\n    }\n}','{Action}{Domain}Bundle',NULL,NULL,NULL,NULL,NULL,'Bundle DTO - Command 전용. 여러 도메인 객체를 입력으로 묶음.','2026-01-28 02:04:35.000000','2026-01-28 02:04:35.000000',NULL),(144,82,88,'/**\n * {Context}CompositeResult - {Context} 복합 조회 결과\n *\n * <p>CompositeRepository의 JOIN 조회 결과를 Application 레이어로 전달합니다.\n *\n * <p><strong>설계 원칙:</strong>\n * <ul>\n *   <li>CPR-001: Persistence에서 Application으로 전달하는 내부용 DTO</li>\n *   <li>CPR-002: 크로스 도메인 데이터를 이미 조합된 형태로 포함</li>\n *   <li>CPR-003: Assembler를 통해 Response DTO로 변환</li>\n *   <li>CPR-004: 불변 객체로 구현 (record 권장)</li>\n * </ul>\n *\n * @author ryu-qqq\n */\npublic record {Context}CompositeResult(\n    {Domain1}Id {domain1}Id,\n    String {domain1}Name,\n    {Domain2}Id {domain2}Id,\n    String {domain2}Name,\n    // 추가 필드...\n    Instant createdAt\n) {\n    /**\n     * Persistence Row에서 변환\n     */\n    public static {Context}CompositeResult from({Context}Row row) {\n        return new {Context}CompositeResult(\n            {Domain1}Id.of(row.{domain1}Id()),\n            row.{domain1}Name(),\n            {Domain2}Id.of(row.{domain2}Id()),\n            row.{domain2}Name(),\n            row.createdAt()\n        );\n    }\n}','{Context}CompositeResult',NULL,NULL,NULL,NULL,NULL,'Composite Result - CompositeRepository 조회 결과. Persistence→Application 전달용 내부 DTO.','2026-01-28 02:04:47.000000','2026-01-28 02:04:47.000000',NULL);
INSERT INTO `class_type` VALUES (1,1,'AGGREGATE','Aggregate','Aggregate Root 클래스',1,'2026-01-26 07:32:46.896089','2026-01-26 07:32:46.896089','2026-01-27 11:40:19.000000'),(2,1,'AGGREGATE_ROOT','Aggregate Root','Aggregate Root 클래스 (별칭)',2,'2026-01-26 07:32:46.896089','2026-01-26 07:32:46.896089',NULL),(3,1,'VALUE_OBJECT','Value Object','Value Object 클래스',3,'2026-01-26 07:32:46.896089','2026-01-26 07:32:46.896089',NULL),(4,1,'DOMAIN_EVENT','Domain Event','도메인 이벤트',4,'2026-01-26 07:32:46.896089','2026-01-26 07:32:46.896089',NULL),(5,1,'DOMAIN_EVENT_INTERFACE','Domain Event Interface','도메인 이벤트 인터페이스',5,'2026-01-26 07:32:46.896089','2026-01-26 07:32:46.896089',NULL),(6,1,'DOMAIN_EXCEPTION','Domain Exception','도메인 예외',6,'2026-01-26 07:32:46.896089','2026-01-26 07:32:46.896089',NULL),(7,1,'DOMAIN_CRITERIA','Domain Criteria','도메인 검색 조건',7,'2026-01-26 07:32:46.896089','2026-01-26 07:32:46.896089','2026-01-27 11:51:29.000000'),(8,1,'ERROR_CODE','Error Code','에러 코드',8,'2026-01-26 07:32:46.896089','2026-01-26 07:32:46.896089',NULL),(9,1,'ERROR_CODE_INTERFACE','Error Code Interface','에러 코드 인터페이스',9,'2026-01-26 07:32:46.896089','2026-01-26 07:32:46.896089',NULL),(10,2,'USE_CASE','UseCase','UseCase 인터페이스',1,'2026-01-26 07:32:46.906006','2026-01-26 07:32:46.906006',NULL),(11,2,'COMMAND_SERVICE','Command Service','Command Service 구현체',2,'2026-01-26 07:32:46.906006','2026-01-26 07:32:46.906006',NULL),(12,2,'QUERY_SERVICE','Query Service','Query Service 구현체',3,'2026-01-26 07:32:46.906006','2026-01-26 07:32:46.906006',NULL),(13,2,'PORT_IN','Port-In','Port-In 인터페이스',4,'2026-01-26 07:32:46.906006','2026-01-26 07:32:46.906006','2026-01-28 01:18:58.000000'),(14,2,'PORT_OUT','Port-Out','Port-Out 인터페이스',5,'2026-01-26 07:32:46.906006','2026-01-26 07:32:46.906006',NULL),(15,2,'FACADE','Facade','Facade 컴포넌트',6,'2026-01-26 07:32:46.906006','2026-01-26 07:32:46.906006',NULL),(16,2,'MANAGER','Manager','Manager 컴포넌트',7,'2026-01-26 07:32:46.906006','2026-01-26 07:32:46.906006',NULL),(17,2,'FACTORY','Factory','Factory 컴포넌트',8,'2026-01-26 07:32:46.906006','2026-01-26 07:32:46.906006',NULL),(18,2,'ASSEMBLER','Assembler','Assembler 컴포넌트',9,'2026-01-26 07:32:46.906006','2026-01-26 07:32:46.906006',NULL),(19,2,'EVENT_LISTENER','Event Listener','이벤트 리스너',10,'2026-01-26 07:32:46.906006','2026-01-26 07:32:46.906006',NULL),(20,2,'SCHEDULER','Scheduler','스케줄러',11,'2026-01-26 07:32:46.906006','2026-01-26 07:32:46.906006','2026-01-28 02:17:42.000000'),(21,3,'JPA_ENTITY','JPA Entity','JPA Entity',1,'2026-01-26 07:32:46.983671','2026-01-26 07:32:46.983671',NULL),(22,3,'JPA_REPOSITORY','JPA Repository','JPA Repository 인터페이스',2,'2026-01-26 07:32:46.983671','2026-01-26 07:32:46.983671',NULL),(23,3,'QUERYDSL_REPOSITORY','QueryDSL Repository','QueryDSL Repository',3,'2026-01-26 07:32:46.983671','2026-01-26 07:32:46.983671',NULL),(24,3,'COMMAND_ADAPTER','Command Adapter','Command Adapter',4,'2026-01-26 07:32:46.983671','2026-01-26 07:32:46.983671',NULL),(25,3,'QUERY_ADAPTER','Query Adapter','Query Adapter',5,'2026-01-26 07:32:46.983671','2026-01-26 07:32:46.983671',NULL),(26,3,'ENTITY_MAPPER','Entity Mapper','Entity Mapper',6,'2026-01-26 07:32:46.983671','2026-01-26 07:32:46.983671',NULL),(27,4,'REST_CONTROLLER','REST Controller','REST Controller',1,'2026-01-26 07:32:46.992054','2026-01-28 00:59:40.000000','2026-01-28 00:59:40.000000'),(28,4,'COMMAND_CONTROLLER','Command Controller','Command Controller',2,'2026-01-26 07:32:46.992054','2026-01-26 07:32:46.992054',NULL),(29,4,'QUERY_CONTROLLER','Query Controller','Query Controller',3,'2026-01-26 07:32:46.992054','2026-01-26 07:32:46.992054',NULL),(30,4,'REQUEST_DTO','Request DTO','Request DTO',4,'2026-01-26 07:32:46.992054','2026-01-26 07:32:46.992054',NULL),(31,4,'RESPONSE_DTO','Response DTO','REST API 레이어의 응답 DTO (ApiResponse로 래핑됨)',5,'2026-01-26 07:32:46.992054','2026-01-26 07:32:46.992054',NULL),(32,4,'API_MAPPER','API Mapper','API Mapper',6,'2026-01-26 07:32:46.992054','2026-01-26 07:32:46.992054',NULL),(33,4,'ERROR_HANDLER','Error Handler','에러 핸들러',7,'2026-01-26 07:32:46.992054','2026-01-28 00:59:40.000000','2026-01-28 00:59:40.000000'),(34,5,'CONFIG','Config','설정 클래스',1,'2026-01-26 07:32:47.000508','2026-01-26 07:32:47.000508',NULL),(35,5,'COMMON_VO','Common VO','공통 Value Object',2,'2026-01-26 07:32:47.000508','2026-01-26 07:32:47.000508',NULL),(36,6,'AUTO_INCREMENT_ID','Auto Increment ID','자동 증가 ID',1,'2026-01-26 07:32:47.011109','2026-01-26 07:32:47.011109',NULL),(37,6,'GENERATED_LONG_ID','Generated Long ID','생성된 Long ID',2,'2026-01-26 07:32:47.011109','2026-01-26 07:32:47.011109',NULL),(38,6,'GENERATED_STRING_ID','Generated String ID','생성된 String ID',3,'2026-01-26 07:32:47.011109','2026-01-26 07:32:47.011109',NULL),(39,6,'UPDATE_DATA','Update Data','업데이트 데이터',4,'2026-01-26 07:32:47.011109','2026-01-26 07:32:47.011109',NULL),(40,6,'DELETION_STATUS_RECORD','Deletion Status Record','삭제 상태 레코드',5,'2026-01-26 07:32:47.011109','2026-01-26 07:32:47.011109',NULL),(41,6,'CACHE_KEY_INTERFACE','Cache Key Interface','캐시 키 인터페이스',6,'2026-01-26 07:32:47.011109','2026-01-26 07:32:47.011109',NULL),(42,6,'LOCK_KEY_INTERFACE','Lock Key Interface','락 키 인터페이스',7,'2026-01-26 07:32:47.011109','2026-01-26 07:32:47.011109',NULL),(43,6,'SORT_KEY_INTERFACE','Sort Key Interface','정렬 키 인터페이스',8,'2026-01-26 07:32:47.011109','2026-01-26 07:32:47.011109',NULL),(44,6,'SORT_DIRECTION_ENUM','Sort Direction Enum','정렬 방향 Enum',9,'2026-01-26 07:32:47.011109','2026-01-26 07:32:47.011109',NULL),(45,7,'PAGE_REQUEST_RECORD','Page Request Record','페이지 요청 레코드',1,'2026-01-26 07:32:47.020074','2026-01-26 07:32:47.020074',NULL),(46,7,'PAGE_META_RECORD','Page Meta Record','페이지 메타 레코드',2,'2026-01-26 07:32:47.020074','2026-01-26 07:32:47.020074',NULL),(47,7,'PAGE_CRITERIA_RECORD','Page Criteria Record','페이지 검색 조건 레코드',3,'2026-01-26 07:32:47.020074','2026-01-26 07:32:47.020074',NULL),(48,7,'SLICE_META_RECORD','Slice Meta Record','슬라이스 메타 레코드',4,'2026-01-26 07:32:47.020074','2026-01-26 07:32:47.020074',NULL),(49,7,'CURSOR_PAGE_REQUEST_RECORD','Cursor Page Request Record','커서 페이지 요청 레코드',5,'2026-01-26 07:32:47.020074','2026-01-26 07:32:47.020074',NULL),(50,7,'CURSOR_CRITERIA_RECORD','Cursor Criteria Record','커서 검색 조건 레코드',6,'2026-01-26 07:32:47.020074','2026-01-26 07:32:47.020074',NULL),(51,7,'CURSOR_QUERY_CONTEXT_RECORD','Cursor Query Context Record','커서 쿼리 컨텍스트 레코드',7,'2026-01-26 07:32:47.020074','2026-01-26 07:32:47.020074',NULL),(52,7,'QUERY_CONTEXT_RECORD','Query Context Record','쿼리 컨텍스트 레코드',8,'2026-01-26 07:32:47.020074','2026-01-26 07:32:47.020074',NULL),(53,7,'DATE_RANGE_RECORD','Date Range Record','날짜 범위 레코드',9,'2026-01-26 07:32:47.020074','2026-01-26 07:32:47.020074',NULL),(54,4,'API_ENDPOINTS','API Endpoints','API 경로 상수 클래스 (도메인별/공통)',8,'2026-01-27 07:11:03.535036','2026-01-27 07:11:03.535036',NULL),(55,4,'API_ERROR_CODE','API Error Code','API 에러 코드 Enum',9,'2026-01-27 07:11:03.535036','2026-01-28 00:59:40.000000','2026-01-28 00:59:40.000000'),(56,4,'API_EXCEPTION','API Exception','API 예외 클래스',10,'2026-01-27 07:11:03.535036','2026-01-28 00:59:40.000000','2026-01-28 00:59:40.000000'),(57,4,'GLOBAL_EXCEPTION_HANDLER','Global Exception Handler','전역 예외 핸들러 (@RestControllerAdvice)',11,'2026-01-27 07:11:03.535036','2026-01-27 07:11:03.535036',NULL),(58,4,'API_REQUEST','API Request','공통 API 요청 DTO',12,'2026-01-27 07:11:03.535036','2026-01-28 00:59:40.000000','2026-01-28 00:59:40.000000'),(59,4,'API_RESPONSE','API Response','공통 API 응답 DTO (ApiResponse)',13,'2026-01-27 07:11:03.535036','2026-01-27 07:11:03.535036',NULL),(60,4,'API_PAGE_RESPONSE','API Page Response','페이지/슬라이스 응답 DTO',14,'2026-01-27 07:11:03.535036','2026-01-27 07:11:03.535036',NULL),(61,5,'UTILITY','Utility','유틸리티 클래스',3,'2026-01-27 07:11:28.860304','2026-01-27 07:11:28.860304',NULL),(62,5,'HELPER','Helper','헬퍼 클래스',4,'2026-01-27 07:11:28.860304','2026-01-27 07:11:28.860304',NULL),(63,3,'CONDITION_BUILDER','Condition Builder','QueryDSL 조건 빌더',0,'2026-01-27 07:24:34.000000','2026-01-27 07:24:34.000000',NULL),(64,3,'BASE_AUDIT_ENTITY','Base Audit Entity','감사 정보 기본 엔티티',0,'2026-01-27 07:24:34.000000','2026-01-27 07:24:34.000000',NULL),(65,3,'SOFT_DELETABLE_ENTITY','Soft Deletable Entity','소프트 삭제 가능 엔티티',0,'2026-01-27 07:24:34.000000','2026-01-27 07:24:34.000000',NULL),(66,3,'JPA_CONFIG','JPA Config','JPA 설정 클래스',0,'2026-01-27 07:24:34.000000','2026-01-27 07:24:34.000000',NULL),(67,3,'PERSISTENCE_OBJECT_MAPPER','Persistence Object Mapper','Persistence 객체 매퍼',0,'2026-01-27 07:24:34.000000','2026-01-27 07:24:34.000000',NULL),(68,3,'PROJECTION_DTO','Projection DTO','다중 도메인 JOIN 조회 결과용 Projection DTO',0,'2026-01-27 07:24:34.000000','2026-01-27 07:24:34.000000',NULL),(69,3,'MCP_QUERY_ADAPTER','MCP Query Adapter','MCP 조회 어댑터',0,'2026-01-27 07:24:34.000000','2026-01-27 07:24:34.000000','2026-01-27 07:59:09.000000'),(70,3,'COMPOSITE_REPOSITORY','Composite Repository','다중 도메인 JOIN을 허용하는 성능 최적화 Repository (읽기 전용)',0,'2026-01-27 07:59:09.000000','2026-01-27 07:59:09.000000',NULL),(71,2,'VALIDATOR','Validator','유효성 검증 클래스',0,'2026-01-27 08:39:14.000000','2026-01-27 08:39:14.000000',NULL),(72,2,'COMMAND_DTO','Command DTO','Command 계층 DTO (record)',0,'2026-01-27 08:39:14.000000','2026-01-27 08:39:14.000000',NULL),(73,2,'QUERY_DTO','Query DTO','Query 계층 DTO (record)',0,'2026-01-27 08:39:14.000000','2026-01-27 08:39:14.000000',NULL),(74,2,'RESULT_DTO','Result DTO','Application 레이어에서 외부로 전달하는 조회 결과 DTO',0,'2026-01-27 08:39:14.000000','2026-01-27 08:39:14.000000',NULL),(75,2,'BUNDLE_DTO','Bundle DTO','복합 데이터 묶음 DTO (record)',0,'2026-01-27 08:39:14.000000','2026-01-27 08:39:14.000000',NULL),(76,2,'COMPONENT','Component','공통 컴포넌트 클래스',0,'2026-01-27 08:39:14.000000','2026-01-27 08:39:14.000000',NULL),(77,2,'COORDINATOR','Coordinator','내부 조정자 클래스',0,'2026-01-27 08:39:14.000000','2026-01-27 08:39:14.000000',NULL),(78,2,'RESOLVER','Resolver','내부 해결자 클래스',0,'2026-01-27 08:39:14.000000','2026-01-27 08:39:14.000000',NULL),(79,2,'PARSER','Parser','내부 파서 클래스',0,'2026-01-27 08:39:14.000000','2026-01-27 08:39:14.000000',NULL),(80,2,'CALCULATOR','Calculator','내부 계산 클래스',0,'2026-01-27 08:39:14.000000','2026-01-27 08:39:14.000000',NULL),(81,2,'CONVERTER','Converter','내부 변환 클래스',0,'2026-01-27 08:39:14.000000','2026-01-27 08:39:14.000000',NULL),(82,1,'DOMAIN_ID','Domain ID','도메인 식별자 Value Object (forNew/isNew 패턴)',0,'2026-01-27 09:59:46.000000','2026-01-27 09:59:46.000000',NULL),(83,1,'DOMAIN_SLICE_CRITERIA','Domain Slice Criteria','커서 기반 페이징을 위한 도메인 조회 조건. Slice 방식의 무한 스크롤 등에 사용됩니다.',0,'2026-01-27 10:16:41.000000','2026-01-27 11:50:07.000000',NULL),(84,1,'DOMAIN_SORT_KEY','Domain Sort Key','도메인별 정렬 키 Enum. SortKey 인터페이스를 구현하여 해당 도메인의 정렬 가능한 필드를 정의합니다.',0,'2026-01-27 11:49:58.000000','2026-01-27 11:49:58.000000',NULL),(85,1,'DOMAIN_PAGE_CRITERIA','Domain Page Criteria','오프셋 기반 페이징을 위한 도메인 조회 조건. 전통적인 페이지 번호 방식의 페이징에 사용됩니다.',0,'2026-01-27 11:50:07.000000','2026-01-27 11:50:07.000000',NULL),(86,1,'DOMAIN_DATE_FIELD','Domain Date Field','도메인별 날짜 필터링 필드 Enum. DateField 인터페이스를 구현하여 날짜 범위 검색이 가능한 필드를 정의합니다.',0,'2026-01-27 11:51:01.000000','2026-01-27 11:51:01.000000',NULL),(87,1,'DOMAIN_SEARCH_FIELD','Domain Search Field','도메인별 검색 필드 Enum. SearchField 인터페이스를 구현하여 키워드 검색이 가능한 필드를 정의합니다.',0,'2026-01-27 11:51:01.000000','2026-01-27 11:51:01.000000',NULL),(88,2,'COMPOSITE_RESULT','Composite Result',NULL,0,'2026-01-28 02:03:32.000000','2026-01-28 02:03:32.000000',NULL),(89,4,'SCHEDULER_ADAPTER','Scheduler Adapter',NULL,0,'2026-01-28 02:20:42.000000','2026-01-28 02:20:42.000000',NULL),(90,3,'ADMIN_QUERYDSL_REPOSITORY','Admin QueryDSL Repository','Admin 모듈용 QueryDSL Repository. 복잡한 조인 쿼리 허용.',0,'2026-01-28 02:44:53.000000','2026-01-28 02:44:53.000000',NULL),(91,3,'FUNCTION_CONTRIBUTOR','Function Contributor','Hibernate Function Contributor. FullText 등 커스텀 SQL 함수 등록.',0,'2026-01-28 02:44:53.000000','2026-01-28 02:44:53.000000',NULL);
INSERT INTO `class_type_category` VALUES (1,1,'DOMAIN_TYPES','Domain Layer Types','도메인 레이어에서 사용되는 클래스 유형',1,'2026-01-26 07:32:46.886403','2026-01-26 07:32:46.886403',NULL),(2,1,'APPLICATION_TYPES','Application Layer Types','애플리케이션 레이어에서 사용되는 클래스 유형',2,'2026-01-26 07:32:46.886403','2026-01-26 07:32:46.886403',NULL),(3,1,'PERSISTENCE_TYPES','Persistence Layer Types','영속성 레이어에서 사용되는 클래스 유형',3,'2026-01-26 07:32:46.886403','2026-01-26 07:32:46.886403',NULL),(4,1,'ADAPTER_IN_TYPES','Adapter-In Layer Types','Adapter-In 레이어에서 사용되는 클래스 유형 (REST API, Scheduler 등)',4,'2026-01-26 07:32:46.886403','2026-01-26 07:32:46.886403',NULL),(5,1,'COMMON_TYPES','Common Types','공통으로 사용되는 클래스 유형',5,'2026-01-26 07:32:46.886403','2026-01-26 07:32:46.886403',NULL),(6,1,'COMMON_VO_TYPES','Common VO Types','공통 Value Object 템플릿 유형',6,'2026-01-26 07:32:46.886403','2026-01-26 07:32:46.886403',NULL),(7,1,'PAGINATION_TYPES','Pagination & Query Types','페이지네이션 및 쿼리 관련 템플릿 유형',7,'2026-01-26 07:32:46.886403','2026-01-26 07:32:46.886403',NULL);
INSERT INTO `coding_rule` VALUES (27,1,'DOM-AGG-004','forNew() 팩토리 메서드 필수','BLOCKER','STRUCTURE','Aggregate는 새로운 인스턴스 생성을 위한 static forNew(..., Instant now) 팩토리 메서드가 필수입니다. ID는 null(Long ID) 또는 외부 주입(String ID)합니다.','생성자를 직접 노출하지 않고 팩토리 메서드를 통해 생성 의도를 명확히 합니다. forNew는 \"새로 생성\"임을 명시합니다.',0,'AGGREGATE_ROOT','2026-01-20 14:59:45.000000','2026-01-20 14:59:45.000000',NULL),(28,1,'DOM-AGG-005','reconstitute() 팩토리 메서드 필수','BLOCKER','STRUCTURE','Aggregate는 DB에서 조회한 데이터로 복원하기 위한 static reconstitute(...) 팩토리 메서드가 필수입니다. 비즈니스 검증은 수행하지 않습니다.','forNew()와 reconstitute()를 분리하여 생성과 복원의 의도를 명확히 합니다.',0,'AGGREGATE_ROOT','2026-01-20 14:59:45.000000','2026-01-20 14:59:45.000000',NULL),(29,1,'DOM-AGG-006','protected 기본 생성자','CRITICAL','STRUCTURE','Aggregate는 reconstitute() 팩토리 메서드와 함께 protected 기본 생성자를 선언할 수 있습니다. 외부에서 직접 호출하지 않도록 protected로 접근을 제한합니다.','JPA는 리플렉션으로 객체를 생성하므로 기본 생성자가 필요합니다. protected로 선언하여 외부 사용을 방지합니다.',0,'AGGREGATE_ROOT','2026-01-20 14:59:45.000000','2026-01-20 15:52:53.000000',NULL),(30,1,'DOM-AGG-007','Aggregate ID는 ID VO 사용','BLOCKER','STRUCTURE','Aggregate의 ID 필드는 원시 타입(Long) 대신 전용 ID VO(예: OrderId)를 사용해야 합니다. ID VO는 domain/{bc}/id 패키지에 위치합니다.','Primitive Obsession 안티패턴 방지. ID VO를 사용하면 타입 안전성이 보장됩니다.',0,'AGGREGATE_ROOT','2026-01-20 14:59:45.000000','2026-01-20 14:59:45.000000',NULL),(31,1,'DOM-AGG-008','isNew() 메서드 필수','BLOCKER','STRUCTURE','Aggregate는 새로 생성된 객체인지 판단하는 isNew() 메서드가 필수입니다. Long ID의 경우 id.value() == null 또는 id.isNew()로 판단합니다.','JPA의 merge/persist 결정, Outbox 이벤트 생성 여부 등에서 신규 생성 여부 판단이 필요합니다.',0,'AGGREGATE_ROOT','2026-01-20 14:59:45.000000','2026-01-20 14:59:45.000000',NULL),(32,1,'DOM-AGG-009','Aggregate 시간 필드는 Instant 타입','BLOCKER','STRUCTURE','Aggregate의 모든 시간 필드(createdAt, updatedAt, expiredAt 등)는 java.time.Instant 타입을 사용합니다. LocalDateTime, LocalDate, Date 등은 금지됩니다.','Instant는 타임존 독립적인 시점을 나타냅니다. UTC 기준 저장 후 표현 계층에서 타임존 변환합니다.',0,'AGGREGATE_ROOT','2026-01-20 14:59:45.000000','2026-01-20 14:59:45.000000',NULL),(33,1,'DOM-AGG-010','Instant 파라미터 주입 (Instant.now() 금지)','BLOCKER','BEHAVIOR','Aggregate 내부에서 Instant.now() 또는 System.currentTimeMillis() 직접 호출을 금지합니다. 시간이 필요한 메서드는 Instant 파라미터로 받습니다.','테스트 가능성 확보. Instant.now()는 테스트에서 시간을 고정할 수 없습니다.',0,'AGGREGATE_ROOT','2026-01-20 14:59:45.000000','2026-01-20 14:59:45.000000',NULL),(34,1,'DOM-AGG-011','상태 변경 시 updatedAt 갱신','CRITICAL','BEHAVIOR','Aggregate의 상태를 변경하는 모든 메서드는 updatedAt 필드를 갱신해야 합니다. 시간은 파라미터로 주입받습니다.','변경 이력 추적을 위해 updatedAt은 항상 최신 상태를 유지해야 합니다.',0,'AGGREGATE_ROOT','2026-01-20 14:59:45.000000','2026-01-20 14:59:45.000000',NULL),(35,1,'DOM-AGG-012','Aggregate Setter 메서드 금지','BLOCKER','STRUCTURE','Aggregate에서 setXxx() 형태의 Setter 메서드 사용을 금지합니다. 상태 변경은 비즈니스 의미가 담긴 메서드(예: cancel(), approve())를 통해서만 가능합니다.','Setter는 캡슐화를 해치고 비즈니스 로직이 외부로 유출됩니다. 도메인 언어로 표현된 메서드를 사용합니다.',0,'AGGREGATE_ROOT','2026-01-20 14:59:45.000000','2026-01-20 14:59:45.000000',NULL),(36,1,'DOM-AGG-013','Aggregate Getter 최소화','MAJOR','STRUCTURE','Aggregate에서 Getter는 꼭 필요한 경우에만 제공합니다. 외부에서 상태를 조회하여 판단하는 것보다 Aggregate가 직접 판단하는 메서드를 제공합니다.','Tell, Don\'t Ask 원칙. 외부에서 상태를 물어보고 판단하는 대신 Aggregate에게 판단을 요청합니다.',0,'AGGREGATE_ROOT','2026-01-20 14:59:45.000000','2026-01-20 14:59:45.000000',NULL),(37,1,'DOM-AGG-014','Law of Demeter (Getter 체이닝 금지)','BLOCKER','BEHAVIOR','order.getCustomer().getAddress().getCity()와 같은 Getter 체이닝을 금지합니다. 필요한 정보는 Aggregate가 직접 제공하는 메서드를 통해 접근합니다.','결합도 감소. Getter 체이닝은 내부 구조에 대한 깊은 의존성을 만듭니다.',0,'AGGREGATE_ROOT','2026-01-20 14:59:45.000000','2026-01-20 14:59:45.000000',NULL),(38,1,'DOM-AGG-015','Tell Don\'t Ask 원칙','CRITICAL','BEHAVIOR','if (order.getStatus() == PENDING) order.cancel() 대신 order.cancelIfPending()처럼 Aggregate에게 판단을 위임합니다.','비즈니스 로직이 Aggregate 내부에 캡슐화되어 일관성이 보장됩니다.',0,'AGGREGATE_ROOT','2026-01-20 14:59:45.000000','2026-01-20 14:59:45.000000',NULL),(39,1,'DOM-AGG-016','복잡한 비즈니스 규칙은 VO로 위임','CRITICAL','BEHAVIOR','복잡한 비즈니스 규칙이나 계산 로직은 Value Object로 추출하여 위임합니다. Aggregate는 조율 역할만 수행합니다.','단일 책임 원칙. Aggregate가 비대해지는 것을 방지하고 테스트 용이성을 높입니다.',0,'AGGREGATE_ROOT','2026-01-20 14:59:45.000000','2026-01-20 14:59:45.000000',NULL),(40,1,'DOM-AGG-017','상태 변경 시 도메인 이벤트 발행','CRITICAL','BEHAVIOR','Aggregate의 중요한 상태 변경은 도메인 이벤트를 발행해야 합니다. registerEvent() 메서드를 통해 이벤트를 등록합니다.','도메인 이벤트를 통해 다른 Bounded Context나 외부 시스템에 변경 사실을 알릴 수 있습니다.',0,'AGGREGATE_ROOT','2026-01-20 14:59:46.000000','2026-01-20 14:59:46.000000',NULL),(41,1,'DOM-AGG-018','registerEvent() protected 메서드','CRITICAL','STRUCTURE','Aggregate는 도메인 이벤트를 등록하는 protected registerEvent(DomainEvent event) 메서드를 가져야 합니다.','이벤트 등록은 Aggregate 내부에서만 가능하도록 protected로 선언합니다.',0,'AGGREGATE_ROOT','2026-01-20 14:59:46.000000','2026-01-20 14:59:46.000000',NULL),(42,1,'DOM-AGG-019','pollEvents() 메서드 (이벤트 수확)','CRITICAL','STRUCTURE','Aggregate는 등록된 이벤트를 수확하는 public List<DomainEvent> pollEvents() 메서드를 가져야 합니다. 호출 후 내부 이벤트 목록은 비워집니다.','Application Layer에서 영속화 후 이벤트를 수확하여 발행합니다.',0,'AGGREGATE_ROOT','2026-01-20 14:59:46.000000','2026-01-20 14:59:46.000000',NULL),(43,1,'DOM-AGG-020','Command 메서드는 동사로 시작','MAJOR','NAMING','상태를 변경하는 Command 메서드는 동사로 시작합니다. 예: cancel(), approve(), updateStatus(), changeAddress().','메서드 이름만으로 상태 변경 여부를 파악할 수 있습니다.',0,'AGGREGATE_ROOT','2026-01-20 14:59:46.000000','2026-01-20 14:59:46.000000',NULL),(44,1,'DOM-AGG-021','Query 메서드는 get/is/has/can으로 시작','MAJOR','NAMING','상태를 조회하는 Query 메서드는 get, is, has, can으로 시작합니다. 예: getStatus(), isActive(), hasItems(), canCancel().','메서드 이름만으로 조회 메서드임을 파악할 수 있습니다.',0,'AGGREGATE_ROOT','2026-01-20 14:59:46.000000','2026-01-20 14:59:46.000000',NULL),(45,1,'DOM-AGG-022','판단 메서드는 boolean 반환','MAJOR','BEHAVIOR','is, has, can으로 시작하는 판단 메서드는 반드시 boolean 타입을 반환합니다.','메서드 시그니처의 일관성을 유지합니다.',0,'AGGREGATE_ROOT','2026-01-20 14:59:46.000000','2026-01-20 14:59:46.000000',NULL),(48,1,'DOM-AGG-025','불변식(Invariant) 검증','CRITICAL','BEHAVIOR','Aggregate는 항상 유효한 상태를 유지해야 합니다. 생성 시점과 상태 변경 시점에 불변식을 검증합니다.','비즈니스 규칙 위반을 방지하고 데이터 정합성을 보장합니다.',0,'AGGREGATE_ROOT','2026-01-20 14:59:46.000000','2026-01-20 14:59:46.000000',NULL),(49,1,'DOM-AGG-026','equals/hashCode는 ID 기반','MAJOR','STRUCTURE','Aggregate의 equals()와 hashCode()는 ID 필드만을 기반으로 구현합니다.','Entity 동등성은 ID로 판단합니다. 다른 필드 변경 시에도 동일한 객체로 인식되어야 합니다.',0,'AGGREGATE_ROOT','2026-01-20 14:59:46.000000','2026-01-20 14:59:46.000000',NULL),(50,1,'DOM-AGG-027','불변 필드는 final 선언','MINOR','STRUCTURE','생성 이후 변경되지 않는 필드는 final로 선언합니다. 예: id, createdAt.','의도를 명확히 하고 실수로 인한 변경을 방지합니다.',0,'AGGREGATE_ROOT','2026-01-20 14:59:46.000000','2026-01-20 14:59:46.000000',NULL),(51,1,'DOM-VO-001','VO Record 타입 필수','BLOCKER','STRUCTURE','Value Object는 Java Record로 정의합니다. Record는 불변성, equals/hashCode, toString을 자동으로 보장합니다.','VO의 핵심 특성인 불변성을 언어 수준에서 보장합니다.',0,'VALUE_OBJECT','2026-01-20 14:59:46.000000','2026-01-20 14:59:46.000000',NULL),(52,1,'DOM-VO-002','VO of() 정적 팩토리 메서드 필수','BLOCKER','STRUCTURE','Value Object는 of() 정적 팩토리 메서드를 제공합니다. 예: Money.of(1000, Currency.KRW).','생성 의도를 명확히 하고 검증 로직을 캡슐화합니다.',0,'VALUE_OBJECT','2026-01-20 14:59:46.000000','2026-01-20 14:59:46.000000',NULL),(53,1,'DOM-VO-003','VO Compact Constructor 검증 필수','BLOCKER','BEHAVIOR','Record의 Compact Constructor에서 필수 검증을 수행합니다. null 체크, 범위 검증 등을 통해 유효하지 않은 VO 생성을 방지합니다.','VO는 생성 시점부터 항상 유효한 상태여야 합니다.',0,'VALUE_OBJECT','2026-01-20 14:59:46.000000','2026-01-20 14:59:46.000000',NULL),(54,1,'DOM-VO-004','Enum VO displayName() 필수','CRITICAL','STRUCTURE','Enum 타입의 VO는 사용자 표시용 displayName() 메서드를 제공합니다.','UI에 표시할 때 코드 대신 의미 있는 이름을 사용할 수 있습니다.',0,'VALUE_OBJECT,ENUM','2026-01-20 14:59:46.000000','2026-01-20 14:59:46.000000',NULL),(55,1,'DOM-VO-005','LockKey 인터페이스 구현 (선택적)','CRITICAL','STRUCTURE','분산락이 필요한 VO는 LockKey 인터페이스를 구현하여 getLockKey() 메서드를 제공합니다.','분산 환경에서 동시성 제어를 위한 표준화된 락 키를 제공합니다.',0,'VALUE_OBJECT','2026-01-20 14:59:46.000000','2026-01-20 14:59:46.000000',NULL),(56,1,'DOM-VO-006','CacheKey 인터페이스 구현 (선택적)','CRITICAL','STRUCTURE','캐싱이 필요한 VO는 CacheKey 인터페이스를 구현하여 getCacheKey() 메서드를 제공합니다.','캐시 키 생성 로직을 표준화하고 캡슐화합니다.',0,'VALUE_OBJECT','2026-01-20 14:59:46.000000','2026-01-20 14:59:46.000000',NULL),(60,1,'DOM-ID-001','ID VO *Id 네이밍 필수','BLOCKER','NAMING','ID Value Object는 {Domain}Id 형태로 네이밍합니다. 예: OrderId, CustomerId, ProductId.','일관된 네이밍으로 ID VO임을 명확히 구분합니다.',0,'DOMAIN_ID','2026-01-20 14:59:46.000000','2026-01-20 14:59:46.000000',NULL),(61,1,'DOM-ID-002','ID VO Record 타입 필수','BLOCKER','STRUCTURE','ID Value Object는 Java Record로 정의합니다. 예: public record OrderId(Long value) {}.','불변성과 값 동등성을 언어 수준에서 보장합니다.',0,'DOMAIN_ID','2026-01-20 14:59:46.000000','2026-01-20 14:59:46.000000',NULL),(62,1,'DOM-ID-003','ID VO of() 정적 팩토리 메서드 필수','BLOCKER','STRUCTURE','ID VO는 of() 정적 팩토리 메서드를 제공합니다. 예: OrderId.of(1L).','생성 의도를 명확히 하고 검증 로직을 캡슐화합니다.',0,'DOMAIN_ID','2026-01-20 14:59:47.000000','2026-01-20 14:59:47.000000',NULL),(63,1,'DOM-ID-004','Long ID forNew() 필수','BLOCKER','STRUCTURE','Long 타입 ID VO는 forNew() 정적 팩토리 메서드를 제공합니다. 새로 생성되는 Aggregate용입니다.','forNew()는 아직 영속화되지 않은 새 Aggregate를 위한 ID 생성임을 명시합니다.',0,'DOMAIN_ID','2026-01-20 14:59:47.000000','2026-01-20 14:59:47.000000',NULL),(64,1,'DOM-ID-005','Long ID forNew()는 null 반환','BLOCKER','BEHAVIOR','Long 타입 ID VO의 forNew()는 value가 null인 ID를 반환합니다. 예: return new OrderId(null).','null ID는 아직 영속화되지 않았음을 의미합니다. DB에서 auto-increment로 할당됩니다.',0,'DOMAIN_ID','2026-01-20 14:59:47.000000','2026-01-20 14:59:47.000000',NULL),(65,1,'DOM-ID-006','Long ID isNew() 필수','BLOCKER','STRUCTURE','Long 타입 ID VO는 isNew() 메서드를 제공합니다. return value == null;로 구현합니다.','신규 생성 여부를 판단할 때 사용합니다.',0,'DOMAIN_ID','2026-01-20 14:59:47.000000','2026-01-20 14:59:47.000000',NULL),(66,1,'DOM-ID-007','String ID isNew() 금지','BLOCKER','BEHAVIOR','String 타입 ID VO는 isNew() 메서드를 제공하지 않습니다. String ID는 항상 외부에서 주입받아 생성됩니다.','String ID는 UUID 등 외부에서 생성하여 주입하므로 null 상태가 없습니다.',0,'DOMAIN_ID','2026-01-20 14:59:47.000000','2026-01-20 14:59:47.000000',NULL),(67,1,'DOM-ID-008','String ID는 외부에서 주입','BLOCKER','BEHAVIOR','String 타입 ID는 Application Layer(Factory)에서 생성하여 Aggregate에 주입합니다. Domain에서 UUID.randomUUID() 호출 금지.','테스트 가능성 확보. ID 생성 로직을 외부로 분리하여 테스트에서 고정된 ID를 주입할 수 있습니다.',0,'DOMAIN_ID','2026-01-20 14:59:47.000000','2026-01-20 14:59:47.000000',NULL),(70,1,'DOM-EVT-001','DomainEvent 인터페이스 구현 필수','BLOCKER','STRUCTURE','모든 도메인 이벤트는 DomainEvent 인터페이스를 구현해야 합니다.','이벤트 기반 아키텍처에서 일관된 이벤트 처리와 추적을 보장합니다.',0,'DOMAIN_EVENT','2026-01-20 14:59:47.000000','2026-01-20 14:59:47.000000',NULL),(71,1,'DOM-EVT-002','Event Record 타입 필수','BLOCKER','STRUCTURE','도메인 이벤트는 Java Record로 정의합니다. 이벤트는 반드시 불변이어야 합니다.','이벤트의 불변성을 통해 이벤트 소싱, 감사 로그, 디버깅의 신뢰성을 보장합니다.',0,'DOMAIN_EVENT','2026-01-20 14:59:47.000000','2026-01-20 14:59:47.000000',NULL),(72,1,'DOM-EVT-003','Event occurredAt 필드 필수','BLOCKER','STRUCTURE','도메인 이벤트는 occurredAt(Instant) 필드를 필수로 포함합니다. 이벤트 발생 시점을 기록합니다.','이벤트 발생 시점 추적과 이벤트 순서 보장에 필요합니다.',0,'DOMAIN_EVENT','2026-01-20 14:59:47.000000','2026-01-20 14:59:47.000000',NULL),(73,1,'DOM-EVT-004','Event from() 팩토리 메서드 필수','BLOCKER','STRUCTURE','도메인 이벤트는 from(Aggregate, Instant) 정적 팩토리 메서드를 제공합니다. Aggregate에서 필요한 정보를 추출하여 이벤트를 생성합니다.','이벤트 생성 로직을 캡슐화하고 Aggregate의 내부 상태 노출을 최소화합니다.',0,'DOMAIN_EVENT','2026-01-20 14:59:47.000000','2026-01-20 14:59:47.000000',NULL),(74,1,'DOM-EVT-005','Event 과거형 네이밍 필수','BLOCKER','NAMING','도메인 이벤트는 과거형으로 네이밍합니다. 예: OrderCreatedEvent, PaymentCompletedEvent.','이벤트는 이미 발생한 사실을 나타내므로 과거형을 사용합니다.',0,'DOMAIN_EVENT','2026-01-20 14:59:47.000000','2026-01-20 14:59:47.000000',NULL),(75,1,'DOM-EVT-006','Event 패키지 위치','BLOCKER','LOCATION','도메인 이벤트는 domain.{bc}.event 패키지에 위치합니다.','이벤트를 별도 패키지로 분리하여 관리합니다.',0,'DOMAIN_EVENT','2026-01-20 14:59:47.000000','2026-01-20 14:59:47.000000',NULL),(81,1,'DOM-EXC-001','ErrorCode 인터페이스 구현 필수','BLOCKER','STRUCTURE','모든 도메인별 ErrorCode enum은 ErrorCode 인터페이스를 구현해야 합니다.','일관된 에러 코드 체계를 통해 API 응답의 일관성을 보장합니다.',0,'ERROR_CODE','2026-01-20 14:59:47.000000','2026-01-20 14:59:47.000000',NULL),(82,1,'DOM-EXC-002','ErrorCode 패키지 위치','BLOCKER','LOCATION','ErrorCode enum은 domain.{bc}.exception 패키지에 위치합니다.','예외 관련 코드를 별도 패키지로 분리하여 관리합니다.',0,'ERROR_CODE','2026-01-20 14:59:47.000000','2026-01-20 14:59:47.000000',NULL),(84,1,'DOM-EXC-004','ErrorCode public 접근 제어자','BLOCKER','STRUCTURE','ErrorCode enum은 public 접근 제어자를 사용합니다.','다른 레이어에서 에러 코드를 참조할 수 있어야 합니다.',0,'ERROR_CODE','2026-01-20 14:59:47.000000','2026-01-20 14:59:47.000000',NULL),(85,1,'DOM-EXC-005','ErrorCode getCode() 메서드 필수','BLOCKER','STRUCTURE','ErrorCode는 getCode() 메서드를 제공합니다. 형식: {DOMAIN}-{NUMBER} (예: ORD-001).','에러 코드를 통해 문제를 식별하고 문서화할 수 있습니다.',0,'ERROR_CODE','2026-01-20 14:59:48.000000','2026-01-20 14:59:48.000000',NULL),(86,1,'DOM-EXC-006','ErrorCode getHttpStatus() int 반환','BLOCKER','STRUCTURE','ErrorCode의 getHttpStatus()는 int 타입을 반환합니다. Spring의 HttpStatus를 사용하지 않습니다.','Domain Layer는 Spring에 의존하면 안 됩니다. 원시 타입을 사용합니다.',0,'ERROR_CODE','2026-01-20 14:59:48.000000','2026-01-20 14:59:48.000000',NULL),(87,1,'DOM-EXC-007','ErrorCode getMessage() 메서드 필수','BLOCKER','STRUCTURE','ErrorCode는 getMessage() 메서드를 제공합니다. 사용자에게 표시할 에러 메시지를 반환합니다.','에러 발생 시 사용자에게 의미 있는 메시지를 제공합니다.',0,'ERROR_CODE','2026-01-20 14:59:48.000000','2026-01-20 14:59:48.000000',NULL),(89,1,'DOM-EXC-009','DomainException 상속 필수','BLOCKER','STRUCTURE','도메인 레이어의 모든 예외 클래스는 DomainException을 상속받아야 합니다.','공통 예외 처리 로직을 적용하고 ErrorCode 기반의 구조화된 에러 응답을 보장합니다.',0,'DOMAIN_EXCEPTION','2026-01-20 14:59:48.000000','2026-01-20 14:59:48.000000',NULL),(90,1,'DOM-EXC-010','Exception 패키지 위치','BLOCKER','LOCATION','도메인 예외 클래스는 domain.{bc}.exception 패키지에 위치합니다.','예외를 별도 패키지로 분리하여 관리합니다.',0,'DOMAIN_EXCEPTION','2026-01-20 14:59:48.000000','2026-01-20 14:59:48.000000',NULL),(94,1,'DOM-EXC-014','Exception public 클래스','BLOCKER','STRUCTURE','도메인 예외는 public 클래스로 선언합니다.','다른 레이어에서 예외를 catch하고 처리할 수 있어야 합니다.',0,'DOMAIN_EXCEPTION','2026-01-20 14:59:48.000000','2026-01-20 14:59:48.000000',NULL),(95,1,'DOM-EXC-015','Exception RuntimeException 계층','BLOCKER','STRUCTURE','도메인 예외는 RuntimeException 계층입니다. Checked Exception을 사용하지 않습니다.','Unchecked Exception을 사용하여 불필요한 try-catch 블록을 방지합니다.',0,'DOMAIN_EXCEPTION','2026-01-20 14:59:48.000000','2026-01-20 14:59:48.000000',NULL),(98,1,'DOM-EXC-018','Exception 비즈니스 네이밍','CRITICAL','NAMING','도메인 예외는 비즈니스 의미가 명확한 이름을 사용합니다. 예: OrderNotFoundException, InsufficientBalanceException.','예외 이름만으로 어떤 비즈니스 상황인지 파악할 수 있어야 합니다.',0,'DOMAIN_EXCEPTION','2026-01-20 14:59:48.000000','2026-01-20 14:59:48.000000',NULL),(99,1,'DOM-EXC-019','DomainException common 패키지','BLOCKER','LOCATION','DomainException 추상 클래스는 domain.common.exception 패키지에 위치합니다.','공통으로 사용되는 기본 예외 클래스는 common 패키지에 위치합니다.',0,'DOMAIN_EXCEPTION','2026-01-20 14:59:48.000000','2026-01-20 14:59:48.000000',NULL),(100,1,'DOM-EXC-020','ErrorCode 인터페이스 common 패키지','BLOCKER','LOCATION','ErrorCode 인터페이스는 domain.common.exception 패키지에 위치합니다.','공통으로 사용되는 인터페이스는 common 패키지에 위치합니다.',0,'ERROR_CODE','2026-01-20 14:59:48.000000','2026-01-20 14:59:48.000000',NULL),(101,1,'DOM-CRI-001','Criteria 패키지 위치','BLOCKER','LOCATION','Criteria는 domain.{bc}.query.criteria 패키지에 위치합니다.','조회 조건을 별도 패키지로 분리하여 관리합니다.',0,'DOMAIN_SLICE_CRITERIA,DOMAIN_PAGE_CRITERIA','2026-01-20 14:59:48.000000','2026-01-20 14:59:48.000000',NULL),(102,1,'DOM-CRI-002','Criteria 네이밍 규칙','BLOCKER','NAMING','Criteria는 {Domain}SliceCriteria 또는 {Domain}SearchCriteria 형태로 네이밍합니다.','일관된 네이밍으로 Criteria 객체임을 명확히 구분합니다.',0,'DOMAIN_SLICE_CRITERIA,DOMAIN_PAGE_CRITERIA','2026-01-20 14:59:48.000000','2026-01-20 14:59:48.000000',NULL),(103,1,'DOM-CRI-003','Criteria public 접근 제어자','BLOCKER','STRUCTURE','Criteria는 public 접근 제어자를 사용합니다.','다른 레이어에서 Criteria를 사용할 수 있어야 합니다.',0,'DOMAIN_SLICE_CRITERIA,DOMAIN_PAGE_CRITERIA','2026-01-20 14:59:48.000000','2026-01-20 14:59:48.000000',NULL),(104,1,'DOM-CRI-004','Criteria Record 타입 필수','BLOCKER','STRUCTURE','Criteria는 Java Record로 정의합니다. 불변성을 보장합니다.','조회 조건은 불변이어야 하며 Record가 이를 보장합니다.',0,'DOMAIN_SLICE_CRITERIA,DOMAIN_PAGE_CRITERIA','2026-01-20 14:59:48.000000','2026-01-20 14:59:48.000000',NULL),(105,1,'DOM-CRI-005','Criteria of() 팩토리 메서드 필수','BLOCKER','STRUCTURE','Criteria는 of() 정적 팩토리 메서드를 제공합니다.','생성 의도를 명확히 하고 기본값 적용 로직을 캡슐화합니다.',0,'DOMAIN_SLICE_CRITERIA,DOMAIN_PAGE_CRITERIA','2026-01-20 14:59:48.000000','2026-01-20 14:59:48.000000',NULL),(110,1,'DOM-CRI-010','Criteria 공통 VO 사용 권장','MINOR','BEHAVIOR','Criteria는 DateRange, CursorQueryContext 등 공통 VO를 사용하여 조회 조건을 구성합니다.','공통 VO를 재사용하여 일관된 조회 패턴을 유지합니다.',0,'DOMAIN_SLICE_CRITERIA,DOMAIN_PAGE_CRITERIA','2026-01-20 14:59:49.000000','2026-01-20 14:59:49.000000',NULL),(111,1,'DOM-CMN-001','순수 자바 객체 원칙 (POJO)','BLOCKER','ANNOTATION','도메인 객체는 순수 자바 객체(POJO)여야 합니다. Lombok(@Data, @Getter, @Setter, @Builder 등), JPA(@Entity, @Table, @Column 등), Spring(@Component, @Service, @Autowired 등) 등 모든 프레임워크/라이브러리 어노테이션 사용을 금지합니다. 도메인 레이어는 인프라스트럭처를 알지 못해야 합니다.','헥사고날 아키텍처에서 도메인 레이어는 가장 안쪽에 위치하며, 외부 프레임워크에 의존하지 않아야 합니다. 이를 통해 도메인 로직의 순수성을 유지하고, 테스트 용이성을 확보하며, 프레임워크 변경에 대한 유연성을 갖출 수 있습니다.',0,'AGGREGATE_ROOT,VALUE_OBJECT,DOMAIN_EVENT,DOMAIN_EXCEPTION,DOMAIN_ID,DOMAIN_SLICE_CRITERIA,DOMAIN_PAGE_CRITERIA','2026-01-20 15:53:15.000000','2026-01-20 15:53:15.000000',NULL),(112,1,'DOM-CMN-002','외부 레이어 의존 금지','BLOCKER','DEPENDENCY','도메인 객체는 Application, Persistence, REST API 레이어를 의존하면 안 됩니다. Repository, Port, Service, Controller, Entity, DTO 등 외부 레이어 클래스를 import하거나 참조할 수 없습니다. 도메인은 오직 자신보다 안쪽에 있는 것만 의존할 수 있습니다.','의존성 역전 원칙(DIP)에 따라 도메인 레이어는 외부 레이어에 의존하지 않습니다. 이를 통해 도메인 로직을 외부 변경으로부터 보호하고, 독립적인 테스트와 재사용이 가능해집니다.',0,'AGGREGATE_ROOT,VALUE_OBJECT,DOMAIN_EVENT,DOMAIN_EXCEPTION,DOMAIN_ID,DOMAIN_SLICE_CRITERIA,DOMAIN_PAGE_CRITERIA','2026-01-20 15:53:34.000000','2026-01-20 15:53:34.000000',NULL),(113,1,'DOM-AGG-028','Collection 불변성 (방어적 복사)','MAJOR','','Aggregate의 Collection 필드를 외부에 노출할 때는 방어적 복사를 사용합니다. List.copyOf(), Set.copyOf(), Collections.unmodifiableList() 등을 사용하여 내부 상태가 외부에서 변경되지 않도록 보호합니다.','Aggregate의 불변식을 보호하기 위해 내부 Collection이 외부에서 직접 수정되는 것을 방지해야 합니다. getter를 통해 원본 Collection을 반환하면 외부에서 add/remove가 가능해져 캡슐화가 깨집니다.',0,'Aggregate','2026-01-21 01:16:57.000000','2026-01-21 01:16:57.000000','2026-01-21 03:08:56.000000'),(114,1,'DOM-AGG-029','Optional 필드 금지, 반환 타입만 허용','MAJOR','','Aggregate의 필드에 Optional을 사용하지 않습니다. Optional은 메서드 반환 타입으로만 사용하며, null이 될 수 있는 필드는 nullable로 선언하고 getter에서 Optional로 감싸서 반환합니다.','Optional은 반환 타입을 위해 설계되었습니다. 필드로 사용하면 직렬화 문제, 메모리 오버헤드, null 체크의 이중화 등 문제가 발생합니다. Brian Goetz(Java 아키텍트)도 필드 사용을 권장하지 않습니다.',0,'Aggregate, ValueObject','2026-01-21 01:16:57.000000','2026-01-21 01:16:57.000000','2026-01-21 03:08:56.000000'),(115,2,'APP-TRX-001','Service @Transactional 금지','BLOCKER','STRUCTURE','Service는 조율만 담당하며 @Transactional을 직접 선언하지 않습니다. 트랜잭션은 Manager/Facade에서 관리합니다.','Service가 트랜잭션을 직접 관리하면 조율 역할과 트랜잭션 경계 관리가 혼재됩니다. Manager/Facade에 트랜잭션 책임을 위임하면 Service는 순수하게 흐름 조율에 집중할 수 있고, 트랜잭션 범위를 더 세밀하게 제어할 수 있습니다.',0,'COMMAND_SERVICE,QUERY_SERVICE','2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL),(116,2,'APP-TRX-002','Manager @Transactional 필수','BLOCKER','STRUCTURE','CommandManager/QueryManager는 @Transactional 필수입니다. QueryManager는 readOnly=true 사용.','클래스 단위가 아닌 메서드 단위로 @Transactional을 선언하여 트랜잭션 범위를 명확히 합니다. Manager는 비즈니스 로직의 원자성을 보장하는 계층으로, CommandManager는 쓰기 트랜잭션으로 데이터 일관성을 보장하고, QueryManager는 readOnly=true로 읽기 최적화와 의도치 않은 변경을 방지합니다.',0,'MANAGER','2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL),(117,2,'APP-TRX-003','ClientManager @Transactional 금지','BLOCKER','STRUCTURE','ClientManager는 외부 호출이므로 트랜잭션 밖에서 실행해야 합니다. @Transactional 금지.','외부 API 호출을 트랜잭션 내에서 수행하면 네트워크 지연이 DB 커넥션 점유 시간을 늘려 커넥션 풀 고갈을 유발합니다. 또한 외부 호출 실패 시 롤백이 불가능하므로 트랜잭션 밖에서 처리해야 합니다.',0,'MANAGER','2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL),(118,2,'APP-TRX-004','CommandFacade @Transactional 선택','MAJOR','STRUCTURE','CommandFacade는 DB 원자성 필요 시에만 @Transactional 사용. 불필요한 트랜잭션 범위 확대 금지.','클래스 단위가 아닌 메서드 단위로 @Transactional을 선언하여 필요한 범위만 트랜잭션으로 묶습니다. CommandFacade는 여러 Manager를 조합하므로 전체 원자성이 필요한 경우에만 트랜잭션을 선언하며, 불필요한 트랜잭션 범위 확대는 락 경합과 커넥션 점유 시간을 증가시킵니다.',0,'FACADE','2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL),(119,2,'APP-TRX-005','QueryFacade @Transactional(readOnly=true)','MAJOR','STRUCTURE','QueryFacade는 복합 조회용이므로 @Transactional(readOnly=true) 사용.','클래스 단위가 아닌 메서드 단위로 @Transactional(readOnly=true)을 선언합니다. QueryFacade가 여러 QueryManager를 조합할 때 readOnly 트랜잭션은 일관된 스냅샷 읽기를 보장하고, JPA flush 모드가 MANUAL로 설정되어 성능이 향상되며, 의도치 않은 데이터 변경을 방지합니다.',0,'FACADE','2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL),(120,2,'APP-DEP-001','Service → Facade/Manager 의존','CRITICAL','BEHAVIOR','Service는 Facade 또는 Manager에 의존합니다. Manager 1개면 직접, 2개 이상이면 Facade 사용.','Service가 Port에 직접 의존하면 트랜잭션 경계가 불명확해집니다. Manager는 트랜잭션을 관리하고, Facade는 여러 Manager를 조합합니다. Manager 1개면 직접 의존, 2개 이상이면 Facade로 조합하여 계층 책임을 명확히 합니다.',0,'COMMAND_SERVICE,QUERY_SERVICE','2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL),(121,2,'APP-DEP-002','Facade → Manager 의존 (같은 CQRS)','CRITICAL','BEHAVIOR','Facade는 같은 CQRS 범위의 Manager만 의존합니다. CommandFacade → CommandManager만 허용.','CQRS 패턴에서 Command와 Query는 분리된 경로를 가집니다. CommandFacade가 QueryManager에 의존하면 CQRS 경계가 무너지고 책임이 혼재됩니다. 같은 CQRS 범위 내에서만 의존하여 관심사 분리를 유지합니다.',0,'FACADE','2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL),(122,2,'APP-DEP-003','CommandFacade → QueryManager 금지 (CQRS)','BLOCKER','BEHAVIOR','CQRS 원칙에 따라 CommandFacade에서 QueryManager 의존이 금지됩니다. 조회가 필요하면 Service에서 분리.','CQRS 원칙에 따라 Command와 Query 경로는 분리되어야 합니다. Command 처리 중 조회가 필요하면 Service에서 QueryManager를 먼저 호출하고, 그 결과를 CommandFacade에 전달해야 합니다. CommandFacade는 순수하게 Command 조합만 담당합니다.',0,'FACADE','2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL),(123,2,'APP-DEP-004','Validator → 단일 도메인 ReadManager만','CRITICAL','BEHAVIOR','Validator는 자기 도메인의 ReadManager(QueryManager)만 의존합니다. 복합 Validator 금지.','Validator는 단일 책임을 가져야 합니다. 여러 도메인의 ReadManager에 의존하면 복합 검증 로직이 되어 테스트와 유지보수가 어려워집니다. 복합 검증이 필요하면 Service 또는 Internal/Coordinator에서 여러 Validator를 조합합니다.',0,'VALIDATOR','2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL),(124,2,'APP-DEP-005','Internal → Manager 의존 (Port 직접 금지)','CRITICAL','BEHAVIOR','Calculator, Resolver 등 Internal 컴포넌트는 Manager를 통해 데이터 접근. Port 직접 의존 금지.','Calculator, Resolver 등 Internal 컴포넌트가 Port에 직접 의존하면 트랜잭션 없이 DB에 접근하게 됩니다. Manager를 통해 접근하면 트랜잭션 경계가 보장되고 캐싱 등 부가 기능을 활용할 수 있습니다.',0,'COORDINATOR,FACADE,VALIDATOR','2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL),(125,2,'APP-DTO-001','Command/Query Record 필수','BLOCKER','STRUCTURE','Command, Query DTO는 반드시 Record로 정의합니다. Lombok 금지.','Record는 불변성이 보장되고 equals/hashCode/toString이 자동 생성됩니다. Command/Query는 레이어 간 데이터 전달 객체이므로 불변이어야 안전합니다. Lombok은 Zero-Tolerance 규칙으로 금지됩니다.',0,'COMMAND_DTO,QUERY_DTO','2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL),(126,2,'APP-DTO-002','Command/Query 인스턴스 메서드 금지','BLOCKER','STRUCTURE','Command/Query DTO는 순수 데이터 컨테이너입니다. 인스턴스 메서드, Compact Constructor 로직, 기본값 처리 모두 금지.','Command/Query는 순수한 데이터 컨테이너입니다. 비즈니스 로직이나 변환 로직을 포함하면 책임이 혼재되고 테스트가 어려워집니다. 변환이 필요하면 Factory나 Mapper에서 처리합니다.',0,'COMMAND_DTO,QUERY_DTO','2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL),(127,2,'APP-DTO-003','SearchParams CommonSearchParams 포함 필수','CRITICAL','STRUCTURE','*SearchParams는 CommonSearchParams를 필수로 포함합니다.','CommonSearchParams는 페이징, 정렬 등 공통 검색 조건을 표준화합니다. 모든 SearchParams가 이를 포함하면 API 일관성이 유지되고, 공통 검색 로직을 재사용할 수 있습니다.',0,'QUERY_DTO','2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL),(128,2,'APP-DTO-004','CursorParams CommonCursorParams 포함 필수','CRITICAL','STRUCTURE','*CursorParams는 CommonCursorParams를 필수로 포함합니다.','CommonCursorParams는 커서 기반 페이징의 공통 조건을 표준화합니다. 모든 CursorParams가 이를 포함하면 무한 스크롤 API의 일관성이 유지되고, 공통 커서 처리 로직을 재사용할 수 있습니다.',0,'QUERY_DTO','2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL),(129,2,'APP-DTO-005','Bundle withId() 패턴','MAJOR','STRUCTURE','Bundle DTO는 withId() 메서드로 상위-하위 ID 연결 로직을 캡슐화합니다.','Bundle은 상위-하위 엔티티를 함께 생성할 때 사용됩니다. withId() 메서드로 상위 ID를 하위에 연결하는 로직을 캡슐화하면 Service 코드가 간결해지고 ID 연결 로직이 Bundle 내부에 응집됩니다.',0,'BUNDLE_DTO','2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL),(130,2,'APP-PRT-001','CommandPort persist/persistAll만','CRITICAL','STRUCTURE','CommandPort는 persist, persistAll 메서드만 허용됩니다. update 메서드 금지 (JPA Dirty Checking 사용).','JPA의 Dirty Checking은 영속성 컨텍스트 내에서 엔티티 변경을 자동 감지하여 UPDATE SQL을 생성합니다. 명시적 update 메서드는 이 메커니즘과 충돌하거나 중복 쿼리를 발생시킬 수 있으므로, persist/persistAll만 사용하여 JPA의 설계 의도를 따릅니다.',0,'PORT_OUT','2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL),(131,2,'APP-PRT-002','QueryPort findAll 금지 (OOM)','BLOCKER','STRUCTURE','QueryPort에서 findAll 금지. 전체 데이터 로딩은 OOM 위험. 반드시 findBySliceCriteria 사용.','findAll은 테이블의 모든 레코드를 메모리에 로딩하여 대용량 데이터에서 OutOfMemory를 유발합니다. findBySliceCriteria를 사용하면 페이지네이션을 강제하여 메모리 사용량을 제어하고 시스템 안정성을 보장합니다.',0,'PORT_OUT','2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL),(132,2,'APP-PRT-003','QueryPort 네이밍 규칙','MAJOR','NAMING','QueryPort 메서드는 findById, findBy*, findBySliceCriteria, existsBy*, countBy* 패턴을 사용합니다.','일관된 네이밍 패턴은 메서드의 동작을 이름만으로 예측 가능하게 합니다. findBy*는 조회, existsBy*는 존재 여부 확인, countBy*는 카운트를 명확히 표현하여 코드 가독성과 유지보수성을 높입니다.',0,'PORT_OUT','2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL),(133,2,'APP-EVT-001','ApplicationEventPublisher 직접 주입 금지','BLOCKER','BEHAVIOR','Service에서 ApplicationEventPublisher 직접 주입이 금지됩니다. 트랜잭션 안전성 보장 불가.','ApplicationEventPublisher를 직접 사용하면 트랜잭션 롤백 시에도 이벤트가 발행될 수 있습니다. 데이터 불일치가 발생하면 보상 트랜잭션이 필요해지고 시스템 복잡도가 증가합니다. 트랜잭션 안전한 이벤트 발행을 위해 TransactionEventRegistry를 사용합니다.',0,'EVENT_LISTENER,COMMAND_SERVICE,QUERY_SERVICE,MANAGER','2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL),(134,2,'APP-EVT-002','TransactionEventRegistry 사용 필수','BLOCKER','BEHAVIOR','도메인 이벤트 발행 시 TransactionEventRegistry 사용 필수. 트랜잭션 커밋 후 이벤트 발행 보장.','TransactionEventRegistry는 트랜잭션 커밋 후에만 이벤트를 발행합니다. 이를 통해 데이터 저장과 이벤트 발행의 원자성이 보장되고, 롤백 시 이벤트가 발행되지 않아 데이터 일관성이 유지됩니다.',0,'EVENT_LISTENER,COMMAND_SERVICE,QUERY_SERVICE,MANAGER','2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL),(135,2,'APP-TIM-001','TimeProvider Factory에서만','BLOCKER','BEHAVIOR','TimeProvider.now()는 Factory에서만 호출합니다. Service에서 직접 사용 금지. Factory가 생성한 Context로 시간 전달.','시간 생성을 Factory에 집중하면 테스트에서 시간을 쉽게 제어할 수 있고, 하나의 비즈니스 트랜잭션 내에서 일관된 시간을 보장합니다. Service에서 직접 호출하면 테스트가 어렵고 시간 불일치가 발생할 수 있습니다.',0,'FACTORY','2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL),(136,2,'APP-FAC-001','Factory 사용 기준','MAJOR','STRUCTURE','복잡한 생성(Bundle), 업데이트(UpdateContext), 상태변경(StatusChangeContext)은 Factory 사용. 단순 조회(ID만)는 Service에서 직접.','Factory는 복잡한 객체 생성 로직을 캡슐화하여 Service의 단순성을 유지합니다. Bundle/Context 패턴이 필요한 복잡한 작업은 Factory로 분리하고, 단순 조회는 Service에서 직접 처리하여 불필요한 추상화를 방지합니다.',0,'FACTORY','2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL),(137,2,'APP-VAL-001','Validator Domain 반환','CRITICAL','BEHAVIOR','Validator의 validate*Exists 메서드는 검증 성공 시 조회한 Domain 객체를 반환합니다.','존재 검증 후 동일 데이터를 다시 조회하는 것은 불필요한 DB 접근입니다. Validator가 검증 과정에서 이미 조회한 Domain 객체를 반환하면 중복 조회를 방지하고 성능을 최적화할 수 있습니다.',0,'VALIDATOR','2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL),(138,2,'APP-VAL-002','Validator 도메인 전용 예외','CRITICAL','BEHAVIOR','Validator는 도메인 전용 예외(OrderNotFoundException 등)를 발생시킵니다. 범용 예외 클래스 사용 금지.','도메인 전용 예외를 사용하면 에러의 출처와 원인을 명확히 파악할 수 있습니다. OrderNotFoundException은 \"주문을 찾을 수 없음\"을 명확히 표현하여 디버깅과 에러 핸들링이 용이해지고, 클라이언트에 적절한 에러 응답을 제공할 수 있습니다.',0,'VALIDATOR','2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL),(139,2,'APP-ASM-001','도메인별 구체 Result 클래스','CRITICAL','STRUCTURE','Assembler는 도메인별 구체 Result 클래스(OrderSliceResult 등)를 반환합니다. 제네릭 래퍼(SliceResult<T>) 금지.','제네릭 래퍼(SliceResult<T>)는 타입 안전성이 떨어지고 IDE 자동완성이 불편합니다. 도메인별 구체 클래스(OrderSliceResult)를 사용하면 명시적이고 도메인 특화 메서드 추가가 가능합니다.',0,'ASSEMBLER','2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL),(140,2,'APP-ASM-002','생성 응답 원시타입 ID','MAJOR','BEHAVIOR','생성(Create) UseCase는 원시타입(Long)만 반환합니다. Assembler 불필요.','생성(Create) 작업은 새로 생성된 엔티티의 ID만 필요합니다. 전체 객체를 반환하면 불필요한 조회가 발생하고, Assembler 의존성이 추가됩니다. 단순히 ID(Long)를 반환하여 책임을 최소화합니다.',0,'ASSEMBLER','2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL),(141,2,'APP-SVC-001','UseCase 1:1 Service 구현','CRITICAL','STRUCTURE','1 UseCase = 1 Service. UseCase 인터페이스명에서 UseCase → Service로 변경.','UseCase와 Service의 1:1 매핑은 단일 책임 원칙을 강제하고 코드 탐색을 단순화합니다. UseCase 인터페이스가 도메인 경계를 정의하고, Service가 구현을 담당하는 명확한 역할 분리를 유지합니다.',0,'USE_CASE,COMMAND_SERVICE,QUERY_SERVICE','2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL),(142,2,'APP-SVC-002','UseCase 네이밍 규칙','MAJOR','NAMING','Command: Create*, Update*, Delete*, Cancel*, Approve*, Reject*. Query: Get*, Get*s, Get*By*, Check*Exists, Count*.','CQRS 패턴에서 Command와 Query의 명확한 네이밍 구분은 코드 의도를 명확히 전달합니다. 동사 접두사로 작업 유형을 즉시 파악할 수 있어 코드 리뷰와 유지보수 효율이 향상됩니다.',0,'USE_CASE,COMMAND_SERVICE,QUERY_SERVICE','2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL),(143,2,'APP-EXC-001','도메인 전용 예외 클래스 사용','CRITICAL','BEHAVIOR','범용 예외 클래스(EntityNotFoundException) 금지. 도메인별 전용 예외(OrderNotFoundException) 사용 필수.','범용 예외(EntityNotFoundException)는 어떤 도메인에서 발생했는지 알 수 없습니다. 도메인별 예외(OrderNotFoundException)를 사용하면 에러 추적이 명확해지고, 도메인별 예외 처리 로직을 분리할 수 있습니다.',0,'COMMAND_SERVICE,QUERY_SERVICE,MANAGER,VALIDATOR','2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL),(144,2,'APP-EXC-002','DomainException 직접 사용 금지','CRITICAL','BEHAVIOR','DomainException을 직접 throw하지 않습니다. 도메인별 전용 예외 클래스를 상속하여 사용.','도메인별 전용 예외를 사용하면 에러의 출처를 명확히 추적할 수 있고, 예외 처리 로직을 도메인 경계에 맞게 분리할 수 있습니다. 범용 DomainException은 디버깅과 에러 핸들링을 어렵게 만듭니다.',0,'COMMAND_SERVICE,QUERY_SERVICE,MANAGER,VALIDATOR','2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL),(145,2,'APP-LSN-001','EventListener @Async 권장','MAJOR','BEHAVIOR','EventListener는 비동기 처리를 권장합니다. 동기 처리 시 트랜잭션 문제 발생 가능.','동기 EventListener는 발행자의 트랜잭션 내에서 실행되어 실패 시 전체 트랜잭션이 롤백될 수 있습니다. @Async를 사용하면 이벤트 처리가 독립적인 트랜잭션에서 실행되어 결합도를 낮추고 장애 격리를 보장합니다.',0,'EVENT_LISTENER','2026-01-21 05:39:51.000000','2026-01-21 05:39:51.000000',NULL),(146,2,'APP-LSN-002','EventListener Manager 의존','CRITICAL','DEPENDENCY','EventListener는 Manager에 의존하여 비즈니스 로직을 처리합니다. Port 직접 의존 금지.','EventListener가 Port를 직접 의존하면 비즈니스 로직이 분산되고 트랜잭션 관리가 복잡해집니다. Manager를 통해 비즈니스 로직을 위임하면 단일 책임 원칙을 준수하고 테스트 가능성이 향상됩니다.',0,'EVENT_LISTENER','2026-01-21 05:39:51.000000','2026-01-21 05:39:51.000000',NULL),(147,3,'PER-REP-001','JpaRepository save/saveAll만 사용','BLOCKER','STRUCTURE','JpaRepository는 save, saveAll 메서드만 사용합니다. 다른 조회/삭제 메서드는 QueryDslRepository에서 처리합니다.','CQRS 패턴 준수. Command와 Query 분리를 통해 확장성과 유지보수성 향상.',0,'JPA_REPOSITORY','2026-01-21 07:49:21.000000','2026-01-21 07:49:21.000000',NULL),(148,3,'PER-REP-002','JpaRepository 커스텀 메서드 금지','BLOCKER','STRUCTURE','JpaRepository에 커스텀 쿼리 메서드(@Query, findBy* 등)를 추가하지 않습니다.','모든 조회 로직은 QueryDslRepository로 일원화하여 쿼리 관리 일관성 유지.',0,'JPA_REPOSITORY','2026-01-21 07:49:21.000000','2026-01-21 07:49:21.000000',NULL),(149,3,'PER-REP-003','모든 조회는 QueryDslRepository','BLOCKER','STRUCTURE','모든 조회 쿼리는 QueryDslRepository에서 QueryDSL을 사용하여 구현합니다. JPQL, Native Query 금지.','타입 안전한 쿼리 작성, 컴파일 타임 오류 검출, 동적 쿼리 구성 용이.',0,'QUERYDSL_REPOSITORY','2026-01-21 07:49:21.000000','2026-01-21 07:49:21.000000',NULL),(150,3,'PER-ADP-001','CommandAdapter는 JpaRepository만 의존','BLOCKER','DEPENDENCY','CommandAdapter는 오직 JpaRepository만 의존합니다. QueryDslRepository를 주입받지 않습니다.','CQRS 원칙 준수. Command 경로에서 조회 로직 혼입 방지.',0,'COMMAND_ADAPTER','2026-01-21 07:49:21.000000','2026-01-21 07:49:21.000000',NULL),(151,3,'PER-ADP-002','QueryAdapter는 QueryDslRepository만 의존','BLOCKER','DEPENDENCY','QueryAdapter는 오직 QueryDslRepository만 의존합니다. JpaRepository를 주입받지 않습니다.','CQRS 원칙 준수. Query 경로에서 변경 로직 혼입 방지.',0,'QUERY_ADAPTER','2026-01-21 07:49:21.000000','2026-01-21 07:49:21.000000',NULL),(152,3,'PER-ENT-001','JPA 관계 어노테이션 금지','BLOCKER','ANNOTATION','@OneToMany, @ManyToOne, @OneToOne, @ManyToMany 관계 어노테이션을 사용하지 않습니다. Long FK 전략 사용.','N+1 문제 원천 차단, 명시적 조인으로 성능 제어, 도메인 경계 명확화.',0,'JPA_ENTITY','2026-01-21 07:49:21.000000','2026-01-21 07:49:21.000000',NULL),(153,3,'PER-ENT-002','Entity는 BaseAuditEntity 상속','MAJOR','STRUCTURE','모든 JpaEntity는 BaseAuditEntity(audit만) 또는 SoftDeletableEntity(audit+soft delete)를 상속합니다.','Audit 필드 일관성, 코드 중복 제거, 감사 추적 표준화.',0,'JPA_ENTITY','2026-01-21 07:49:21.000000','2026-01-21 07:49:21.000000',NULL),(154,3,'PER-CFG-001','OSIV 비활성화 필수','BLOCKER','STRUCTURE','Open Session In View를 반드시 비활성화합니다. spring.jpa.open-in-view=false','커넥션 점유 시간 최소화, Lazy Loading은 Transaction 내에서만 수행.',0,'JPA_CONFIG','2026-01-21 07:49:21.000000','2026-01-21 07:49:21.000000',NULL),(155,3,'PER-CFG-002','DDL-AUTO는 validate만 허용','BLOCKER','STRUCTURE','Hibernate ddl-auto는 validate만 사용합니다. 스키마 변경은 Flyway로 관리.','운영 환경 스키마 안정성, 마이그레이션 이력 관리, 롤백 가능성 확보.',0,'JPA_CONFIG','2026-01-21 07:49:21.000000','2026-01-21 07:49:21.000000',NULL),(156,3,'PER-CND-001','BooleanExpression은 ConditionBuilder로 분리','MAJOR','STRUCTURE','QueryDslRepository의 where절 조건은 별도 ConditionBuilder 클래스에서 BooleanExpression 메서드로 분리합니다.','조건 로직 재사용, Repository 가독성 향상, 테스트 용이성.',0,'CONDITION_BUILDER','2026-01-21 07:49:21.000000','2026-01-21 07:49:21.000000',NULL),(157,3,'PER-CND-002','deletedAt null 조건 필수','BLOCKER','BEHAVIOR','Soft Delete 테이블 조회 시 반드시 deletedAt IS NULL 조건을 포함합니다.','삭제된 데이터 조회 방지, 데이터 무결성 보장.',0,'CONDITION_BUILDER,QUERYDSL_REPOSITORY','2026-01-21 07:49:21.000000','2026-01-21 07:49:21.000000',NULL),(158,3,'PER-MAP-001','EntityMapper 양방향 변환','MAJOR','STRUCTURE','EntityMapper는 toDomain(Entity)과 toEntity(Domain) 양방향 변환 메서드를 제공합니다.','도메인-영속성 변환 표준화, 의존성 방향 준수.',0,'ENTITY_MAPPER','2026-01-21 07:49:21.000000','2026-01-21 07:49:21.000000',NULL),(159,3,'PER-FTS-001','FullText는 FunctionContributor 등록','MAJOR','STRUCTURE','MySQL MATCH AGAINST 사용 시 Hibernate FunctionContributor를 META-INF/services에 등록합니다.','Native Query 의존 제거, QueryDSL 통합, 타입 안전성 확보.',0,'FUNCTION_CONTRIBUTOR','2026-01-21 07:49:21.000000','2026-01-21 07:49:21.000000',NULL),(160,3,'PER-ADM-001','Admin 복잡 쿼리는 persistence-mysql-admin 모듈','BLOCKER','LOCATION','조인, 서브쿼리 등 복잡한 쿼리는 persistence-mysql-admin 모듈에서만 허용됩니다. 도메인용 persistence-mysql에서는 단일 테이블 쿼리만 허용.','도메인 모듈의 순수성 유지, OLTP/OLAP 분리, 정책 명확화.',0,'ADMIN_QUERYDSL_REPOSITORY','2026-01-21 07:59:04.000000','2026-01-21 07:59:04.000000',NULL),(161,3,'PER-ADM-002','Admin 모듈은 조인 허용','INFO','STRUCTURE','persistence-mysql-admin 모듈에서는 leftJoin, innerJoin 등 조인이 허용됩니다. 단, DTO Projection 필수.','Admin/통계용 복잡 쿼리 지원, OLAP 최적화.',0,'ADMIN_QUERYDSL_REPOSITORY','2026-01-21 07:59:04.000000','2026-01-21 07:59:04.000000',NULL),(165,4,'API-CTR-001','@RestController 어노테이션 필수','CRITICAL','ANNOTATION','Controller 클래스는 반드시 @RestController 어노테이션을 사용해야 합니다.','@Controller + @ResponseBody 조합 대신 @RestController로 명시적으로 REST API임을 선언합니다.',1,'COMMAND_CONTROLLER,QUERY_CONTROLLER','2026-01-21 13:25:01.000000','2026-01-21 13:25:01.000000',NULL),(166,4,'API-CTR-002','DELETE 메서드 금지','BLOCKER','BEHAVIOR','HTTP DELETE 메서드 사용을 금지합니다. 대신 PATCH /{id}/delete로 soft delete를 구현해야 합니다.','데이터 복구 가능성과 감사 추적을 위해 물리 삭제 대신 논리 삭제(soft delete)를 사용합니다.',0,'COMMAND_CONTROLLER,QUERY_CONTROLLER','2026-01-21 13:25:01.000000','2026-01-21 13:25:01.000000',NULL),(167,4,'API-CTR-003','UseCase 인터페이스 의존','CRITICAL','DEPENDENCY','Controller는 Application Layer의 UseCase(Port-In) 인터페이스에만 의존해야 합니다. 구체 Service 클래스 직접 의존 금지.','헥사고날 아키텍처의 포트-어댑터 패턴을 준수하여 계층 간 결합도를 낮춥니다.',0,'COMMAND_CONTROLLER,QUERY_CONTROLLER','2026-01-21 13:25:01.000000','2026-01-21 13:25:01.000000',NULL),(168,4,'API-CTR-004','ResponseEntity + ApiResponse 래핑','CRITICAL','STRUCTURE','모든 응답은 ResponseEntity<ApiResponse<T>> 형태로 래핑해야 합니다.','일관된 API 응답 형식을 제공하고, timestamp, requestId 등 공통 메타데이터를 포함합니다.',0,'COMMAND_CONTROLLER,QUERY_CONTROLLER','2026-01-21 13:25:01.000000','2026-01-21 13:25:01.000000',NULL),(169,4,'API-CTR-005','Controller @Transactional 금지','BLOCKER','ANNOTATION','Controller에서 @Transactional 어노테이션 사용을 금지합니다. 트랜잭션은 Application Layer에서 관리합니다.','Controller는 HTTP 요청/응답만 담당하며, 비즈니스 로직과 트랜잭션 경계는 Application Layer의 책임입니다.',1,'COMMAND_CONTROLLER,QUERY_CONTROLLER','2026-01-21 13:25:01.000000','2026-01-21 13:25:01.000000',NULL),(170,4,'API-CTR-006','OpenAPI 어노테이션 필수','MAJOR','ANNOTATION','@Tag, @Operation, @ApiResponses 어노테이션을 반드시 사용해야 합니다.','Swagger/OpenAPI 문서 자동 생성을 위해 API 메타데이터를 어노테이션으로 선언합니다.',0,'COMMAND_CONTROLLER,QUERY_CONTROLLER','2026-01-21 13:25:01.000000','2026-01-21 13:25:01.000000',NULL),(171,4,'API-CTR-007','Controller 비즈니스 로직 금지','MAJOR','BEHAVIOR','Controller에 비즈니스 로직을 작성하지 않습니다. 변환 로직은 Mapper에 위임합니다.','Controller는 얇은(thin) 레이어로 유지하고, 요청 수신과 응답 반환만 담당합니다.',0,'COMMAND_CONTROLLER,QUERY_CONTROLLER','2026-01-21 13:25:20.000000','2026-01-21 13:25:20.000000',NULL),(172,4,'API-CTR-008','Endpoints 상수 사용','MAJOR','STRUCTURE','경로를 하드코딩하지 않고 *ApiEndpoints 상수 클래스를 사용해야 합니다.','경로 관리의 일관성과 오타 방지, IDE 자동완성 지원을 위해 상수로 관리합니다.',0,'COMMAND_CONTROLLER,QUERY_CONTROLLER','2026-01-21 13:25:20.000000','2026-01-21 13:25:20.000000',NULL),(173,4,'API-CTR-009','@Valid 어노테이션 필수','MAJOR','ANNOTATION','Request DTO 파라미터에 @Valid 어노테이션을 반드시 사용해야 합니다.','Jakarta Validation을 통한 입력값 검증을 활성화하여 비즈니스 로직 진입 전 유효성을 검사합니다.',1,'COMMAND_CONTROLLER,QUERY_CONTROLLER','2026-01-21 13:25:20.000000','2026-01-21 13:25:20.000000',NULL),(174,4,'API-CTR-010','CQRS Controller 분리','MAJOR','STRUCTURE','Command(CUD)와 Query(R) Controller를 별도 클래스로 분리해야 합니다.','CQRS 패턴에 따라 명령과 조회의 책임을 분리하여 코드 복잡도를 낮춥니다.',0,'COMMAND_CONTROLLER,QUERY_CONTROLLER','2026-01-21 13:25:20.000000','2026-01-21 13:25:20.000000',NULL),(175,4,'API-CTR-011','List 직접 반환 금지','BLOCKER','STRUCTURE','목록 조회 시 List를 직접 반환하지 않습니다. SliceApiResponse 또는 PageApiResponse를 사용해야 합니다.','페이지네이션 메타 정보(hasNext, cursor, totalPages 등)를 함께 제공하여 클라이언트의 페이징 처리를 지원합니다.',0,'COMMAND_CONTROLLER,QUERY_CONTROLLER','2026-01-21 13:25:20.000000','2026-01-21 13:25:20.000000',NULL),(176,4,'API-CTR-012','URL 경로 규칙','MINOR','NAMING','URL 경로는 소문자 + 복수형을 사용합니다. 예: /conventions, /modules','RESTful API 네이밍 컨벤션을 준수하여 일관된 API 설계를 유지합니다.',0,'COMMAND_CONTROLLER,QUERY_CONTROLLER','2026-01-21 13:25:20.000000','2026-01-21 13:25:20.000000',NULL),(177,4,'API-DTO-001','Record 타입 필수','CRITICAL','STRUCTURE','Request/Response DTO는 Java Record를 사용해야 합니다.','Record는 불변성을 보장하고 boilerplate 코드를 줄여줍니다.',0,'REQUEST_DTO,RESPONSE_DTO','2026-01-21 13:25:41.000000','2026-01-21 13:25:41.000000',NULL),(178,4,'API-DTO-002','DTO 불변성 보장','CRITICAL','STRUCTURE','DTO는 불변 객체로 설계해야 합니다. Setter 금지.','불변 객체는 스레드 안전하고 부수효과가 없어 예측 가능한 동작을 보장합니다.',0,'REQUEST_DTO,RESPONSE_DTO','2026-01-21 13:25:41.000000','2026-01-21 13:25:41.000000',NULL),(179,4,'API-DTO-003','Validation 어노테이션','MAJOR','ANNOTATION','Request DTO에 Jakarta Validation 어노테이션(@NotNull, @NotBlank 등)을 사용해야 합니다.','입력값 검증을 선언적으로 수행하여 컨트롤러 코드를 간결하게 유지합니다.',0,'REQUEST_DTO','2026-01-21 13:25:41.000000','2026-01-21 13:25:41.000000',NULL),(180,4,'API-DTO-004','createdAt/updatedAt 필수','CRITICAL','STRUCTURE','Response DTO에는 createdAt, updatedAt 필드가 반드시 포함되어야 합니다.','생성/수정 시각 정보는 클라이언트의 캐싱, 정렬, 표시에 필수적인 메타데이터입니다.',0,'RESPONSE_DTO','2026-01-21 13:25:41.000000','2026-01-21 13:25:41.000000',NULL),(181,4,'API-DTO-005','날짜 String 변환 필수','CRITICAL','STRUCTURE','Instant 타입은 DateTimeFormatUtils.formatIso8601()로 String 변환하여 반환해야 합니다.','ISO 8601 형식의 문자열로 제공하여 클라이언트의 타임존 처리를 용이하게 합니다.',0,'RESPONSE_DTO','2026-01-21 13:25:41.000000','2026-01-21 13:25:41.000000',NULL),(182,4,'API-DTO-006','Nested Record 허용','MINOR','STRUCTURE','복잡한 구조는 중첩 Record로 표현할 수 있습니다.','관련 필드를 그룹화하여 API 응답의 구조를 명확하게 표현합니다.',0,'REQUEST_DTO,RESPONSE_DTO','2026-01-21 13:25:41.000000','2026-01-21 13:25:41.000000',NULL),(183,4,'API-DTO-007','@Schema 어노테이션 권장','MINOR','ANNOTATION','OpenAPI 문서화를 위해 @Schema 어노테이션 사용을 권장합니다.','API 문서에 필드 설명, 예시값, 제약조건을 명시하여 개발자 경험을 향상시킵니다.',0,'REQUEST_DTO,RESPONSE_DTO','2026-01-21 13:25:41.000000','2026-01-21 13:25:41.000000',NULL),(184,4,'API-DTO-008','Optional 대신 Nullable','MAJOR','STRUCTURE','Optional 대신 @Nullable 또는 기본값을 사용합니다.','DTO에서 Optional은 직렬화 이슈가 있고, null 허용을 명시적으로 표현하는 것이 더 명확합니다.',0,'REQUEST_DTO,RESPONSE_DTO','2026-01-21 13:25:41.000000','2026-01-21 13:25:41.000000',NULL),(185,4,'API-DTO-009','List 필드 불변 복사','MAJOR','STRUCTURE','List 필드는 생성자에서 List.copyOf()로 방어적 복사해야 합니다.','외부에서 전달받은 컬렉션의 변경으로부터 DTO 내부 상태를 보호합니다.',0,'REQUEST_DTO,RESPONSE_DTO','2026-01-21 13:25:41.000000','2026-01-21 13:25:41.000000',NULL),(186,4,'API-MAP-001','@Component 필수','CRITICAL','ANNOTATION','Mapper 클래스는 @Component 어노테이션으로 Spring Bean 등록해야 합니다.','DI를 통한 테스트 용이성과 일관된 관리를 위해 Spring Bean으로 등록합니다.',1,'API_MAPPER','2026-01-21 13:25:56.000000','2026-01-21 13:25:56.000000',NULL),(187,4,'API-MAP-002','양방향 변환 지원','CRITICAL','BEHAVIOR','Mapper는 Request→Application Query/Command, Application Result→Response 양방향 변환을 지원해야 합니다.','API 경계의 모든 변환 로직을 Mapper에 집중하여 Controller를 얇게 유지합니다.',0,'API_MAPPER','2026-01-21 13:25:56.000000','2026-01-21 13:25:56.000000',NULL),(188,4,'API-MAP-003','날짜 포맷팅 담당','CRITICAL','BEHAVIOR','Response 생성 시 DateTimeFormatUtils.formatIso8601()로 날짜를 포맷팅해야 합니다.','Instant→String 변환 로직을 Mapper에 일원화하여 일관된 날짜 형식을 보장합니다.',0,'API_MAPPER','2026-01-21 13:25:56.000000','2026-01-21 13:25:56.000000',NULL),(189,4,'API-MAP-004','Slice/Page 변환 지원','MAJOR','BEHAVIOR','SliceResult/PageResult를 SliceApiResponse/PageApiResponse로 변환하는 메서드를 제공해야 합니다.','페이지네이션 결과의 변환 로직을 Mapper에 캡슐화합니다.',0,'API_MAPPER','2026-01-21 13:25:56.000000','2026-01-21 13:25:56.000000',NULL),(190,4,'API-MAP-005','순수 변환 로직만','MAJOR','BEHAVIOR','Mapper는 순수 변환 로직만 담당합니다. 비즈니스 로직 금지.','Mapper의 단일 책임을 유지하여 테스트와 유지보수를 용이하게 합니다.',0,'API_MAPPER','2026-01-21 13:25:56.000000','2026-01-21 13:25:56.000000',NULL),(191,4,'API-MAP-006','기본값 처리 담당','MAJOR','BEHAVIOR','Request에서 null인 필드의 기본값 처리는 Mapper에서 수행합니다.','Request DTO는 기본값 없이 원시 입력을 받고, Mapper에서 정책에 따라 기본값을 설정합니다.',0,'API_MAPPER','2026-01-21 13:25:56.000000','2026-01-21 13:25:56.000000',NULL),(192,4,'API-ERR-001','ErrorMapper 패턴','CRITICAL','STRUCTURE','도메인별 ErrorMapper를 구현하여 DomainException을 HTTP 응답으로 매핑해야 합니다.','예외 처리 로직을 ErrorMapper에 캡슐화하여 GlobalExceptionHandler를 얇게 유지합니다.',0,'ErrorMapper','2026-01-21 13:26:09.000000','2026-01-21 13:26:09.000000',NULL),(193,4,'API-ERR-002','ProblemDetail 응답','CRITICAL','STRUCTURE','에러 응답은 RFC 7807 ProblemDetail 형식을 사용해야 합니다.','표준화된 에러 응답 형식으로 클라이언트의 에러 처리를 일관되게 합니다.',0,'ErrorMapper','2026-01-21 13:26:09.000000','2026-01-21 13:26:09.000000',NULL),(194,4,'API-ERR-003','x-error-code 헤더','MAJOR','STRUCTURE','ProblemDetail에 x-error-code 확장 헤더를 추가해야 합니다.','에러 코드를 헤더로 제공하여 클라이언트의 조건부 에러 처리를 지원합니다.',0,'ErrorMapper','2026-01-21 13:26:09.000000','2026-01-21 13:26:09.000000',NULL),(195,4,'API-ERR-004','GlobalExceptionHandler 사용','CRITICAL','STRUCTURE','전역 예외 처리기(GlobalExceptionHandler)를 사용해야 합니다.','Controller별 예외 처리 중복을 제거하고 일관된 에러 응답을 보장합니다.',0,'GLOBAL_EXCEPTION_HANDLER','2026-01-21 13:26:09.000000','2026-01-21 13:26:09.000000',NULL),(196,4,'API-ERR-005','application/problem+json','MAJOR','STRUCTURE','에러 응답의 Content-Type은 application/problem+json이어야 합니다.','RFC 7807 표준에 따른 Content-Type으로 클라이언트가 에러 응답임을 인식할 수 있게 합니다.',0,'GLOBAL_EXCEPTION_HANDLER','2026-01-21 13:26:09.000000','2026-01-21 13:26:09.000000',NULL),(197,4,'API-CFG-001','JacksonConfig 설정','MAJOR','STRUCTURE','ObjectMapper 설정을 JacksonConfig에서 중앙 관리한다. PropertyNamingStrategies.SNAKE_CASE, JavaTimeModule 등록 필수.','JSON 직렬화/역직렬화 일관성 보장 및 Java 8+ 시간 타입 지원',0,'JacksonConfig','2026-01-21 13:27:27.000000','2026-01-21 13:27:27.000000',NULL),(198,4,'API-CFG-002','OpenApiConfig 설정','MINOR','STRUCTURE','Swagger/OpenAPI 문서화 설정을 OpenApiConfig에서 관리한다. GroupedOpenApi로 API 그룹핑.','API 문서 자동 생성 및 버전 관리',0,'OpenApiConfig','2026-01-21 13:27:27.000000','2026-01-21 13:27:27.000000',NULL),(199,4,'API-CFG-003','WebMvcConfig 설정','MAJOR','STRUCTURE','CORS, Interceptor, ArgumentResolver 설정을 WebMvcConfig에서 관리한다.','MVC 설정 중앙 집중화',0,'WebMvcConfig','2026-01-21 13:27:27.000000','2026-01-21 13:27:27.000000',NULL),(200,4,'API-CFG-004','서버 프리픽스 경로','MAJOR','NAMING','server.servlet.context-path=/api/v1/mcp 설정으로 모든 API 경로에 프리픽스 적용.','버전 관리 및 API Gateway 라우팅 지원',0,'application.yml','2026-01-21 13:27:27.000000','2026-01-21 13:27:27.000000',NULL),(201,4,'API-END-001','Endpoints final class','MAJOR','STRUCTURE','API 엔드포인트 상수 클래스는 final class로 선언하고 private 생성자를 가진다.','상속 방지 및 인스턴스화 방지로 유틸리티 클래스 패턴 준수',1,'API_ENDPOINTS','2026-01-21 13:27:44.000000','2026-01-21 13:27:44.000000',NULL),(202,4,'API-END-002','static final 상수','MAJOR','NAMING','모든 경로 상수는 public static final String으로 선언한다. 예: public static final String CONVENTIONS = \"/conventions\";','컴파일 타임 상수 보장 및 경로 중앙 관리',1,'API_ENDPOINTS','2026-01-21 13:27:44.000000','2026-01-21 13:27:44.000000',NULL),(203,4,'API-END-003','Path Variable 상수','MINOR','NAMING','PathVariable 이름도 상수로 관리한다. 예: public static final String PATH_ID = \"conventionId\";','오타 방지 및 일관된 경로 변수명 사용',1,'API_ENDPOINTS','2026-01-21 13:27:44.000000','2026-01-21 13:27:44.000000',NULL),(204,4,'API-END-004','도메인별 Endpoints 분리','MAJOR','STRUCTURE','각 도메인(Convention, Module 등)별로 별도의 *ApiEndpoints 클래스를 생성한다.','관심사 분리 및 유지보수성 향상',0,'API_ENDPOINTS','2026-01-21 13:27:44.000000','2026-01-21 13:27:44.000000',NULL),(205,4,'API-TST-001','MockMvc 금지','CRITICAL','TESTING','❌ MockMvc 사용 금지. 실제 HTTP 요청/응답 검증을 위해 TestRestTemplate 사용 필수.','MockMvc는 서블릿 컨테이너 없이 테스트하므로 실제 HTTP 동작과 차이 발생',0,'*ControllerTest','2026-01-21 13:27:59.000000','2026-01-21 13:27:59.000000',NULL),(206,4,'API-TST-002','TestRestTemplate 사용','CRITICAL','TESTING','✅ @SpringBootTest(webEnvironment = RANDOM_PORT) + TestRestTemplate으로 통합 테스트 작성.','실제 서블릿 컨테이너에서 HTTP 요청/응답 검증',0,'*ControllerTest','2026-01-21 13:27:59.000000','2026-01-21 13:27:59.000000',NULL),(207,4,'API-TST-003','ParameterizedTypeReference 사용','MAJOR','TESTING','ApiResponse<T> 제네릭 응답 역직렬화 시 ParameterizedTypeReference 사용 필수.','제네릭 타입 정보 보존을 위한 Type Token 패턴',0,'*ControllerTest','2026-01-21 13:27:59.000000','2026-01-21 13:27:59.000000',NULL),(208,4,'API-TST-004','Fixture 패턴','MAJOR','TESTING','테스트 데이터 생성은 *Fixture 클래스에서 static factory 메서드로 제공. 예: CreateOrderApiRequestFixture.valid()','테스트 데이터 중앙 관리 및 재사용성 향상',0,'*Fixture','2026-01-21 13:27:59.000000','2026-01-21 13:27:59.000000',NULL),(209,4,'API-TST-005','ErrorMapper 단위 테스트','MAJOR','TESTING','ErrorMapper는 supports() + map() 메서드 단위 테스트 필수. 도메인 예외별 HTTP 상태 코드 검증.','예외 처리 로직 안정성 보장',0,'*ErrorMapperTest','2026-01-21 13:27:59.000000','2026-01-21 13:27:59.000000',NULL),(210,2,'APP-PRT-004','Port 파라미터 Domain VO 사용 원칙','MAJOR','STRUCTURE','Port/UseCase 인터페이스의 파라미터는 원시타입 대신 Domain VO(Value Object)를 사용합니다.\n\n✅ 올바른 예:\nOptional<Order> findById(OrderId id);\nboolean existsByCustomerId(CustomerId customerId);\n\n⚠️ 예외 허용 (nullable 파라미터):\nList<Order> search(@Nullable Long customerId, OrderStatus status);\n\n❌ 잘못된 예:\nOptional<Order> findById(Long id);  // 원시타입 사용\nboolean exists(Long customerId);    // VO 없이 원시타입','Domain VO 사용의 이점:\n1. 타입 안전성: 컴파일 타임에 파라미터 혼동 방지 (Long customerId vs Long orderId)\n2. 도메인 언어 일관성: 유비쿼터스 언어를 인터페이스에 반영\n3. 검증 보장: VO 생성 시 유효성 검증이 이미 완료됨\n4. 의도 명확화: 파라미터의 비즈니스 의미가 타입으로 표현됨\n\nnullable 파라미터 예외 이유:\n- 검색 조건 등에서 null 허용이 필요한 경우 VO로 감싸면 불필요한 복잡성 증가\n- Optional.ofNullable(vo).map(Vo::value) 패턴의 반복을 피함',0,'*Port,*UseCase','2026-01-22 00:42:12.000000','2026-01-22 00:42:12.000000',NULL),(211,4,'API-CTR-013','Controller 조회 메서드명 규칙','MAJOR','NAMING','복합 조건 + 페이징/커서 조회: search{Bc}(Offset), search{Bc}ByCursor(커서). 단순 목록 조회: list{Bc}(필터 없음)','조회 API의 일관된 네이밍으로 클라이언트가 페이징 방식을 명확히 인지할 수 있음',0,'COMMAND_CONTROLLER,QUERY_CONTROLLER','2026-01-22 02:11:08.000000','2026-01-22 02:11:08.000000',NULL),(212,4,'API-DTO-010','Request DTO 조회 네이밍 규칙','MAJOR','NAMING','Offset 페이징: Search{Bc}ApiRequest. 커서 기반: Search{Bc}CursorApiRequest. 단순 목록: List{Bc}ApiRequest','Request DTO 네이밍으로 페이징 방식을 명확히 구분하여 API 문서화와 클라이언트 사용성 향상',0,'REQUEST_DTO','2026-01-22 02:11:26.000000','2026-01-22 02:11:26.000000',NULL),(213,2,'APP-UC-001','UseCase 조회 네이밍 규칙','MAJOR','NAMING','커서 기반 조회: Search{Domain}ByCursorUseCase. Offset 페이징: Search{Domain}UseCase. GetAll 네이밍 금지','UseCase 네이밍에 조회 방식을 명시하여 CQRS 분리와 조회 전략을 명확히 표현',0,'USE_CASE','2026-01-22 02:11:27.000000','2026-01-22 02:11:27.000000',NULL),(214,2,'APP-UC-002','Delete 네이밍 금지','CRITICAL','NAMING','UseCase, Service, Manager 등에서 Delete 네이밍 금지. Soft Delete는 Archive/Deactivate/Disable 사용. 예: ArchiveTechStackUseCase, DeactivateOrderService','Soft Delete와 Hard Delete 혼동 방지. Delete는 물리 삭제로 오해할 수 있어 명시적 네이밍 필수',0,'USE_CASE,COMMAND_SERVICE,QUERY_SERVICE,MANAGER','2026-01-22 02:23:03.000000','2026-01-22 02:23:03.000000',NULL),(215,2,'APP-FAC-002','Factory 메서드에 DTO 통째로 전달','CRITICAL','BEHAVIOR','Factory 메서드 호출 시 DTO를 풀어서 개별 파라미터로 전달하지 말고, DTO 자체를 전달합니다.','개별 파라미터를 풀어서 전달하면 DTO 필드 변경 시 호출하는 모든 곳을 수정해야 하므로 변경에 취약합니다. DTO를 통째로 전달하면 Factory 내부에서만 필드 접근을 처리하므로 응집도가 높아지고 변경에 강해집니다.',0,'FACTORY','2026-01-22 02:32:57.000000','2026-01-22 02:32:57.000000',NULL),(216,2,'APP-FAC-008','Factory에서 UpdateContext로 ID, UpdateData, changedAt 한 번에 생성','MAJOR','STRUCTURE','Update Command에서 ID, UpdateData, 변경 시간을 생성할 때 Factory를 여러 번 호출하지 않고, createUpdateContext() 메서드를 통해 UpdateContext<ID, UPDATE_DATA>(id, updateData, changedAt)를 한 번에 생성합니다. changedAt은 C-006에 따라 Factory에서 TimeProvider.now()로 생성합니다. Service에서는 context.changedAt()을 Domain.update()에 전달합니다.','Factory 호출 단순화 및 시간 생성 책임 일원화. Service에서 toId(), toUpdateData(), now()를 각각 호출하지 않고, createUpdateContext() 한 번 호출로 모든 업데이트 컨텍스트를 받습니다. C-006(시간 생성은 Factory에서만)과 일관성을 유지합니다.',0,'FACTORY','2026-01-22 03:17:03.000000','2026-01-22 03:17:03.000000',NULL),(217,2,'APP-FAC-003','Factory null 체크/기본값 설정 금지','CRITICAL','BEHAVIOR','Factory에서 Command/Query의 null 필드를 체크하고 기본값을 설정하는 로직을 금지합니다. 기본값 결정은 Domain VO의 Compact Constructor에서 수행해야 합니다.','DDD 원칙에 따라 도메인 불변 조건과 기본값 로직은 Domain 계층(VO, Aggregate)이 소유합니다. Factory가 이 책임을 가지면 도메인 로직이 Application 계층으로 유출되어 응집도가 낮아지고, 여러 Factory에서 중복 로직이 발생할 수 있습니다.',0,'METHOD','2026-01-28 08:18:12.000000','2026-01-28 08:18:12.000000',NULL),(218,2,'APP-FAC-004','Factory 의사결정 로직 금지','CRITICAL','BEHAVIOR','Factory에서 특정 ID나 필드 값을 기준으로 어떤 객체를 생성할지 판단하는 의사결정 로직을 금지합니다. 이러한 판단은 Domain Aggregate나 Domain Service가 담당해야 합니다.','Factory는 객체 생성의 복잡성을 캡슐화하는 역할이지, 비즈니스 의사결정을 하는 곳이 아닙니다. 어떤 객체를 생성할지 결정하는 로직은 도메인 지식이므로 Domain 계층에 위치해야 합니다. Factory에 이 로직이 있으면 도메인 규칙이 분산되어 유지보수가 어려워집니다.',0,'METHOD','2026-01-28 08:18:12.000000','2026-01-28 08:18:12.000000',NULL),(224,1,'DOM-AGG-030','Aggregate 필수 도메인 값은 VO 사용 필수','BLOCKER','STRUCTURE','Aggregate의 필수 도메인 값(phoneNumber, hashedPassword, email 등)은 원시 타입(String) 대신 전용 Value Object를 사용해야 합니다. VO는 domain/{bc}/vo 패키지에 위치하며, Compact Constructor에서 null 체크 및 유효성 검증을 수행합니다.','Primitive Obsession 안티패턴 방지. VO 사용으로 타입 안전성과 도메인 의미가 명확해지며, 검증 로직이 한 곳에 집중됩니다. Aggregate에서 불필요한 null 체크를 제거할 수 있습니다.',0,'FIELD','2026-01-28 08:21:16.000000','2026-01-28 08:21:16.000000',NULL),(225,1,'DOM-AGG-031','Aggregate에서 파라미터 null 체크 금지','CRITICAL','BEHAVIOR','Aggregate의 팩토리 메서드(forNew, reconstitute)나 명령 메서드(changeXXX)에서 파라미터에 대한 null 체크를 직접 수행하지 않아야 합니다. 대신 VO를 사용하고, VO의 Compact Constructor에서 null 체크 및 유효성 검증을 수행해야 합니다.','책임 분리 원칙. VO는 자신의 불변 조건을 보장하는 책임이 있으며, Aggregate는 비즈니스 로직에 집중해야 합니다. VO 생성 시점에 검증이 이루어지므로 Aggregate에서 중복 검증이 불필요합니다.',0,'METHOD','2026-01-28 08:21:16.000000','2026-01-28 08:21:16.000000',NULL),(226,1,'DOM-AGG-032','UpdateData에서 null 체크 금지','CRITICAL','BEHAVIOR','UpdateData는 Aggregate의 update() 메서드에 전달되는 데이터 번들입니다. UpdateData에 포함되는 VO 객체들은 이미 null 검증이 완료된 객체이므로, UpdateData에서 중복 검증을 수행하지 않아야 합니다.','VO 객체들은 자체적으로 생성 시점에 검증을 수행하므로, UpdateData에서 중복 검증할 필요가 없습니다. null 체크가 필요하다면 VO 내부에서 수행해야 합니다.',0,'CLASS','2026-01-28 08:21:16.000000','2026-01-28 08:21:16.000000',NULL),(227,1,'DOM-AGG-033','Aggregate VO 원시값 반환 편의 메서드 필수','CRITICAL','STRUCTURE','Aggregate는 VO 객체를 반환하는 메서드와 함께 원시값을 반환하는 편의 메서드를 제공해야 합니다. Law of Demeter를 준수하고 외부에서 체이닝 호출(aggregate.vo().value())을 방지합니다.','외부에서 aggregate.vo().value() 같은 체이닝 호출을 방지하고, Aggregate가 자신의 내부 구조를 직접 노출하지 않도록 캡슐화를 강화합니다.',0,'CLASS','2026-01-28 08:21:16.000000','2026-01-28 08:21:16.000000',NULL);
INSERT INTO `config_file_template` VALUES (1,1,1,'CLAUDE','.claude/CLAUDE.md','CLAUDE.md','# {{project_name}} - Claude Code Configuration\n\n이 프로젝트는 **{{tech_stack.framework_type}} {{tech_stack.framework_version}} + {{tech_stack.language_type}} {{tech_stack.language_version}}** 기반의 **{{architecture.name}}** 프로젝트입니다.\n\n---\n\n## 🏗️ 아키텍처 개요\n\n{{layers_diagram}}\n\n---\n\n## 🧰 MCP 도구 사용법\n\n이 프로젝트의 코딩 컨벤션은 **Convention Hub DB**에서 관리됩니다.\n코드 작성 시 반드시 MCP 도구를 사용하여 규칙을 조회하세요.\n\n### 3-Phase 워크플로우\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│  1️⃣ PLANNING PHASE                                          │\n│     planning_context(layers=[...])                          │\n│     → 레이어는 list_tech_stacks()로 먼저 조회                 │\n├─────────────────────────────────────────────────────────────┤\n│  2️⃣ EXECUTION PHASE                                         │\n│     module_context(module_id=N, class_type=\"...\")           │\n│     → 템플릿 + 규칙 기반 코드 생성                            │\n├─────────────────────────────────────────────────────────────┤\n│  3️⃣ VALIDATION PHASE                                        │\n│     validation_context(layers=[...])                        │\n│     → Zero-Tolerance + Checklist 검증                       │\n└─────────────────────────────────────────────────────────────┘\n```\n\n### 사용 예시\n\n```python\n# 0. 먼저 레이어 목록 조회 (하드코딩 금지!)\nlist_tech_stacks()\n# → layers: [\"DOMAIN\", \"APPLICATION\", \"ADAPTER_OUT\", \"ADAPTER_IN\", \"BOOTSTRAP\"]\n\n# 1. 개발 계획 수립\nplanning_context(layers=[\"DOMAIN\", \"APPLICATION\"])\n\n# 2. 코드 생성\nmodule_context(module_id=1, class_type=\"AGGREGATE\")\n\n# 3. 코드 검증\nvalidation_context(layers=[\"DOMAIN\"])\n```\n\n---\n\n## 🚨 Zero-Tolerance 규칙\n\n> ⚠️ **중요**: 규칙은 DB에서 조회하세요.\n\n```python\n# Zero-Tolerance 규칙 조회 (레이어는 동적으로!)\nvalidation_context(layers={{layers}})\n```\n\n### 주요 규칙 (요약)\n\n> 상세 규칙은 MCP `validation_context()` 또는 `get_rule()` 로 조회\n\nMCP를 통해 최신 규칙을 동적으로 조회하세요.\n하드코딩된 규칙은 DB 변경 시 outdated 될 수 있습니다.\n\n---\n\n## 📚 MCP Tools 목록\n\n| 분류 | Tool | 용도 |\n|------|------|------|\n| **워크플로우** | planning_context | 개발 계획 수립 |\n| | module_context | 코드 생성 (템플릿 + 규칙) |\n| | validation_context | 코드 검증 (Zero-Tolerance) |\n| **컨텍스트** | get_context | 빠른 컨텍스트 조회 |\n| | get_rule | 규칙 상세 + 예시 |\n| **계층** | list_tech_stacks | 기술 스택 + 레이어 목록 |\n| | get_architecture | 아키텍처 상세 |\n| | get_layer_detail | 레이어 상세 |\n\n---\n\n## 🔧 설계 원칙\n\nMCP 서버는 **순수 정보 브릿지**로 설계되었습니다:\n- MCP = 규칙/템플릿 전달 (Spring API → LLM)\n- **LLM은 규칙을 반드시 준수**하며 코드 생성\n- 규칙을 \"판단\"하지 않고 **100% 준수**\n\n---\n\n## ⚡ 빠른 시작\n\n```python\n# 1. 레이어 목록 조회\nlayers = list_tech_stacks()  # → [\"DOMAIN\", \"APPLICATION\", ...]\n\n# 2. Aggregate 생성 시\nplanning_context(layers=[\"DOMAIN\"])\nmodule_context(module_id=1, class_type=\"AGGREGATE\")\nvalidation_context(layers=[\"DOMAIN\"])\n\n# 3. UseCase 생성 시\nmodule_context(module_id=2, class_type=\"USE_CASE\")\n```\n','MAIN_CONFIG','Claude Code 메인 설정 파일. MCP 사용법과 아키텍처 개요 포함.','{\"tech_stack\": \"DYNAMIC - tech_stack 테이블에서 조회\", \"architecture\": \"DYNAMIC - architecture 테이블에서 조회\", \"project_name\": \"프로젝트명 (init 시 치환)\", \"layers_diagram\": \"DYNAMIC - layer 테이블에서 조회하여 다이어그램 생성\"}',1,1,'2026-01-24 07:44:23.000000','2026-01-25 06:38:38.000000',NULL),(2,1,1,'CLAUDE','.claude/settings.local.json','settings.local.json','{\n  \"hooks\": {}\n}','MAIN_CONFIG','Claude Code 로컬 설정 (hooks 비활성화)',NULL,2,0,'2026-01-24 07:44:39.000000','2026-01-25 06:42:55.000000',NULL),(3,1,1,'CLAUDE','.claude/agents/','implementer.md','# Implementer Agent\n\n모든 레이어 구현 전문가. Convention Hub의 규칙을 100% 준수하며 코드 생성.\n\n## 🎯 핵심 원칙\n\n> **MCP 기반 동적 규칙 조회 + Serena Lazy Caching**\n\n모든 컨벤션은 DB에서 관리됩니다. 하드코딩된 규칙이 아닌 MCP를 통해 동적으로 조회하세요.\n\n---\n\n## 📋 작업 워크플로우\n\n### Phase 1: 컨텍스트 확인\n\n```python\n# 1. Serena 캐시 확인\nserena.list_memories()\n# → \"convention-{layer}-{class_type}\" 존재 여부 확인\n\n# 2. 캐시 없으면 MCP로 조회\nplanning_context(layers=[\"요청된_레이어\"])\n# → 현재 TechStack/Architecture의 모듈 구조 파악\n```\n\n### Phase 2: 템플릿/규칙 조회 (Lazy Loading)\n\n```python\n# Serena에 캐시 없을 때만 호출\nresult = module_context(module_id=N, class_type=\"AGGREGATE\")\n\n# 결과를 Serena에 저장 (Lazy Caching)\nserena.write_memory(\n    memory_file_name=\"convention-domain-aggregate\",\n    content=result\n)\n```\n\n### Phase 3: 코드 생성\n\n1. 조회된 **템플릿 구조** 그대로 따르기\n2. 조회된 **규칙 100% 준수**\n3. BLOCKER 등급 규칙 위반 시 즉시 수정\n\n### Phase 4: 검증\n\n```python\nvalidation_context(layers=[\"작업한_레이어\"])\n# → Zero-Tolerance 규칙 체크\n```\n\n---\n\n## 🗂️ Serena 캐싱 전략\n\n### Memory Naming Convention\n```\nconvention-{layer_code}-{class_type}\n\n예시:\n- convention-domain-aggregate\n- convention-domain-vo\n- convention-application-usecase\n- convention-application-service\n- convention-persistence-entity\n- convention-restapi-controller\n```\n\n### 캐시 정책\n| 상황 | 동작 |\n|------|------|\n| 첫 요청 | MCP 호출 → Serena 저장 |\n| 재요청 | Serena에서 읽기 (API 호출 X) |\n| `--refresh` | 강제 재조회 |\n\n---\n\n## ⚠️ 필수 준수 사항\n\n1. **MCP 먼저**: 코드 작성 전 반드시 `module_context()` 호출\n2. **Serena 활용**: 동일 작업 반복 시 캐시 활용\n3. **Zero-Tolerance**: `validation_context()`로 검증 필수\n','AGENT','구현 전문가 Agent. MCP 동적 조회 + Serena Lazy Caching 워크플로우.',NULL,1,1,'2026-01-24 16:39:06.000000','2026-01-24 16:39:06.000000',NULL),(4,1,1,'CLAUDE','.claude/agents/','planner.md','# Planner Agent\n\nEpic 기획 및 Task 분해 전문가. 요구사항을 분석하고 구현 전략을 수립.\n\n## 🎯 핵심 원칙\n\n> **MCP로 프로젝트 구조 파악 → 영향도 분석 → Task 분해**\n\n---\n\n## 📋 작업 워크플로우\n\n### Phase 1: 프로젝트 구조 파악\n\n```python\n# 먼저 레이어 목록 조회\nlist_tech_stacks()\n# → layers: [\"DOMAIN\", \"APPLICATION\", \"ADAPTER_OUT\", \"ADAPTER_IN\", \"BOOTSTRAP\"]\n\n# 현재 TechStack/Architecture 확인\nplanning_context(layers=[...])  # 조회된 레이어 사용\n# → 모듈 목록, 패키지 구조, 레이어 관계 파악\n```\n\n### Phase 2: 영향도 분석\n\n```python\n# Serena로 기존 코드 검색\nserena.search_for_pattern(pattern=\"관련_키워드\")\nserena.find_symbol(name_path=\"관련_클래스\")\n# → 변경 영향 범위 파악\n```\n\n### Phase 3: Task 분해\n\n1. **컨텍스트 크기 기준**: ~15K tokens per Task\n2. **레이어별 분리**: 하위 레이어 → 상위 레이어 순서\n3. **의존성 순서**: Domain → Application → Adapter 순\n\n### Phase 4: Epic 문서 작성\n\n```python\n# Serena Memory에 Epic 저장\nserena.write_memory(\n    memory_file_name=\"epic-{feature_name}\",\n    content=epic_document\n)\n```\n\n---\n\n## 📊 Task 분해 기준\n\n| 작업 유형 | Task 단위 |\n|----------|----------|\n| 🆕 신규 기능 | 레이어별 1 Task |\n| ➕ 기능 확장 | 변경 파일 그룹별 |\n| 🔄 리팩토링 | 패턴별 |\n| 🐛 버그 수정 | 원인별 |\n','AGENT','기획 전문가 Agent. 요구사항 분석 및 Task 분해.',NULL,2,1,'2026-01-24 16:39:06.000000','2026-01-25 06:38:38.000000',NULL),(5,1,1,'CLAUDE','.claude/agents/','reviewer.md','# Reviewer Agent\n\n코드 리뷰 전문가. Convention Hub 규칙 기반 검증.\n\n## 🎯 핵심 원칙\n\n> **MCP로 규칙 조회 → 코드 대조 → 위반 사항 리포트**\n\n---\n\n## 📋 리뷰 워크플로우\n\n### Phase 1: 레이어 및 규칙 로드\n\n```python\n# 먼저 레이어 목록 조회\nlist_tech_stacks()\n\n# 변경된 레이어의 규칙 조회\nvalidation_context(layers=[...])  # 동적으로 레이어 지정\n# → Zero-Tolerance 규칙 + 체크리스트 획득\n\n# Serena에 캐싱\nserena.write_memory(\"review-rules\", rules)\n```\n\n### Phase 2: 코드 분석\n\n```python\n# 변경 파일 분류\ngit diff --name-only\n\n# 레이어별 파일 그룹핑 (경로 패턴으로 판별)\n# /domain/     → DOMAIN\n# /application/ → APPLICATION\n# /adapter-out/ or /persistence/ → ADAPTER_OUT\n# /adapter-in/ or /rest-api/     → ADAPTER_IN\n```\n\n### Phase 3: 규칙 대조\n\n각 파일에 대해:\n1. 해당 레이어/클래스타입의 규칙 조회\n2. 코드와 규칙 대조\n3. 위반 사항 기록\n\n### Phase 4: 리포트 생성\n\n```markdown\n## 리뷰 결과\n\n### 🔴 필수 수정 (Zero-Tolerance 위반)\n- [ ] 규칙코드: 설명 → 파일:라인\n\n### 🟡 권장 수정\n- [ ] ...\n\n### 🟢 통과\n- ✅ 규칙 준수 항목들\n```\n\n---\n\n## ⚠️ Zero-Tolerance 우선 체크\n\nMCP `validation_context()` 로 최신 규칙 조회 후 체크:\n- Lombok 사용 여부\n- Getter 체이닝 (Law of Demeter)\n- @Transactional 내 외부 API 호출\n- JPA 관계 어노테이션\n','AGENT','리뷰 전문가 Agent. Convention Hub 규칙 기반 코드 검증.',NULL,3,1,'2026-01-24 16:39:06.000000','2026-01-25 06:38:39.000000',NULL),(6,1,1,'CLAUDE','.claude/agents/','shipper.md','# Shipper Agent\n\n배포 전문가. Git 커밋, 푸시, PR 생성, Jira 상태 업데이트.\n\n## 🎯 핵심 원칙\n\n> **Epic 단위 배포: 1 Epic = 1 Branch = 1 PR**\n\n---\n\n## 📋 배포 워크플로우\n\n### Phase 1: 상태 확인\n\n```bash\ngit status\ngit log --oneline -10\n```\n\n### Phase 2: 커밋 정리\n\n```bash\n# WIP 커밋들 Squash\ngit rebase -i main\n\n# 커밋 메시지 형식\nfeat(domain): Order Aggregate 구현\n\n- OrderId, OrderStatus VO 추가\n- OrderCreatedEvent 이벤트 정의\n- Zero-Tolerance 규칙 준수 확인\n\nEPIC-123\n```\n\n### Phase 3: PR 생성\n\n```bash\ngh pr create --title \"feat: 주문 기능 구현\" --body \"...\"\n```\n\n### Phase 4: Jira 업데이트\n\n```python\n# Jira MCP 사용\njira.transition_issue(issue_key=\"EPIC-123\", status=\"In Review\")\n```\n\n---\n\n## 📝 PR 템플릿\n\n```markdown\n## Summary\n- 주문 도메인 Aggregate 구현\n- CQRS 패턴 적용\n\n## Changes\n- Domain: Order Aggregate, VO, Event\n- Application: CreateOrderUseCase\n- Persistence: OrderJpaEntity, Repository\n- REST API: OrderController\n\n## Test Plan\n- [ ] 단위 테스트 통과\n- [ ] ArchUnit 테스트 통과\n- [ ] 정적 분석 통과\n```\n','AGENT','배포 전문가 Agent. Git, PR, Jira 관리.',NULL,4,1,'2026-01-24 16:39:06.000000','2026-01-24 16:39:06.000000',NULL),(7,1,1,'CLAUDE','.claude/agents/','tester.md','# Tester Agent\n\n테스트 전문가. ArchUnit, 단위 테스트, 통합 테스트 작성 및 실행.\n\n## 🎯 핵심 원칙\n\n> **MCP로 테스트 규칙 조회 → 테스트 작성 → 실행 검증**\n\n---\n\n## 📋 테스트 워크플로우\n\n### Phase 1: 테스트 규칙 조회\n\n```python\n# 해당 레이어의 테스트 규칙 조회\nmodule_context(module_id=N, class_type=\"TEST\")\n# → 테스트 패턴, Mock 규칙, 네이밍 컨벤션\n```\n\n### Phase 2: 테스트 작성\n\n#### 단위 테스트\n```java\n@ExtendWith(MockitoExtension.class)\n@Tag(\"unit\")\nclass CreateOrderServiceTest {\n    @Mock private OrderCommandPort orderCommandPort;\n    // BDDMockito 스타일\n}\n```\n\n#### 통합 테스트\n```java\n@SpringBootTest(webEnvironment = RANDOM_PORT)\n@Tag(\"integration\")\nclass OrderApiIntegrationTest {\n    @Autowired private TestRestTemplate restTemplate;\n    // MockMvc 금지 → TestRestTemplate 사용\n}\n```\n\n### Phase 3: 실행 및 검증\n\n```bash\n# 단위 테스트\n./gradlew test --tests \"*Test\"\n\n# ArchUnit 테스트\n./gradlew test --tests \"*ArchTest\"\n\n# 정적 분석\n./gradlew check\n```\n\n---\n\n## ⚠️ 테스트 규칙\n\n| 항목 | 규칙 |\n|------|------|\n| Mock 프레임워크 | Mockito + BDDMockito |\n| 단위 테스트 | @ExtendWith(MockitoExtension.class) |\n| 통합 테스트 | TestRestTemplate (MockMvc 금지) |\n| Assertion | AssertJ |\n| 태그 | @Tag(\"unit\"), @Tag(\"integration\") |\n','AGENT','테스트 전문가 Agent. 테스트 작성 및 실행.',NULL,5,1,'2026-01-24 16:39:06.000000','2026-01-24 16:39:06.000000',NULL),(8,1,1,'CLAUDE','.claude/skills/implementer/','SKILL.md','# /implementer Skill\n\n코드 구현 스킬. MCP + Serena Lazy Caching 기반.\n\n## 사용법\n\n```\n/implementer \"Order Aggregate 생성\"\n/implementer --layer domain --type aggregate\n```\n\n## 실행 흐름\n\n1. **캐시 확인**: `serena.read_memory(\"convention-{layer}-{type}\")`\n2. **캐시 미스**: `module_context()` 호출 → Serena 저장\n3. **코드 생성**: 템플릿 + 규칙 기반\n4. **검증**: `validation_context()` 호출\n\n## Lazy Caching 로직\n\n```python\ncache_key = f\"convention-{layer}-{class_type}\"\n\n# 1. Serena 캐시 확인\ncached = serena.read_memory(cache_key)\n\nif cached:\n    # 캐시 히트 → API 호출 스킵\n    rules = cached\nelse:\n    # 캐시 미스 → MCP 호출\n    rules = module_context(module_id, class_type)\n    # Serena에 저장\n    serena.write_memory(cache_key, rules)\n\n# 규칙 기반 코드 생성\ngenerate_code(rules)\n```\n','SKILL','구현 스킬. Lazy Caching 기반 코드 생성.',NULL,1,1,'2026-01-24 16:39:06.000000','2026-01-24 16:39:06.000000',NULL),(9,1,1,'CLAUDE','.claude/skills/planner/','SKILL.md','# /planner Skill\n\n기획 및 Task 분해 스킬.\n\n## 사용법\n\n```\n/planner \"결제 기능 구현\"\n/planner --analyze \"영향도 분석\"\n```\n\n## 실행 흐름\n\n1. `planning_context()` → 프로젝트 구조 파악\n2. `serena.search_for_pattern()` → 영향도 분석\n3. Task 분해 (컨텍스트 크기 ~15K 기준)\n4. `serena.write_memory(\"epic-{name}\")` → Epic 저장\n','SKILL','기획 스킬. Task 분해 및 Epic 관리.',NULL,2,1,'2026-01-24 16:39:06.000000','2026-01-24 16:39:06.000000',NULL),(10,1,1,'CLAUDE','.claude/skills/reviewer/','SKILL.md','# /reviewer Skill\n\n코드 리뷰 스킬. Convention Hub 규칙 기반.\n\n## 사용법\n\n```\n/reviewer\n/reviewer --staged\n/reviewer --fix\n```\n\n## 실행 흐름\n\n1. `validation_context()` → Zero-Tolerance 규칙 로드\n2. 변경 파일 분석\n3. 규칙 대조 및 위반 사항 리포트\n4. `--fix` 옵션 시 자동 수정\n','SKILL','리뷰 스킬. 규칙 기반 코드 검증.',NULL,3,1,'2026-01-24 16:39:06.000000','2026-01-24 16:39:06.000000',NULL),(11,1,1,'CLAUDE','.claude/skills/shipper/','SKILL.md','# /shipper Skill\n\n배포 스킬. Git + PR + Jira 통합.\n\n## 사용법\n\n```\n/shipper\n/shipper --draft\n/shipper --no-squash\n```\n\n## 실행 흐름\n\n1. Git 상태 확인\n2. WIP 커밋 Squash\n3. PR 생성\n4. Jira 상태 업데이트\n','SKILL','배포 스킬. Epic 단위 PR 생성.',NULL,4,1,'2026-01-24 16:39:06.000000','2026-01-24 16:39:06.000000',NULL),(12,1,1,'CLAUDE','.claude/skills/tester/','SKILL.md','# /tester Skill\n\n테스트 스킬. 테스트 작성 및 실행.\n\n## 사용법\n\n```\n/tester\n/tester --unit\n/tester --arch\n```\n\n## 실행 흐름\n\n1. `module_context(class_type=\"TEST\")` → 테스트 규칙 조회\n2. 테스트 코드 작성\n3. `./gradlew test` 실행\n4. 결과 리포트\n','SKILL','테스트 스킬. 테스트 작성 및 실행.',NULL,5,1,'2026-01-24 16:39:06.000000','2026-01-24 16:39:06.000000',NULL),(13,1,1,'CLAUDE','.claude/rules/','convention-guide.md','# Convention Guide\n\n> ⚠️ **규칙은 하드코딩되지 않습니다. MCP를 통해 동적으로 조회하세요.**\n\n## 규칙 조회 방법\n\n### 1. 레이어 목록 확인\n```python\n# 먼저 사용 가능한 레이어 목록 조회\nlist_tech_stacks()\n# 또는\nget_architecture(architecture_id=1)\n```\n\n### 2. 전체 규칙 개요\n```python\n# 조회된 레이어 코드로 validation_context 호출\nvalidation_context(layers={{layers}})\n```\n\n### 3. 레이어별 상세 규칙\n```python\nget_layer_detail(layer_code=\"조회된_레이어_코드\")\n```\n\n### 4. 특정 규칙 상세\n```python\nget_rule(rule_code=\"규칙_코드\")\n```\n\n### 5. 클래스별 템플릿 + 규칙\n```python\nmodule_context(module_id=N, class_type=\"클래스_타입\")\n```\n\n## Serena 캐싱\n\n조회된 규칙은 Serena Memory에 캐싱하여 재사용:\n\n```python\n# 캐시 키: convention-{layer}-{class_type}\nserena.write_memory(\"convention-domain-aggregate\", rules)\nserena.read_memory(\"convention-domain-aggregate\")\n```\n\n## Zero-Tolerance 빠른 참조\n\n> 상세 규칙은 `validation_context()` 또는 `get_rule()` 로 조회\n\nMCP를 통해 최신 규칙을 동적으로 조회하세요.\n하드코딩된 규칙은 DB 변경 시 outdated 될 수 있습니다.\n','RULE','Convention 가이드. MCP 동적 조회 안내.','{\"layers\": \"DYNAMIC - layer 테이블에서 조회\"}',1,1,'2026-01-24 16:39:06.000000','2026-01-25 06:35:23.000000',NULL),(16,1,NULL,'CLAUDE','.claude/agents/','implementer.md','# Implementer Agent\n\n모든 레이어 구현 전문가. Convention Hub의 규칙을 100% 준수하며 코드 생성.\n\n## 🎯 핵심 원칙\n\n> **MCP 기반 동적 규칙 조회 + Serena Lazy Caching**\n\n모든 컨벤션은 DB에서 관리됩니다. 하드코딩된 규칙이 아닌 MCP를 통해 동적으로 조회하세요.\n\n---\n\n## 📋 작업 워크플로우\n\n### Phase 1: 컨텍스트 확인\n\n```python\n# 1. Serena 캐시 확인\nserena.list_memories()\n# → \"convention-{layer}-{class_type}\" 존재 여부 확인\n\n# 2. 캐시 없으면 MCP로 조회 (레이어는 list_tech_stacks()로 먼저 조회!)\nplanning_context(layers=[...])  # 동적 레이어 사용\n# → 현재 TechStack/Architecture의 모듈 구조 파악\n```\n\n### Phase 2: 템플릿/규칙 조회 (Lazy Loading)\n\n```python\n# Serena에 캐시 없을 때만 호출\nresult = module_context(module_id=N, class_type=\"AGGREGATE\")\n\n# 결과를 Serena에 저장 (Lazy Caching)\nserena.write_memory(\n    memory_file_name=\"convention-domain-aggregate\",\n    content=result\n)\n```\n\n### Phase 3: 코드 생성\n\n1. 조회된 **템플릿 구조** 그대로 따르기\n2. 조회된 **규칙 100% 준수**\n3. BLOCKER 등급 규칙 위반 시 즉시 수정\n\n### Phase 4: 검증\n\n```python\nvalidation_context(layers=[...])  # 동적 레이어 사용\n# → Zero-Tolerance 규칙 체크\n```\n\n---\n\n## 🗂️ Serena 캐싱 전략\n\n### Memory Naming Convention\n```\nconvention-{layer_code}-{class_type}\n\n예시:\n- convention-domain-aggregate\n- convention-domain-vo\n- convention-application-usecase\n- convention-application-service\n- convention-adapter_out-entity\n- convention-adapter_in-controller\n```\n\n### 캐시 정책\n| 상황 | 동작 |\n|------|------|\n| 첫 요청 | MCP 호출 → Serena 저장 |\n| 재요청 | Serena에서 읽기 (API 호출 X) |\n| `--refresh` | 강제 재조회 |\n\n---\n\n## ⚠️ 필수 준수 사항\n\n1. **MCP 먼저**: 코드 작성 전 반드시 `module_context()` 호출\n2. **Serena 활용**: 동일 작업 반복 시 캐시 활용\n3. **Zero-Tolerance**: `validation_context()`로 검증 필수\n','AGENT','구현 전문가 Agent. MCP 동적 조회 + Serena Lazy Caching 워크플로우.',NULL,1,1,'2026-01-25 07:46:59.000000','2026-01-25 07:46:59.000000',NULL),(17,1,NULL,'CLAUDE','.claude/agents/','planner.md','# Planner Agent\n\nEpic 기획 및 Task 분해 전문가. 요구사항을 분석하고 구현 전략을 수립.\n\n## 🎯 핵심 원칙\n\n> **MCP로 프로젝트 구조 파악 → 영향도 분석 → Task 분해**\n\n---\n\n## 📋 작업 워크플로우\n\n### Phase 1: 프로젝트 구조 파악\n\n```python\n# 먼저 레이어 목록 조회\nlist_tech_stacks()\n# → layers: [\"DOMAIN\", \"APPLICATION\", \"ADAPTER_OUT\", \"ADAPTER_IN\", \"BOOTSTRAP\"]\n\n# 현재 TechStack/Architecture 확인\nplanning_context(layers=[...])  # 조회된 레이어 사용\n# → 모듈 목록, 패키지 구조, 레이어 관계 파악\n```\n\n### Phase 2: 영향도 분석\n\n```python\n# Serena로 기존 코드 검색\nserena.search_for_pattern(pattern=\"관련_키워드\")\nserena.find_symbol(name_path=\"관련_클래스\")\n# → 변경 영향 범위 파악\n```\n\n### Phase 3: Task 분해\n\n1. **컨텍스트 크기 기준**: ~15K tokens per Task\n2. **레이어별 분리**: 하위 레이어 → 상위 레이어 순서\n3. **의존성 순서**: Domain → Application → Adapter 순\n\n### Phase 4: Epic 문서 작성\n\n```python\n# Serena Memory에 Epic 저장\nserena.write_memory(\n    memory_file_name=\"epic-{feature_name}\",\n    content=epic_document\n)\n```\n\n---\n\n## 📊 Task 분해 기준\n\n| 작업 유형 | Task 단위 |\n|----------|----------|\n| 🆕 신규 기능 | 레이어별 1 Task |\n| ➕ 기능 확장 | 변경 파일 그룹별 |\n| 🔄 리팩토링 | 패턴별 |\n| 🐛 버그 수정 | 원인별 |\n','AGENT','기획 전문가 Agent. 요구사항 분석 및 Task 분해.',NULL,2,1,'2026-01-25 07:46:59.000000','2026-01-25 07:46:59.000000',NULL),(18,1,NULL,'CLAUDE','.claude/agents/','reviewer.md','# Reviewer Agent\n\n코드 리뷰 전문가. Convention Hub 규칙 기반 검증.\n\n## 🎯 핵심 원칙\n\n> **MCP로 규칙 조회 → 코드 대조 → 위반 사항 리포트**\n\n---\n\n## 📋 리뷰 워크플로우\n\n### Phase 1: 레이어 및 규칙 로드\n\n```python\n# 먼저 레이어 목록 조회\nlist_tech_stacks()\n\n# 변경된 레이어의 규칙 조회\nvalidation_context(layers=[...])  # 동적으로 레이어 지정\n# → Zero-Tolerance 규칙 + 체크리스트 획득\n\n# Serena에 캐싱\nserena.write_memory(\"review-rules\", rules)\n```\n\n### Phase 2: 코드 분석\n\n```python\n# 변경 파일 분류\ngit diff --name-only\n\n# 레이어별 파일 그룹핑 (경로 패턴으로 판별)\n# /domain/     → DOMAIN\n# /application/ → APPLICATION\n# /adapter-out/ or /persistence/ → ADAPTER_OUT\n# /adapter-in/ or /rest-api/     → ADAPTER_IN\n```\n\n### Phase 3: 규칙 대조\n\n각 파일에 대해:\n1. 해당 레이어/클래스타입의 규칙 조회\n2. 코드와 규칙 대조\n3. 위반 사항 기록\n\n### Phase 4: 리포트 생성\n\n```markdown\n## 리뷰 결과\n\n### 🔴 필수 수정 (Zero-Tolerance 위반)\n- [ ] 규칙코드: 설명 → 파일:라인\n\n### 🟡 권장 수정\n- [ ] ...\n\n### 🟢 통과\n- ✅ 규칙 준수 항목들\n```\n\n---\n\n## ⚠️ Zero-Tolerance 우선 체크\n\nMCP `validation_context()` 로 최신 규칙 조회 후 체크:\n- Lombok 사용 여부\n- Getter 체이닝 (Law of Demeter)\n- @Transactional 내 외부 API 호출\n- JPA 관계 어노테이션\n','AGENT','리뷰 전문가 Agent. Convention Hub 규칙 기반 코드 검증.',NULL,3,1,'2026-01-25 07:46:59.000000','2026-01-25 07:46:59.000000',NULL),(19,1,NULL,'CLAUDE','.claude/agents/','shipper.md','# Shipper Agent\n\n배포 전문가. Git 커밋, 푸시, PR 생성, Jira 상태 업데이트.\n\n## 🎯 핵심 원칙\n\n> **Epic 단위 배포: 1 Epic = 1 Branch = 1 PR**\n\n---\n\n## 📋 배포 워크플로우\n\n### Phase 1: 상태 확인\n\n```bash\ngit status\ngit log --oneline -10\n```\n\n### Phase 2: 커밋 정리\n\n```bash\n# WIP 커밋들 Squash\ngit rebase -i main\n\n# 커밋 메시지 형식\nfeat(domain): Order Aggregate 구현\n\n- OrderId, OrderStatus VO 추가\n- OrderCreatedEvent 이벤트 정의\n- Zero-Tolerance 규칙 준수 확인\n\nEPIC-123\n```\n\n### Phase 3: PR 생성\n\n```bash\ngh pr create --title \"feat: 주문 기능 구현\" --body \"...\"\n```\n\n### Phase 4: Jira 업데이트\n\n```python\n# Jira MCP 사용\njira.transition_issue(issue_key=\"EPIC-123\", status=\"In Review\")\n```\n\n---\n\n## 📝 PR 템플릿\n\n```markdown\n## Summary\n- 주문 도메인 Aggregate 구현\n- CQRS 패턴 적용\n\n## Changes\n- Domain: Order Aggregate, VO, Event\n- Application: CreateOrderUseCase\n- Adapter-Out: OrderJpaEntity, Repository\n- Adapter-In: OrderController\n\n## Test Plan\n- [ ] 단위 테스트 통과\n- [ ] ArchUnit 테스트 통과\n- [ ] 정적 분석 통과\n```\n','AGENT','배포 전문가 Agent. Git, PR, Jira 관리.',NULL,4,1,'2026-01-25 07:46:59.000000','2026-01-25 07:46:59.000000',NULL),(20,1,NULL,'CLAUDE','.claude/agents/','tester.md','# Tester Agent\n\n테스트 전문가. ArchUnit, 단위 테스트, 통합 테스트 작성 및 실행.\n\n## 🎯 핵심 원칙\n\n> **MCP로 테스트 규칙 조회 → 테스트 작성 → 실행 검증**\n\n---\n\n## 📋 테스트 워크플로우\n\n### Phase 1: 테스트 규칙 조회\n\n```python\n# 해당 레이어의 테스트 규칙 조회\nmodule_context(module_id=N, class_type=\"TEST\")\n# → 테스트 패턴, Mock 규칙, 네이밍 컨벤션\n```\n\n### Phase 2: 테스트 작성\n\n#### 단위 테스트\n```java\n@ExtendWith(MockitoExtension.class)\n@Tag(\"unit\")\nclass CreateOrderServiceTest {\n    @Mock private OrderCommandPort orderCommandPort;\n    // BDDMockito 스타일\n}\n```\n\n#### 통합 테스트\n```java\n@SpringBootTest(webEnvironment = RANDOM_PORT)\n@Tag(\"integration\")\nclass OrderApiIntegrationTest {\n    @Autowired private TestRestTemplate restTemplate;\n    // MockMvc 금지 → TestRestTemplate 사용\n}\n```\n\n### Phase 3: 실행 및 검증\n\n```bash\n# 단위 테스트\n./gradlew test --tests \"*Test\"\n\n# ArchUnit 테스트\n./gradlew test --tests \"*ArchTest\"\n\n# 정적 분석\n./gradlew check\n```\n\n---\n\n## ⚠️ 테스트 규칙\n\n| 항목 | 규칙 |\n|------|------|\n| Mock 프레임워크 | Mockito + BDDMockito |\n| 단위 테스트 | @ExtendWith(MockitoExtension.class) |\n| 통합 테스트 | TestRestTemplate (MockMvc 금지) |\n| Assertion | AssertJ |\n| 태그 | @Tag(\"unit\"), @Tag(\"integration\") |\n','AGENT','테스트 전문가 Agent. 테스트 작성 및 실행.',NULL,5,1,'2026-01-25 07:46:59.000000','2026-01-25 07:46:59.000000',NULL),(21,1,NULL,'CLAUDE','.claude/skills/implementer/','SKILL.md','# /implementer Skill\n\n코드 구현 스킬. MCP + Serena Lazy Caching 기반.\n\n## 사용법\n\n```\n/implementer \"Order Aggregate 생성\"\n/implementer --layer domain --type aggregate\n```\n\n## 실행 흐름\n\n1. **캐시 확인**: `serena.read_memory(\"convention-{layer}-{type}\")`\n2. **캐시 미스**: `module_context()` 호출 → Serena 저장\n3. **코드 생성**: 템플릿 + 규칙 기반\n4. **검증**: `validation_context()` 호출\n\n## Lazy Caching 로직\n\n```python\ncache_key = f\"convention-{layer}-{class_type}\"\n\n# 1. Serena 캐시 확인\ncached = serena.read_memory(cache_key)\n\nif cached:\n    # 캐시 히트 → API 호출 스킵\n    rules = cached\nelse:\n    # 캐시 미스 → MCP 호출\n    rules = module_context(module_id, class_type)\n    # Serena에 저장\n    serena.write_memory(cache_key, rules)\n\n# 규칙 기반 코드 생성\ngenerate_code(rules)\n```\n','SKILL','구현 스킬. Lazy Caching 기반 코드 생성.',NULL,1,1,'2026-01-25 07:46:59.000000','2026-01-25 07:46:59.000000',NULL),(22,1,NULL,'CLAUDE','.claude/skills/planner/','SKILL.md','# /planner Skill\n\n기획 및 Task 분해 스킬.\n\n## 사용법\n\n```\n/planner \"결제 기능 구현\"\n/planner --analyze \"영향도 분석\"\n```\n\n## 실행 흐름\n\n1. `planning_context()` → 프로젝트 구조 파악\n2. `serena.search_for_pattern()` → 영향도 분석\n3. Task 분해 (컨텍스트 크기 ~15K 기준)\n4. `serena.write_memory(\"epic-{name}\")` → Epic 저장\n','SKILL','기획 스킬. Task 분해 및 Epic 관리.',NULL,2,1,'2026-01-25 07:46:59.000000','2026-01-25 07:46:59.000000',NULL),(23,1,NULL,'CLAUDE','.claude/skills/reviewer/','SKILL.md','# /reviewer Skill\n\n코드 리뷰 스킬. Convention Hub 규칙 기반.\n\n## 사용법\n\n```\n/reviewer\n/reviewer --staged\n/reviewer --fix\n```\n\n## 실행 흐름\n\n1. `validation_context()` → Zero-Tolerance 규칙 로드\n2. 변경 파일 분석\n3. 규칙 대조 및 위반 사항 리포트\n4. `--fix` 옵션 시 자동 수정\n','SKILL','리뷰 스킬. 규칙 기반 코드 검증.',NULL,3,1,'2026-01-25 07:46:59.000000','2026-01-25 07:46:59.000000',NULL),(24,1,NULL,'CLAUDE','.claude/skills/shipper/','SKILL.md','# /shipper Skill\n\n배포 스킬. Git + PR + Jira 통합.\n\n## 사용법\n\n```\n/shipper\n/shipper --draft\n/shipper --no-squash\n```\n\n## 실행 흐름\n\n1. Git 상태 확인\n2. WIP 커밋 Squash\n3. PR 생성\n4. Jira 상태 업데이트\n','SKILL','배포 스킬. Epic 단위 PR 생성.',NULL,4,1,'2026-01-25 07:46:59.000000','2026-01-25 07:46:59.000000',NULL),(25,1,NULL,'CLAUDE','.claude/skills/tester/','SKILL.md','# /tester Skill\n\n테스트 스킬. 테스트 작성 및 실행.\n\n## 사용법\n\n```\n/tester\n/tester --unit\n/tester --arch\n```\n\n## 실행 흐름\n\n1. `module_context(class_type=\"TEST\")` → 테스트 규칙 조회\n2. 테스트 코드 작성\n3. `./gradlew test` 실행\n4. 결과 리포트\n','SKILL','테스트 스킬. 테스트 작성 및 실행.',NULL,5,1,'2026-01-25 07:46:59.000000','2026-01-25 07:46:59.000000',NULL),(26,1,NULL,'CLAUDE','.claude/rules/','convention-guide.md','# Convention Guide\n\n> ⚠️ **규칙은 하드코딩되지 않습니다. MCP를 통해 동적으로 조회하세요.**\n\n## 규칙 조회 방법\n\n### 1. 레이어 목록 먼저 조회\n```python\nlist_tech_stacks()\n# → layers: [\"DOMAIN\", \"APPLICATION\", \"ADAPTER_OUT\", \"ADAPTER_IN\", \"BOOTSTRAP\"]\n```\n\n### 2. 전체 규칙 개요\n```python\nvalidation_context(layers=[...])  # 조회된 레이어 사용\n```\n\n### 3. 레이어별 상세 규칙\n```python\nget_layer_detail(layer_code=\"DOMAIN\")\n```\n\n### 4. 특정 규칙 상세\n```python\nget_rule(rule_code=\"DOM-AGG-001\")\n```\n\n### 5. 클래스별 템플릿 + 규칙\n```python\nmodule_context(module_id=1, class_type=\"AGGREGATE\")\n```\n\n## Serena 캐싱\n\n조회된 규칙은 Serena Memory에 캐싱하여 재사용:\n\n```python\n# 캐시 키: convention-{layer}-{class_type}\nserena.write_memory(\"convention-domain-aggregate\", rules)\nserena.read_memory(\"convention-domain-aggregate\")\n```\n\n## Zero-Tolerance 빠른 참조\n\n> 상세 규칙은 `validation_context()`로 조회\n\n| Layer | 핵심 규칙 |\n|-------|----------|\n| DOMAIN | Lombok 금지, Getter 체이닝 금지 |\n| APPLICATION | @Transactional 내 외부 API 금지 |\n| ADAPTER_OUT | JPA 관계 어노테이션 금지 |\n| ADAPTER_IN | MockMvc 금지 |\n','RULE','Convention 가이드. MCP 동적 조회 안내.',NULL,1,1,'2026-01-25 07:46:59.000000','2026-01-25 07:46:59.000000',NULL);
INSERT INTO `convention` VALUES (1,1,'1.0.0','Domain Layer 코딩 컨벤션',1,'2026-01-20 02:11:20.000000','2026-01-20 02:11:20.000000',NULL),(2,2,'1.0.0','Application Layer 코딩 컨벤션',1,'2026-01-20 02:11:20.000000','2026-01-20 02:11:20.000000',NULL),(3,4,'1.0.0','Persistence Layer 코딩 컨벤션',1,'2026-01-20 02:11:20.000000','2026-01-20 02:11:20.000000',NULL),(4,6,'1.0.0','REST API Layer 코딩 컨벤션',1,'2026-01-20 02:11:20.000000','2026-01-20 02:11:20.000000',NULL),(5,7,'1.0.0','Bootstrap Layer 코딩 컨벤션',1,'2026-01-20 05:59:01.000000','2026-01-20 05:59:01.000000',NULL),(7,18,'1.0.0','Scheduler Adapter Layer 코딩 컨벤션',1,'2026-01-28 02:27:51.000000','2026-01-28 02:27:51.000000','2026-01-28 02:28:12.000000'),(8,13,'1.0.0','Scheduler Adapter Layer 코딩 컨벤션',1,'2026-01-28 02:28:28.000000','2026-01-28 02:28:28.000000',NULL);
INSERT INTO `feedback_queue` VALUES (1,'RULE_EXAMPLE',0,'ADD','SAFE','{\"codingRuleId\":1,\"exampleType\":\"GOOD\",\"code\":\"public class Test {}\",\"language\":\"java\",\"explanation\":\"MCP 테스트용 예시\"}','MERGED',NULL,'2026-01-20 07:04:02.196472','2026-01-20 07:07:09.559264'),(2,'RULE_EXAMPLE',0,'ADD','SAFE','{\"codingRuleId\": 1, \"exampleType\": \"GOOD\", \"code\": \"// Test code via MCP ADD\", \"language\": \"java\", \"explanation\": \"MCP ADD 테스트\"}','MERGED',NULL,'2026-01-20 07:06:29.875127','2026-01-20 07:07:44.932344'),(3,'RULE_EXAMPLE',0,'ADD','SAFE','{\"codingRuleId\": 1, \"exampleType\": \"BAD\", \"code\": \"// Test code via MCP CREATE alias\", \"language\": \"java\", \"explanation\": \"MCP CREATE 별칭 테스트\"}','MERGED',NULL,'2026-01-20 07:06:30.058563','2026-01-20 07:07:45.453006'),(4,'RULE_EXAMPLE',0,'ADD','SAFE','{\"codingRuleId\": 1, \"exampleType\": \"GOOD\", \"code\": \"// 통합 테스트 코드\", \"language\": \"java\", \"explanation\": \"통합 테스트용 예제\"}','MERGED',NULL,'2026-01-20 07:08:51.027288','2026-01-20 07:08:51.899897'),(5,'CODING_RULE',0,'ADD','SAFE','{\"conventionId\": 1, \"code\": \"DOM-AGG-028\", \"name\": \"Aggregate에서 파라미터 null 체크 금지\", \"severity\": \"CRITICAL\", \"category\": \"STRUCTURE\", \"description\": \"Aggregate의 팩토리 메서드(forNew, reconstitute)나 명령 메서드(changeXXX)에서 파라미터에 대한 null 체크를 직접 수행하지 않아야 합니다. 대신 VO를 사용하고, VO의 Compact Constructor에서 null 체크 및 유효성 검증을 수행해야 합니다.\", \"rationale\": \"책임 분리 원칙. VO는 자신의 불변 조건을 보장하는 책임이 있으며, Aggregate는 비즈니스 로직에 집중해야 합니다. VO 생성 시점에 검증이 이루어지므로 Aggregate에서 중복 검증이 불필요합니다.\", \"autoFixable\": false, \"appliesTo\": [\"CLASS\", \"METHOD\"]}','MERGED','DOM-AGG-030~033으로 반영됨','2026-01-25 16:14:42.159730','2026-01-25 16:14:42.159730'),(6,'CODING_RULE',0,'ADD','SAFE','{\"conventionId\": 1, \"code\": \"DOM-AGG-027\", \"name\": \"Aggregate 필수 도메인 값은 VO 사용 필수\", \"severity\": \"BLOCKER\", \"category\": \"STRUCTURE\", \"description\": \"Aggregate의 필수 도메인 값(phoneNumber, hashedPassword, email 등)은 원시 타입(String) 대신 전용 Value Object를 사용해야 합니다. VO는 domain/{bc}/vo 패키지에 위치하며, Compact Constructor에서 null 체크 및 유효성 검증을 수행합니다.\", \"rationale\": \"Primitive Obsession 안티패턴 방지. VO 사용으로 타입 안전성과 도메인 의미가 명확해지며, 검증 로직이 한 곳에 집중됩니다. Aggregate에서 불필요한 null 체크를 제거할 수 있습니다.\", \"autoFixable\": false, \"appliesTo\": [\"CLASS\", \"FIELD\"]}','MERGED','DOM-AGG-030~033으로 반영됨','2026-01-25 16:14:42.178917','2026-01-25 16:14:42.178917'),(7,'CODING_RULE',0,'ADD','SAFE','{\"conventionId\": 1, \"code\": \"DOM-AGG-028\", \"name\": \"UpdateData에서 null 체크 금지\", \"severity\": \"CRITICAL\", \"category\": \"BEHAVIOR\", \"description\": \"UpdateData는 Aggregate의 update() 메서드에 전달되는 데이터 번들입니다. UpdateData에 포함되는 VO 객체들은 이미 null 검증이 완료된 객체이므로, UpdateData에서 중복 검증을 수행하지 않아야 합니다.\", \"rationale\": \"VO 객체들은 자체적으로 생성 시점에 검증을 수행하므로, UpdateData에서 중복 검증할 필요가 없습니다. null 체크가 필요하다면 VO 내부에서 수행해야 합니다.\", \"autoFixable\": false, \"appliesTo\": [\"CLASS\"]}','MERGED','DOM-AGG-030~033으로 반영됨','2026-01-26 08:20:00.489587','2026-01-26 08:20:00.489587'),(8,'CODING_RULE',0,'ADD','SAFE','{\"conventionId\": 1, \"code\": \"DOM-AGG-029\", \"name\": \"Aggregate VO 원시값 반환 편의 메서드 필수\", \"severity\": \"CRITICAL\", \"category\": \"STRUCTURE\", \"description\": \"Aggregate는 VO 객체를 반환하는 메서드와 함께 원시값을 반환하는 편의 메서드를 제공해야 합니다. 이것은 Law of Demeter를 준수하고 외부에서 체이닝 호출(aggregate.vo().value())을 방지하기 위함입니다.\", \"rationale\": \"외부에서 aggregate.vo().value() 같은 체이닝 호출을 방지하고, Aggregate가 자신의 내부 구조를 직접 노출하지 않도록 캡슐화를 강화합니다.\", \"autoFixable\": false, \"appliesTo\": [\"CLASS\"]}','MERGED','DOM-AGG-030~033으로 반영됨','2026-01-26 08:20:02.309592','2026-01-26 08:20:02.309592');
INSERT INTO `layer` VALUES (1,1,'DOMAIN','Domain Layer','비즈니스 로직과 도메인 모델을 포함하는 핵심 레이어. Aggregate, Value Object, Domain Event, Domain Exception을 정의합니다.',1,'2026-01-20 02:11:20.000000','2026-01-20 02:11:20.000000',NULL),(2,1,'APPLICATION','Application Layer','애플리케이션 비즈니스 로직을 조율하는 레이어. UseCase(Port-In), Service, Manager, Port-Out을 정의합니다.',2,'2026-01-20 02:11:20.000000','2026-01-20 02:11:20.000000',NULL),(3,1,'ADAPTER_OUT','Adapter-Out Layer','아웃바운드 어댑터 레이어. 외부 시스템(DB, 외부 API, 메시지 큐 등)과의 통신을 담당합니다. Port-Out 인터페이스의 구현체가 위치합니다.',3,'2026-01-20 02:11:20.000000','2026-01-20 05:59:01.000000',NULL),(4,1,'ADAPTER_IN','Adapter-In Layer','인바운드 어댑터 레이어. 외부 요청(REST API, gRPC, CLI 등)을 받아 애플리케이션으로 전달합니다. Controller, API DTO, Mapper를 포함합니다.',4,'2026-01-20 02:11:20.000000','2026-01-20 05:59:01.000000',NULL),(5,1,'BOOTSTRAP','Bootstrap Layer','애플리케이션 실행 진입점 레이어. main() 메서드, Spring Boot Application 클래스, 설정 파일이 위치합니다. 모든 모듈을 조립하여 실행 가능한 애플리케이션을 구성합니다.',5,'2026-01-20 05:59:01.000000','2026-01-20 05:59:01.000000',NULL);
INSERT INTO `layer_dependency_rule` VALUES (1,1,'APPLICATION','DOMAIN','ALLOWED','Application 레이어는 Domain 레이어에 의존할 수 있습니다.','2026-01-20 02:11:20.000000','2026-01-20 02:11:20.000000',NULL),(2,1,'ADAPTER_OUT','DOMAIN','ALLOWED','Adapter-Out 레이어는 Domain 레이어에 의존할 수 있습니다.','2026-01-20 02:11:20.000000','2026-01-20 05:59:01.000000',NULL),(3,1,'ADAPTER_IN','APPLICATION','ALLOWED','Adapter-In 레이어는 Application 레이어에 의존할 수 있습니다.','2026-01-20 02:11:20.000000','2026-01-20 05:59:01.000000',NULL),(4,1,'DOMAIN','APPLICATION','FORBIDDEN','Domain 레이어는 Application 레이어에 의존할 수 없습니다.','2026-01-20 02:11:20.000000','2026-01-20 02:11:20.000000',NULL),(5,1,'DOMAIN','ADAPTER_OUT','FORBIDDEN','Domain 레이어는 Adapter-Out 레이어에 의존할 수 없습니다.','2026-01-20 02:11:20.000000','2026-01-20 05:59:01.000000',NULL),(6,1,'DOMAIN','ADAPTER_IN','FORBIDDEN','Domain 레이어는 Adapter-In 레이어에 의존할 수 없습니다.','2026-01-20 02:11:20.000000','2026-01-20 05:59:01.000000',NULL),(7,1,'BOOTSTRAP','ADAPTER_IN','ALLOWED','Bootstrap 레이어는 Adapter-In 레이어에 의존할 수 있습니다.','2026-01-20 05:59:01.000000','2026-01-20 05:59:01.000000',NULL),(8,1,'BOOTSTRAP','ADAPTER_OUT','ALLOWED','Bootstrap 레이어는 Adapter-Out 레이어에 의존할 수 있습니다.','2026-01-20 05:59:01.000000','2026-01-20 05:59:01.000000',NULL),(9,1,'BOOTSTRAP','APPLICATION','ALLOWED','Bootstrap 레이어는 Application 레이어에 의존할 수 있습니다.','2026-01-20 05:59:01.000000','2026-01-20 05:59:01.000000',NULL),(10,1,'BOOTSTRAP','DOMAIN','ALLOWED','Bootstrap 레이어는 Domain 레이어에 의존할 수 있습니다.','2026-01-20 05:59:01.000000','2026-01-20 05:59:01.000000',NULL),(11,1,'DOMAIN','BOOTSTRAP','FORBIDDEN','Domain 레이어는 Bootstrap 레이어에 의존할 수 없습니다.','2026-01-20 05:59:01.000000','2026-01-20 05:59:01.000000',NULL),(12,1,'APPLICATION','BOOTSTRAP','FORBIDDEN','Application 레이어는 Bootstrap 레이어에 의존할 수 없습니다.','2026-01-20 05:59:01.000000','2026-01-20 05:59:01.000000',NULL),(13,1,'ADAPTER_IN','BOOTSTRAP','FORBIDDEN','Adapter-In 레이어는 Bootstrap 레이어에 의존할 수 없습니다.','2026-01-20 05:59:01.000000','2026-01-20 05:59:01.000000',NULL),(14,1,'ADAPTER_OUT','BOOTSTRAP','FORBIDDEN','Adapter-Out 레이어는 Bootstrap 레이어에 의존할 수 없습니다.','2026-01-20 05:59:01.000000','2026-01-20 05:59:01.000000',NULL);
INSERT INTO `module` VALUES (1,1,NULL,'domain','Domain 핵심 모듈','domain',':domain','2026-01-20 02:11:20.000000','2026-01-20 02:11:20.000000',NULL),(2,2,NULL,'application','Application 서비스 모듈','application',':application','2026-01-20 02:11:20.000000','2026-01-20 02:11:20.000000',NULL),(3,3,NULL,'adapter-out','Outbound Adapter 부모 모듈','adapter-out',':adapter-out','2026-01-20 02:11:20.000000','2026-01-20 02:11:20.000000',NULL),(4,3,3,'persistence-mysql','MySQL Persistence 어댑터','adapter-out/persistence-mysql',':adapter-out:persistence-mysql','2026-01-20 02:11:20.000000','2026-01-20 02:11:20.000000',NULL),(5,4,NULL,'adapter-in','Inbound Adapter 부모 모듈','adapter-in',':adapter-in','2026-01-20 02:11:20.000000','2026-01-20 02:11:20.000000',NULL),(6,4,5,'rest-api','REST API 어댑터','adapter-in/rest-api',':adapter-in:rest-api','2026-01-20 02:11:20.000000','2026-01-20 02:11:20.000000',NULL),(7,5,NULL,'bootstrap','Bootstrap 부모 모듈','bootstrap',':bootstrap','2026-01-20 05:59:01.000000','2026-01-20 05:59:01.000000',NULL),(8,5,7,'bootstrap-web-api','Web API 실행 모듈','bootstrap/bootstrap-web-api',':bootstrap:bootstrap-web-api','2026-01-20 05:59:01.000000','2026-01-20 05:59:01.000000',NULL),(9,5,7,'bootstrap-scheduler','Scheduler 실행 모듈','bootstrap/bootstrap-scheduler',':bootstrap:bootstrap-scheduler','2026-01-20 05:59:01.000000','2026-01-20 05:59:01.000000',NULL),(10,3,3,'persistence-redis','Redis 캐시 어댑터','adapter-out/persistence-redis',':adapter-out:persistence-redis','2026-01-20 05:59:01.000000','2026-01-20 05:59:01.000000',NULL),(11,3,3,'sqs-publisher','AWS SQS 메시지 발행 어댑터','adapter-out/sqs-publisher',':adapter-out:sqs-publisher','2026-01-20 05:59:01.000000','2026-01-20 05:59:01.000000',NULL),(12,4,5,'sqs-consumer','AWS SQS 메시지 소비 어댑터','adapter-in/sqs-consumer',':adapter-in:sqs-consumer','2026-01-20 05:59:01.000000','2026-01-20 05:59:01.000000',NULL),(13,4,5,'scheduler','스케줄 작업 어댑터','adapter-in/scheduler',':adapter-in:scheduler','2026-01-20 05:59:01.000000','2026-01-20 05:59:01.000000',NULL),(14,3,3,'client','외부 클라이언트 부모 모듈','adapter-out/client',':adapter-out:client','2026-01-20 05:59:01.000000','2026-01-20 05:59:01.000000',NULL),(15,3,14,'distributed-lock-redis','Redis 기반 분산락 클라이언트','adapter-out/client/distributed-lock-redis',':adapter-out:client:distributed-lock-redis','2026-01-20 05:59:01.000000','2026-01-20 05:59:01.000000',NULL),(16,5,7,'bootstrap-worker','메시지 리스너 및 백그라운드 작업 실행 모듈','bootstrap/bootstrap-worker',':bootstrap:bootstrap-worker','2026-01-20 05:59:01.000000','2026-01-20 05:59:01.000000',NULL),(17,3,3,'persistence-mysql-admin','Admin/통계용 MySQL Persistence 어댑터. 조인 허용, 복잡 쿼리 허용. OLAP 최적화.','adapter-out/persistence-mysql-admin',':adapter-out:persistence-mysql-admin','2026-01-21 07:57:35.000000','2026-01-21 07:57:35.000000',NULL),(18,4,NULL,'scheduler','Scheduler Adapter 모듈 - @Scheduled 기반 배치 작업','adapter-in/scheduler','adapter-in:scheduler','2026-01-28 02:27:43.000000','2026-01-28 02:27:43.000000','2026-01-28 02:28:12.000000');
INSERT INTO `onboarding_context` VALUES (1,1,1,'SUMMARY','프로젝트 개요','## 기술 스택\n- **Language**: Java 21 (Virtual Thread, Record, Pattern Matching)\n- **Framework**: Spring Boot 3.5.x\n- **Build**: Gradle (Kotlin DSL)\n\n## 아키텍처\n- **Pattern**: Hexagonal Architecture (Ports & Adapters)\n- **Principles**: DIP, SRP, OCP, ISP, CQRS, DDD\n\n## 모듈 구조\n```\ndomain                  → 비즈니스 로직 (Aggregate, VO, Event)\napplication             → 유스케이스 (Service, Port)\nadapter-out/persistence → 영속성 (Entity, Repository)\nadapter-in/rest-api     → REST API (Controller, DTO)\n```',1,'2026-01-24 07:51:10.000000','2026-01-24 07:51:10.000000',NULL),(2,1,1,'MCP_USAGE','MCP 사용법','## 3-Phase 워크플로우\n\n| Phase | Tool | 용도 |\n|-------|------|------|\n| 1. Planning | `planning_context()` | 어떤 컴포넌트를 어디에 만들지 결정 |\n| 2. Execution | `module_context()` | 템플릿 + 규칙 기반 코드 생성 |\n| 3. Validation | `validation_context()` | Zero-Tolerance 검증 |\n\n## 핵심 사용 패턴\n\n```python\n# Aggregate 생성 시\nplanning_context(layers=[\"DOMAIN\"])\nmodule_context(module_id=1, class_type=\"AGGREGATE\")\nvalidation_context(layers=[\"DOMAIN\"])\n\n# UseCase 생성 시\nmodule_context(module_id=2, class_type=\"USE_CASE\")\n```\n\n## 주요 도구\n\n| Tool | 용도 |\n|------|------|\n| `get_context()` | 빠른 컨텍스트 조회 |\n| `get_rule()` | 규칙 상세 + 예시 |\n| `get_layer_detail()` | 레이어 상세 |',2,'2026-01-24 07:51:23.000000','2026-01-24 07:51:23.000000',NULL),(3,1,1,'ZERO_TOLERANCE','Zero-Tolerance 규칙','## 절대 위반 금지 규칙\n\n> 상세 규칙은 `validation_context()`로 조회하세요.\n\n### Domain Layer\n- ❌ Lombok 금지 (@Data, @Getter, @Builder 등)\n- ❌ Getter 체이닝 금지 (Law of Demeter)\n- ❌ Setter 금지\n- ✅ Tell, Don\'t Ask 원칙\n\n### Application Layer\n- ❌ @Transactional 내 외부 API 호출 금지\n- ✅ DTO는 Record 필수\n- ✅ CQRS 분리\n\n### Persistence Layer\n- ❌ JPA 관계 어노테이션 금지 (@OneToMany 등)\n- ✅ Long FK 전략\n- ✅ QueryDSL DTO Projection\n\n### REST API Layer\n- ❌ MockMvc 금지\n- ✅ TestRestTemplate 사용\n- ✅ @Valid 필수\n\n## 검증 방법\n```python\nvalidation_context(layers=[\"DOMAIN\", \"APPLICATION\", \"PERSISTENCE\", \"REST_API\"])\n```',3,'2026-01-24 07:51:37.000000','2026-01-24 07:51:37.000000',NULL),(4,1,1,'RULES_INDEX','규칙 인덱스','## 레이어별 규칙 현황\n\n| Layer | Module | Rules | BLOCKER | Examples |\n|-------|--------|-------|---------|----------|\n| DOMAIN | domain | 63 | 44 | 15 |\n| APPLICATION | application | 37 | 10 | 68 |\n| PERSISTENCE | persistence-mysql | 15 | 10 | 29 |\n| REST_API | rest-api | 47 | 3 | 20 |\n| **합계** | - | **162** | **67** | **134** |\n\n## 클래스 템플릿 현황\n\n| Layer | Templates |\n|-------|-----------|\n| DOMAIN | 25개 (Aggregate, VO, Event, Exception) |\n| APPLICATION | 22개 (UseCase, Service, Manager, Port) |\n| PERSISTENCE | 15개 (Entity, Repository, Mapper) |\n| REST_API | 7개 (Controller, DTO, Mapper) |\n\n## 규칙 조회 방법\n\n```python\n# 레이어별 규칙 조회\nget_layer_detail(layer_code=\"DOMAIN\")\n\n# 특정 규칙 상세\nget_rule(rule_code=\"DOM-AGG-001\")\n\n# 클래스 템플릿 조회\nmodule_context(module_id=1, class_type=\"AGGREGATE\")\n```',4,'2026-01-24 07:51:50.000000','2026-01-24 07:51:50.000000',NULL);
INSERT INTO `package_purpose` VALUES (1,1,'AGGREGATE','Aggregate 패키지','Domain Aggregate Root와 내부 Entity가 위치하는 패키지입니다. Aggregate Root는 비즈니스 불변식을 보장하고, 트랜잭션 일관성 경계를 정의합니다.','2026-01-20 08:21:55.000000','2026-01-20 08:21:55.000000',NULL),(2,2,'VALUE_OBJECT','Value Object 패키지','도메인별 Value Object가 위치하는 패키지입니다. 불변 객체로 동등성은 값으로 판단합니다. Money, Address, DateRange 등이 해당됩니다.','2026-01-20 08:21:55.000000','2026-01-20 08:21:55.000000',NULL),(3,3,'ID_VALUE_OBJECT','ID Value Object 패키지','Aggregate Root의 식별자 Value Object가 위치하는 패키지입니다. record로 정의하며, Long value 필드를 가집니다.','2026-01-20 08:21:55.000000','2026-01-20 08:21:55.000000',NULL),(4,4,'DOMAIN_EXCEPTION','Domain Exception 패키지','도메인별 예외 클래스와 ErrorCode enum이 위치하는 패키지입니다. DomainException을 상속받고, 도메인별 ErrorCode를 정의합니다.','2026-01-20 08:21:55.000000','2026-01-20 08:21:55.000000',NULL),(16,5,'COMMON_VO','공통 Value Object 패키지','여러 도메인에서 공통으로 사용되는 불변 Value Object를 정의합니다.','2026-01-20 07:36:20.000000','2026-01-20 07:36:20.000000',NULL),(17,6,'COMMON_EXCEPTION','공통 Exception 패키지','도메인 예외의 기본 구조를 정의합니다. ErrorCode 인터페이스와 DomainException 추상 클래스를 제공합니다.','2026-01-20 07:36:20.000000','2026-01-20 07:36:20.000000',NULL),(18,7,'COMMON_EVENT','공통 Event 패키지','도메인 이벤트의 기본 구조를 정의합니다. DomainEvent 마커 인터페이스를 제공합니다.','2026-01-20 07:36:20.000000','2026-01-20 07:36:20.000000',NULL),(19,8,'DOMAIN_QUERY','도메인 Query 패키지','도메인별 조회 조건(Criteria)을 정의합니다. 페이지 기반은 *PageCriteria, 커서 기반은 *CursorCriteria 네이밍을 따릅니다. QueryContext 또는 CursorQueryContext를 필수로 포함하며, DateRange 등 공통 VO를 활용할 수 있습니다.','2026-01-20 07:57:26.000000','2026-01-20 07:57:26.000000',NULL),(20,9,'PORT_IN_COMMAND','Command UseCase 인터페이스','Command UseCase 인터페이스가 위치합니다. execute() 단일 메서드를 가지며, 1 UseCase = 1 Service로 구현됩니다.','2026-01-21 05:26:15.000000','2026-01-21 05:26:15.000000',NULL),(21,10,'PORT_IN_QUERY','Query UseCase 인터페이스','Query UseCase 인터페이스가 위치합니다. Get*, Count*, Check*Exists 패턴의 조회 UseCase가 위치합니다.','2026-01-21 05:26:15.000000','2026-01-21 05:26:15.000000',NULL),(22,11,'PORT_OUT_COMMAND','Command Port 인터페이스','DB 쓰기용 CommandPort가 위치합니다. persist(), persistAll() 메서드만 허용됩니다. update 메서드는 JPA Dirty Checking으로 대체.','2026-01-21 05:26:15.000000','2026-01-21 05:26:15.000000',NULL),(23,12,'PORT_OUT_QUERY','Query Port 인터페이스','DB 읽기용 QueryPort가 위치합니다. findById, findBy*, findBySliceCriteria, existsBy*, countBy* 패턴을 사용합니다. findAll 금지 (OOM 위험).','2026-01-21 05:26:15.000000','2026-01-21 05:26:15.000000',NULL),(24,13,'PORT_OUT_CLIENT','Client Port 인터페이스','외부 HTTP API, 메시징 큐 연동용 ClientPort가 위치합니다. PaymentClientPort, NotificationClientPort 등.','2026-01-21 05:26:15.000000','2026-01-21 05:26:15.000000',NULL),(25,14,'SERVICE_COMMAND','Command Service 구현체','Command UseCase 1:1 구현체가 위치합니다. @Transactional 금지. Factory → Validator → Facade/Manager → Assembler 흐름으로 조율합니다.','2026-01-21 05:26:15.000000','2026-01-21 05:26:15.000000',NULL),(26,15,'SERVICE_QUERY','Query Service 구현체','Query UseCase 1:1 구현체가 위치합니다. QueryFacade/QueryManager를 통해 조회합니다.','2026-01-21 05:26:15.000000','2026-01-21 05:26:15.000000',NULL),(27,16,'FACADE_COMMAND','Command Facade','Manager 2개 이상 조합 시 사용합니다. DB 원자성 필요 시 @Transactional 사용. CommandFacade → QueryManager 의존 금지 (CQRS).','2026-01-21 05:26:15.000000','2026-01-21 05:26:15.000000',NULL),(28,17,'FACADE_QUERY','Query Facade','어드민 복합 조회 등 Manager 2개 이상 조합 시 사용합니다. @Transactional(readOnly=true) 사용.','2026-01-21 05:26:15.000000','2026-01-21 05:26:15.000000',NULL),(29,18,'MANAGER_COMMAND','Command Manager','CommandPort 1:1 래핑. @Transactional 필수. 트랜잭션 관리 주체입니다.','2026-01-21 05:26:15.000000','2026-01-21 05:26:15.000000',NULL),(30,19,'MANAGER_QUERY','Query Manager (ReadManager)','QueryPort 1:1 래핑. @Transactional(readOnly=true) 필수. NOT_FOUND 예외 처리 통일.','2026-01-21 05:26:15.000000','2026-01-21 05:26:15.000000',NULL),(31,20,'MANAGER_CLIENT','Client Manager','ClientPort 래핑. @Transactional 금지. 외부 호출은 트랜잭션 밖에서 실행. Service에서 직접 의존 가능.','2026-01-21 05:26:15.000000','2026-01-21 05:26:15.000000',NULL),(32,21,'FACTORY_COMMAND','Command Factory','Command → Domain/Bundle 생성. TimeProvider 사용하여 Instant 전달. UpdateContext, StatusChangeContext 생성.','2026-01-21 05:26:15.000000','2026-01-21 05:26:15.000000',NULL),(33,22,'FACTORY_QUERY','Query Factory','Query → Criteria 변환. 도메인별 기본값(sortKey, direction, dateRange) 결정. CommonVoFactory로 순수 변환 위임.','2026-01-21 05:26:15.000000','2026-01-21 05:26:15.000000',NULL),(34,23,'ASSEMBLER','Assembler','Domain → Application Response 변환. 도메인별 구체 Result 클래스 반환 (제네릭 래퍼 금지).','2026-01-21 05:26:15.000000','2026-01-21 05:26:15.000000',NULL),(35,24,'VALIDATOR','Validator','외부 의존성 필요한 비즈니스 검증. 자기 도메인 ReadManager만 의존. 검증 성공 시 Domain 객체 반환.','2026-01-21 05:26:15.000000','2026-01-21 05:26:15.000000',NULL),(38,27,'DTO_COMMAND','Command DTO','Command DTO 패키지. Record 필수. 순수 데이터 컨테이너 (인스턴스 메서드 금지). 기본값 처리는 REST API Mapper에서.','2026-01-21 05:26:15.000000','2026-01-21 05:26:15.000000',NULL),(39,28,'DTO_QUERY','Query DTO','Query DTO 패키지. *SearchParams는 CommonSearchParams 포함 필수. *CursorParams는 CommonCursorParams 포함 필수.','2026-01-21 05:26:15.000000','2026-01-21 05:26:15.000000',NULL),(40,29,'DTO_RESPONSE','Response DTO','Response/Result DTO 패키지. 도메인별 구체 Result 클래스 사용. *SliceResult, *PageResult는 SliceMeta/PageMeta(Domain VO) 포함.','2026-01-21 05:26:15.000000','2026-01-21 05:26:15.000000',NULL),(41,30,'DTO_BUNDLE','Bundle DTO','Facade용 복합 DTO. withId() 패턴으로 상위-하위 ID 연결. Service → Factory → Facade(Bundle) 흐름.','2026-01-21 05:26:15.000000','2026-01-21 05:26:15.000000',NULL),(42,31,'DTO_COMMON_QUERY','공통 Query DTO','공통 Query DTO. CommonSearchParams(page, size, sortKey, sortDirection, includeDeleted, startDate, endDate), CommonCursorParams(cursor, size).','2026-01-21 05:26:15.000000','2026-01-21 05:26:15.000000',NULL),(44,33,'FACTORY_COMMON','공통 Factory','공통 Factory. CommonVoFactory가 위치. 순수 타입 변환만 담당 (기본값 로직 없음).','2026-01-21 05:26:15.000000','2026-01-21 05:26:15.000000',NULL),(45,25,'INTERNAL_HELPER','Internal Helper','Calculator, Resolver, Converter 등 내부 헬퍼 컴포넌트','2026-01-21 05:38:47.000000','2026-01-21 05:38:47.000000',NULL),(46,32,'COMMON_COMMAND_DTO','Common Command DTO','StatusChangeContext 등 공통 Command DTO','2026-01-21 05:38:47.000000','2026-01-21 05:38:47.000000',NULL),(47,34,'COMMON_INTERNAL','Common Internal Helper','여러 도메인에서 공유하는 내부 헬퍼 컴포넌트','2026-01-21 05:38:47.000000','2026-01-21 05:38:47.000000',NULL),(48,35,'COMMON_EVENT','Common Event Component','TransactionEventRegistry 등 이벤트 관련 공통 컴포넌트','2026-01-21 05:38:47.000000','2026-01-21 05:38:47.000000',NULL),(49,36,'EVENT_LISTENER','Event Listener','도메인 이벤트를 처리하는 리스너','2026-01-21 05:38:47.000000','2026-01-21 05:38:47.000000',NULL),(50,37,'COMMAND_ADAPTER','Command Adapter','CommandPort 구현체. JpaRepository만 의존','2026-01-21 07:42:54.000000','2026-01-21 07:42:54.000000',NULL),(51,37,'QUERY_ADAPTER','Query Adapter','QueryPort 구현체. QueryDslRepository만 의존','2026-01-21 07:42:54.000000','2026-01-21 07:42:54.000000',NULL),(52,38,'JPA_ENTITY','JPA Entity','JPA 엔티티. BaseAuditEntity 또는 SoftDeletableEntity 상속','2026-01-21 07:42:54.000000','2026-01-21 07:42:54.000000',NULL),(53,39,'ENTITY_MAPPER','Entity Mapper','Domain ↔ Entity 변환. static 메서드로 구성','2026-01-21 07:42:54.000000','2026-01-21 07:42:54.000000',NULL),(54,40,'JPA_REPOSITORY','JPA Repository','Command용. save, saveAll만 사용 (커스텀 메서드 추가 금지)','2026-01-21 07:42:54.000000','2026-01-21 07:42:54.000000',NULL),(55,40,'QUERYDSL_REPOSITORY','QueryDSL Repository','Query용. 모든 조회 담당','2026-01-21 07:42:54.000000','2026-01-21 07:42:54.000000',NULL),(56,41,'CONDITION_BUILDER','Condition Builder','BooleanExpression/BooleanBuilder 생성 전담','2026-01-21 07:42:54.000000','2026-01-21 07:42:54.000000',NULL),(57,42,'BASE_AUDIT_ENTITY','Base Audit Entity','감사 필드 제공 (createdAt, updatedAt)','2026-01-21 07:42:54.000000','2026-01-21 07:42:54.000000',NULL),(58,42,'SOFT_DELETABLE_ENTITY','Soft Deletable Entity','소프트 삭제 지원. BaseAuditEntity 상속 + deletedAt','2026-01-21 07:42:54.000000','2026-01-21 07:42:54.000000',NULL),(59,43,'JPA_CONFIG','JPA Config','JPA/QueryDSL/ObjectMapper Bean 설정','2026-01-21 07:42:54.000000','2026-01-21 07:42:54.000000',NULL),(60,43,'PERSISTENCE_OBJECT_MAPPER','Persistence ObjectMapper','JSON 파싱 래퍼. 에러 처리 중앙화','2026-01-21 07:42:54.000000','2026-01-21 07:42:54.000000',NULL),(61,44,'SLICE_CRITERIA','Slice Criteria','커서 기반 페이징 조건 (cursor, size)','2026-01-21 07:42:54.000000','2026-01-21 07:42:54.000000',NULL),(62,44,'SORT_CRITERIA','Sort Criteria','정렬 조건 (field, direction)','2026-01-21 07:42:54.000000','2026-01-21 07:42:54.000000',NULL),(63,44,'SEARCH_CRITERIA','Search Criteria','검색 조건 (keyword, searchType)','2026-01-21 07:42:54.000000','2026-01-21 07:42:54.000000',NULL),(64,45,'FUNCTION_CONTRIBUTOR','Function Contributor','Hibernate 커스텀 함수 등록 (FullText 등)','2026-01-21 07:42:54.000000','2026-01-21 07:42:54.000000',NULL),(65,46,'ADMIN_QUERY_ADAPTER','Admin 조회 어댑터','Admin용 QueryPort 구현체. AdminQueryDslRepository만 의존.','2026-01-21 07:58:16.000000','2026-01-21 07:58:16.000000',NULL),(66,46,'ADMIN_QUERYDSL_REPOSITORY','Admin QueryDSL 레포지토리','Admin용 복잡 쿼리 처리. 조인 허용, 서브쿼리 허용.','2026-01-21 07:58:16.000000','2026-01-21 07:58:16.000000',NULL),(67,47,'ADMIN_PROJECTION_DTO','Admin Projection DTO','여러 테이블 조인 결과를 담는 DTO. Record 권장.','2026-01-21 07:58:16.000000','2026-01-21 07:58:16.000000',NULL),(68,48,'ADMIN_JPA_CONFIG','Admin JPA 설정','Read Replica 연결, 별도 DataSource 설정 등.','2026-01-21 07:58:16.000000','2026-01-21 07:58:16.000000',NULL),(69,49,'API_ENDPOINTS','API Endpoints','도메인 API 엔드포인트 상수 클래스','2026-01-21 08:13:08.120519','2026-01-21 08:13:08.120519',NULL),(73,52,'API_ERROR_CODE','API Error Code','API 에러 코드 Enum','2026-01-21 08:13:08.120519','2026-01-21 08:13:08.120519',NULL),(74,52,'API_EXCEPTION','API Exception','API 예외 클래스','2026-01-21 08:13:08.120519','2026-01-21 08:13:08.120519',NULL),(75,53,'API_MAPPER','API DTO Mapper','API DTO <-> Application DTO 매퍼','2026-01-21 08:13:08.120519','2026-01-21 08:13:08.120519',NULL),(76,54,'COMMON_API_PATHS','Common API Paths','공통 API 경로 상수 (ApiPaths)','2026-01-21 08:13:08.120519','2026-01-21 08:13:08.120519',NULL),(77,55,'COMMON_CONTROLLER','Common Controller','공통 컨트롤러 (Health Check, Info 등)','2026-01-21 08:13:08.120519','2026-01-21 08:13:08.120519',NULL),(78,56,'COMMON_API_REQUEST','Common API Request','공통 API 요청 DTO','2026-01-21 08:13:08.120519','2026-01-21 08:13:08.120519',NULL),(79,56,'COMMON_API_RESPONSE','Common API Response','공통 API 응답 DTO','2026-01-21 08:13:08.120519','2026-01-21 08:13:08.120519',NULL),(80,56,'API_PAGE_RESPONSE','API Page Response','페이징 API 응답 래퍼','2026-01-21 08:13:08.120519','2026-01-21 08:13:08.120519',NULL),(81,57,'GLOBAL_EXCEPTION_HANDLER','Global Exception Handler','전역 예외 처리 핸들러 (@RestControllerAdvice)','2026-01-21 08:13:08.120519','2026-01-21 08:13:08.120519',NULL),(82,57,'API_ERROR_RESPONSE','API Error Response','API 에러 응답 DTO','2026-01-21 08:13:08.120519','2026-01-21 08:13:08.120519',NULL),(83,58,'COMMON_API_MAPPER','Common API Mapper','공통 API 매퍼','2026-01-21 08:13:08.120519','2026-01-21 08:13:08.120519',NULL),(84,59,'UTILITY','Utility Class','유틸리티 클래스','2026-01-21 08:13:08.120519','2026-01-21 08:13:08.120519',NULL),(85,59,'HELPER','Helper Class','헬퍼 클래스','2026-01-21 08:13:08.120519','2026-01-21 08:13:08.120519',NULL),(86,60,'COMMAND_CONTROLLER','Command Controller','CUD 작업을 처리하는 REST Controller','2026-01-21 13:24:16.000000','2026-01-21 13:24:16.000000',NULL),(87,61,'QUERY_CONTROLLER','Query Controller','R(조회) 작업을 처리하는 REST Controller','2026-01-21 13:24:16.000000','2026-01-21 13:24:16.000000',NULL),(88,62,'CREATE_REQUEST','Create Request DTO','생성 API 요청 DTO','2026-01-21 13:24:16.000000','2026-01-21 13:24:16.000000',NULL),(89,62,'UPDATE_REQUEST','Update Request DTO','수정 API 요청 DTO','2026-01-21 13:24:16.000000','2026-01-21 13:24:16.000000',NULL),(90,62,'FIND_REQUEST','Find Request DTO','목록 조회 API 요청 DTO (커서/페이지)','2026-01-21 13:24:16.000000','2026-01-21 13:24:16.000000',NULL),(91,63,'ITEM_RESPONSE','Item Response DTO','단일 항목 API 응답 DTO','2026-01-21 13:24:16.000000','2026-01-21 13:24:16.000000',NULL),(92,63,'ID_RESPONSE','ID Response DTO','ID만 반환하는 API 응답 DTO','2026-01-21 13:24:16.000000','2026-01-21 13:24:16.000000',NULL);
INSERT INTO `package_structure` VALUES (1,1,'{base_package}.{domain}.aggregate','Domain Aggregate 패키지','2026-01-20 02:11:21.000000','2026-01-20 07:29:58.000000',NULL),(2,1,'{base_package}.{domain}.vo','Domain Value Object 패키지','2026-01-20 02:11:21.000000','2026-01-20 07:29:58.000000',NULL),(3,1,'{base_package}.{domain}.id','Domain ID 패키지','2026-01-20 02:11:21.000000','2026-01-20 07:29:58.000000',NULL),(4,1,'{base_package}.{domain}.exception','Domain Exception 패키지','2026-01-20 02:11:21.000000','2026-01-20 07:29:58.000000',NULL),(5,1,'{base_package}.common.vo','도메인 공통 Value Object 패키지. 여러 도메인에서 재사용되는 불변 값 객체가 위치합니다.','2026-01-20 07:29:58.000000','2026-01-20 07:29:58.000000',NULL),(6,1,'{base_package}.common.exception','도메인 공통 예외 패키지. DomainException, ErrorCode 인터페이스가 위치합니다.','2026-01-20 07:29:58.000000','2026-01-20 07:29:58.000000',NULL),(7,1,'{base_package}.common.event','도메인 공통 이벤트 패키지. DomainEvent 마커 인터페이스가 위치합니다.','2026-01-20 07:29:58.000000','2026-01-20 07:29:58.000000',NULL),(8,1,'{base_package}.{domain}.query','도메인 조회 조건 패키지. PageCriteria 또는 CursorCriteria로 끝나는 조회 조건 객체가 위치합니다.','2026-01-20 07:57:17.000000','2026-01-20 07:57:17.000000',NULL),(9,2,'{base_package}.{domain}.port.in.command','Command UseCase 인터페이스 패키지. 단일 execute() 메서드를 가진 UseCase 인터페이스가 위치합니다.','2026-01-21 05:25:44.000000','2026-01-21 05:25:44.000000','2026-01-27 08:39:27.000000'),(10,2,'{base_package}.{domain}.port.in.query','Query UseCase 인터페이스 패키지. 조회용 UseCase 인터페이스가 위치합니다.','2026-01-21 05:25:44.000000','2026-01-21 05:25:44.000000','2026-01-27 08:39:27.000000'),(11,2,'{base_package}.{domain}.port.out.command','Command Port 인터페이스 패키지. DB 쓰기용 CommandPort (persist, persistAll 메서드)가 위치합니다.','2026-01-21 05:25:44.000000','2026-01-21 05:25:44.000000','2026-01-27 08:39:27.000000'),(12,2,'{base_package}.{domain}.port.out.query','Query Port 인터페이스 패키지. DB 읽기용 QueryPort (findBy*, existsBy*, countBy* 메서드)가 위치합니다.','2026-01-21 05:25:44.000000','2026-01-21 05:25:44.000000','2026-01-27 08:39:27.000000'),(13,2,'{base_package}.{domain}.port.out.client','Client Port 인터페이스 패키지. 외부 HTTP/메시징 연동용 Port가 위치합니다.','2026-01-21 05:25:44.000000','2026-01-21 05:25:44.000000','2026-01-27 08:39:27.000000'),(14,2,'{base_package}.{domain}.service.command','Command Service 구현체 패키지. Command UseCase 1:1 구현체가 위치합니다. @Transactional 금지.','2026-01-21 05:25:44.000000','2026-01-21 05:25:44.000000','2026-01-27 08:39:27.000000'),(15,2,'{base_package}.{domain}.service.query','Query Service 구현체 패키지. Query UseCase 1:1 구현체가 위치합니다.','2026-01-21 05:25:44.000000','2026-01-21 05:25:44.000000','2026-01-27 08:39:27.000000'),(16,2,'{base_package}.{domain}.facade.command','Command Facade 패키지. Manager 2개 이상 조합 시 사용. @Transactional 선택.','2026-01-21 05:25:44.000000','2026-01-21 05:25:44.000000','2026-01-27 08:39:27.000000'),(17,2,'{base_package}.{domain}.facade.query','Query Facade 패키지. 어드민 복합 조회 등 Manager 2개 이상 조합. @Transactional(readOnly=true).','2026-01-21 05:25:44.000000','2026-01-21 05:25:44.000000','2026-01-27 08:39:27.000000'),(18,2,'{base_package}.{domain}.manager.command','Command Manager 패키지. CommandPort 1:1 래핑. @Transactional 필수.','2026-01-21 05:25:44.000000','2026-01-21 05:25:44.000000','2026-01-27 08:39:27.000000'),(19,2,'{base_package}.{domain}.manager.query','Query Manager 패키지. QueryPort 1:1 래핑. @Transactional(readOnly=true) 필수.','2026-01-21 05:25:44.000000','2026-01-21 05:25:44.000000','2026-01-27 08:39:27.000000'),(20,2,'{base_package}.{domain}.manager.client','Client Manager 패키지. ClientPort 래핑. @Transactional 금지.','2026-01-21 05:25:44.000000','2026-01-21 05:25:44.000000','2026-01-27 08:39:27.000000'),(21,2,'{base_package}.{domain}.factory.command','Command Factory 패키지. Command → Domain/Bundle 생성. TimeProvider 사용.','2026-01-21 05:25:44.000000','2026-01-21 05:25:44.000000',NULL),(22,2,'{base_package}.{domain}.factory.query','Query Factory 패키지. Query → Criteria 변환. 도메인별 기본값 결정.','2026-01-21 05:25:44.000000','2026-01-21 05:25:44.000000',NULL),(23,2,'{base_package}.{domain}.assembler','Assembler 패키지. Domain → Response 변환. 도메인별 구체 Result 클래스 반환.','2026-01-21 05:25:44.000000','2026-01-21 05:25:44.000000',NULL),(24,2,'{base_package}.{domain}.validator','Validator 패키지. 비즈니스 검증 (외부 의존성). 자기 도메인 ReadManager만 의존.','2026-01-21 05:25:44.000000','2026-01-21 05:25:44.000000',NULL),(25,2,'{base_package}.{domain}.internal','내부 헬퍼 컴포넌트 (Calculator, Resolver, Converter 등)','2026-01-21 05:25:44.000000','2026-01-21 05:38:06.000000',NULL),(27,2,'{base_package}.{domain}.dto.command','Command DTO 패키지. Record 필수. 인스턴스 메서드 금지.','2026-01-21 05:25:44.000000','2026-01-21 05:25:44.000000',NULL),(28,2,'{base_package}.{domain}.dto.query','Query DTO 패키지. *SearchParams, *CursorParams. CommonSearchParams/CommonCursorParams 필수 포함.','2026-01-21 05:25:44.000000','2026-01-21 05:25:44.000000',NULL),(29,2,'{base_package}.{domain}.dto.response','Response DTO 패키지. *Response, *Result, *SliceResult, *PageResult.','2026-01-21 05:25:44.000000','2026-01-21 05:25:44.000000',NULL),(30,2,'{base_package}.{domain}.dto.bundle','Bundle DTO 패키지. Facade용 복합 DTO. withId() 패턴으로 ID 전파.','2026-01-21 05:25:44.000000','2026-01-21 05:25:44.000000',NULL),(31,2,'{base_package}.common.dto.query','공통 Query DTO 패키지. CommonSearchParams, CommonCursorParams가 위치합니다.','2026-01-21 05:25:44.000000','2026-01-21 05:25:44.000000',NULL),(32,2,'{base_package}.common.dto.command','공통 Command DTO (StatusChangeContext 등)','2026-01-21 05:25:44.000000','2026-01-21 05:38:06.000000',NULL),(33,2,'{base_package}.common.factory','공통 Factory 패키지. CommonVoFactory가 위치합니다.','2026-01-21 05:25:44.000000','2026-01-21 05:25:44.000000',NULL),(34,2,'{base_package}.common.internal','공통 내부 헬퍼 컴포넌트','2026-01-21 05:38:21.000000','2026-01-21 05:38:21.000000',NULL),(35,2,'{base_package}.common.event','공통 이벤트 관련 컴포넌트 (TransactionEventRegistry 등)','2026-01-21 05:38:21.000000','2026-01-21 05:38:21.000000','2026-01-27 08:39:27.000000'),(36,2,'{base_package}.{domain}.listener','도메인 이벤트 리스너','2026-01-21 05:38:21.000000','2026-01-21 05:38:21.000000',NULL),(37,4,'{base_package}.{domain}.adapter',NULL,'2026-01-21 07:42:21.000000','2026-01-21 07:42:21.000000',NULL),(38,4,'{base_package}.{domain}.entity',NULL,'2026-01-21 07:42:21.000000','2026-01-21 07:42:21.000000',NULL),(39,4,'{base_package}.{domain}.mapper',NULL,'2026-01-21 07:42:21.000000','2026-01-21 07:42:21.000000',NULL),(40,4,'{base_package}.{domain}.repository',NULL,'2026-01-21 07:42:21.000000','2026-01-21 07:42:21.000000',NULL),(41,4,'{base_package}.{domain}.condition',NULL,'2026-01-21 07:42:21.000000','2026-01-21 07:42:21.000000',NULL),(42,4,'{base_package}.common.entity',NULL,'2026-01-21 07:42:21.000000','2026-01-21 07:42:21.000000',NULL),(43,4,'{base_package}.config',NULL,'2026-01-21 07:42:21.000000','2026-01-21 07:42:21.000000',NULL),(44,4,'{base_package}.common.dto.query',NULL,'2026-01-21 07:42:21.000000','2026-01-21 07:42:21.000000','2026-01-27 07:24:45.000000'),(45,4,'{base_package}.common.function',NULL,'2026-01-21 07:42:21.000000','2026-01-21 07:42:21.000000','2026-01-27 07:24:45.000000'),(46,17,'{base_package}.{domain}.admin','Admin용 조회 어댑터 및 레포지토리. 조인 허용, 복잡 쿼리 허용.','2026-01-21 07:57:48.000000','2026-01-21 07:57:48.000000',NULL),(47,17,'{base_package}.{domain}.admin.dto','Admin용 DTO Projection. 여러 테이블 조인 결과를 담는 DTO.','2026-01-21 07:57:48.000000','2026-01-21 07:57:48.000000',NULL),(48,17,'{base_package}.common.config','Admin 전용 JPA 설정. Read Replica 연결 등.','2026-01-21 07:57:48.000000','2026-01-21 07:57:48.000000',NULL),(49,6,'{base_package}.{domain}','도메인 API 엔드포인트 상수','2026-01-21 08:12:45.943082','2026-01-21 08:12:45.943082',NULL),(52,6,'{base_package}.{domain}.error','API 에러 코드 및 예외','2026-01-21 08:12:45.943082','2026-01-21 08:12:45.943082',NULL),(53,6,'{base_package}.{domain}.mapper','API DTO 매퍼','2026-01-21 08:12:45.943082','2026-01-21 08:12:45.943082',NULL),(54,6,'{base_package}.common','공통 API 엔드포인트 상수 (ApiPaths)','2026-01-21 08:12:45.943082','2026-01-21 08:12:45.943082',NULL),(55,6,'{base_package}.common.controller','공통 컨트롤러 (Health Check 등)','2026-01-21 08:12:45.943082','2026-01-27 07:11:19.944420',NULL),(56,6,'{base_package}.common.dto','공통 API DTO','2026-01-21 08:12:45.943082','2026-01-27 07:11:20.054002',NULL),(57,6,'{base_package}.common.error','전역 예외 처리 및 에러 응답','2026-01-21 08:12:45.943082','2026-01-27 07:11:19.991054',NULL),(58,6,'{base_package}.common.mapper','공통 API 매퍼','2026-01-21 08:12:45.943082','2026-01-21 08:12:45.943082',NULL),(59,6,'{base_package}.common.util','공통 유틸리티','2026-01-21 08:12:45.943082','2026-01-21 08:12:45.943082',NULL),(60,6,'{base_package}.{domain}.controller.command','Command 컨트롤러 (CUD 작업)','2026-01-21 13:23:46.000000','2026-01-27 07:11:19.862660',NULL),(61,6,'{base_package}.{domain}.controller.query','Query 컨트롤러 (R 작업)','2026-01-21 13:23:46.000000','2026-01-27 07:11:19.906432',NULL),(62,6,'{base_package}.{domain}.dto.request','API 요청 DTO','2026-01-21 13:23:46.000000','2026-01-21 13:23:46.000000',NULL),(63,6,'{base_package}.{domain}.dto.response','API 응답 DTO','2026-01-21 13:23:46.000000','2026-01-21 13:23:46.000000',NULL),(64,2,'{base_package}.common.config','공통 설정 클래스 패키지. ApplicationJsonConfig 등이 위치합니다.','2026-01-25 15:55:06.000000','2026-01-25 15:55:06.000000',NULL),(65,2,'{base_package}.common.port.out','공통 출력 포트 패키지. CachePort, DistributedLockPort, IdGeneratorPort 등이 위치합니다.','2026-01-25 15:55:06.000000','2026-01-25 15:55:06.000000',NULL),(66,2,'{base_package}.common.time','공통 시간 관련 컴포넌트 패키지. TimeProvider가 위치합니다.','2026-01-25 15:55:06.000000','2026-01-25 15:55:06.000000',NULL),(67,6,'{base_package}.common','REST API 공통 상수 패키지. ApiPaths 등이 위치합니다.','2026-01-25 16:01:05.000000','2026-01-25 16:01:05.000000','2026-01-27 07:10:34.199259'),(68,6,'{base_package}.common.controller','REST API 공통 컨트롤러 패키지. ApiDocsController가 위치합니다.','2026-01-25 16:01:05.000000','2026-01-25 16:01:05.000000','2026-01-27 07:10:34.199259'),(69,6,'{base_package}.common.dto','REST API 공통 DTO 패키지. ApiResponse, PageApiResponse, SliceApiResponse가 위치합니다.','2026-01-25 16:01:05.000000','2026-01-25 16:01:05.000000','2026-01-27 07:10:34.199259'),(70,6,'{base_package}.common.error','REST API 공통 에러 처리 패키지. ErrorMapper, GlobalExceptionHandler가 위치합니다.','2026-01-25 16:01:05.000000','2026-01-25 16:01:05.000000','2026-01-27 07:10:34.199259'),(71,6,'{base_package}.common.util','REST API 공통 유틸리티 패키지. DateTimeFormatUtils가 위치합니다.','2026-01-25 16:01:05.000000','2026-01-25 16:01:05.000000','2026-01-27 07:10:34.199259'),(72,4,'{base_package}.mcp.adapter','MCP 전용 Query Adapter','2026-01-27 07:24:59.000000','2026-01-27 07:24:59.000000','2026-01-27 07:27:51.000000'),(73,4,'{base_package}.mcp.dto','MCP QueryDSL 조회 결과 DTO','2026-01-27 07:24:59.000000','2026-01-27 07:24:59.000000','2026-01-27 07:27:51.000000'),(74,4,'{base_package}.mcp.repository','MCP 전용 QueryDSL Repository','2026-01-27 07:24:59.000000','2026-01-27 07:24:59.000000','2026-01-27 07:27:51.000000'),(75,4,'{base_package}.composite.repository','다중 도메인 JOIN 허용 Repository (성능 최적화, 읽기 전용)','2026-01-27 07:59:28.000000','2026-01-27 07:59:28.000000',NULL),(76,4,'{base_package}.composite.dto','Composite Repository용 Projection DTO','2026-01-27 07:59:28.000000','2026-01-27 07:59:28.000000',NULL),(77,2,'{base_package}.{domain}.port.in','Port-In 인터페이스 (UseCase)','2026-01-27 08:39:35.000000','2026-01-27 08:39:35.000000',NULL),(78,2,'{base_package}.{domain}.port.out','Port-Out 인터페이스 (CommandPort, QueryPort)','2026-01-27 08:39:35.000000','2026-01-27 08:39:35.000000',NULL),(79,2,'{base_package}.{domain}.service','UseCase 구현 Service','2026-01-27 08:39:35.000000','2026-01-27 08:39:35.000000',NULL),(80,2,'{base_package}.{domain}.manager','Manager 클래스','2026-01-27 08:39:35.000000','2026-01-27 08:39:35.000000',NULL),(81,2,'{base_package}.common.component','공통 컴포넌트','2026-01-27 08:39:35.000000','2026-01-27 08:39:35.000000',NULL),(82,2,'{base_package}.{domain}.dto.composite','Composite 조회 결과용 Application DTO','2026-01-27 10:16:41.000000','2026-01-27 10:16:41.000000',NULL);
INSERT INTO `resource_template` VALUES (1,4,'CONFIG','src/main/resources/persistence.yml','YAML','Persistence Layer 공통 설정. OSIV off, Batch 설정, Flyway 설정','# ============================================================\n# Persistence Layer 공통 설정\n# ============================================================\n# 환경별 설정은 persistence-{profile}.yml 참조\n\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n\n  jpa:\n    # ⚠️ OSIV 비활성화 (필수!)\n    open-in-view: false\n    hibernate:\n      # ⚠️ Flyway가 스키마 관리, Hibernate는 검증만\n      ddl-auto: validate\n    properties:\n      hibernate:\n        jdbc:\n          batch_size: 50\n          fetch_size: 50\n        order_inserts: true\n        order_updates: true\n        batch_versioned_data: true\n        query:\n          plan_cache_max_size: 2048\n          in_clause_parameter_padding: true\n    show-sql: false\n\n  flyway:\n    enabled: true\n    locations: classpath:db/migration\n    baseline-on-migrate: true\n    validate-on-migrate: true\n    out-of-order: false\n    clean-disabled: true',1,'2026-01-21 07:45:16.000000','2026-01-21 07:45:16.000000',NULL),(2,4,'CONFIG','src/main/resources/persistence-local.yml','YAML','Persistence Layer 로컬 환경. HikariCP 최소 설정, Debug 로깅','# ============================================================\n# Persistence Layer 로컬 개발 환경 설정\n# ============================================================\n\nspring:\n  datasource:\n    url: jdbc:mysql://${DB_HOST:localhost}:${DB_PORT:3306}/${DB_NAME}?useSSL=false&allowPublicKeyRetrieval=true&serverTimezone=Asia/Seoul\n    username: ${DB_USER:root}\n    password: ${DB_PASSWORD:}\n\n    hikari:\n      maximum-pool-size: 5\n      minimum-idle: 2\n      connection-timeout: 20000\n      idle-timeout: 300000\n      max-lifetime: 600000\n      leak-detection-threshold: 0\n      pool-name: HikariPool-Local\n      data-source-properties:\n        cachePrepStmts: true\n        prepStmtCacheSize: 250\n        prepStmtCacheSqlLimit: 2048\n        useServerPrepStmts: true\n        rewriteBatchedStatements: true\n\n  jpa:\n    properties:\n      hibernate:\n        format_sql: true\n        use_sql_comments: true\n\n  flyway:\n    clean-disabled: true\n\nlogging:\n  level:\n    org.hibernate.SQL: DEBUG\n    org.hibernate.orm.jdbc.bind: TRACE',1,'2026-01-21 07:45:16.000000','2026-01-21 07:45:16.000000',NULL),(3,4,'CONFIG','src/main/resources/persistence-prod.yml','YAML','Persistence Layer 운영 환경. HikariCP 최적화, Leak Detection','# ============================================================\n# Persistence Layer 운영 환경 설정\n# ============================================================\n# ⚠️ 모든 민감 정보는 환경 변수로 관리\n\nspring:\n  datasource:\n    url: jdbc:mysql://${DB_HOST}:${DB_PORT:3306}/${DB_NAME}?useSSL=true&requireSSL=true&serverTimezone=Asia/Seoul\n    username: ${DB_USERNAME}\n    password: ${DB_PASSWORD}\n\n    hikari:\n      # Pool Size: (core_count * 2) + effective_spindle_count\n      maximum-pool-size: 20\n      minimum-idle: 10\n      connection-timeout: 30000\n      idle-timeout: 600000\n      max-lifetime: 1800000\n      leak-detection-threshold: 60000\n      pool-name: HikariPool-Prod\n      connection-init-sql: SELECT 1\n      data-source-properties:\n        cachePrepStmts: true\n        prepStmtCacheSize: 250\n        prepStmtCacheSqlLimit: 2048\n        useServerPrepStmts: true\n        rewriteBatchedStatements: true\n        cacheResultSetMetadata: true\n        cacheServerConfiguration: true\n        elideSetAutoCommits: true\n        maintainTimeStats: false\n\n  jpa:\n    hibernate:\n      ddl-auto: none\n    properties:\n      hibernate:\n        format_sql: false\n        use_sql_comments: false\n\n  flyway:\n    clean-disabled: true\n    validate-on-migrate: false\n\nlogging:\n  level:\n    org.hibernate.SQL: WARN\n    org.hibernate.orm.jdbc.bind: WARN',1,'2026-01-21 07:45:16.000000','2026-01-21 07:45:16.000000',NULL),(4,4,'SERVICE','src/main/resources/META-INF/services/org.hibernate.boot.model.FunctionContributor','TEXT','Hibernate 커스텀 함수 등록. FullText 검색 지원','{base_package}.common.function.MatchAgainstFunctionContributor',0,'2026-01-21 07:45:28.000000','2026-01-21 07:45:28.000000',NULL),(5,4,'MIGRATION','src/main/resources/db/migration/V{version}__{description}.sql','SQL','Flyway DB 마이그레이션. V숫자__설명.sql 형식','-- ============================================================\n-- V{version}__{description}.sql\n-- ============================================================\n-- 작성자: {author}\n-- 작성일: {date}\n-- 설명: {description}\n-- ============================================================\n\n-- DDL 작업\nCREATE TABLE IF NOT EXISTS {table_name} (\n    id BIGINT NOT NULL AUTO_INCREMENT,\n    -- 비즈니스 컬럼\n    {column_name} VARCHAR(100) NOT NULL,\n    -- 감사 컬럼\n    created_at DATETIME(6) NOT NULL,\n    updated_at DATETIME(6) NOT NULL,\n    deleted_at DATETIME(6) NULL,\n    PRIMARY KEY (id),\n    -- 인덱스\n    INDEX idx_{table}_deleted (deleted_at)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- ⚠️ 풀텍스트 인덱스 (필요시)\n-- ALTER TABLE {table_name} ADD FULLTEXT INDEX ft_{column} ({column}) WITH PARSER ngram;',0,'2026-01-21 07:45:28.000000','2026-01-21 07:45:28.000000',NULL),(6,6,'CONFIG','src/main/resources/rest-api.yml','YAML','REST API 공통 설정. Jackson, MessageSource, Springdoc, RFC 7807 에러 설정.','# ============================================================\n# REST API Adapter 공통 설정\n# ============================================================\n# 환경별 설정은 rest-api-{profile}.yml 참조\n# - rest-api-local.yml: 로컬 개발 환경\n# - rest-api-prod.yml: 운영 환경\n#\n# 인증 아키텍처: Gateway Only\n# - JWT 검증: API Gateway에서 처리\n# - OAuth2: API Gateway에서 처리\n# - CORS: API Gateway에서 처리\n# - 이 서비스: Gateway가 전달하는 헤더(X-User-Id, X-User-Roles)만 파싱\n#\n# @since 1.0.0\n# ============================================================\n\nspring:\n  # ============================================================\n  # MessageSource (i18n)\n  # ============================================================\n  messages:\n    basename: messages\n    encoding: UTF-8\n    fallback-to-system-locale: false\n\n  # ============================================================\n  # Jackson (JSON 직렬화/역직렬화)\n  # ============================================================\n  jackson:\n    date-format: yyyy-MM-dd\'T\'HH:mm:ss\n    time-zone: Asia/Seoul\n\n    serialization:\n      WRITE_DATES_AS_TIMESTAMPS: false\n      FAIL_ON_EMPTY_BEANS: false\n\n    deserialization:\n      FAIL_ON_UNKNOWN_PROPERTIES: false\n\n    default-property-inclusion: non_null\n\n  # ============================================================\n  # Web Configuration\n  # ============================================================\n  web:\n    locale: ko_KR\n    locale-resolver: fixed\n\n  # ============================================================\n  # MVC Configuration\n  # ============================================================\n  mvc:\n    contentnegotiation:\n      favor-parameter: false\n      favor-path-extension: false\n\n# ============================================================\n# Error Response Configuration (RFC 7807)\n# ============================================================\napi:\n  error:\n    base-url: about:blank\n    use-about-blank: true\n\n# ============================================================\n# API Documentation (Springdoc OpenAPI)\n# ============================================================\nspringdoc:\n  api-docs:\n    enabled: true\n    path: /api-docs\n\n  swagger-ui:\n    enabled: true\n    path: /swagger-ui.html\n    operations-sorter: method\n    tags-sorter: alpha\n    display-request-duration: true\n    try-it-out-enabled: true\n\n  packages-to-scan:\n    - ${BASE_PACKAGE:com.example}.adapter.in.rest\n\n  default-consumes-media-type: application/json\n  default-produces-media-type: application/json\n\n  cache:\n    disabled: true\n',1,'2026-01-21 13:48:13.000000','2026-01-21 13:48:13.000000',NULL),(7,6,'CONFIG','src/main/resources/rest-api-local.yml','YAML','REST API 로컬 환경 설정. Swagger 활성화, DEBUG 로깅.','# ============================================================\n# REST API Adapter 로컬 개발 환경 설정\n# ============================================================\n# 활성화: spring.profiles.active=local\n#\n# Gateway-Only 아키텍처:\n# - 로컬에서도 Gateway를 통해 접근 (docker-compose로 Gateway 실행)\n# - Gateway가 X-User-Id, X-User-Roles 헤더 전달\n# - 이 서비스는 헤더만 파싱\n# ============================================================\n\n# ============================================================\n# API Documentation (로컬: 전체 활성화)\n# ============================================================\nspringdoc:\n  api-docs:\n    enabled: true\n  swagger-ui:\n    enabled: true\n  cache:\n    disabled: true\n\n# ============================================================\n# Logging (로컬: 상세 로깅)\n# ============================================================\nlogging:\n  level:\n    ${BASE_PACKAGE:com.example}.adapter.in.rest: DEBUG\n    org.springframework.web: DEBUG\n',1,'2026-01-21 13:48:23.000000','2026-01-21 13:48:23.000000',NULL),(8,6,'CONFIG','src/main/resources/rest-api-prod.yml','YAML','REST API 운영 환경 설정. 환경변수 기반 Swagger 제어, 최소 로깅.','# ============================================================\n# REST API Adapter 운영 환경 설정\n# ============================================================\n# 활성화: spring.profiles.active=prod\n#\n# Gateway-Only 아키텍처:\n# - Gateway만 이 서비스에 접근 가능 (네트워크 정책으로 강제)\n# - JWT 검증, OAuth2, CORS 모두 Gateway에서 처리\n# - 이 서비스는 X-User-Id, X-User-Roles 헤더만 파싱\n# ============================================================\n\n# ============================================================\n# API Documentation (운영: 환경변수로 제어)\n# ============================================================\n# 기본 비활성화, 필요시 SWAGGER_ENABLED=true로 활성화\nspringdoc:\n  api-docs:\n    enabled: ${SWAGGER_ENABLED:false}\n  swagger-ui:\n    enabled: ${SWAGGER_ENABLED:false}\n  cache:\n    disabled: false\n\n# ============================================================\n# Error Response (운영: 상세 URL 제공)\n# ============================================================\napi:\n  error:\n    base-url: ${API_ERROR_DOCS_URL:https://api.example.com/problems}\n    use-about-blank: false\n\n# ============================================================\n# Logging (운영: 최소화)\n# ============================================================\nlogging:\n  level:\n    ${BASE_PACKAGE:com.example}.adapter.in.rest: INFO\n    org.springframework.web: WARN\n',1,'2026-01-21 13:48:33.000000','2026-01-21 13:48:33.000000',NULL),(9,6,'I18N','src/main/resources/messages_en.properties','PROPERTIES','영어 에러 메시지. 공통 에러 + 도메인별 에러 패턴 가이드.','# ===============================================\n# English Error Messages (messages_en.properties)\n# ===============================================\n# Used by Spring Boot MessageSource\n# UTF-8 encoding required\n#\n# Usage:\n# messageSource.getMessage(\"error.example.not_found\", args, locale)\n#\n# Parameter usage:\n# {0}, {1}, {2} format to reference args array values\n#\n# @since 1.0.0\n# ===============================================\n\n# ===============================================\n# Common Error Messages\n# ===============================================\n\n# Generic 400 Bad Request\nerror.common.bad_request=Bad request\n\n# Generic 401 Unauthorized\nerror.common.unauthorized=Authentication required\n\n# Generic 403 Forbidden\nerror.common.forbidden=Access forbidden\n\n# Generic 404 Not Found\nerror.common.not_found=Resource not found\n\n# Generic 409 Conflict\nerror.common.conflict=Resource conflict occurred\n\n# Generic 500 Internal Server Error\nerror.common.internal_server_error=Internal server error. Please try again later\n\n# ===============================================\n# Domain Error Messages Template\n# ===============================================\n# Replace {domain} with your domain name:\n#   error.order.not_found=Order not found (ID: {0})\n#   error.product.duplicate=Product already exists (code: {0})\n#\n# Common patterns:\n#   error.{domain}.not_found={Domain} not found (ID: {0})\n#   error.{domain}.duplicate={Domain} already exists ({0})\n#   error.{domain}.invalid_status=Invalid status transition (current: {0}, attempted: {1})\n# ===============================================\n',1,'2026-01-21 13:48:44.000000','2026-01-21 13:48:44.000000',NULL),(10,6,'I18N','src/main/resources/messages_ko.properties','PROPERTIES','한국어 에러 메시지. 공통 에러 + 도메인별 에러 패턴 가이드.','# ===============================================\n# 한국어 에러 메시지 (messages_ko.properties)\n# ===============================================\n# Spring Boot MessageSource에서 사용\n# UTF-8 인코딩 필수\n#\n# 사용 예시:\n# messageSource.getMessage(\"error.example.not_found\", args, locale)\n#\n# 파라미터 사용:\n# {0}, {1}, {2} 형식으로 args 배열의 값을 참조\n#\n# @since 1.0.0\n# ===============================================\n\n# ===============================================\n# 공통 에러 메시지\n# ===============================================\n\n# 일반적인 400 Bad Request\nerror.common.bad_request=잘못된 요청입니다.\n\n# 일반적인 401 Unauthorized\nerror.common.unauthorized=인증이 필요합니다.\n\n# 일반적인 403 Forbidden\nerror.common.forbidden=접근 권한이 없습니다.\n\n# 일반적인 404 Not Found\nerror.common.not_found=리소스를 찾을 수 없습니다.\n\n# 일반적인 409 Conflict\nerror.common.conflict=리소스 충돌이 발생했습니다.\n\n# 일반적인 500 Internal Server Error\nerror.common.internal_server_error=서버 오류가 발생했습니다. 잠시 후 다시 시도해주세요.\n\n# ===============================================\n# 도메인 에러 메시지 템플릿\n# ===============================================\n# {domain}을 도메인명으로 대체:\n#   error.order.not_found=주문을 찾을 수 없습니다. (ID: {0})\n#   error.product.duplicate=이미 존재하는 상품입니다. (코드: {0})\n#\n# 공통 패턴:\n#   error.{domain}.not_found={Domain}을(를) 찾을 수 없습니다. (ID: {0})\n#   error.{domain}.duplicate=이미 존재하는 {Domain}입니다. ({0})\n#   error.{domain}.invalid_status=유효하지 않은 상태 전환입니다. (현재: {0}, 시도: {1})\n# ===============================================\n',1,'2026-01-21 13:48:55.000000','2026-01-21 13:48:55.000000',NULL),(11,6,'CONFIG','persistence-local.yml','YAML','로컬 개발 환경 설정. Docker MySQL 또는 로컬 MySQL 연결. 상세 SQL 로깅, 작은 커넥션 풀.','# ============================================================\n# Persistence Module - Local Development Configuration\n# ============================================================\n\nspring:\n  # ─────────────────────────────────────────────────────────\n  # DataSource 설정 (로컬 MySQL)\n  # ─────────────────────────────────────────────────────────\n  datasource:\n    url: jdbc:mysql://localhost:3306/$${DB_NAME:app}?useSSL=false&allowPublicKeyRetrieval=true&serverTimezone=Asia/Seoul&characterEncoding=UTF-8&useUnicode=true&rewriteBatchedStatements=true&cachePrepStmts=true&useServerPrepStmts=true\n    username: $${DB_USERNAME:root}\n    password: $${DB_PASSWORD:root}\n\n    # ─────────────────────────────────────────────────────\n    # HikariCP 설정 (로컬: 최소 설정)\n    # ─────────────────────────────────────────────────────\n    hikari:\n      # 풀 크기 (로컬: 작게)\n      maximum-pool-size: 5\n      minimum-idle: 2\n\n      # 타임아웃 (로컬: 짧게)\n      connection-timeout: 5000        # 커넥션 획득 대기 최대 5초\n      idle-timeout: 300000            # 유휴 커넥션 유지 5분\n      max-lifetime: 600000            # 커넥션 최대 수명 10분\n      validation-timeout: 3000        # 커넥션 유효성 검사 3초\n\n      # 커넥션 테스트 (MySQL 전용)\n      connection-test-query: SELECT 1\n\n      # 커넥션 누수 감지 (개발 시 유용)\n      leak-detection-threshold: 30000  # 30초 이상 반환 안 되면 경고\n\n  # ─────────────────────────────────────────────────────────\n  # JPA 설정 (로컬: DDL 자동 검증)\n  # ─────────────────────────────────────────────────────────\n  jpa:\n    hibernate:\n      ddl-auto: validate    # 스키마 검증만 (Flyway로 관리)\n\n    # SQL 로깅 (개발 편의)\n    show-sql: true\n\n    properties:\n      hibernate:\n        # SQL 포맷팅\n        format_sql: true\n        use_sql_comments: true\n        highlight_sql: true\n\n        # 통계 수집 (개발 시 성능 분석)\n        generate_statistics: true\n\n        # 느린 쿼리 로깅 (100ms 이상)\n        session:\n          events:\n            log:\n              LOG_QUERIES_SLOWER_THAN_MS: 100\n\n  # ─────────────────────────────────────────────────────────\n  # Flyway 설정 (로컬)\n  # ─────────────────────────────────────────────────────────\n  flyway:\n    enabled: true\n    clean-disabled: false    # 로컬에서는 clean 허용\n    baseline-on-migrate: true\n\n# ─────────────────────────────────────────────────────────\n# 로깅 설정 (로컬: 상세 SQL 로깅)\n# ─────────────────────────────────────────────────────────\nlogging:\n  level:\n    # Hibernate SQL 로깅\n    org.hibernate.SQL: DEBUG\n    org.hibernate.type.descriptor.sql.BasicBinder: TRACE\n    org.hibernate.orm.jdbc.bind: TRACE\n\n    # HikariCP 로깅\n    com.zaxxer.hikari: DEBUG\n    com.zaxxer.hikari.HikariConfig: DEBUG\n\n    # Spring Data JPA\n    org.springframework.data.jpa: DEBUG\n\n    # QueryDSL\n    com.querydsl: DEBUG\n\n    # Flyway\n    org.flywaydb: DEBUG\n',1,'2026-01-16 06:52:08.000000','2026-01-16 06:52:08.000000',NULL),(12,6,'CONFIG','persistence-dev.yml','YAML','개발 서버 환경 설정. 팀 공유 개발 DB 연결. 적당한 커넥션 풀, SQL 로깅 활성화.','# ============================================================\n# Persistence Module - Development Server Configuration\n# ============================================================\n\nspring:\n  # ─────────────────────────────────────────────────────────\n  # DataSource 설정 (개발 서버 MySQL)\n  # ─────────────────────────────────────────────────────────\n  datasource:\n    url: jdbc:mysql://$${DB_HOST:dev-mysql.internal}:$${DB_PORT:3306}/$${DB_NAME:app}?useSSL=true&requireSSL=true&verifyServerCertificate=false&serverTimezone=Asia/Seoul&characterEncoding=UTF-8&useUnicode=true&rewriteBatchedStatements=true&cachePrepStmts=true&useServerPrepStmts=true&connectTimeout=5000&socketTimeout=30000\n    username: $${DB_USERNAME}\n    password: $${DB_PASSWORD}\n\n    # ─────────────────────────────────────────────────────\n    # HikariCP 설정 (개발 서버: 중간 설정)\n    # ─────────────────────────────────────────────────────\n    hikari:\n      # 풀 크기 (개발: 중간)\n      maximum-pool-size: 10\n      minimum-idle: 5\n\n      # 타임아웃\n      connection-timeout: 10000       # 커넥션 획득 대기 최대 10초\n      idle-timeout: 600000            # 유휴 커넥션 유지 10분\n      max-lifetime: 1800000           # 커넥션 최대 수명 30분\n      validation-timeout: 5000        # 커넥션 유효성 검사 5초\n\n      # 커넥션 테스트\n      connection-test-query: SELECT 1\n\n      # 커넥션 누수 감지\n      leak-detection-threshold: 60000  # 60초 이상 반환 안 되면 경고\n\n      # 초기화 실패 타임아웃\n      initialization-fail-timeout: 30000\n\n  # ─────────────────────────────────────────────────────────\n  # JPA 설정 (개발 서버)\n  # ─────────────────────────────────────────────────────────\n  jpa:\n    hibernate:\n      ddl-auto: validate\n\n    show-sql: false    # 파일 로깅으로 대체\n\n    properties:\n      hibernate:\n        format_sql: true\n        generate_statistics: true\n\n        session:\n          events:\n            log:\n              LOG_QUERIES_SLOWER_THAN_MS: 500\n\n  # ─────────────────────────────────────────────────────────\n  # Flyway 설정 (개발 서버)\n  # ─────────────────────────────────────────────────────────\n  flyway:\n    enabled: true\n    clean-disabled: true    # 개발 서버에서도 clean 금지\n    out-of-order: true      # 팀 협업으로 순서 외 마이그레이션 허용\n\n# ─────────────────────────────────────────────────────────\n# 로깅 설정 (개발 서버: SQL 로깅)\n# ─────────────────────────────────────────────────────────\nlogging:\n  level:\n    org.hibernate.SQL: DEBUG\n    org.hibernate.orm.jdbc.bind: DEBUG\n    com.zaxxer.hikari: INFO\n    org.flywaydb: INFO\n',1,'2026-01-16 06:52:08.000000','2026-01-16 06:52:08.000000',NULL),(13,6,'CONFIG','persistence-staging.yml','YAML','스테이징 환경 설정. 운영과 유사한 설정으로 사전 검증. SQL 로깅 최소화, 운영급 커넥션 풀.','# ============================================================\n# Persistence Module - Staging Configuration\n# ============================================================\n\nspring:\n  # ─────────────────────────────────────────────────────────\n  # DataSource 설정 (스테이징 MySQL)\n  # ─────────────────────────────────────────────────────────\n  datasource:\n    url: jdbc:mysql://$${DB_HOST}:$${DB_PORT:3306}/$${DB_NAME}?useSSL=true&requireSSL=true&verifyServerCertificate=true&serverTimezone=Asia/Seoul&characterEncoding=UTF-8&useUnicode=true&rewriteBatchedStatements=true&cachePrepStmts=true&useServerPrepStmts=true&connectTimeout=5000&socketTimeout=60000\n    username: $${DB_USERNAME}\n    password: $${DB_PASSWORD}\n\n    # ─────────────────────────────────────────────────────\n    # HikariCP 설정 (스테이징: 운영과 유사)\n    # ─────────────────────────────────────────────────────\n    hikari:\n      # 풀 크기 (운영의 절반 수준)\n      maximum-pool-size: 15\n      minimum-idle: 10\n\n      # 타임아웃 (운영과 동일)\n      connection-timeout: 30000       # 커넥션 획득 대기 최대 30초\n      idle-timeout: 600000            # 유휴 커넥션 유지 10분\n      max-lifetime: 1800000           # 커넥션 최대 수명 30분\n      validation-timeout: 5000        # 커넥션 유효성 검사 5초\n      keepalive-time: 300000          # Keep-alive 5분\n\n      # 커넥션 테스트\n      connection-test-query: SELECT 1\n\n      # 커넥션 누수 감지 (스테이징에서 검증)\n      leak-detection-threshold: 120000  # 2분\n\n      # 초기화 실패 타임아웃\n      initialization-fail-timeout: 60000\n\n  # ─────────────────────────────────────────────────────────\n  # JPA 설정 (스테이징)\n  # ─────────────────────────────────────────────────────────\n  jpa:\n    hibernate:\n      ddl-auto: validate\n\n    show-sql: false\n\n    properties:\n      hibernate:\n        format_sql: false\n        generate_statistics: false\n\n        # 느린 쿼리만 로깅 (1초 이상)\n        session:\n          events:\n            log:\n              LOG_QUERIES_SLOWER_THAN_MS: 1000\n\n  # ─────────────────────────────────────────────────────────\n  # Flyway 설정 (스테이징)\n  # ─────────────────────────────────────────────────────────\n  flyway:\n    enabled: true\n    clean-disabled: true\n    validate-on-migrate: true\n\n# ─────────────────────────────────────────────────────────\n# 로깅 설정 (스테이징: 최소 로깅)\n# ─────────────────────────────────────────────────────────\nlogging:\n  level:\n    org.hibernate.SQL: WARN\n    org.hibernate.orm.jdbc.bind: WARN\n    com.zaxxer.hikari: WARN\n    org.flywaydb: INFO\n',1,'2026-01-16 06:52:08.000000','2026-01-16 06:52:08.000000',NULL),(14,6,'CONFIG','persistence-prod.yml','YAML','운영 환경 설정. 보안 최우선, 성능 최적화, 고가용성. HikariCP 풀 최적화, SSL 필수.','# ============================================================\n# Persistence Module - Production Configuration\n# ============================================================\n\nspring:\n  # ─────────────────────────────────────────────────────────\n  # DataSource 설정 (운영 MySQL - AWS RDS/Aurora 등)\n  # ─────────────────────────────────────────────────────────\n  datasource:\n    # AWS RDS MySQL 예시 (Aurora, RDS 모두 적용 가능)\n    url: jdbc:mysql://$${DB_HOST}:$${DB_PORT:3306}/$${DB_NAME}?useSSL=true&requireSSL=true&verifyServerCertificate=true&enabledTLSProtocols=TLSv1.2,TLSv1.3&serverTimezone=Asia/Seoul&characterEncoding=UTF-8&useUnicode=true&rewriteBatchedStatements=true&cachePrepStmts=true&prepStmtCacheSize=500&prepStmtCacheSqlLimit=4096&useServerPrepStmts=true&connectTimeout=5000&socketTimeout=60000&tcpKeepAlive=true\n    username: $${DB_USERNAME}\n    password: $${DB_PASSWORD}\n\n    # ─────────────────────────────────────────────────────\n    # HikariCP 설정 (운영: 고성능 최적화)\n    # ─────────────────────────────────────────────────────\n    hikari:\n      pool-name: HikariPool-Production\n\n      # ─────────────────────────────────────────────────\n      # 풀 크기 설정\n      # 공식: connections = ((core_count * 2) + effective_spindle_count)\n      # 일반적으로 CPU 코어 수 * 2 ~ 4\n      # ─────────────────────────────────────────────────\n      maximum-pool-size: $${HIKARI_MAX_POOL_SIZE:30}\n      minimum-idle: $${HIKARI_MIN_IDLE:15}\n\n      # ─────────────────────────────────────────────────\n      # 타임아웃 설정 (운영: 안정성 중시)\n      # ─────────────────────────────────────────────────\n\n      # 커넥션 획득 대기 최대 시간 (30초)\n      # 이 시간 내에 커넥션을 얻지 못하면 SQLException 발생\n      connection-timeout: 30000\n\n      # 유휴 커넥션 유지 시간 (10분)\n      # minimum-idle보다 많은 유휴 커넥션은 이 시간 후 제거\n      idle-timeout: 600000\n\n      # 커넥션 최대 수명 (30분)\n      # DB의 wait_timeout보다 짧아야 함 (MySQL 기본 8시간)\n      # 커넥션 재활용으로 메모리 누수 방지\n      max-lifetime: 1800000\n\n      # 커넥션 유효성 검사 타임아웃 (5초)\n      validation-timeout: 5000\n\n      # Keep-Alive 간격 (5분)\n      # 유휴 커넥션이 DB에 의해 끊기지 않도록 유지\n      keepalive-time: 300000\n\n      # ─────────────────────────────────────────────────\n      # 커넥션 검증\n      # ─────────────────────────────────────────────────\n\n      # MySQL 커넥션 테스트 쿼리\n      # JDBC4 드라이버는 isValid() 사용, 설정하지 않아도 됨\n      # 하지만 명시적으로 설정하면 더 확실함\n      connection-test-query: SELECT 1\n\n      # ─────────────────────────────────────────────────\n      # 초기화 설정\n      # ─────────────────────────────────────────────────\n\n      # 초기화 실패 시 즉시 예외 발생 (fail-fast)\n      # 0보다 크면 해당 시간만큼 재시도\n      initialization-fail-timeout: 1\n\n      # ─────────────────────────────────────────────────\n      # 커넥션 누수 감지 (운영에서는 비활성화 또는 높은 값)\n      # 운영에서 오탐 방지를 위해 높은 임계값 또는 비활성화\n      # ─────────────────────────────────────────────────\n      leak-detection-threshold: 0    # 비활성화 (0)\n\n      # ─────────────────────────────────────────────────\n      # 기타 최적화 설정\n      # ─────────────────────────────────────────────────\n      auto-commit: false\n      read-only: false\n\n      # MySQL 드라이버 최적화 속성\n      data-source-properties:\n        # PreparedStatement 캐싱 (성능 향상)\n        cachePrepStmts: true\n        prepStmtCacheSize: 500\n        prepStmtCacheSqlLimit: 4096\n        useServerPrepStmts: true\n\n        # 배치 처리 최적화\n        rewriteBatchedStatements: true\n\n        # 메타데이터 캐싱\n        cacheResultSetMetadata: true\n        cacheServerConfiguration: true\n        elideSetAutoCommits: true\n\n        # 네트워크 최적화\n        tcpKeepAlive: true\n        tcpNoDelay: true\n\n        # 로깅 비활성화 (성능)\n        maintainTimeStats: false\n        enableQueryTimeouts: true\n\n  # ─────────────────────────────────────────────────────────\n  # JPA 설정 (운영)\n  # ─────────────────────────────────────────────────────────\n  jpa:\n    hibernate:\n      ddl-auto: none    # 절대 자동 DDL 금지\n\n    show-sql: false\n    open-in-view: false\n\n    properties:\n      hibernate:\n        format_sql: false\n        use_sql_comments: false\n        generate_statistics: false\n\n        # 배치 처리 (운영: 큰 배치)\n        jdbc:\n          batch_size: 100\n          fetch_size: 200\n\n        # 캐시 비활성화 (Redis로 대체)\n        cache:\n          use_second_level_cache: false\n          use_query_cache: false\n\n        # 느린 쿼리 로깅 비활성화 (APM 도구로 대체)\n        session:\n          events:\n            log:\n              LOG_QUERIES_SLOWER_THAN_MS: 0\n\n  # ─────────────────────────────────────────────────────────\n  # Flyway 설정 (운영)\n  # ─────────────────────────────────────────────────────────\n  flyway:\n    enabled: $${FLYWAY_ENABLED:true}\n    clean-disabled: true    # 절대 clean 금지\n    validate-on-migrate: true\n    out-of-order: false     # 순서 엄격 적용\n\n# ─────────────────────────────────────────────────────────\n# 로깅 설정 (운영: 에러만)\n# ─────────────────────────────────────────────────────────\nlogging:\n  level:\n    org.hibernate: WARN\n    org.hibernate.SQL: WARN\n    org.hibernate.orm.jdbc.bind: OFF\n    com.zaxxer.hikari: WARN\n    org.flywaydb: WARN\n',1,'2026-01-16 06:52:08.000000','2026-01-16 06:52:08.000000',NULL),(15,6,'CONFIG','config/JpaConfig.java','JAVA','JPA 설정 클래스. JPA Auditing, EntityManager, TransactionManager 설정.','package com.{bc}.adapter.out.persistence.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.domain.AuditorAware;\nimport org.springframework.data.jpa.repository.config.EnableJpaAuditing;\nimport org.springframework.data.jpa.repository.config.EnableJpaRepositories;\nimport org.springframework.transaction.annotation.EnableTransactionManagement;\n\nimport java.util.Optional;\n\n/**\n * JPA 설정 클래스\n *\n * <p>기능:</p>\n * <ul>\n *   <li>JPA Auditing 활성화 (@CreatedDate, @LastModifiedDate)</li>\n *   <li>JPA Repository 스캔 경로 지정</li>\n *   <li>트랜잭션 관리 활성화</li>\n * </ul>\n *\n * <p>주의사항:</p>\n * <ul>\n *   <li>auditorProvider는 보안 컨텍스트에서 사용자 ID를 가져오도록 구현</li>\n *   <li>멀티 모듈 프로젝트에서는 basePackages 명시 필수</li>\n * </ul>\n */\n@Configuration\n@EnableJpaAuditing(auditorAwareRef = \"auditorProvider\")\n@EnableJpaRepositories(\n    basePackages = \"com.{bc}.adapter.out.persistence\",\n    // EntityManager 지정 (멀티 DataSource 시)\n    entityManagerFactoryRef = \"entityManagerFactory\",\n    transactionManagerRef = \"transactionManager\"\n)\n@EnableTransactionManagement\npublic class JpaConfig {\n\n    /**\n     * Auditor Provider - 현재 사용자 ID 제공\n     *\n     * <p>@CreatedBy, @LastModifiedBy 필드에 사용자 ID 자동 주입</p>\n     *\n     * <p>구현 방법:</p>\n     * <ul>\n     *   <li>Spring Security: SecurityContextHolder에서 가져오기</li>\n     *   <li>JWT: 토큰에서 사용자 ID 추출</li>\n     *   <li>시스템 작업: \"SYSTEM\" 또는 고정값 반환</li>\n     * </ul>\n     *\n     * @return AuditorAware 구현체\n     */\n    @Bean\n    public AuditorAware<String> auditorProvider() {\n        // 기본 구현: 시스템 사용자\n        // TODO: 실제 구현 시 SecurityContext에서 사용자 ID 추출\n        return () -> Optional.of(\"SYSTEM\");\n\n        // Spring Security 사용 시 예시:\n        // return () -> Optional.ofNullable(SecurityContextHolder.getContext())\n        //     .map(SecurityContext::getAuthentication)\n        //     .filter(Authentication::isAuthenticated)\n        //     .map(Authentication::getName);\n    }\n}',1,'2026-01-16 06:52:08.000000','2026-01-16 06:52:08.000000',NULL),(16,6,'CONFIG','config/QueryDslConfig.java','JAVA','QueryDSL 설정 클래스. JPAQueryFactory Bean 등록.','package com.{bc}.adapter.out.persistence.config;\n\nimport com.querydsl.jpa.impl.JPAQueryFactory;\nimport jakarta.persistence.EntityManager;\nimport jakarta.persistence.PersistenceContext;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n/**\n * QueryDSL 설정 클래스\n *\n * <p>JPAQueryFactory Bean을 등록하여 QueryDslRepository에서 사용</p>\n *\n * <p>사용 예시:</p>\n * <pre>{@code\n * @Repository\n * public class OrderQueryDslRepository {\n *\n *     private final JPAQueryFactory queryFactory;\n *\n *     public OrderQueryDslRepository(JPAQueryFactory queryFactory) {\n *         this.queryFactory = queryFactory;\n *     }\n *\n *     public List<OrderJpaEntity> findByStatus(OrderStatus status) {\n *         return queryFactory\n *             .selectFrom(order)\n *             .where(order.status.eq(status))\n *             .fetch();\n *     }\n * }\n * }</pre>\n *\n * <p>주의사항:</p>\n * <ul>\n *   <li>EntityManager는 요청 스코프이므로 Thread-Safe</li>\n *   <li>JPAQueryFactory는 Singleton Bean으로 등록해도 안전</li>\n *   <li>멀티 DataSource 환경에서는 EntityManager 구분 필요</li>\n * </ul>\n */\n@Configuration\npublic class QueryDslConfig {\n\n    @PersistenceContext\n    private EntityManager entityManager;\n\n    /**\n     * JPAQueryFactory Bean 등록\n     *\n     * <p>QueryDSL의 타입 안전한 쿼리 빌더</p>\n     *\n     * @return JPAQueryFactory 인스턴스\n     */\n    @Bean\n    public JPAQueryFactory jpaQueryFactory() {\n        return new JPAQueryFactory(entityManager);\n    }\n}',1,'2026-01-16 06:52:08.000000','2026-01-16 06:52:08.000000',NULL),(17,6,'CONFIG','config/P6SpyConfig.java','JAVA','P6Spy SQL 로깅 설정 (선택적). 바인딩 파라미터 포함 실제 SQL 출력.','package com.{bc}.adapter.out.persistence.config;\n\nimport com.p6spy.engine.logging.Category;\nimport com.p6spy.engine.spy.P6SpyOptions;\nimport com.p6spy.engine.spy.appender.MessageFormattingStrategy;\nimport jakarta.annotation.PostConstruct;\nimport org.hibernate.engine.jdbc.internal.FormatStyle;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Profile;\n\nimport java.util.Locale;\n\n/**\n * P6Spy SQL 로깅 설정 (선택적)\n *\n * <p>실제 바인딩된 파라미터 값을 포함한 SQL 출력</p>\n *\n * <p>활성화 조건:</p>\n * <ul>\n *   <li>local, dev 프로파일에서만 활성화</li>\n *   <li>운영 환경에서는 비활성화 (성능 영향)</li>\n * </ul>\n *\n * <p>의존성 추가 필요:</p>\n * <pre>{@code\n * implementation \'com.github.gavlyukovskiy:p6spy-spring-boot-starter:1.9.0\'\n * }</pre>\n *\n * <p>application.yml 설정:</p>\n * <pre>{@code\n * decorator:\n *   datasource:\n *     p6spy:\n *       enable-logging: true\n *       multiline: true\n *       logging: slf4j\n * }</pre>\n */\n@Configuration\n@Profile({\"local\", \"dev\"})\npublic class P6SpyConfig {\n\n    @PostConstruct\n    public void setLogMessageFormat() {\n        P6SpyOptions.getActiveInstance().setLogMessageFormat(P6SpySqlFormatStrategy.class.getName());\n    }\n\n    /**\n     * SQL 포맷팅 전략\n     */\n    public static class P6SpySqlFormatStrategy implements MessageFormattingStrategy {\n\n        @Override\n        public String formatMessage(int connectionId, String now, long elapsed,\n                                    String category, String prepared, String sql, String url) {\n            if (sql == null || sql.trim().isEmpty()) {\n                return \"\";\n            }\n\n            String formattedSql = formatSql(category, sql);\n\n            return String.format(\n                \"\n============================================================\n\" +\n                \"  Connection ID: %d\n\" +\n                \"  Execution Time: %d ms\n\" +\n                \"  Category: %s\n\" +\n                \"============================================================\n\" +\n                \"%s\n\" +\n                \"============================================================\",\n                connectionId, elapsed, category, formattedSql\n            );\n        }\n\n        private String formatSql(String category, String sql) {\n            if (sql == null || sql.trim().isEmpty()) {\n                return sql;\n            }\n\n            // DDL과 DML 구분하여 포맷팅\n            if (Category.STATEMENT.getName().equals(category)) {\n                String trimmedSql = sql.trim().toLowerCase(Locale.ROOT);\n                if (trimmedSql.startsWith(\"create\") ||\n                    trimmedSql.startsWith(\"alter\") ||\n                    trimmedSql.startsWith(\"drop\") ||\n                    trimmedSql.startsWith(\"comment\")) {\n                    return FormatStyle.DDL.getFormatter().format(sql);\n                }\n                return FormatStyle.BASIC.getFormatter().format(sql);\n            }\n            return sql;\n        }\n    }\n}',0,'2026-01-16 06:52:08.000000','2026-01-16 06:52:08.000000',NULL),(18,6,'CONFIG','entity/common/BaseAuditEntity.java','JAVA','JPA Auditing 기반 추상 엔티티. createdAt, updatedAt 자동 관리.','package com.{bc}.adapter.out.persistence.entity.common;\n\nimport jakarta.persistence.Column;\nimport jakarta.persistence.EntityListeners;\nimport jakarta.persistence.MappedSuperclass;\nimport org.springframework.data.annotation.CreatedDate;\nimport org.springframework.data.annotation.LastModifiedDate;\nimport org.springframework.data.jpa.domain.support.AuditingEntityListener;\n\nimport java.time.Instant;\n\n/**\n * 감사 기반 추상 엔티티\n *\n * <p>모든 Entity가 상속받아야 하는 기본 클래스</p>\n *\n * <p>제공 기능:</p>\n * <ul>\n *   <li>createdAt: 생성 시각 (INSERT 시 자동 설정, 변경 불가)</li>\n *   <li>updatedAt: 수정 시각 (UPDATE 시 자동 갱신)</li>\n * </ul>\n *\n * <p>주의사항:</p>\n * <ul>\n *   <li>@EnableJpaAuditing 설정 필수</li>\n *   <li>Instant 타입 사용 (타임존 독립적)</li>\n *   <li>Setter 미제공 (JPA Auditing이 자동 설정)</li>\n * </ul>\n *\n * <p>사용 예시:</p>\n * <pre>{@code\n * @Entity\n * @Table(name = \"orders\")\n * public class OrderJpaEntity extends BaseAuditEntity {\n *     // Entity 필드 정의\n * }\n * }</pre>\n */\n@MappedSuperclass\n@EntityListeners(AuditingEntityListener.class)\npublic abstract class BaseAuditEntity {\n\n    @CreatedDate\n    @Column(name = \"created_at\", nullable = false, updatable = false)\n    private Instant createdAt;\n\n    @LastModifiedDate\n    @Column(name = \"updated_at\", nullable = false)\n    private Instant updatedAt;\n\n    // Getter만 제공 (Setter 금지 - Auditing이 자동 설정)\n    public Instant getCreatedAt() {\n        return createdAt;\n    }\n\n    public Instant getUpdatedAt() {\n        return updatedAt;\n    }\n}',1,'2026-01-16 06:52:08.000000','2026-01-16 06:52:08.000000',NULL),(19,6,'CONFIG','entity/common/SoftDeletableEntity.java','JAVA','소프트 삭제 기반 추상 엔티티. deleted, deletedAt 필드 제공.','package com.{bc}.adapter.out.persistence.entity.common;\n\nimport jakarta.persistence.Column;\nimport jakarta.persistence.MappedSuperclass;\n\nimport java.time.Instant;\n\n/**\n * 소프트 삭제 기반 추상 엔티티\n *\n * <p>BaseAuditEntity를 상속하고 소프트 삭제 기능 추가</p>\n *\n * <p>제공 기능:</p>\n * <ul>\n *   <li>deleted: 삭제 여부 플래그</li>\n *   <li>deletedAt: 삭제 시각</li>\n *   <li>softDelete(): 소프트 삭제 실행 메서드</li>\n *   <li>restore(): 복원 메서드</li>\n * </ul>\n *\n * <p>주의사항:</p>\n * <ul>\n *   <li>조회 시 deleted = false 조건 필수</li>\n *   <li>복원 시 deletedAt = null로 초기화</li>\n *   <li>물리적 삭제(DELETE)는 배치 작업으로 별도 처리</li>\n * </ul>\n *\n * <p>QueryDSL 조회 예시:</p>\n * <pre>{@code\n * queryFactory\n *     .selectFrom(order)\n *     .where(order.deleted.isFalse())  // 소프트 삭제되지 않은 것만\n *     .fetch();\n * }</pre>\n */\n@MappedSuperclass\npublic abstract class SoftDeletableEntity extends BaseAuditEntity {\n\n    @Column(name = \"deleted\", nullable = false)\n    private boolean deleted = false;\n\n    @Column(name = \"deleted_at\")\n    private Instant deletedAt;\n\n    // Getter\n    public boolean isDeleted() {\n        return deleted;\n    }\n\n    public Instant getDeletedAt() {\n        return deletedAt;\n    }\n\n    /**\n     * 소프트 삭제 실행\n     *\n     * <p>deleted = true, deletedAt = 현재 시각으로 설정</p>\n     *\n     * @param deletedAt 삭제 시각 (Domain에서 전달)\n     */\n    public void softDelete(Instant deletedAt) {\n        this.deleted = true;\n        this.deletedAt = deletedAt;\n    }\n\n    /**\n     * 복원 (삭제 취소)\n     *\n     * <p>deleted = false, deletedAt = null로 초기화</p>\n     */\n    public void restore() {\n        this.deleted = false;\n        this.deletedAt = null;\n    }\n}',1,'2026-01-16 06:52:08.000000','2026-01-16 06:52:08.000000',NULL),(20,6,'CONFIG','config/FlywayConfig.java','JAVA','Flyway 콜백 설정 (선택적). 마이그레이션 전후 커스텀 로직 실행.','package com.{bc}.adapter.out.persistence.config;\n\nimport org.flywaydb.core.api.callback.Callback;\nimport org.flywaydb.core.api.callback.Context;\nimport org.flywaydb.core.api.callback.Event;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n/**\n * Flyway 콜백 설정 (선택적)\n *\n * <p>마이그레이션 이벤트에 대한 커스텀 로직 실행</p>\n *\n * <p>지원 이벤트:</p>\n * <ul>\n *   <li>BEFORE_MIGRATE: 마이그레이션 시작 전</li>\n *   <li>AFTER_MIGRATE: 마이그레이션 완료 후</li>\n *   <li>AFTER_MIGRATE_ERROR: 마이그레이션 실패 시</li>\n *   <li>BEFORE_EACH_MIGRATE: 각 스크립트 실행 전</li>\n *   <li>AFTER_EACH_MIGRATE: 각 스크립트 실행 후</li>\n * </ul>\n *\n * <p>활용 예시:</p>\n * <ul>\n *   <li>마이그레이션 완료 Slack 알림</li>\n *   <li>마이그레이션 실패 시 롤백 알림</li>\n *   <li>마이그레이션 전후 캐시 초기화</li>\n * </ul>\n */\n@Configuration\npublic class FlywayConfig {\n\n    private static final Logger log = LoggerFactory.getLogger(FlywayConfig.class);\n\n    @Bean\n    public Callback flywayCallback() {\n        return new Callback() {\n\n            @Override\n            public boolean supports(Event event, Context context) {\n                return event == Event.BEFORE_MIGRATE\n                    || event == Event.AFTER_MIGRATE\n                    || event == Event.AFTER_MIGRATE_ERROR;\n            }\n\n            @Override\n            public boolean canHandleInTransaction(Event event, Context context) {\n                return true;\n            }\n\n            @Override\n            public void handle(Event event, Context context) {\n                switch (event) {\n                    case BEFORE_MIGRATE -> log.info(\n                        \"[Flyway] 마이그레이션 시작 - Schema: {}\",\n                        context.getConfiguration().getDefaultSchema()\n                    );\n                    case AFTER_MIGRATE -> log.info(\n                        \"[Flyway] 마이그레이션 완료 - Version: {}\",\n                        context.getMigrationInfo() != null\n                            ? context.getMigrationInfo().getVersion()\n                            : \"N/A\"\n                    );\n                    case AFTER_MIGRATE_ERROR -> log.error(\n                        \"[Flyway] 마이그레이션 실패! 롤백 필요\"\n                    );\n                    default -> { }\n                }\n            }\n\n            @Override\n            public String getCallbackName() {\n                return \"FlywayLoggingCallback\";\n            }\n        };\n    }\n}',0,'2026-01-16 06:52:08.000000','2026-01-16 06:52:08.000000',NULL),(21,6,'CONFIG','config/DataSourceHealthConfig.java','JAVA','DataSource 헬스체크 확장 설정 (선택적). HikariCP 풀 상태 모니터링.','package com.{bc}.adapter.out.persistence.config;\n\nimport com.zaxxer.hikari.HikariDataSource;\nimport com.zaxxer.hikari.HikariPoolMXBean;\nimport org.springframework.boot.actuate.health.Health;\nimport org.springframework.boot.actuate.health.HealthIndicator;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Profile;\n\nimport javax.sql.DataSource;\n\n/**\n * DataSource 헬스체크 확장 설정 (선택적)\n *\n * <p>HikariCP 커넥션 풀 상태를 Actuator 헬스체크에 포함</p>\n *\n * <p>모니터링 항목:</p>\n * <ul>\n *   <li>activeConnections: 현재 사용 중인 커넥션 수</li>\n *   <li>idleConnections: 유휴 커넥션 수</li>\n *   <li>totalConnections: 전체 커넥션 수</li>\n *   <li>threadsAwaitingConnection: 커넥션 대기 중인 스레드 수</li>\n * </ul>\n *\n * <p>Actuator 엔드포인트:</p>\n * <pre>\n * GET /actuator/health/hikariPool\n * </pre>\n */\n@Configuration\n@Profile({\"!test\"})  // 테스트 환경 제외\npublic class DataSourceHealthConfig {\n\n    @Bean\n    public HealthIndicator hikariPoolHealthIndicator(DataSource dataSource) {\n        return () -> {\n            if (!(dataSource instanceof HikariDataSource hikariDataSource)) {\n                return Health.unknown()\n                    .withDetail(\"message\", \"DataSource is not HikariDataSource\")\n                    .build();\n            }\n\n            HikariPoolMXBean poolMXBean = hikariDataSource.getHikariPoolMXBean();\n            if (poolMXBean == null) {\n                return Health.down()\n                    .withDetail(\"message\", \"HikariPool not initialized\")\n                    .build();\n            }\n\n            int activeConnections = poolMXBean.getActiveConnections();\n            int idleConnections = poolMXBean.getIdleConnections();\n            int totalConnections = poolMXBean.getTotalConnections();\n            int threadsAwaiting = poolMXBean.getThreadsAwaitingConnection();\n            int maxPoolSize = hikariDataSource.getMaximumPoolSize();\n\n            // 풀 사용률 계산\n            double poolUsage = (double) activeConnections / maxPoolSize * 100;\n\n            Health.Builder builder;\n            if (poolUsage >= 90) {\n                builder = Health.down()\n                    .withDetail(\"warning\", \"Connection pool usage over 90%\");\n            } else if (poolUsage >= 70) {\n                builder = Health.up()\n                    .withDetail(\"warning\", \"Connection pool usage over 70%\");\n            } else {\n                builder = Health.up();\n            }\n\n            return builder\n                .withDetail(\"poolName\", hikariDataSource.getPoolName())\n                .withDetail(\"activeConnections\", activeConnections)\n                .withDetail(\"idleConnections\", idleConnections)\n                .withDetail(\"totalConnections\", totalConnections)\n                .withDetail(\"maxPoolSize\", maxPoolSize)\n                .withDetail(\"poolUsagePercent\", String.format(\"%.1f%%\", poolUsage))\n                .withDetail(\"threadsAwaitingConnection\", threadsAwaiting)\n                .build();\n        };\n    }\n}',0,'2026-01-16 06:52:08.000000','2026-01-16 06:52:08.000000',NULL);
INSERT INTO `rule_example` VALUES (5,24,'BAD','// ❌ BAD: Lombok 사용\n@Data\n@Builder\n@AllArgsConstructor\npublic class Order {\n    private Long id;\n    private String status;\n    private Instant createdAt;\n}','java','Lombok 어노테이션은 컴파일 타임 코드 생성으로 디버깅이 어렵고, Domain Layer의 순수성을 해칩니다.','[2, 3, 4]','MANUAL',NULL,'2026-01-20 15:04:52.000000','2026-01-20 15:04:52.000000',NULL),(6,24,'GOOD','// ✅ GOOD: 명시적 구현\npublic class Order {\n    private final OrderId id;\n    private OrderStatus status;\n    private final Instant createdAt;\n\n    private Order(OrderId id, OrderStatus status, Instant createdAt) {\n        this.id = id;\n        this.status = status;\n        this.createdAt = createdAt;\n    }\n\n    public OrderId id() { return id; }\n    public OrderStatus status() { return status; }\n    public Instant createdAt() { return createdAt; }\n}','java','모든 필드와 메서드를 명시적으로 작성하여 코드 가독성과 디버깅 용이성을 확보합니다.','[7, 8, 9, 10]','MANUAL',NULL,'2026-01-20 15:04:52.000000','2026-01-20 15:04:52.000000',NULL),(7,27,'BAD','// ❌ BAD: 생성자 직접 노출\npublic class Order {\n    private OrderId id;\n    private OrderStatus status;\n\n    // public 생성자 직접 노출\n    public Order(Long customerId, List<OrderLine> lines) {\n        this.id = OrderId.forNew();\n        this.status = OrderStatus.PENDING;\n    }\n}\n\n// 사용 시\nOrder order = new Order(customerId, lines);','java','생성자를 직접 노출하면 생성 의도가 불명확하고, 비즈니스 규칙 검증이 분산됩니다.','[7, 8, 9, 10, 14]','MANUAL',NULL,'2026-01-20 15:04:52.000000','2026-01-20 15:04:52.000000',NULL),(8,27,'GOOD','// ✅ GOOD: forNew() 정적 팩토리 메서드\npublic class Order {\n    private final OrderId id;\n    private OrderStatus status;\n\n    private Order(OrderId id, OrderStatus status) {\n        this.id = id;\n        this.status = status;\n    }\n\n    // 새 Aggregate 생성 - ID는 null\n    public static Order forNew(Long customerId, List<OrderLine> lines, Instant now) {\n        validateNewOrder(customerId, lines);\n        return new Order(OrderId.forNew(), OrderStatus.PENDING);\n    }\n\n    // DB에서 복원 - ID 존재\n    public static Order reconstitute(OrderId id, OrderStatus status) {\n        return new Order(id, status);\n    }\n}\n\n// 사용 시\nOrder order = Order.forNew(customerId, lines, now);','java','forNew()는 새 Aggregate 생성 의도를 명확히 하고, reconstitute()는 영속성 복원을 표현합니다.','[12, 13, 14, 15, 18, 19, 20, 24]','MANUAL',NULL,'2026-01-20 15:04:52.000000','2026-01-20 15:04:52.000000',NULL),(9,35,'BAD','// ❌ BAD: Setter 메서드 사용\npublic class Order {\n    private OrderStatus status;\n\n    public void setStatus(OrderStatus status) {\n        this.status = status;\n    }\n}\n\n// 사용 시 - 비즈니스 의도 불명확\norder.setStatus(OrderStatus.SHIPPED);','java','Setter는 상태 변경 의도가 불명확하고, 비즈니스 불변식 검증이 누락됩니다.','[5, 6, 7, 11]','MANUAL',NULL,'2026-01-20 15:04:52.000000','2026-01-20 15:04:52.000000',NULL),(10,35,'GOOD','// ✅ GOOD: 도메인 메서드로 상태 변경\npublic class Order {\n    private OrderStatus status;\n\n    public void ship(Instant shippedAt) {\n        if (this.status != OrderStatus.PAID) {\n            throw new OrderNotPaidException(this.id);\n        }\n        this.status = OrderStatus.SHIPPED;\n        this.shippedAt = shippedAt;\n    }\n\n    public void cancel(String reason, Instant cancelledAt) {\n        if (this.status == OrderStatus.SHIPPED) {\n            throw new OrderAlreadyShippedException(this.id);\n        }\n        this.status = OrderStatus.CANCELLED;\n        this.cancelReason = reason;\n    }\n}\n\n// 사용 시 - 비즈니스 의도 명확\norder.ship(now);\norder.cancel(\"고객 요청\", now);','java','도메인 메서드는 비즈니스 의도를 명확히 하고, 불변식 검증을 캡슐화합니다.','[5, 6, 7, 8, 9, 10, 11, 13, 14, 15, 16, 17, 18, 19, 23, 24]','MANUAL',NULL,'2026-01-20 15:04:52.000000','2026-01-20 15:04:52.000000',NULL),(11,37,'BAD','// ❌ BAD: Getter 체이닝 (Law of Demeter 위반)\npublic class OrderService {\n    public void processOrder(Order order) {\n        // 내부 구조 노출\n        BigDecimal amount = order.getTotalPrice().getValue();\n        String city = order.getShippingAddress().getCity();\n\n        // 구조 변경 시 모든 호출부 수정 필요\n        if (order.getCustomer().getMembership().getLevel().equals(\"VIP\")) {\n            applyDiscount();\n        }\n    }\n}','java','Getter 체이닝은 내부 구조를 노출하고, 구조 변경 시 모든 호출부를 수정해야 합니다.','[5, 6, 9]','MANUAL',NULL,'2026-01-20 15:04:52.000000','2026-01-20 15:04:52.000000',NULL),(12,37,'GOOD','// ✅ GOOD: 편의 메서드로 캡슐화\npublic class Order {\n    private final Money totalPrice;\n    private final Address shippingAddress;\n    private final Customer customer;\n\n    // VO 원시값 접근 편의 메서드\n    public BigDecimal totalPriceValue() {\n        return totalPrice.value();\n    }\n\n    public String shippingCity() {\n        return shippingAddress.city();\n    }\n\n    // 비즈니스 로직 캡슐화\n    public boolean isVipCustomer() {\n        return customer.isVip();\n    }\n}\n\n// 사용 시 - 체이닝 없음\npublic class OrderService {\n    public void processOrder(Order order) {\n        BigDecimal amount = order.totalPriceValue();\n        if (order.isVipCustomer()) {\n            applyDiscount();\n        }\n    }\n}','java','편의 메서드로 내부 구조를 캡슐화하면, 구조 변경 시 Aggregate만 수정합니다.','[8, 9, 12, 13, 17, 18, 19, 25, 26, 27]','MANUAL',NULL,'2026-01-20 15:04:52.000000','2026-01-20 15:04:52.000000',NULL),(13,51,'BAD','// ❌ BAD: class로 VO 정의\npublic class Money {\n    private final BigDecimal value;\n    private final String currency;\n\n    public Money(BigDecimal value, String currency) {\n        this.value = value;\n        this.currency = currency;\n    }\n\n    public BigDecimal getValue() { return value; }\n    public String getCurrency() { return currency; }\n\n    // equals, hashCode 직접 구현 필요\n    @Override\n    public boolean equals(Object o) { ... }\n    @Override\n    public int hashCode() { ... }\n}','java','class로 VO를 정의하면 equals/hashCode를 직접 구현해야 하고, 불변성 보장이 어렵습니다.','[2, 6, 7, 8, 14, 15, 16, 17]','MANUAL',NULL,'2026-01-20 15:04:52.000000','2026-01-20 15:04:52.000000',NULL),(14,51,'GOOD','// ✅ GOOD: Record로 VO 정의\npublic record Money(BigDecimal value, String currency) {\n\n    // Compact Constructor로 검증\n    public Money {\n        if (value == null || value.compareTo(BigDecimal.ZERO) < 0) {\n            throw new IllegalArgumentException(\"금액은 0 이상이어야 합니다\");\n        }\n        if (currency == null || currency.isBlank()) {\n            throw new IllegalArgumentException(\"통화 코드는 필수입니다\");\n        }\n    }\n\n    // 정적 팩토리 메서드\n    public static Money of(BigDecimal value, String currency) {\n        return new Money(value, currency);\n    }\n\n    public static Money krw(BigDecimal value) {\n        return new Money(value, \"KRW\");\n    }\n}','java','Record는 자동으로 불변성, equals/hashCode, toString을 제공하고, Compact Constructor로 검증합니다.','[2, 5, 6, 7, 8, 9, 10, 11, 15, 16, 19, 20]','MANUAL',NULL,'2026-01-20 15:04:52.000000','2026-01-20 15:04:52.000000',NULL),(15,52,'GOOD','// ✅ GOOD: of() 정적 팩토리 메서드\npublic record Email(String value) {\n\n    private static final Pattern EMAIL_PATTERN =\n        Pattern.compile(\"^[A-Za-z0-9+_.-]+@(.+)$\");\n\n    public Email {\n        if (value == null || !EMAIL_PATTERN.matcher(value).matches()) {\n            throw new IllegalArgumentException(\"유효하지 않은 이메일: \" + value);\n        }\n    }\n\n    // 생성을 위한 유일한 진입점\n    public static Email of(String value) {\n        return new Email(value);\n    }\n}\n\n// 사용 시\nEmail email = Email.of(\"user@example.com\");','java','of() 정적 팩토리로 생성을 통제하고, 명명된 생성자 패턴으로 가독성을 높입니다.','[13, 14, 15, 19]','MANUAL',NULL,'2026-01-20 15:04:52.000000','2026-01-20 15:04:52.000000',NULL),(16,61,'GOOD','// ✅ GOOD: Long ID VO\npublic record OrderId(Long value) {\n\n    // 새 Aggregate용 - ID null\n    public static OrderId forNew() {\n        return new OrderId(null);\n    }\n\n    // DB 복원용 - ID 필수\n    public static OrderId of(Long value) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"OrderId는 null일 수 없습니다\");\n        }\n        return new OrderId(value);\n    }\n\n    public boolean isNew() {\n        return value == null;\n    }\n}','java','Long ID는 forNew()에서 null을 반환하고, of()에서는 null 검증을 수행합니다.','[2, 5, 6, 9, 10, 11, 12, 13, 16, 17]','MANUAL',NULL,'2026-01-20 15:04:52.000000','2026-01-20 15:04:52.000000',NULL),(17,62,'GOOD','// ✅ GOOD: String ID VO (UUID 등)\npublic record ProductId(String value) {\n\n    public ProductId {\n        if (value == null || value.isBlank()) {\n            throw new IllegalArgumentException(\"ProductId는 필수입니다\");\n        }\n    }\n\n    // String ID는 외부에서 주입 (forNew 없음)\n    public static ProductId of(String value) {\n        return new ProductId(value);\n    }\n\n    // String ID는 항상 값이 있으므로 isNew() 제공하지 않음\n}\n\n// 사용 시 - UUID는 외부에서 생성\nProductId productId = ProductId.of(UUID.randomUUID().toString());','java','String ID는 외부에서 값을 주입받아야 하므로 forNew()가 없고, isNew()도 불필요합니다.','[2, 4, 5, 6, 7, 10, 11, 12, 18]','MANUAL',NULL,'2026-01-20 15:04:52.000000','2026-01-20 15:04:52.000000',NULL),(18,81,'BAD','// ❌ BAD: RuntimeException 직접 상속\npublic class OrderNotFoundException extends RuntimeException {\n    public OrderNotFoundException(Long orderId) {\n        super(\"주문을 찾을 수 없습니다: \" + orderId);\n    }\n}\n\n// 사용 시 - ErrorCode 없음\nthrow new OrderNotFoundException(orderId);','java','RuntimeException을 직접 상속하면 공통 에러 처리 로직 적용이 어렵습니다.','[2]','MANUAL',NULL,'2026-01-20 15:04:52.000000','2026-01-20 15:04:52.000000',NULL),(19,81,'GOOD','// ✅ GOOD: ErrorCode + DomainException 구조\npublic enum OrderErrorCode implements ErrorCode {\n    NOT_FOUND(\"ORD-001\", 404, \"주문을 찾을 수 없습니다\"),\n    ALREADY_SHIPPED(\"ORD-002\", 400, \"이미 배송된 주문입니다\");\n\n    private final String code;\n    private final int httpStatus;\n    private final String message;\n\n    // constructor, getters...\n}\n\npublic class OrderNotFoundException extends DomainException {\n    public OrderNotFoundException(OrderId orderId) {\n        super(OrderErrorCode.NOT_FOUND,\n              String.format(\"주문 ID: %s\", orderId.value()),\n              Map.of(\"orderId\", orderId.value()));\n    }\n}\n\n// 사용 시\nthrow new OrderNotFoundException(orderId);','java','ErrorCode enum으로 에러 코드를 체계화하고, DomainException으로 공통 처리가 가능합니다.','[2, 3, 4, 13, 14, 15, 16, 17]','MANUAL',NULL,'2026-01-20 15:04:52.000000','2026-01-20 15:04:52.000000',NULL),(20,70,'GOOD','// ✅ GOOD: DomainEvent 구현 (Record)\npublic record OrderCreatedEvent(\n    OrderId orderId,\n    Long customerId,\n    BigDecimal totalAmount,\n    Instant occurredAt\n) implements DomainEvent {\n\n    // 정적 팩토리 메서드 - Application 레이어에서 시간 주입\n    public static OrderCreatedEvent from(Order order, Instant occurredAt) {\n        return new OrderCreatedEvent(\n            order.id(),\n            order.customerId(),\n            order.totalAmount(),\n            occurredAt\n        );\n    }\n}\n\n// Application 레이어에서 이벤트 생성\n@Service\n@Transactional\npublic class OrderCommandManager {\n    private final TimeProvider timeProvider;\n    \n    public void place(Order order) {\n        order.place();\n        OrderCreatedEvent event = OrderCreatedEvent.from(order, timeProvider.now());\n        eventRegistry.register(event);\n    }\n}','java','DomainEvent는 Record로 불변성을 보장하고, occurredAt으로 이벤트 발생 시각을 기록합니다.','[2, 3, 4, 5, 6, 7, 11, 12, 13, 22, 23, 24]','MANUAL',NULL,'2026-01-20 15:04:52.000000','2026-01-21 14:57:52.000000',NULL),(21,101,'GOOD','// ✅ GOOD: Cursor 기반 Criteria\npublic record OrderSliceCriteria(\n    Long customerId,\n    OrderStatus status,\n    DateRange orderDateRange,\n    CursorQueryContext<OrderSortKey, Long> queryContext  // 필수!\n) implements CursorSliceCriteria<OrderSortKey, Long> {\n\n    // 빌더 스타일 정적 팩토리\n    public static OrderSliceCriteria of(\n            Long customerId,\n            OrderStatus status,\n            CursorQueryContext<OrderSortKey, Long> queryContext) {\n        return new OrderSliceCriteria(customerId, status, null, queryContext);\n    }\n}\n\n// SortKey enum\npublic enum OrderSortKey implements SortKey {\n    ORDER_DATE(\"orderDate\"),\n    TOTAL_AMOUNT(\"totalAmount\");\n\n    private final String fieldName;\n\n    OrderSortKey(String fieldName) { this.fieldName = fieldName; }\n\n    @Override\n    public String fieldName() { return fieldName; }\n}','java','Criteria는 반드시 CursorQueryContext를 포함하고, SortKey enum으로 정렬 필드를 정의합니다.','[2, 3, 4, 5, 6, 7, 20, 21, 22, 27, 28]','MANUAL',NULL,'2026-01-20 15:04:53.000000','2026-01-20 15:04:53.000000',NULL),(24,115,'GOOD','@Service\npublic class CreateOrderService implements CreateOrderUseCase {\n    private final OrderCommandFacade orderCommandFacade;\n    \n    @Override\n    public Long execute(CreateOrderCommand command) {\n        return orderCommandFacade.createOrder(command);\n    }\n}','java','Service는 @Transactional 없이 Facade에 위임',NULL,NULL,NULL,'2026-01-21 05:31:07.000000','2026-01-21 05:31:07.000000',NULL),(25,115,'BAD','@Service\n@Transactional\npublic class CreateOrderService implements CreateOrderUseCase {\n    @Override\n    public Long execute(CreateOrderCommand command) {\n        // Service에 @Transactional 직접 선언\n    }\n}','java','Service에 @Transactional 직접 선언 - Manager에서 관리해야 함',NULL,NULL,NULL,'2026-01-21 05:31:07.000000','2026-01-21 05:31:07.000000',NULL),(26,116,'GOOD','@Component\npublic class OrderCommandManager {\n    private final OrderCommandPort orderCommandPort;\n\n    @Transactional\n    public Long create(Order order) {\n        return orderCommandPort.persist(order);\n    }\n\n    @Transactional\n    public void update(Order order) {\n        // Dirty Checking으로 자동 반영\n    }\n}','java','Manager는 @Component 사용, 메서드 단위로 @Transactional 선언',NULL,NULL,NULL,'2026-01-21 05:31:07.000000','2026-01-21 05:31:07.000000',NULL),(27,116,'BAD','@Component\npublic class OrderCommandManager {\n    // @Transactional 누락 - 트랜잭션 경계 미정의\n    public Long create(Order order) {\n        return orderCommandPort.persist(order);\n    }\n}','java','Manager 메서드에 @Transactional 누락 - 트랜잭션 경계 미정의',NULL,NULL,NULL,'2026-01-21 05:31:07.000000','2026-01-21 05:31:07.000000',NULL),(28,117,'GOOD','@Component\npublic class PaymentClientManager {\n    private final PaymentClientPort paymentClientPort;\n    \n    public PaymentResult process(PaymentRequest request) {\n        return paymentClientPort.execute(request);\n    }\n}','java','ClientManager는 @Transactional 없이 외부 호출만',NULL,NULL,NULL,'2026-01-21 05:31:19.000000','2026-01-21 05:31:19.000000',NULL),(29,117,'BAD','@Component\n@Transactional\npublic class PaymentClientManager {\n    public PaymentResult process(PaymentRequest request) {\n        return paymentClientPort.execute(request);\n    }\n}','java','ClientManager에 @Transactional - 외부 호출 시 트랜잭션 문제 발생 가능',NULL,NULL,NULL,'2026-01-21 05:31:19.000000','2026-01-21 05:31:19.000000',NULL),(30,118,'GOOD','@Service\npublic class OrderCommandFacade {\n    private final OrderCommandManager orderCommandManager;\n    private final InventoryCommandManager inventoryCommandManager;\n\n    @Transactional\n    public Long createOrder(CreateOrderCommand command) {\n        Long orderId = orderCommandManager.create(command);\n        inventoryCommandManager.decrease(command.items());\n        return orderId;\n    }\n\n    // 트랜잭션 불필요한 경우 @Transactional 없이\n    public void notifyOrderCreated(Long orderId) {\n        // 외부 알림 등\n    }\n}','java','CommandFacade는 메서드 단위로 필요 시에만 @Transactional 선언',NULL,NULL,NULL,'2026-01-21 05:31:19.000000','2026-01-21 05:31:19.000000',NULL),(31,118,'BAD','@Service\n@Transactional\npublic class OrderCommandFacade {\n    // 클래스 레벨 @Transactional - 불필요한 트랜잭션 범위 확대\n    public Long createOrder(CreateOrderCommand command) { ... }\n    public void notifyOrderCreated(Long orderId) { ... } // 트랜잭션 불필요한데 포함됨\n}','java','클래스 레벨 @Transactional은 불필요한 트랜잭션 범위 확대',NULL,NULL,NULL,'2026-01-21 05:31:19.000000','2026-01-21 05:31:19.000000',NULL),(32,119,'GOOD','@Service\npublic class OrderQueryFacade {\n    private final OrderQueryManager orderQueryManager;\n    private final CustomerQueryManager customerQueryManager;\n\n    @Transactional(readOnly = true)\n    public OrderDetailBundle getOrderDetail(Long orderId) {\n        Order order = orderQueryManager.findById(orderId);\n        Customer customer = customerQueryManager.findById(order.customerId());\n        return OrderDetailBundle.of(order, customer);\n    }\n}','java','QueryFacade는 메서드 단위로 @Transactional(readOnly=true) 선언',NULL,NULL,NULL,'2026-01-21 05:31:19.000000','2026-01-21 05:31:19.000000',NULL),(33,119,'BAD','@Service\n@Transactional(readOnly = true)\npublic class OrderQueryFacade {\n    // 클래스 레벨 선언 - 메서드 단위 제어 불가\n    public OrderDetailBundle getOrderDetail(Long orderId) { ... }\n}','java','클래스 레벨 @Transactional - 메서드별 세밀한 트랜잭션 제어 불가',NULL,NULL,NULL,'2026-01-21 05:31:19.000000','2026-01-21 05:31:19.000000',NULL),(34,120,'GOOD','@Service\npublic class CreateOrderService implements CreateOrderUseCase {\n    private final OrderCommandFacade orderCommandFacade;\n    \n    public Long execute(CreateOrderCommand command) {\n        return orderCommandFacade.createOrder(command);\n    }\n}','java','Service는 Facade 또는 Manager에 위임',NULL,NULL,NULL,'2026-01-21 05:31:35.000000','2026-01-21 05:31:35.000000',NULL),(35,120,'BAD','@Service\npublic class CreateOrderService implements CreateOrderUseCase {\n    private final OrderCommandPort orderCommandPort; // Port 직접 의존\n    \n    public Long execute(CreateOrderCommand command) {\n        return orderCommandPort.persist(order);\n    }\n}','java','Service에서 Port 직접 의존 금지 - Manager/Facade 통해 접근',NULL,NULL,NULL,'2026-01-21 05:31:35.000000','2026-01-21 05:31:35.000000',NULL),(36,121,'GOOD','@Service\npublic class OrderCommandFacade {\n    private final OrderCommandManager orderCommandManager;\n    private final InventoryCommandManager inventoryCommandManager;\n}','java','CommandFacade는 CommandManager들에 의존',NULL,NULL,NULL,'2026-01-21 05:31:35.000000','2026-01-21 05:31:35.000000',NULL),(37,121,'BAD','@Service\npublic class OrderCommandFacade {\n    private final OrderCommandPort orderCommandPort; // Port 직접 의존\n}','java','Facade에서 Port 직접 의존 금지 - Manager 통해 접근',NULL,NULL,NULL,'2026-01-21 05:31:35.000000','2026-01-21 05:31:35.000000',NULL),(38,122,'GOOD','@Service\npublic class OrderCommandFacade {\n    private final OrderCommandManager orderCommandManager;\n    // QueryManager 의존 없음 - CQRS 준수\n}','java','CommandFacade는 QueryManager에 의존하지 않음 - CQRS 준수',NULL,NULL,NULL,'2026-01-21 05:31:35.000000','2026-01-21 05:31:35.000000',NULL),(39,122,'BAD','@Service\npublic class OrderCommandFacade {\n    private final OrderCommandManager orderCommandManager;\n    private final OrderQueryManager orderQueryManager; // CQRS 위반\n    \n    public Long createOrder(CreateOrderCommand command) {\n        Order existing = orderQueryManager.findById(id); // 조회 혼합\n        return orderCommandManager.create(order);\n    }\n}','java','CommandFacade에서 QueryManager 의존 - CQRS 원칙 위반',NULL,NULL,NULL,'2026-01-21 05:31:35.000000','2026-01-21 05:31:35.000000',NULL),(40,123,'GOOD','@Component\npublic class OrderValidator {\n    private final OrderQueryManager orderQueryManager; // 같은 도메인만\n    \n    public void validateExists(OrderId orderId) {\n        if (!orderQueryManager.existsById(orderId)) {\n            throw new DomainException(OrderErrorCode.NOT_FOUND);\n        }\n    }\n}','java','Validator는 같은 도메인의 QueryManager만 의존',NULL,NULL,NULL,'2026-01-21 05:31:35.000000','2026-01-21 05:31:35.000000',NULL),(41,123,'BAD','@Component\npublic class OrderValidator {\n    private final OrderQueryManager orderQueryManager;\n    private final CustomerQueryManager customerQueryManager; // 다른 도메인\n}','java','Validator에서 다른 도메인 Manager 의존 - 단일 도메인 원칙 위반',NULL,NULL,NULL,'2026-01-21 05:31:35.000000','2026-01-21 05:31:35.000000',NULL),(42,124,'GOOD','@Component\nclass PriceCalculator { // internal 패키지\n    private final ProductQueryManager productQueryManager;\n    \n    BigDecimal calculate(List<Long> productIds) {\n        return productQueryManager.findPrices(productIds)\n            .stream()\n            .reduce(BigDecimal.ZERO, BigDecimal::add);\n    }\n}','java','Internal 컴포넌트는 Manager를 통해 데이터 접근',NULL,NULL,NULL,'2026-01-21 05:31:51.000000','2026-01-21 05:31:51.000000',NULL),(43,124,'BAD','@Component\nclass PriceCalculator {\n    private final ProductQueryPort productQueryPort; // Port 직접 의존\n}','java','Internal 컴포넌트에서 Port 직접 의존 금지',NULL,NULL,NULL,'2026-01-21 05:31:51.000000','2026-01-21 05:31:51.000000',NULL),(44,125,'GOOD','public record CreateOrderCommand(\n    Long customerId,\n    List<OrderLineCommand> lines,\n    String memo\n) {}','java','Command/Query DTO는 record로 정의',NULL,NULL,NULL,'2026-01-21 05:31:51.000000','2026-01-21 05:31:51.000000',NULL),(45,125,'BAD','@Data\npublic class CreateOrderCommand {\n    private Long customerId;\n    private List<OrderLineCommand> lines;\n}','java','Command/Query에 클래스 + Lombok 사용 금지 - record 필수',NULL,NULL,NULL,'2026-01-21 05:31:51.000000','2026-01-21 05:31:51.000000',NULL),(46,126,'GOOD','public record CreateOrderCommand(\n    Long customerId,\n    List<OrderLineCommand> lines\n) {\n    // 정적 팩토리만 허용\n    public static CreateOrderCommand of(Long customerId) {\n        return new CreateOrderCommand(customerId, List.of());\n    }\n}','java','Command/Query에는 정적 팩토리만 허용',NULL,NULL,NULL,'2026-01-21 05:31:51.000000','2026-01-21 05:31:51.000000',NULL),(47,126,'BAD','public record CreateOrderCommand(\n    Long customerId,\n    List<OrderLineCommand> lines\n) {\n    public int getTotalLineCount() { // 인스턴스 메서드 금지\n        return lines.size();\n    }\n}','java','Command/Query에 인스턴스 메서드 금지 - 행위 없는 데이터 전달자',NULL,NULL,NULL,'2026-01-21 05:31:51.000000','2026-01-21 05:31:51.000000',NULL),(48,127,'GOOD','public record OrderSearchQuery(\n    String keyword,\n    OrderStatus status,\n    CommonSearchParams searchParams\n) {}','java','검색 Query는 CommonSearchParams 포함',NULL,NULL,NULL,'2026-01-21 05:31:51.000000','2026-01-21 05:31:51.000000',NULL),(49,127,'BAD','public record OrderSearchQuery(\n    String keyword,\n    OrderStatus status,\n    int page,     // 직접 정의 금지\n    int size\n) {}','java','페이징 파라미터 직접 정의 금지 - CommonSearchParams 사용',NULL,NULL,NULL,'2026-01-21 05:31:51.000000','2026-01-21 05:31:51.000000',NULL),(50,128,'GOOD','public record OrderListQuery(\n    OrderStatus status,\n    CommonCursorParams cursorParams\n) {}','java','커서 기반 조회는 CommonCursorParams 포함',NULL,NULL,NULL,'2026-01-21 05:31:51.000000','2026-01-21 05:31:51.000000',NULL),(51,128,'BAD','public record OrderListQuery(\n    OrderStatus status,\n    Long cursor,  // 직접 정의 금지\n    int size\n) {}','java','커서 파라미터 직접 정의 금지 - CommonCursorParams 사용',NULL,NULL,NULL,'2026-01-21 05:31:51.000000','2026-01-21 05:31:51.000000',NULL),(52,129,'GOOD','public record OrderBundle(\n    Order order,\n    List<OrderLine> lines,\n    Customer customer\n) {\n    public OrderBundle withId(Long orderId) {\n        return new OrderBundle(\n            order.withId(orderId),\n            lines,\n            customer\n        );\n    }\n}','java','Bundle은 withId() 패턴으로 ID 설정',NULL,NULL,NULL,'2026-01-21 05:32:07.000000','2026-01-21 05:32:07.000000',NULL),(53,129,'BAD','public record OrderBundle(\n    Order order,\n    List<OrderLine> lines\n) {\n    public void setOrderId(Long id) { // setter 금지\n        // record는 immutable\n    }\n}','java','Bundle에 setter 패턴 금지 - withId() 사용',NULL,NULL,NULL,'2026-01-21 05:32:07.000000','2026-01-21 05:32:07.000000',NULL),(54,130,'GOOD','public interface OrderCommandPort {\n    Long persist(Order order);\n    List<Long> persistAll(List<Order> orders);\n}','java','CommandPort는 persist/persistAll 메서드만 제공',NULL,NULL,NULL,'2026-01-21 05:32:07.000000','2026-01-21 05:32:07.000000',NULL),(55,130,'BAD','public interface OrderCommandPort {\n    Long save(Order order);      // persist 사용\n    void update(Order order);    // persist가 처리\n    void delete(Long id);        // persist가 처리 (soft delete)\n}','java','save/update/delete 개별 메서드 금지 - persist로 통합',NULL,NULL,NULL,'2026-01-21 05:32:07.000000','2026-01-21 05:32:07.000000',NULL),(56,131,'GOOD','public interface OrderQueryPort {\n    Optional<Order> findById(OrderId id);\n    List<Order> findBySliceCriteria(OrderSliceCriteria criteria);\n    boolean existsById(OrderId id);\n}','java','QueryPort는 조건 기반 조회만 제공, findAll 금지',NULL,NULL,NULL,'2026-01-21 05:32:07.000000','2026-01-21 05:32:07.000000',NULL),(57,131,'BAD','public interface OrderQueryPort {\n    List<Order> findAll(); // OOM 위험\n}','java','findAll 금지 - 대량 데이터로 OOM 발생 가능',NULL,NULL,NULL,'2026-01-21 05:32:07.000000','2026-01-21 05:32:07.000000',NULL),(58,132,'GOOD','public interface OrderQueryPort {\n    Optional<Order> findById(OrderId id);\n    List<Order> findByCustomerId(CustomerId customerId);\n    boolean existsByOrderNumber(String orderNumber);\n    long countByStatus(OrderStatus status);\n}','java','QueryPort 메서드명: findBy*, existsBy*, countBy*',NULL,NULL,NULL,'2026-01-21 05:32:07.000000','2026-01-21 05:32:07.000000',NULL),(59,132,'BAD','public interface OrderQueryPort {\n    Order getById(Long id);           // get 대신 find 사용\n    List<Order> selectByCustomer(Long customerId); // select 금지\n    boolean hasOrder(Long id);        // exists 패턴 사용\n}','java','get/select/has 대신 find/exists/count 패턴 사용',NULL,NULL,NULL,'2026-01-21 05:32:07.000000','2026-01-21 05:32:07.000000',NULL),(60,133,'GOOD','@Component\npublic class OrderCommandManager {\n    private final TransactionEventRegistry eventRegistry;\n    \n    public Long create(Order order) {\n        Long id = orderCommandPort.persist(order);\n        eventRegistry.register(new OrderCreatedEvent(id));\n        return id;\n    }\n}','java','TransactionEventRegistry를 통해 이벤트 등록',NULL,NULL,NULL,'2026-01-21 05:32:25.000000','2026-01-21 05:32:25.000000',NULL),(61,133,'BAD','@Component\npublic class OrderCommandManager {\n    private final ApplicationEventPublisher eventPublisher; // 직접 주입 금지\n    \n    public Long create(Order order) {\n        Long id = orderCommandPort.persist(order);\n        eventPublisher.publishEvent(new OrderCreatedEvent(id));\n        return id;\n    }\n}','java','ApplicationEventPublisher 직접 주입 금지 - 트랜잭션 타이밍 문제',NULL,NULL,NULL,'2026-01-21 05:32:25.000000','2026-01-21 05:32:25.000000',NULL),(62,134,'GOOD','@Component\npublic class PaymentCommandManager {\n    private final TransactionEventRegistry eventRegistry;\n    \n    public void complete(Payment payment) {\n        paymentCommandPort.persist(payment);\n        eventRegistry.register(new PaymentCompletedEvent(\n            payment.getId(),\n            payment.getAmount()\n        ));\n    }\n}','java','TransactionEventRegistry로 커밋 후 이벤트 발행 보장',NULL,NULL,NULL,'2026-01-21 05:32:25.000000','2026-01-21 05:32:25.000000',NULL),(63,134,'BAD','@Component\npublic class PaymentCommandManager {\n    public void complete(Payment payment) {\n        paymentCommandPort.persist(payment);\n        // 이벤트 발행 누락 또는 잘못된 시점\n    }\n}','java','이벤트 발행 누락 - TransactionEventRegistry 사용 필수',NULL,NULL,NULL,'2026-01-21 05:32:25.000000','2026-01-21 05:32:25.000000',NULL),(64,135,'GOOD','@Component\npublic class OrderFactory {\n    private final TimeProvider timeProvider;\n    \n    public Order create(CreateOrderCommand command) {\n        return Order.create(\n            command.customerId(),\n            command.lines(),\n            timeProvider.now()\n        );\n    }\n}','java','TimeProvider는 Factory에서만 사용',NULL,NULL,NULL,'2026-01-21 05:32:25.000000','2026-01-21 05:32:25.000000',NULL),(65,135,'BAD','@Component\npublic class OrderCommandManager {\n    private final TimeProvider timeProvider; // Manager에서 사용 금지\n    \n    public Long create(CreateOrderCommand command) {\n        Instant now = timeProvider.now();\n        Order order = Order.create(command, now);\n        return orderCommandPort.persist(order);\n    }\n}','java','Manager에서 TimeProvider 직접 사용 금지 - Factory에 위임',NULL,NULL,NULL,'2026-01-21 05:32:25.000000','2026-01-21 05:32:25.000000',NULL),(66,136,'GOOD','@Component\npublic class OrderFactory {\n    private final TimeProvider timeProvider;\n    private final IdGenerator idGenerator;\n    \n    public Order create(CreateOrderCommand command) {\n        return Order.builder()\n            .id(idGenerator.generate())\n            .customerId(command.customerId())\n            .createdAt(timeProvider.now())\n            .build();\n    }\n}','java','Factory는 외부 의존성 주입이 필요한 생성 로직에 사용',NULL,NULL,NULL,'2026-01-21 05:32:25.000000','2026-01-21 05:32:25.000000',NULL),(67,136,'BAD','@Component\npublic class OrderFactory {\n    // 단순 매핑만 하는 Factory는 불필요\n    public Order create(CreateOrderCommand command) {\n        return new Order(command.customerId());\n    }\n}','java','단순 매핑만 하는 Factory는 불필요 - 도메인 생성자 직접 사용',NULL,NULL,NULL,'2026-01-21 05:32:25.000000','2026-01-21 05:32:25.000000',NULL),(68,137,'GOOD','@Component\npublic class OrderValidator {\n    private final OrderQueryManager orderQueryManager;\n    \n    public Order validateAndGet(OrderId orderId) {\n        return orderQueryManager.findById(orderId)\n            .orElseThrow(() -> new DomainException(\n                OrderErrorCode.NOT_FOUND, orderId));\n    }\n}','java','Validator는 검증 후 도메인 객체 반환',NULL,NULL,NULL,'2026-01-21 05:32:43.000000','2026-01-21 05:32:43.000000',NULL),(69,137,'BAD','@Component\npublic class OrderValidator {\n    public void validate(OrderId orderId) {\n        // void 반환 - 조회 중복 발생\n        if (!orderQueryManager.existsById(orderId)) {\n            throw new DomainException(OrderErrorCode.NOT_FOUND);\n        }\n    }\n    // 호출 측에서 다시 조회해야 함\n}','java','void 반환 시 조회 중복 - 검증 후 도메인 반환 권장',NULL,NULL,NULL,'2026-01-21 05:32:43.000000','2026-01-21 05:32:43.000000',NULL),(70,138,'GOOD','@Component\npublic class OrderValidator {\n    public Order validateAndGet(OrderId orderId) {\n        return orderQueryManager.findById(orderId)\n            .orElseThrow(() -> new DomainException(\n                OrderErrorCode.NOT_FOUND, orderId));\n    }\n}','java','Validator는 DomainException(ErrorCode, id) 형태로 예외 발생',NULL,NULL,NULL,'2026-01-21 05:32:43.000000','2026-01-21 05:32:43.000000',NULL),(71,138,'BAD','@Component\npublic class OrderValidator {\n    public Order validateAndGet(OrderId orderId) {\n        return orderQueryManager.findById(orderId)\n            .orElseThrow(() -> new IllegalArgumentException(\n                \"Order not found: \" + orderId)); // 범용 예외 금지\n    }\n}','java','범용 예외 금지 - DomainException + ErrorCode 사용',NULL,NULL,NULL,'2026-01-21 05:32:43.000000','2026-01-21 05:32:43.000000',NULL),(72,139,'GOOD','@Component\npublic class OrderAssembler {\n    public OrderResponse toResponse(Order order) {\n        return new OrderResponse(\n            order.getId().value(),\n            order.getStatus().name(),\n            order.getTotalAmount()\n        );\n    }\n}','java','Assembler는 도메인별 구체적인 Response 클래스 반환',NULL,NULL,NULL,'2026-01-21 05:32:43.000000','2026-01-21 05:32:43.000000',NULL),(73,139,'BAD','@Component\npublic class OrderAssembler {\n    public Map<String, Object> toResponse(Order order) {\n        // Map 반환 금지 - 타입 안정성 없음\n        return Map.of(\n            \"id\", order.getId(),\n            \"status\", order.getStatus()\n        );\n    }\n}','java','Map 반환 금지 - 구체적인 Response 클래스 사용',NULL,NULL,NULL,'2026-01-21 05:32:43.000000','2026-01-21 05:32:43.000000',NULL),(74,140,'GOOD','@Service\npublic class CreateOrderService implements CreateOrderUseCase {\n    @Override\n    public Long execute(CreateOrderCommand command) {\n        // 생성 결과는 원시타입 ID 반환\n        return orderCommandFacade.createOrder(command);\n    }\n}','java','생성 UseCase는 원시타입 ID(Long) 반환',NULL,NULL,NULL,'2026-01-21 05:32:43.000000','2026-01-21 05:32:43.000000',NULL),(75,140,'BAD','@Service\npublic class CreateOrderService implements CreateOrderUseCase {\n    @Override\n    public OrderResponse execute(CreateOrderCommand command) {\n        // 생성 시 Response 반환 불필요\n        Long id = orderCommandFacade.createOrder(command);\n        return orderQueryFacade.getOrder(id); // 불필요한 조회\n    }\n}','java','생성 후 Response 반환 불필요 - ID만 반환',NULL,NULL,NULL,'2026-01-21 05:32:43.000000','2026-01-21 05:32:43.000000',NULL),(76,141,'GOOD','public interface CreateOrderUseCase {\n    Long execute(CreateOrderCommand command);\n}\n\n@Service\npublic class CreateOrderService implements CreateOrderUseCase {\n    @Override\n    public Long execute(CreateOrderCommand command) {\n        return orderCommandFacade.createOrder(command);\n    }\n}','java','UseCase 인터페이스당 하나의 Service 구현체',NULL,NULL,NULL,'2026-01-21 05:33:00.000000','2026-01-21 05:33:00.000000',NULL),(77,141,'BAD','@Service\npublic class OrderService implements CreateOrderUseCase, UpdateOrderUseCase, DeleteOrderUseCase {\n    // 여러 UseCase를 하나의 Service에서 구현 금지\n    @Override\n    public Long execute(CreateOrderCommand command) { ... }\n    \n    @Override\n    public void execute(UpdateOrderCommand command) { ... }\n}','java','하나의 Service에서 여러 UseCase 구현 금지',NULL,NULL,NULL,'2026-01-21 05:33:00.000000','2026-01-21 05:33:00.000000',NULL),(78,142,'GOOD','// Command UseCase\npublic interface CreateOrderUseCase { }\npublic interface UpdateOrderStatusUseCase { }\npublic interface CancelOrderUseCase { }\n\n// Query UseCase\npublic interface GetOrderUseCase { }\npublic interface SearchOrdersUseCase { }\npublic interface ListOrdersByCustomerUseCase { }','java','Command: Create/Update/Delete/Cancel, Query: Get/Search/List',NULL,NULL,NULL,'2026-01-21 05:33:00.000000','2026-01-21 05:33:00.000000',NULL),(79,142,'BAD','public interface OrderCreationUseCase { }  // Create 동사형 사용\npublic interface FetchOrderUseCase { }      // Get 사용\npublic interface FindOrdersUseCase { }      // Search/List 사용','java','네이밍 규칙 위반 - 동사형 + 도메인 + UseCase',NULL,NULL,NULL,'2026-01-21 05:33:00.000000','2026-01-21 05:33:00.000000',NULL),(80,143,'GOOD','@Component\npublic class OrderCommandManager {\n    public void cancel(Order order) {\n        if (!order.isCancellable()) {\n            throw new DomainException(\n                OrderErrorCode.CANNOT_CANCEL,\n                order.getId()\n            );\n        }\n        order.cancel();\n    }\n}','java','DomainException + 도메인별 ErrorCode 사용',NULL,NULL,NULL,'2026-01-21 05:33:00.000000','2026-01-21 05:33:00.000000',NULL),(81,143,'BAD','@Component\npublic class OrderCommandManager {\n    public void cancel(Order order) {\n        if (!order.isCancellable()) {\n            throw new IllegalStateException(\"Cannot cancel order\");\n            // 또는\n            throw new RuntimeException(\"Order cancellation failed\");\n        }\n    }\n}','java','범용 예외 사용 금지 - DomainException 사용',NULL,NULL,NULL,'2026-01-21 05:33:00.000000','2026-01-21 05:33:00.000000',NULL),(82,144,'GOOD','// Order 도메인의 ErrorCode\npublic enum OrderErrorCode implements ErrorCode {\n    NOT_FOUND(\"ORDER_001\", \"주문을 찾을 수 없습니다\"),\n    CANNOT_CANCEL(\"ORDER_002\", \"취소할 수 없는 주문입니다\");\n}\n\n// 사용\nthrow new DomainException(OrderErrorCode.NOT_FOUND, orderId);','java','도메인별 ErrorCode enum 정의 후 DomainException에 전달',NULL,NULL,NULL,'2026-01-21 05:33:00.000000','2026-01-21 05:33:00.000000',NULL),(83,144,'BAD','throw new DomainException(\"ORDER_001\", \"주문을 찾을 수 없습니다\");\n// 또는\nthrow new DomainException(\"Order not found: \" + orderId);','java','문자열 직접 전달 금지 - ErrorCode enum 사용',NULL,NULL,NULL,'2026-01-21 05:33:00.000000','2026-01-21 05:33:00.000000',NULL),(84,145,'GOOD','@Component\npublic class OrderCreatedEventListener {\n\n    @Async\n    @EventListener\n    public void handle(OrderCreatedEvent event) {\n        // 비동기 처리\n        notificationManager.sendOrderConfirmation(event.getOrderId());\n    }\n}','java','EventListener는 @Async로 비동기 처리 권장',NULL,NULL,NULL,'2026-01-21 05:40:00.000000','2026-01-21 05:40:00.000000',NULL),(85,145,'BAD','@Component\npublic class OrderCreatedEventListener {\n\n    @EventListener\n    public void handle(OrderCreatedEvent event) {\n        // 동기 처리 - 발행자 트랜잭션에 영향\n        notificationManager.sendOrderConfirmation(event.getOrderId());\n    }\n}','java','동기 처리 시 이벤트 발행자의 트랜잭션에 영향을 줄 수 있음',NULL,NULL,NULL,'2026-01-21 05:40:00.000000','2026-01-21 05:40:00.000000',NULL),(86,146,'GOOD','@Component\npublic class OrderCreatedEventListener {\n    private final NotificationCommandManager notificationManager;\n    \n    @Async\n    @EventListener\n    public void handle(OrderCreatedEvent event) {\n        notificationManager.sendOrderConfirmation(event.getOrderId());\n    }\n}','java','EventListener는 Manager에 의존',NULL,NULL,NULL,'2026-01-21 05:40:00.000000','2026-01-21 05:40:00.000000',NULL),(87,146,'BAD','@Component\npublic class OrderCreatedEventListener {\n    private final NotificationCommandPort notificationPort; // Port 직접 의존 금지\n    \n    @EventListener\n    public void handle(OrderCreatedEvent event) {\n        notificationPort.persist(notification);\n    }\n}','java','EventListener에서 Port 직접 의존 금지 - Manager 통해 접근',NULL,NULL,NULL,'2026-01-21 05:40:00.000000','2026-01-21 05:40:00.000000',NULL),(88,147,'BAD','public interface OrderJpaRepository extends JpaRepository<OrderJpaEntity, Long> {\n    List<OrderJpaEntity> findByCustomerId(Long customerId);\n    Optional<OrderJpaEntity> findByOrderNumber(String orderNumber);\n    void deleteByOrderId(Long orderId);\n}','java','JpaRepository에서 조회/삭제 메서드를 정의하면 CQRS 원칙을 위반합니다.',NULL,NULL,NULL,'2026-01-21 07:49:46.000000','2026-01-21 07:49:46.000000',NULL),(89,147,'GOOD','public interface OrderJpaRepository extends JpaRepository<OrderJpaEntity, Long> {\n    // save, saveAll만 사용 - JpaRepository 기본 제공 메서드만 활용\n    // 조회는 QueryDslRepository에서, 삭제는 soft delete로\n}','java','JpaRepository는 저장만 담당하고, 조회는 QueryDslRepository로 분리합니다.',NULL,NULL,NULL,'2026-01-21 07:49:46.000000','2026-01-21 07:49:46.000000',NULL),(90,148,'BAD','@Repository\npublic interface UserJpaRepository extends JpaRepository<UserJpaEntity, Long> {\n    \n    @Query(\"SELECT u FROM UserJpaEntity u WHERE u.email = :email\")\n    Optional<UserJpaEntity> findByEmail(@Param(\"email\") String email);\n    \n    boolean existsByEmail(String email);\n    \n    @Modifying\n    @Query(\"DELETE FROM UserJpaEntity u WHERE u.id = :id\")\n    void deleteById(@Param(\"id\") Long id);\n}','java','@Query, 쿼리 메서드 정의 등 커스텀 메서드를 추가하면 안됩니다.',NULL,NULL,NULL,'2026-01-21 07:49:46.000000','2026-01-21 07:49:46.000000',NULL),(91,148,'GOOD','@Repository\npublic interface UserJpaRepository extends JpaRepository<UserJpaEntity, Long> {\n    // 커스텀 메서드 추가 금지\n    // JpaRepository 기본 제공: save, saveAll, findById, existsById 등만 사용\n}\n\n// 모든 조회 로직은 QueryDslRepository에서\n@Repository\npublic class UserQueryDslRepository {\n    public Optional<UserJpaEntity> findByEmail(String email) { ... }\n    public boolean existsByEmail(String email) { ... }\n}','java','커스텀 조회 로직은 QueryDslRepository로 일원화합니다.',NULL,NULL,NULL,'2026-01-21 07:49:46.000000','2026-01-21 07:49:46.000000',NULL),(92,149,'BAD','@Query(\"SELECT o FROM OrderJpaEntity o WHERE o.status = :status\")\nList<OrderJpaEntity> findByStatus(@Param(\"status\") String status);\n\n@Query(value = \"SELECT * FROM orders WHERE created_at > :date\", nativeQuery = true)\nList<OrderJpaEntity> findRecentOrders(@Param(\"date\") LocalDateTime date);','java','JPQL이나 Native Query 대신 QueryDSL을 사용합니다.',NULL,NULL,NULL,'2026-01-21 07:49:46.000000','2026-01-21 07:49:46.000000',NULL),(93,149,'GOOD','@Repository\npublic class OrderQueryDslRepository {\n    private final JPAQueryFactory queryFactory;\n    \n    public OrderQueryDslRepository(JPAQueryFactory queryFactory) {\n        this.queryFactory = queryFactory;\n    }\n    \n    public List<OrderJpaEntity> findByStatus(OrderStatus status) {\n        return queryFactory\n            .selectFrom(orderJpaEntity)\n            .where(OrderConditionBuilder.statusEq(status))\n            .fetch();\n    }\n    \n    public List<OrderJpaEntity> findRecentOrders(Instant fromDate) {\n        return queryFactory\n            .selectFrom(orderJpaEntity)\n            .where(orderJpaEntity.createdAt.after(fromDate))\n            .fetch();\n    }\n}','java','QueryDSL로 타입 안전한 쿼리를 작성합니다.',NULL,NULL,NULL,'2026-01-21 07:49:46.000000','2026-01-21 14:55:26.000000',NULL),(94,150,'BAD','@Component\npublic class OrderCommandAdapter implements OrderCommandPort {\n    private final OrderJpaRepository jpaRepository;\n    private final OrderQueryDslRepository queryDslRepository; // 금지!\n    \n    @Override\n    public Long persist(Order order) {\n        // QueryDslRepository 사용 금지!\n        if (queryDslRepository.existsByOrderNumber(order.getNumber())) {\n            throw new DomainException(...);\n        }\n        return jpaRepository.save(mapper.toEntity(order)).getId();\n    }\n}','java','CommandAdapter에서 QueryDslRepository를 의존하면 CQRS 원칙을 위반합니다.',NULL,NULL,NULL,'2026-01-21 07:50:06.000000','2026-01-21 07:50:06.000000',NULL),(95,150,'GOOD','@Component\npublic class OrderCommandAdapter implements OrderCommandPort {\n    private final OrderJpaRepository jpaRepository;\n    private final OrderEntityMapper mapper;\n    \n    @Override\n    public Long persist(Order order) {\n        OrderJpaEntity entity = mapper.toEntity(order);\n        return jpaRepository.save(entity).getId();\n    }\n}','java','CommandAdapter는 JpaRepository만 의존하여 저장 로직만 수행합니다.',NULL,NULL,NULL,'2026-01-21 07:50:06.000000','2026-01-21 07:50:06.000000',NULL),(96,151,'BAD','@Component\npublic class OrderQueryAdapter implements OrderQueryPort {\n    private final OrderJpaRepository jpaRepository; // 금지!\n    private final OrderQueryDslRepository queryDslRepository;\n    \n    @Override\n    public Optional<Order> findById(OrderId id) {\n        return jpaRepository.findById(id.value()) // JpaRepository 사용 금지!\n            .map(mapper::toDomain);\n    }\n}','java','QueryAdapter에서 JpaRepository를 의존하면 CQRS 원칙을 위반합니다.',NULL,NULL,NULL,'2026-01-21 07:50:06.000000','2026-01-21 07:50:06.000000',NULL),(97,151,'GOOD','@Component\npublic class OrderQueryAdapter implements OrderQueryPort {\n    private final OrderQueryDslRepository queryDslRepository;\n    private final OrderEntityMapper mapper;\n    \n    @Override\n    public Optional<Order> findById(OrderId id) {\n        return queryDslRepository.findById(id.value())\n            .map(mapper::toDomain);\n    }\n    \n    @Override\n    public List<Order> findByCustomerId(CustomerId customerId) {\n        return queryDslRepository.findByCustomerId(customerId.value())\n            .stream()\n            .map(mapper::toDomain)\n            .toList();\n    }\n}','java','QueryAdapter는 QueryDslRepository만 의존하여 조회 로직만 수행합니다.',NULL,NULL,NULL,'2026-01-21 07:50:06.000000','2026-01-21 07:50:06.000000',NULL),(98,152,'BAD','@Entity\n@Table(name = \"orders\")\npublic class OrderJpaEntity {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = \"customer_id\")\n    private CustomerJpaEntity customer; // 관계 어노테이션 금지!\n    \n    @OneToMany(mappedBy = \"order\", cascade = CascadeType.ALL)\n    private List<OrderLineJpaEntity> orderLines; // 관계 어노테이션 금지!\n}','java','JPA 관계 어노테이션은 N+1 문제와 도메인 결합을 유발합니다.',NULL,NULL,NULL,'2026-01-21 07:50:06.000000','2026-01-21 07:50:06.000000',NULL),(99,152,'GOOD','@Entity\n@Table(name = \"orders\")\npublic class OrderJpaEntity extends SoftDeletableEntity {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    @Column(name = \"customer_id\", nullable = false)\n    private Long customerId;  // Long FK 전략\n    \n    // OrderLine은 별도 Repository에서 customerId로 조회\n    // 필요시 QueryDSL join으로 명시적 조회\n}','java','Long FK 전략으로 관계를 관리하고, 필요시 QueryDSL join을 사용합니다.',NULL,NULL,NULL,'2026-01-21 07:50:06.000000','2026-01-21 07:50:06.000000',NULL),(100,153,'BAD','@Entity\n@Table(name = \"orders\")\npublic class OrderJpaEntity {\n    @Id\n    private Long id;\n    \n    @Column(name = \"created_at\")\n    private Instant createdAt; // 직접 정의 금지\n    \n    @Column(name = \"updated_at\")\n    private Instant updatedAt; // 직접 정의 금지\n}','java','Audit 필드를 직접 정의하면 코드 중복과 불일치가 발생합니다.',NULL,NULL,NULL,'2026-01-21 07:50:06.000000','2026-01-21 07:50:06.000000',NULL),(101,153,'GOOD','@Entity\n@Table(name = \"orders\")\npublic class OrderJpaEntity extends SoftDeletableEntity {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    @Column(name = \"customer_id\", nullable = false)\n    private Long customerId;\n    \n    // createdAt, updatedAt, deletedAt은 SoftDeletableEntity에서 상속\n}','java','BaseAuditEntity나 SoftDeletableEntity를 상속하여 Audit 필드를 표준화합니다.',NULL,NULL,NULL,'2026-01-21 07:50:06.000000','2026-01-21 07:50:06.000000',NULL),(102,154,'BAD','spring:\n  jpa:\n    open-in-view: true  # 기본값이지만 명시적 활성화도 금지','yaml','OSIV 활성화는 커넥션 점유 시간을 늘리고 예측 불가능한 지연 로딩을 유발합니다.',NULL,NULL,NULL,'2026-01-21 07:50:28.000000','2026-01-21 07:50:28.000000',NULL),(103,154,'GOOD','spring:\n  jpa:\n    open-in-view: false\n    \n# Lazy Loading은 반드시 @Transactional 범위 내에서만 수행\n# View 렌더링 시점의 지연 로딩은 LazyInitializationException 발생','yaml','OSIV를 비활성화하여 트랜잭션 범위를 명확히 합니다.',NULL,NULL,NULL,'2026-01-21 07:50:28.000000','2026-01-21 07:50:28.000000',NULL),(104,155,'BAD','spring:\n  jpa:\n    hibernate:\n      ddl-auto: update  # 운영 장애 원인!\n      # 또는 create, create-drop','yaml','ddl-auto가 update/create면 운영 환경에서 예기치 않은 스키마 변경이 발생합니다.',NULL,NULL,NULL,'2026-01-21 07:50:28.000000','2026-01-21 07:50:28.000000',NULL),(105,155,'GOOD','spring:\n  jpa:\n    hibernate:\n      ddl-auto: validate  # 스키마 검증만\n      \n  flyway:\n    enabled: true\n    locations: classpath:db/migration\n    baseline-on-migrate: true','yaml','Hibernate는 검증만, 스키마 변경은 Flyway로 관리합니다.',NULL,NULL,NULL,'2026-01-21 07:50:28.000000','2026-01-21 07:50:28.000000',NULL),(106,156,'BAD','@Repository\npublic class OrderQueryDslRepository {\n    \n    // Repository 내부에 조건 메서드 정의 - 금지!\n    private BooleanExpression statusEq(OrderStatus status) {\n        return status != null ? order.status.eq(status) : null;\n    }\n    \n    private BooleanExpression customerIdEq(Long customerId) {\n        return customerId != null ? order.customerId.eq(customerId) : null;\n    }\n    \n    public List<OrderJpaEntity> findByCondition(OrderStatus status, Long customerId) {\n        return queryFactory.selectFrom(order)\n            .where(statusEq(status), customerIdEq(customerId))\n            .fetch();\n    }\n}','java','Repository 내부에 조건 메서드를 정의하면 재사용이 어렵고 코드가 비대해집니다.',NULL,NULL,NULL,'2026-01-21 07:50:28.000000','2026-01-21 07:50:28.000000',NULL),(107,156,'GOOD','// ConditionBuilder로 분리\npublic class OrderConditionBuilder {\n    private static final QOrderJpaEntity order = QOrderJpaEntity.orderJpaEntity;\n    \n    public static BooleanExpression notDeleted() {\n        return order.deletedAt.isNull();\n    }\n    \n    public static BooleanExpression statusEq(OrderStatus status) {\n        return status != null ? order.status.eq(status) : null;\n    }\n    \n    public static BooleanExpression customerIdEq(Long customerId) {\n        return customerId != null ? order.customerId.eq(customerId) : null;\n    }\n}\n\n// Repository에서 사용\npublic List<OrderJpaEntity> findByCondition(OrderStatus status, Long customerId) {\n    return queryFactory.selectFrom(order)\n        .where(\n            OrderConditionBuilder.notDeleted(),\n            OrderConditionBuilder.statusEq(status),\n            OrderConditionBuilder.customerIdEq(customerId)\n        )\n        .fetch();\n}','java','ConditionBuilder로 분리하여 조건 로직을 재사용하고 가독성을 높입니다.',NULL,NULL,NULL,'2026-01-21 07:50:28.000000','2026-01-21 07:50:28.000000',NULL),(108,157,'BAD','public List<OrderJpaEntity> findByCustomerId(Long customerId) {\n    return queryFactory\n        .selectFrom(order)\n        .where(order.customerId.eq(customerId))\n        .fetch();  // deletedAt 조건 누락 - 삭제된 데이터도 조회됨!\n}','java','deletedAt 조건이 누락되면 soft delete된 데이터가 조회됩니다.',NULL,NULL,NULL,'2026-01-21 07:50:28.000000','2026-01-21 07:50:28.000000',NULL),(109,157,'GOOD','public List<OrderJpaEntity> findByCustomerId(Long customerId) {\n    return queryFactory\n        .selectFrom(order)\n        .where(\n            OrderConditionBuilder.notDeleted(),  // deletedAt IS NULL 필수!\n            OrderConditionBuilder.customerIdEq(customerId)\n        )\n        .fetch();\n}','java','Soft Delete 테이블은 반드시 notDeleted() 조건을 포함합니다.',NULL,NULL,NULL,'2026-01-21 07:50:28.000000','2026-01-21 07:50:28.000000',NULL),(110,158,'BAD','@Component\npublic class OrderEntityMapper {\n    \n    public Order toDomain(OrderJpaEntity entity) {\n        return Order.reconstitute(\n            new OrderId(entity.getId()),\n            new CustomerId(entity.getCustomerId()),\n            OrderStatus.valueOf(entity.getStatus())\n        );\n    }\n    \n    // toEntity 메서드 누락!\n}','java','단방향 매핑만 있으면 저장 시 변환이 불가능합니다.',NULL,NULL,NULL,'2026-01-21 07:50:44.000000','2026-01-21 07:50:44.000000',NULL),(111,158,'GOOD','@Component\npublic class OrderEntityMapper {\n    \n    public Order toDomain(OrderJpaEntity entity) {\n        return Order.reconstitute(\n            new OrderId(entity.getId()),\n            new CustomerId(entity.getCustomerId()),\n            OrderStatus.valueOf(entity.getStatus()),\n            entity.getCreatedAt()\n        );\n    }\n    \n    public OrderJpaEntity toEntity(Order domain) {\n        OrderJpaEntity entity = new OrderJpaEntity();\n        if (domain.getId() != null) {\n            entity.setId(domain.getId().value());\n        }\n        entity.setCustomerId(domain.getCustomerId().value());\n        entity.setStatus(domain.getStatus().name());\n        return entity;\n    }\n}','java','양방향 변환 메서드를 모두 제공하여 Command/Query 모두 지원합니다.',NULL,NULL,NULL,'2026-01-21 07:50:44.000000','2026-01-21 07:50:44.000000',NULL),(112,159,'BAD','// Native Query로 FullText 검색 - 금지!\n@Query(value = \"SELECT * FROM products WHERE MATCH(name, description) AGAINST(:keyword IN BOOLEAN MODE)\", nativeQuery = true)\nList<ProductJpaEntity> fullTextSearch(@Param(\"keyword\") String keyword);','java','Native Query는 타입 안전성이 없고 QueryDSL과 통합되지 않습니다.',NULL,NULL,NULL,'2026-01-21 07:50:44.000000','2026-01-21 07:50:44.000000',NULL),(113,159,'GOOD','// 1. FunctionContributor 구현\npublic class MatchAgainstFunctionContributor implements FunctionContributor {\n    @Override\n    public void contributeFunctions(FunctionContributions contributions) {\n        contributions.getFunctionRegistry().registerPattern(\n            \"match_against\",\n            \"MATCH(?1) AGAINST(?2 IN BOOLEAN MODE)\",\n            contributions.getTypeConfiguration()\n                .getBasicTypeForJavaType(Double.class)\n        );\n    }\n}\n\n// 2. META-INF/services/org.hibernate.boot.model.FunctionContributor 파일 생성\n// 내용: com.example.persistence.common.function.MatchAgainstFunctionContributor\n\n// 3. QueryDSL에서 사용\npublic List<ProductJpaEntity> fullTextSearch(String keyword) {\n    NumberExpression<Double> score = Expressions.numberTemplate(\n        Double.class,\n        \"match_against({0}, {1})\",\n        product.name,\n        keyword\n    );\n    \n    return queryFactory\n        .selectFrom(product)\n        .where(score.gt(0))\n        .orderBy(score.desc())\n        .fetch();\n}','java','FunctionContributor를 등록하여 QueryDSL에서 타입 안전하게 FullText 검색을 사용합니다.',NULL,NULL,NULL,'2026-01-21 07:50:44.000000','2026-01-21 07:50:44.000000',NULL),(114,160,'BAD','// persistence-mysql 모듈에서 조인 사용 - 금지!\n@Repository\npublic class OrderQueryDslRepository {\n    \n    public List<OrderWithCustomerDto> findOrdersWithCustomer(Long customerId) {\n        return queryFactory\n            .select(Projections.constructor(OrderWithCustomerDto.class,\n                order.id,\n                customer.name  // 조인!\n            ))\n            .from(order)\n            .leftJoin(customer).on(order.customerId.eq(customer.id))  // 금지!\n            .fetch();\n    }\n}','java','도메인용 persistence-mysql에서 조인을 사용하면 안됩니다.',NULL,NULL,NULL,'2026-01-21 07:59:31.000000','2026-01-21 07:59:31.000000',NULL),(115,160,'GOOD','// persistence-mysql-admin 모듈에서 조인 사용 - 허용\n@Repository\npublic class OrderAdminQueryDslRepository {\n    \n    public List<OrderWithCustomerDto> findOrdersWithCustomer(Long customerId) {\n        return queryFactory\n            .select(Projections.constructor(OrderWithCustomerDto.class,\n                order.id,\n                order.orderNumber,\n                customer.name,\n                customer.email\n            ))\n            .from(order)\n            .leftJoin(customer).on(order.customerId.eq(customer.id))  // Admin 모듈에서 허용\n            .where(order.customerId.eq(customerId))\n            .fetch();\n    }\n}','java','Admin 모듈에서는 조인이 허용됩니다.',NULL,NULL,NULL,'2026-01-21 07:59:31.000000','2026-01-21 07:59:31.000000',NULL),(116,161,'GOOD','@Repository\npublic class OrderAdminQueryDslRepository {\n    \n    // leftJoin 허용\n    public List<OrderSummaryDto> findOrderSummary() {\n        return queryFactory\n            .select(Projections.constructor(OrderSummaryDto.class,\n                order.id,\n                order.totalAmount,\n                customer.name,\n                orderLine.count()\n            ))\n            .from(order)\n            .leftJoin(customer).on(order.customerId.eq(customer.id))\n            .leftJoin(orderLine).on(orderLine.orderId.eq(order.id))\n            .groupBy(order.id, customer.name)\n            .fetch();\n    }\n    \n    // innerJoin 허용\n    public List<ActiveOrderDto> findActiveOrdersWithPayment() {\n        return queryFactory\n            .select(Projections.constructor(ActiveOrderDto.class,\n                order.id,\n                payment.status\n            ))\n            .from(order)\n            .innerJoin(payment).on(payment.orderId.eq(order.id))\n            .where(order.status.eq(OrderStatus.ACTIVE))\n            .fetch();\n    }\n}','java','Admin 모듈에서는 다양한 조인 타입이 허용됩니다.',NULL,NULL,NULL,'2026-01-21 07:59:31.000000','2026-01-21 07:59:31.000000',NULL),(123,165,'GOOD','@Tag(name = \"Convention\", description = \"코딩 컨벤션 관리 API\")\n@RestController\n@RequestMapping(ConventionApiEndpoints.CONVENTIONS)\npublic class ConventionCommandController {\n    private final CreateConventionUseCase createConventionUseCase;\n    // ...\n}','java','Controller는 @RestController로 선언, @Tag로 OpenAPI 문서화',NULL,'ConventionCommandController.java',NULL,'2026-01-21 14:19:44.000000','2026-01-21 14:19:44.000000',NULL),(124,165,'BAD','@Controller\n@RequestMapping(\"/api/v1/conventions\")\npublic class ConventionController {\n    // @RestController 대신 @Controller 사용 - 금지\n}','java','@Controller 사용 금지 - @RestController 필수',NULL,NULL,NULL,'2026-01-21 14:19:44.000000','2026-01-21 14:19:44.000000',NULL),(125,166,'GOOD','@PatchMapping(ConventionApiEndpoints.ID_DELETE)\npublic ResponseEntity<ApiResponse<Void>> delete(\n        @Parameter(description = \"Convention ID\", required = true)\n        @PathVariable(ConventionApiEndpoints.PATH_CONVENTION_ID) Long conventionId) {\n    deleteConventionUseCase.execute(conventionId);\n    return ResponseEntity.ok(ApiResponse.of());\n}','java','Soft Delete는 PATCH 메서드 사용 - /resource/{id}/delete 경로',NULL,'ConventionCommandController.java',NULL,'2026-01-21 14:19:53.000000','2026-01-21 14:19:53.000000',NULL),(126,166,'BAD','@DeleteMapping(\"/{conventionId}\")\npublic ResponseEntity<Void> delete(@PathVariable Long conventionId) {\n    // DELETE 메서드 금지 - PATCH 사용 필수\n    deleteConventionUseCase.execute(conventionId);\n    return ResponseEntity.noContent().build();\n}','java','DELETE 메서드 사용 금지 - PATCH /delete 패턴 사용',NULL,NULL,NULL,'2026-01-21 14:19:53.000000','2026-01-21 14:19:53.000000',NULL),(127,167,'GOOD','public class ConventionCommandController {\n    private final CreateConventionUseCase createConventionUseCase;\n    private final UpdateConventionUseCase updateConventionUseCase;\n    private final DeleteConventionUseCase deleteConventionUseCase;\n    private final ConventionCommandApiMapper mapper;\n    \n    public ConventionCommandController(\n            CreateConventionUseCase createConventionUseCase,\n            UpdateConventionUseCase updateConventionUseCase,\n            DeleteConventionUseCase deleteConventionUseCase,\n            ConventionCommandApiMapper mapper) {\n        // UseCase 인터페이스만 주입\n    }\n}','java','Controller는 UseCase(Port-In) 인터페이스만 의존 - 구현체 직접 의존 금지',NULL,'ConventionCommandController.java',NULL,'2026-01-21 14:20:05.000000','2026-01-21 14:20:05.000000',NULL),(128,167,'BAD','public class ConventionCommandController {\n    private final ConventionCommandManager manager;  // 금지: Service/Manager 직접 의존\n    private final ConventionRepository repository;   // 금지: Repository 직접 의존\n    \n    public ConventionCommandController(\n            ConventionCommandManager manager,\n            ConventionRepository repository) {\n        // UseCase 인터페이스가 아닌 구현체 직접 의존 - 금지\n    }\n}','java','Service/Manager/Repository 직접 의존 금지 - UseCase 인터페이스만 사용',NULL,NULL,NULL,'2026-01-21 14:20:05.000000','2026-01-21 14:20:05.000000',NULL),(129,168,'GOOD','@PostMapping\npublic ResponseEntity<ApiResponse<ConventionIdApiResponse>> create(\n        @Valid @RequestBody CreateConventionApiRequest request) {\n    CreateConventionCommand command = mapper.toCommand(request);\n    Long id = createConventionUseCase.execute(command);\n    ConventionIdApiResponse response = ConventionIdApiResponse.of(id);\n    return ResponseEntity.status(HttpStatus.CREATED).body(ApiResponse.of(response));\n}','java','ResponseEntity<ApiResponse<T>> 형식 필수 - 일관된 응답 포맷',NULL,'ConventionCommandController.java',NULL,'2026-01-21 14:20:15.000000','2026-01-21 14:20:15.000000',NULL),(130,168,'BAD','@PostMapping\npublic ConventionIdApiResponse create(@RequestBody CreateConventionApiRequest request) {\n    // ResponseEntity 누락 - HTTP 상태 코드 제어 불가\n    // ApiResponse 래핑 누락 - 응답 포맷 불일치\n    Long id = createConventionUseCase.execute(mapper.toCommand(request));\n    return ConventionIdApiResponse.of(id);\n}','java','ResponseEntity와 ApiResponse 래핑 필수 - 직접 DTO 반환 금지',NULL,NULL,NULL,'2026-01-21 14:20:15.000000','2026-01-21 14:20:15.000000',NULL),(131,169,'GOOD','@RestController\n@RequestMapping(ConventionApiEndpoints.CONVENTIONS)\npublic class ConventionCommandController {\n    private final CreateConventionUseCase createConventionUseCase;\n    \n    public ConventionCommandController(CreateConventionUseCase createConventionUseCase) {\n        this.createConventionUseCase = createConventionUseCase;\n    }\n    \n    // @Transactional 없음 - Controller는 트랜잭션 관리 금지\n    // 트랜잭션은 Application Layer(Manager)에서 관리\n    @PostMapping\n    public ResponseEntity<ApiResponse<ConventionIdApiResponse>> create(\n            @Valid @RequestBody CreateConventionApiRequest request) {\n        CreateConventionCommand command = mapper.toCommand(request);\n        Long conventionId = createConventionUseCase.execute(command);\n        ConventionIdApiResponse response = new ConventionIdApiResponse(conventionId);\n        return ResponseEntity.status(HttpStatus.CREATED).body(ApiResponse.of(response));\n    }\n}','java','Controller에 @Transactional 선언 금지 - 트랜잭션은 Manager에서 관리',NULL,'ConventionCommandController.java',NULL,'2026-01-21 14:20:25.000000','2026-01-21 14:59:10.000000',NULL),(132,169,'BAD','@RestController\n@Transactional  // 금지: Controller에 @Transactional\npublic class ConventionController {\n    @PostMapping\n    @Transactional(readOnly = true)  // 금지: 메서드에도 @Transactional 선언 금지\n    public ResponseEntity<ApiResponse<ConventionResponse>> create(...) {\n        // ...\n    }\n}','java','Controller에 @Transactional 선언 금지 - 트랜잭션 경계는 Application Layer',NULL,NULL,NULL,'2026-01-21 14:20:25.000000','2026-01-21 14:20:25.000000',NULL),(133,177,'GOOD','public record CreateConventionApiRequest(\n    @NotNull @Schema(description = \"모듈 ID\") Long moduleId,\n    @NotBlank @Schema(description = \"버전\") String version,\n    @Schema(description = \"설명\") String description\n) {}','java','API Request/Response DTO는 반드시 record로 정의 - 불변성 보장',NULL,'CreateConventionApiRequest.java',NULL,'2026-01-21 14:20:34.000000','2026-01-21 14:20:34.000000',NULL),(134,177,'BAD','public class CreateConventionApiRequest {\n    private Long moduleId;\n    private String version;\n    \n    // Getter/Setter - 금지\n    public Long getModuleId() { return moduleId; }\n    public void setModuleId(Long moduleId) { this.moduleId = moduleId; }\n}','java','class 타입 금지 - record 필수 사용',NULL,NULL,NULL,'2026-01-21 14:20:34.000000','2026-01-21 14:20:34.000000',NULL),(135,175,'GOOD','@GetMapping\npublic ResponseEntity<ApiResponse<SliceApiResponse<ConventionApiResponse>>> getAll(\n        @Valid GetAllConventionsApiRequest request) {\n    GetAllConventionsQuery query = mapper.toQuery(request);\n    ConventionSliceResult sliceResult = getAllConventionsUseCase.execute(query);\n    SliceApiResponse<ConventionApiResponse> response = mapper.toSliceResponse(sliceResult);\n    return ResponseEntity.ok(ApiResponse.of(response));\n}','java','List 반환 시 SliceApiResponse로 래핑 - hasNext, cursor 등 페이징 정보 포함',NULL,'ConventionQueryController.java',NULL,'2026-01-21 14:20:44.000000','2026-01-21 14:20:44.000000',NULL),(136,175,'BAD','@GetMapping\npublic ResponseEntity<ApiResponse<List<ConventionApiResponse>>> getAll() {\n    // List 직접 반환 금지 - 페이징 정보 누락\n    List<Convention> conventions = conventionRepository.findAll();\n    return ResponseEntity.ok(ApiResponse.of(conventions));\n}','java','List 직접 반환 금지 - SliceApiResponse 필수 사용',NULL,NULL,NULL,'2026-01-21 14:20:44.000000','2026-01-21 14:20:44.000000',NULL),(137,192,'GOOD','@Component\npublic class ConventionErrorMapper implements ErrorMapper {\n    \n    @Override\n    public boolean supports(DomainException ex) {\n        return ex instanceof ConventionNotFoundException\n                || ex instanceof ConventionDuplicateException;\n    }\n\n    @Override\n    public MappedError map(DomainException ex, Locale locale) {\n        return switch (ex) {\n            case ConventionNotFoundException e ->\n                new MappedError(HttpStatus.NOT_FOUND, \"Convention Not Found\", \n                    e.getMessage(), URI.create(\"/errors/convention/not-found\"));\n            // ...\n        };\n    }\n}','java','ErrorMapper 인터페이스 구현 - supports()로 지원 예외 판단, map()으로 MappedError 변환',NULL,'ConventionErrorMapper.java',NULL,'2026-01-21 14:20:59.000000','2026-01-21 14:20:59.000000',NULL),(138,192,'BAD','@ControllerAdvice\npublic class GlobalExceptionHandler {\n    @ExceptionHandler(ConventionNotFoundException.class)\n    public ResponseEntity<ErrorResponse> handleNotFound(ConventionNotFoundException ex) {\n        // 도메인별 ErrorMapper 분리 필요 - GlobalExceptionHandler에 직접 처리 금지\n        return ResponseEntity.status(404).body(new ErrorResponse(ex.getMessage()));\n    }\n}','java','GlobalExceptionHandler에 도메인별 예외 직접 처리 금지 - ErrorMapper로 분리',NULL,NULL,NULL,'2026-01-21 14:20:59.000000','2026-01-21 14:20:59.000000',NULL),(139,201,'GOOD','public final class ConventionApiEndpoints {\n\n    private ConventionApiEndpoints() {\n        // Utility class - prevent instantiation\n    }\n\n    public static final String CONVENTIONS = ApiPaths.SERVICE_BASE + \"/conventions\";\n    public static final String ID = \"/{conventionId}\";\n    public static final String ID_DELETE = \"/{conventionId}/delete\";\n    \n    public static final String PATH_CONVENTION_ID = \"conventionId\";\n}','java','Endpoints 클래스는 final class로 선언, private 생성자로 인스턴스화 방지',NULL,'ConventionApiEndpoints.java',NULL,'2026-01-21 14:21:14.000000','2026-01-21 14:21:14.000000',NULL),(140,201,'BAD','public class ConventionApiEndpoints {\n    // final 누락 - 상속 가능\n    // private 생성자 누락 - 인스턴스화 가능\n    \n    public String conventions = \"/conventions\";  // static final 아님 - 금지\n}','java','final class 필수, private 생성자 필수, static final 상수 필수',NULL,NULL,NULL,'2026-01-21 14:21:14.000000','2026-01-21 14:21:14.000000',NULL),(141,173,'GOOD','@PostMapping\npublic ResponseEntity<ApiResponse<ConventionIdApiResponse>> create(\n        @Valid @RequestBody CreateConventionApiRequest request) {\n    // @Valid로 Request DTO 검증 필수\n    CreateConventionCommand command = mapper.toCommand(request);\n    Long id = createConventionUseCase.execute(command);\n    return ResponseEntity.status(HttpStatus.CREATED).body(ApiResponse.of(response));\n}','java','@Valid 어노테이션으로 Request DTO Bean Validation 자동 적용',NULL,'ConventionCommandController.java',NULL,'2026-01-21 14:21:24.000000','2026-01-21 14:21:24.000000',NULL),(142,173,'BAD','@PostMapping\npublic ResponseEntity<ApiResponse<ConventionIdApiResponse>> create(\n        @RequestBody CreateConventionApiRequest request) {\n    // @Valid 누락 - 검증 수행 안됨\n    // 유효하지 않은 데이터가 Application Layer로 전달될 수 있음\n    return ResponseEntity.ok(ApiResponse.of(response));\n}','java','@Valid 누락 시 Bean Validation 미적용 - 유효성 검사 우회됨',NULL,NULL,NULL,'2026-01-21 14:21:24.000000','2026-01-21 14:21:24.000000',NULL),(143,210,'GOOD','public interface OrderQueryPort {\n    \n    // ✅ Domain VO 사용 - 타입 안전성 보장\n    Optional<Order> findById(OrderId orderId);\n    \n    // ✅ Domain VO 사용 - 비즈니스 의도 명확\n    boolean existsByCustomerId(CustomerId customerId);\n    \n    // ✅ 복합 VO 파라미터\n    List<Order> findByCustomerIdAndStatus(CustomerId customerId, OrderStatus status);\n    \n    // ⚠️ nullable 파라미터는 원시타입 허용 (예외)\n    List<Order> search(@Nullable Long customerId, \n                       @Nullable OrderStatus status, \n                       SearchParams params);\n}','java','Port 인터페이스에서 Domain VO를 사용하면 타입 안전성이 보장되고, 파라미터의 비즈니스 의미가 명확해집니다. 다만 검색 조건 등에서 null 허용이 필요한 파라미터는 예외적으로 원시타입 사용이 가능합니다.','[4, 7, 10]',NULL,NULL,'2026-01-22 00:42:46.000000','2026-01-22 00:42:46.000000',NULL),(144,210,'BAD','public interface OrderQueryPort {\n    \n    // ❌ 원시타입 사용 - 타입 혼동 위험\n    Optional<Order> findById(Long id);\n    \n    // ❌ 원시타입 사용 - 비즈니스 의도 불명확\n    boolean exists(Long customerId);\n    \n    // ❌ 모든 파라미터가 원시타입\n    List<Order> findByCustomerIdAndStatus(Long customerId, String status);\n    \n    // ❌ 필수 파라미터도 원시타입 사용\n    Order getByIdAndVersion(Long orderId, Long version);\n}','java','원시타입을 사용하면 Long customerId와 Long orderId를 혼동할 위험이 있고, 파라미터의 비즈니스 의미를 알기 어렵습니다. 또한 VO 생성 시 수행되는 유효성 검증 이점을 활용할 수 없습니다.','[4, 7, 10, 13]',NULL,NULL,'2026-01-22 00:42:46.000000','2026-01-22 00:42:46.000000',NULL),(145,216,'GOOD','// CommandFactory\npublic UpdateContext<TechStackId, TechStackUpdateData> createUpdateContext(\n        UpdateTechStackCommand command) {\n    TechStackId id = TechStackId.of(command.id());\n    TechStackUpdateData updateData = createUpdateData(command);\n    Instant changedAt = timeProvider.now();  // C-006: Factory에서 시간 생성\n    return new UpdateContext<>(id, updateData, changedAt);\n}\n\n// Service\n@Override\npublic void execute(UpdateTechStackCommand command) {\n    UpdateContext<TechStackId, TechStackUpdateData> context =\n            techStackCommandFactory.createUpdateContext(command);\n    \n    techStackValidator.validateNameNotDuplicateExcluding(\n        TechStackName.of(command.name()), context.id());\n    \n    TechStack techStack = techStackValidator.findExistingOrThrow(context.id());\n    techStack.update(context.updateData(), context.changedAt());\n    techStackPersistenceManager.persist(techStack);\n}','java','Factory의 createUpdateContext()로 ID, UpdateData, changedAt을 한 번에 생성합니다. Service는 UpdateContext에서 필요한 값을 꺼내 사용합니다.',NULL,NULL,NULL,'2026-01-22 03:17:27.000000','2026-01-22 03:17:27.000000',NULL),(146,216,'BAD','// ❌ BAD: Factory를 여러 번 호출\n@Override\npublic void execute(UpdateTechStackCommand command) {\n    // Factory 여러 번 호출\n    TechStackId id = techStackCommandFactory.createId(command.id());\n    TechStackUpdateData updateData = techStackCommandFactory.createUpdateData(command);\n    Instant changedAt = techStackCommandFactory.now();  // 시간도 따로 호출\n    \n    techStackValidator.validateNameNotDuplicateExcluding(updateData.name(), id);\n    \n    TechStack techStack = techStackValidator.findExistingOrThrow(id);\n    techStack.update(updateData, changedAt);\n    techStackPersistenceManager.persist(techStack);\n}\n\n// ❌ BAD: Service에서 직접 TimeProvider 사용 (C-006 위반)\n@Override\npublic void execute(UpdateTechStackCommand command) {\n    UpdateContext<TechStackId, TechStackUpdateData> context =\n            techStackCommandFactory.createUpdateContext(command);\n    \n    // C-006 위반: Service에서 직접 시간 생성\n    Instant changedAt = timeProvider.now();\n    \n    TechStack techStack = techStackValidator.findExistingOrThrow(context.id());\n    techStack.update(context.updateData(), changedAt);\n    techStackPersistenceManager.persist(techStack);\n}','java','Factory를 여러 번 호출하거나, Service에서 직접 TimeProvider를 사용하면 안 됩니다. createUpdateContext()로 한 번에 생성하고, context.changedAt()을 사용합니다.',NULL,NULL,NULL,'2026-01-22 03:17:38.000000','2026-01-22 03:17:38.000000',NULL),(147,215,'GOOD','@Component\npublic class OrderFactory {\n    \n    public CreateBundle createBundle(CreateOrderCommand command) {\n        return CreateBundle.of(\n            createOrder(command),\n            createOrderHistory(command),\n            createOrderOutbox(command)\n        );\n    }\n    \n    private Order createOrder(CreateOrderCommand command) {\n        return Order.forNew(command.customerId(), command.items());\n    }\n    \n    private OrderHistory createOrderHistory(CreateOrderCommand command) {\n        return OrderHistory.forNew(command.customerId());\n    }\n    \n    private OrderOutbox createOrderOutbox(CreateOrderCommand command) {\n        return OrderOutbox.forNew(command.orderId());\n    }\n}','java','공개 메서드는 Command를 통째로 받고, 내부 분해는 private 메서드에서 처리',NULL,NULL,NULL,'2026-01-28 08:38:47.000000','2026-01-28 08:38:47.000000',NULL),(148,215,'BAD','// Service에서 DTO를 풀어서 전달 - 금지\n@Service\npublic class CreateOrderService {\n    public Long execute(CreateOrderCommand command) {\n        // ❌ DTO를 풀어서 개별 파라미터로 전달\n        CreateBundle bundle = orderFactory.createBundle(\n            command.customerId(),\n            command.items(),\n            command.address(),\n            command.memo()\n        );\n    }\n}','java','Service에서 DTO를 풀어서 Factory에 전달 - 파라미터 변경 시 호출부 모두 수정 필요',NULL,NULL,NULL,'2026-01-28 08:38:47.000000','2026-01-28 08:38:47.000000',NULL),(149,217,'GOOD','@Component\npublic class OrderFactory {\n    \n    public CreateBundle createBundle(CreateOrderCommand command) {\n        // null 체크 없이 VO 생성에 위임\n        return CreateBundle.of(\n            OrderId.generate(),\n            OrderName.from(command.name()),  // VO Compact Constructor에서 검증\n            OrderMemo.from(command.memo())   // VO에서 null 허용 여부 결정\n        );\n    }\n}','java','Factory는 null 체크 없이 VO 생성에 위임. 검증은 VO Compact Constructor에서 수행',NULL,NULL,NULL,'2026-01-28 08:38:57.000000','2026-01-28 08:38:57.000000',NULL),(150,217,'BAD','@Component\npublic class OrderFactory {\n    \n    public CreateBundle createBundle(CreateOrderCommand command) {\n        // ❌ Factory에서 null 체크 및 기본값 설정 금지\n        String name = command.name() != null ? command.name() : \"기본주문\";\n        String memo = command.memo() != null ? command.memo() : \"\";\n        \n        return CreateBundle.of(\n            OrderId.generate(),\n            name,\n            memo\n        );\n    }\n}','java','Factory에서 null 체크/기본값 설정 - 도메인 로직이 Application 계층으로 유출',NULL,NULL,NULL,'2026-01-28 08:38:57.000000','2026-01-28 08:38:57.000000',NULL),(151,218,'GOOD','@Component\npublic class OrderFactory {\n    \n    public CreateBundle createBundle(CreateOrderCommand command) {\n        // 단순히 번들 생성만 담당 - 어떤 타입 생성할지 판단하지 않음\n        return CreateBundle.of(\n            OrderId.generate(),\n            command,\n            timeProvider.now()\n        );\n    }\n}','java','Factory는 객체 생성만 담당. 어떤 타입을 생성할지 판단은 Domain에서 수행',NULL,NULL,NULL,'2026-01-28 08:39:06.000000','2026-01-28 08:39:06.000000',NULL),(152,218,'BAD','@Component\npublic class OrderFactory {\n    \n    public Order createOrder(CreateOrderCommand command) {\n        // ❌ Factory에서 어떤 객체를 생성할지 판단 금지\n        if (command.orderType() == OrderType.SUBSCRIPTION) {\n            return SubscriptionOrder.forNew(command);\n        } else if (command.orderType() == OrderType.GIFT) {\n            return GiftOrder.forNew(command);\n        } else {\n            return RegularOrder.forNew(command);\n        }\n    }\n}','java','Factory에서 의사결정 로직 - 도메인 규칙이 Application 계층에 분산됨',NULL,NULL,NULL,'2026-01-28 08:39:06.000000','2026-01-28 08:39:06.000000',NULL),(153,213,'GOOD','// 커서 기반 조회\npublic interface SearchOrderByCursorUseCase {\n    SliceResult<OrderSummary> execute(SearchOrderByCursorQuery query);\n}\n\n// Offset 페이징 조회\npublic interface SearchOrderByOffsetUseCase {\n    PageResult<OrderSummary> execute(SearchOrderByOffsetQuery query);\n}\n\n// 단건 조회\npublic interface GetOrderUseCase {\n    OrderDetail execute(GetOrderQuery query);\n}','java','커서: SearchXxxByCursorUseCase, Offset: SearchXxxByOffsetUseCase, 단건: GetXxxUseCase',NULL,NULL,NULL,'2026-01-28 08:39:17.000000','2026-01-28 08:39:17.000000',NULL),(154,213,'BAD','// ❌ GetAll 네이밍 금지\npublic interface GetAllOrdersUseCase { }\n\n// ❌ Find 대신 Search 사용\npublic interface FindOrdersUseCase { }\n\n// ❌ 페이징 방식 불명확\npublic interface SearchOrderUseCase { }','java','GetAll 금지, Find 대신 Search 사용, 페이징 방식(ByCursor/ByOffset) 명시 필요',NULL,NULL,NULL,'2026-01-28 08:39:17.000000','2026-01-28 08:39:17.000000',NULL),(155,214,'GOOD','// Soft Delete는 의미있는 동사 사용\npublic interface ArchiveOrderUseCase { }      // 보관/아카이브\npublic interface DeactivateUserUseCase { }    // 비활성화\npublic interface DisableFeatureUseCase { }    // 기능 끄기\npublic interface CancelSubscriptionUseCase { } // 구독 취소\n\n// Hard Delete가 필요한 경우 (데이터 정리 등)\npublic interface PurgeExpiredSessionUseCase { } // 만료 세션 제거','java','Soft Delete: Archive/Deactivate/Disable/Cancel 사용. Hard Delete: Purge 사용',NULL,NULL,NULL,'2026-01-28 08:39:29.000000','2026-01-28 08:39:29.000000',NULL),(156,214,'BAD','// ❌ Delete 네이밍 금지\npublic interface DeleteOrderUseCase { }\npublic interface DeleteUserUseCase { }\n\n// ❌ Remove 네이밍 금지  \npublic interface RemoveOrderUseCase { }\npublic interface RemoveUserUseCase { }','java','Delete/Remove는 의미가 불명확. Soft/Hard Delete 구분 없이 혼란 유발',NULL,NULL,NULL,'2026-01-28 08:39:29.000000','2026-01-28 08:39:29.000000',NULL),(157,197,'GOOD','@Configuration\npublic class JacksonConfig {\n    \n    @Bean\n    public ObjectMapper objectMapper() {\n        return new ObjectMapper()\n            .setPropertyNamingStrategy(PropertyNamingStrategies.SNAKE_CASE)\n            .registerModule(new JavaTimeModule())\n            .disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n    }\n}','java','ObjectMapper를 JacksonConfig에서 중앙 관리. SNAKE_CASE, JavaTimeModule 필수',NULL,NULL,NULL,'2026-01-28 08:54:16.000000','2026-01-28 08:54:16.000000',NULL),(158,197,'BAD','@RestController\npublic class OrderController {\n    // ❌ 개별 Controller에서 ObjectMapper 직접 생성\n    private final ObjectMapper mapper = new ObjectMapper();\n    \n    @GetMapping\n    public String getOrder() {\n        return mapper.writeValueAsString(order); // 중앙 설정과 불일치\n    }\n}','java','Controller에서 ObjectMapper 직접 생성 - 설정 불일치 및 중복',NULL,NULL,NULL,'2026-01-28 08:54:16.000000','2026-01-28 08:54:16.000000',NULL),(159,198,'GOOD','@Configuration\npublic class OpenApiConfig {\n    \n    @Bean\n    public GroupedOpenApi publicApi() {\n        return GroupedOpenApi.builder()\n            .group(\"public\")\n            .pathsToMatch(\"/api/v1/**\")\n            .build();\n    }\n    \n    @Bean\n    public OpenAPI customOpenAPI() {\n        return new OpenAPI()\n            .info(new Info().title(\"Order API\").version(\"1.0\"));\n    }\n}','java','OpenAPI 설정을 OpenApiConfig에서 중앙 관리. GroupedOpenApi로 그룹핑',NULL,NULL,NULL,'2026-01-28 08:54:42.000000','2026-01-28 08:54:42.000000',NULL),(160,198,'BAD','// ❌ OpenApiConfig 없이 Controller에만 @Operation 작성\n@RestController\npublic class OrderController {\n    @Operation(summary = \"주문 조회\")  // 설정 없이 어노테이션만\n    @GetMapping\n    public OrderResponse getOrder() { }\n}','java','OpenApiConfig 없이 Controller 어노테이션만 - API 문서 구조화 불가',NULL,NULL,NULL,'2026-01-28 08:54:42.000000','2026-01-28 08:54:42.000000',NULL),(161,199,'GOOD','@Configuration\npublic class WebMvcConfig implements WebMvcConfigurer {\n    \n    private final LoggingInterceptor loggingInterceptor;\n    \n    @Override\n    public void addCorsMappings(CorsRegistry registry) {\n        registry.addMapping(\"/**\")\n            .allowedOrigins(\"*\")\n            .allowedMethods(\"GET\", \"POST\", \"PUT\", \"PATCH\");\n    }\n    \n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(loggingInterceptor);\n    }\n}','java','CORS, Interceptor 설정을 WebMvcConfig에서 중앙 관리',NULL,NULL,NULL,'2026-01-28 08:54:42.000000','2026-01-28 08:54:42.000000',NULL),(162,199,'BAD','// ❌ Controller에서 개별 CORS 설정\n@CrossOrigin(origins = \"*\")\n@RestController\npublic class OrderController { }\n\n// ❌ 다른 Controller는 다른 설정\n@CrossOrigin(origins = \"http://localhost:3000\")\n@RestController  \npublic class UserController { }','java','Controller마다 개별 CORS 설정 - 일관성 없음',NULL,NULL,NULL,'2026-01-28 08:54:42.000000','2026-01-28 08:54:42.000000',NULL),(163,170,'GOOD','@Tag(name = \"Order\", description = \"주문 관리 API\")\n@RestController\n@RequestMapping(OrderApiEndpoints.ORDERS)\npublic class OrderCommandController {\n    \n    @Operation(summary = \"주문 생성\", description = \"새 주문을 생성합니다\")\n    @ApiResponses({\n        @ApiResponse(responseCode = \"201\", description = \"생성 성공\"),\n        @ApiResponse(responseCode = \"400\", description = \"잘못된 요청\")\n    })\n    @PostMapping\n    public ResponseEntity<ApiResponse<Long>> create(\n            @Valid @RequestBody CreateOrderRequest request) {\n        return ResponseEntity.status(HttpStatus.CREATED)\n            .body(ApiResponse.of(createOrderUseCase.execute(mapper.toCommand(request))));\n    }\n}','java','@Tag, @Operation, @ApiResponses 어노테이션으로 API 문서화 필수',NULL,NULL,NULL,'2026-01-28 08:57:52.000000','2026-01-28 08:57:52.000000',NULL),(164,170,'BAD','@RestController\n@RequestMapping(OrderApiEndpoints.ORDERS)\npublic class OrderCommandController {\n    \n    // ❌ OpenAPI 어노테이션 누락 - API 문서 자동 생성 불가\n    @PostMapping\n    public ResponseEntity<ApiResponse<Long>> create(\n            @Valid @RequestBody CreateOrderRequest request) {\n        return ResponseEntity.status(HttpStatus.CREATED)\n            .body(ApiResponse.of(createOrderUseCase.execute(mapper.toCommand(request))));\n    }\n}','java','OpenAPI 어노테이션 누락 - Swagger 문서에 설명 없음',NULL,NULL,NULL,'2026-01-28 08:57:52.000000','2026-01-28 08:57:52.000000',NULL),(165,171,'GOOD','@PostMapping\npublic ResponseEntity<ApiResponse<Long>> create(\n        @Valid @RequestBody CreateOrderRequest request) {\n    CreateOrderCommand command = mapper.toCommand(request);  // Mapper에 위임\n    Long id = createOrderUseCase.execute(command);\n    return ResponseEntity.status(HttpStatus.CREATED).body(ApiResponse.of(id));\n}','java','변환 로직은 Mapper에 위임. Controller는 위임만 수행',NULL,NULL,NULL,'2026-01-28 08:58:20.000000','2026-01-28 08:58:20.000000',NULL),(166,171,'BAD','@PostMapping\npublic ResponseEntity<ApiResponse<Long>> create(\n        @Valid @RequestBody CreateOrderRequest request) {\n    // ❌ Controller에서 직접 변환 - Mapper에 위임해야 함\n    CreateOrderCommand command = new CreateOrderCommand(\n        request.customerId(),\n        request.items().stream()\n            .map(i -> new OrderItemCommand(i.productId(), i.quantity()))\n            .toList()\n    );\n    Long id = createOrderUseCase.execute(command);\n    return ResponseEntity.status(HttpStatus.CREATED).body(ApiResponse.of(id));\n}','java','Controller에서 직접 변환/비즈니스 로직 수행 금지',NULL,NULL,NULL,'2026-01-28 08:58:20.000000','2026-01-28 08:58:20.000000',NULL),(167,172,'GOOD','@RestController\n@RequestMapping(OrderApiEndpoints.ORDERS)\npublic class OrderCommandController {\n    \n    @GetMapping(OrderApiEndpoints.ID)\n    public ResponseEntity<ApiResponse<OrderResponse>> getById(\n            @PathVariable(OrderApiEndpoints.PATH_ORDER_ID) Long orderId) {\n        return ResponseEntity.ok(ApiResponse.of(mapper.toResponse(getOrderUseCase.execute(orderId))));\n    }\n    \n    @PatchMapping(OrderApiEndpoints.ID_DELETE)\n    public ResponseEntity<ApiResponse<Void>> delete(\n            @PathVariable(OrderApiEndpoints.PATH_ORDER_ID) Long orderId) {\n        deleteOrderUseCase.execute(orderId);\n        return ResponseEntity.ok(ApiResponse.of());\n    }\n}','java','OrderApiEndpoints 상수 클래스로 경로 중앙 관리',NULL,NULL,NULL,'2026-01-28 08:58:20.000000','2026-01-28 08:58:20.000000',NULL),(168,172,'BAD','@RestController\n@RequestMapping(\"/api/v1/orders\")  // ❌ 하드코딩 금지\npublic class OrderCommandController {\n    \n    @GetMapping(\"/{orderId}\")  // ❌ 하드코딩 금지\n    public ResponseEntity<ApiResponse<OrderResponse>> getById(\n            @PathVariable Long orderId) {\n        // ...\n    }\n}','java','경로 하드코딩 금지 - *ApiEndpoints 상수 클래스 사용 필수',NULL,NULL,NULL,'2026-01-28 08:58:20.000000','2026-01-28 08:58:20.000000',NULL),(169,174,'GOOD','// Command Controller (CUD)\n@Tag(name = \"Order Command\", description = \"주문 명령 API\")\n@RestController\n@RequestMapping(OrderApiEndpoints.ORDERS)\npublic class OrderCommandController {\n    \n    @PostMapping\n    public ResponseEntity<ApiResponse<Long>> create(...) { }\n    \n    @PatchMapping(OrderApiEndpoints.ID)\n    public ResponseEntity<ApiResponse<Void>> update(...) { }\n    \n    @PatchMapping(OrderApiEndpoints.ID_DELETE)\n    public ResponseEntity<ApiResponse<Void>> delete(...) { }\n}\n\n// Query Controller (R)\n@Tag(name = \"Order Query\", description = \"주문 조회 API\")\n@RestController\n@RequestMapping(OrderApiEndpoints.ORDERS)\npublic class OrderQueryController {\n    \n    @GetMapping(OrderApiEndpoints.ID)\n    public ResponseEntity<ApiResponse<OrderResponse>> getById(...) { }\n    \n    @GetMapping\n    public ResponseEntity<ApiResponse<SliceApiResponse<OrderSummary>>> searchByOffset(...) { }\n}','java','Command(CUD)와 Query(R) Controller를 별도 클래스로 분리',NULL,NULL,NULL,'2026-01-28 08:58:46.000000','2026-01-28 08:58:46.000000',NULL),(170,174,'BAD','// ❌ 하나의 Controller에 CRUD 모두 포함\n@RestController\n@RequestMapping(OrderApiEndpoints.ORDERS)\npublic class OrderController {\n    \n    @PostMapping\n    public ResponseEntity<...> create(...) { }\n    \n    @GetMapping(OrderApiEndpoints.ID)\n    public ResponseEntity<...> getById(...) { }\n    \n    @PatchMapping(OrderApiEndpoints.ID)\n    public ResponseEntity<...> update(...) { }\n    \n    @PatchMapping(OrderApiEndpoints.ID_DELETE)\n    public ResponseEntity<...> delete(...) { }\n}','java','단일 Controller에 CRUD 혼재 - Command/Query 분리 필요',NULL,NULL,NULL,'2026-01-28 08:58:46.000000','2026-01-28 08:58:46.000000',NULL),(171,176,'GOOD','// 소문자 + 복수형 + kebab-case\npublic final class OrderApiEndpoints {\n    public static final String ORDERS = \"/orders\";\n    public static final String ORDER_ITEMS = \"/order-items\";\n    public static final String TECH_STACKS = \"/tech-stacks\";\n    public static final String CODING_RULES = \"/coding-rules\";\n}','java','URL 경로는 소문자, 복수형, kebab-case 사용',NULL,NULL,NULL,'2026-01-28 14:14:48.000000','2026-01-28 14:14:48.000000',NULL),(172,176,'BAD','// 잘못된 URL 경로 패턴\npublic final class OrderApiEndpoints {\n    public static final String ORDERS = \"/Order\";      // 대문자 금지\n    public static final String ITEMS = \"/orderItem\";   // camelCase 금지\n    public static final String STACK = \"/tech-stack\";  // 단수형 금지\n    public static final String RULES = \"/coding_rules\"; // snake_case 금지\n}','java','대문자, camelCase, 단수형, snake_case 사용 금지',NULL,NULL,NULL,'2026-01-28 14:14:48.000000','2026-01-28 14:14:48.000000',NULL),(173,211,'GOOD','@RestController\n@RequestMapping(OrderApiEndpoints.ORDERS)\npublic class OrderQueryController {\n    \n    // Offset 페이징 조회\n    @GetMapping\n    public ResponseEntity<...> searchOrdersByOffset(SearchOrdersByOffsetRequest request) { }\n    \n    // 커서 기반 조회\n    @GetMapping(OrderApiEndpoints.CURSOR)\n    public ResponseEntity<...> searchOrdersByCursor(SearchOrdersByCursorRequest request) { }\n    \n    // 필터 없는 단순 목록\n    @GetMapping(OrderApiEndpoints.LIST)\n    public ResponseEntity<...> listOrders() { }\n    \n    // 단건 조회\n    @GetMapping(OrderApiEndpoints.ID)\n    public ResponseEntity<...> getOrder(@PathVariable Long orderId) { }\n}','java','searchXxxByOffset, searchXxxByCursor, listXxx, getXxx 패턴 사용',NULL,NULL,NULL,'2026-01-28 14:15:00.000000','2026-01-28 14:15:00.000000',NULL),(174,211,'BAD','@RestController\npublic class OrderQueryController {\n    \n    // find 대신 search 사용해야 함\n    @GetMapping\n    public ResponseEntity<...> findOrders(...) { }\n    \n    // getAll 금지\n    @GetMapping\n    public ResponseEntity<...> getAllOrders(...) { }\n    \n    // 페이징 방식 불명확\n    @GetMapping\n    public ResponseEntity<...> searchOrders(...) { }\n}','java','find/getAll 금지, 페이징 방식(ByOffset/ByCursor) 명시 필요',NULL,NULL,NULL,'2026-01-28 14:15:00.000000','2026-01-28 14:15:00.000000',NULL),(175,178,'GOOD','public record OrderResponse(\n    Long id,\n    String status,\n    String createdAt,\n    String updatedAt\n) {\n    // Record는 기본적으로 불변 - Setter 없음\n}','java','Record는 기본 불변. Setter 메서드 없음',NULL,NULL,NULL,'2026-01-28 14:18:16.000000','2026-01-28 14:18:16.000000',NULL),(176,178,'BAD','public class OrderResponse {\n    private Long id;\n    private String status;\n    \n    // ❌ Setter 사용 금지\n    public void setId(Long id) { this.id = id; }\n    public void setStatus(String status) { this.status = status; }\n}','java','class + Setter 사용 금지 - Record 사용으로 불변성 보장',NULL,NULL,NULL,'2026-01-28 14:18:16.000000','2026-01-28 14:18:16.000000',NULL),(177,179,'GOOD','public record CreateOrderRequest(\n    @NotNull @Schema(description = \"고객 ID\") Long customerId,\n    @NotBlank @Size(max = 100) @Schema(description = \"주문명\") String orderName,\n    @NotEmpty @Schema(description = \"주문 항목\") List<OrderItemRequest> items\n) { }','java','Jakarta Validation 어노테이션으로 입력값 검증',NULL,NULL,NULL,'2026-01-28 14:18:16.000000','2026-01-28 14:18:16.000000',NULL),(178,179,'BAD','public record CreateOrderRequest(\n    Long customerId,      // ❌ @NotNull 누락\n    String orderName,     // ❌ @NotBlank 누락\n    List<OrderItemRequest> items  // ❌ @NotEmpty 누락\n) { }','java','Validation 어노테이션 누락 - 유효하지 않은 데이터 유입 가능',NULL,NULL,NULL,'2026-01-28 14:18:16.000000','2026-01-28 14:18:16.000000',NULL),(179,180,'GOOD','public record OrderResponse(\n    Long id,\n    String status,\n    String orderName,\n    String createdAt,   // 필수\n    String updatedAt    // 필수\n) { }','java','Response DTO에 createdAt, updatedAt 필수 포함',NULL,NULL,NULL,'2026-01-28 14:18:36.000000','2026-01-28 14:18:36.000000',NULL),(180,180,'BAD','public record OrderResponse(\n    Long id,\n    String status,\n    String orderName\n    // ❌ createdAt, updatedAt 누락\n) { }','java','시간 정보 누락 - 데이터 추적 및 캐싱 판단 불가',NULL,NULL,NULL,'2026-01-28 14:18:36.000000','2026-01-28 14:18:36.000000',NULL),(181,181,'GOOD','// Mapper에서 Instant -> String 변환\n@Component\npublic class OrderApiMapper {\n    \n    public OrderResponse toResponse(Order order) {\n        return new OrderResponse(\n            order.id(),\n            order.status().name(),\n            DateTimeFormatUtils.formatIso8601(order.createdAt()),\n            DateTimeFormatUtils.formatIso8601(order.updatedAt())\n        );\n    }\n}\n\n// Response DTO는 String 타입\npublic record OrderResponse(\n    Long id, String status, String createdAt, String updatedAt\n) { }','java','Instant는 Mapper에서 ISO8601 String으로 변환',NULL,NULL,NULL,'2026-01-28 14:18:36.000000','2026-01-28 14:18:36.000000',NULL),(182,181,'BAD','// ❌ Response DTO에 Instant 직접 사용 금지\npublic record OrderResponse(\n    Long id,\n    String status,\n    Instant createdAt,  // ❌ Instant 금지 - String 사용\n    Instant updatedAt   // ❌ Instant 금지 - String 사용\n) { }','java','Instant 직접 반환 금지 - JSON 직렬화 형식 불일치',NULL,NULL,NULL,'2026-01-28 14:18:36.000000','2026-01-28 14:18:36.000000',NULL),(183,182,'GOOD','public record OrderDetailResponse(\n    Long id,\n    String status,\n    CustomerInfo customer,\n    List<OrderItemInfo> items,\n    String createdAt,\n    String updatedAt\n) {\n    // 중첩 Record로 복잡한 구조 표현\n    public record CustomerInfo(Long id, String name, String email) { }\n    public record OrderItemInfo(Long productId, String productName, int quantity) { }\n}','java','복잡한 구조는 중첩 Record로 표현',NULL,NULL,NULL,'2026-01-28 14:18:48.000000','2026-01-28 14:18:48.000000',NULL),(184,182,'BAD','// ❌ 플랫한 구조로 모든 필드 나열\npublic record OrderDetailResponse(\n    Long id,\n    String status,\n    Long customerId,\n    String customerName,\n    String customerEmail,\n    // ... 모든 필드가 플랫하게 나열됨\n) { }','java','플랫한 구조는 가독성 저하 - 중첩 Record로 그룹화',NULL,NULL,NULL,'2026-01-28 14:18:48.000000','2026-01-28 14:18:48.000000',NULL),(185,183,'GOOD','public record CreateOrderRequest(\n    @NotNull \n    @Schema(description = \"고객 ID\", example = \"123\") \n    Long customerId,\n    \n    @NotBlank \n    @Schema(description = \"주문명\", maxLength = 100, example = \"신규 주문\") \n    String orderName,\n    \n    @Schema(description = \"메모 (선택)\", nullable = true) \n    String memo\n) { }','java','@Schema로 OpenAPI 문서에 필드 설명, 예시값 제공',NULL,NULL,NULL,'2026-01-28 14:18:48.000000','2026-01-28 14:18:48.000000',NULL),(186,183,'BAD','// @Schema 없음 - API 문서에 필드 설명 없음\npublic record CreateOrderRequest(\n    @NotNull Long customerId,\n    @NotBlank String orderName,\n    String memo\n) { }','java','@Schema 누락 시 Swagger 문서에 필드 설명 없음',NULL,NULL,NULL,'2026-01-28 14:18:48.000000','2026-01-28 14:18:48.000000',NULL),(187,184,'GOOD','public record UpdateOrderRequest(\n    @NotNull Long id,\n    @Nullable String memo,     // null 허용 필드는 @Nullable\n    @Nullable String address   // null 허용 필드는 @Nullable\n) { }','java','null 허용 필드는 @Nullable 사용. Optional 금지',NULL,NULL,NULL,'2026-01-28 14:19:00.000000','2026-01-28 14:19:00.000000',NULL),(188,184,'BAD','public record UpdateOrderRequest(\n    Long id,\n    Optional<String> memo,    // ❌ Optional 금지\n    Optional<String> address  // ❌ Optional 금지\n) { }','java','Optional은 DTO 필드로 부적합 - JSON 직렬화 문제',NULL,NULL,NULL,'2026-01-28 14:19:00.000000','2026-01-28 14:19:00.000000',NULL),(189,185,'GOOD','public record OrderResponse(\n    Long id,\n    String status,\n    List<OrderItemResponse> items,\n    String createdAt,\n    String updatedAt\n) {\n    // Compact Constructor에서 방어적 복사\n    public OrderResponse {\n        items = items != null ? List.copyOf(items) : List.of();\n    }\n}','java','List 필드는 Compact Constructor에서 List.copyOf()로 방어적 복사',NULL,NULL,NULL,'2026-01-28 14:19:00.000000','2026-01-28 14:19:00.000000',NULL),(190,185,'BAD','public record OrderResponse(\n    Long id,\n    String status,\n    List<OrderItemResponse> items,  // ❌ 방어적 복사 없음\n    String createdAt,\n    String updatedAt\n) {\n    // Compact Constructor 없음 - 외부에서 List 변경 가능\n}','java','방어적 복사 없이 List 직접 할당 - 불변성 보장 불가',NULL,NULL,NULL,'2026-01-28 14:19:00.000000','2026-01-28 14:19:00.000000',NULL),(191,212,'GOOD','// Offset 페이징 조회\npublic record SearchOrdersByOffsetApiRequest(\n    @Nullable String status,\n    @Nullable Long customerId,\n    CommonPageApiRequest page\n) { }\n\n// 커서 기반 조회  \npublic record SearchOrdersByCursorApiRequest(\n    @Nullable String status,\n    @Nullable Long customerId,\n    CommonCursorApiRequest cursor\n) { }\n\n// 단순 목록 (필터 없음)\npublic record ListOrderStatusesApiRequest() { }','java','SearchXxxByOffset, SearchXxxByCursor, ListXxx 패턴 사용',NULL,NULL,NULL,'2026-01-28 14:19:13.000000','2026-01-28 14:19:13.000000',NULL),(192,212,'BAD','// ❌ GetAll 금지\npublic record GetAllOrdersApiRequest() { }\n\n// ❌ Find 금지\npublic record FindOrdersApiRequest() { }\n\n// ❌ 페이징 방식 불명확\npublic record SearchOrdersApiRequest() { }','java','GetAll/Find 금지, 페이징 방식(ByOffset/ByCursor) 명시 필요',NULL,NULL,NULL,'2026-01-28 14:19:13.000000','2026-01-28 14:19:13.000000',NULL),(193,202,'GOOD','public final class OrderApiEndpoints {\n    \n    public static final String ORDERS = \"/orders\";\n    public static final String ID = \"/{orderId}\";\n    public static final String ID_DELETE = \"/{orderId}/delete\";\n    public static final String CURSOR = \"/cursor\";\n    public static final String LIST = \"/list\";\n    \n    private OrderApiEndpoints() { }\n}','java','모든 경로 상수는 public static final String으로 선언',NULL,NULL,NULL,'2026-01-28 14:19:43.000000','2026-01-28 14:19:43.000000',NULL),(194,202,'BAD','public final class OrderApiEndpoints {\n    \n    // ❌ static 누락\n    public final String ORDERS = \"/orders\";\n    \n    // ❌ final 누락\n    public static String ID = \"/{orderId}\";\n    \n    // ❌ private 아님\n    protected static final String DELETE = \"/delete\";\n}','java','static, final, public 모두 필수',NULL,NULL,NULL,'2026-01-28 14:19:43.000000','2026-01-28 14:19:43.000000',NULL),(195,203,'GOOD','public final class OrderApiEndpoints {\n    \n    // 경로 상수\n    public static final String ORDERS = \"/orders\";\n    public static final String ID = \"/{orderId}\";\n    \n    // PathVariable 이름 상수\n    public static final String PATH_ORDER_ID = \"orderId\";\n    public static final String PATH_ITEM_ID = \"itemId\";\n    \n    private OrderApiEndpoints() { }\n}\n\n// Controller에서 사용\n@GetMapping(OrderApiEndpoints.ID)\npublic ResponseEntity<...> getById(\n        @PathVariable(OrderApiEndpoints.PATH_ORDER_ID) Long orderId) { }','java','PathVariable 이름도 상수로 관리하여 일관성 유지',NULL,NULL,NULL,'2026-01-28 14:19:43.000000','2026-01-28 14:19:43.000000',NULL),(196,203,'BAD','@GetMapping(\"/{orderId}\")\npublic ResponseEntity<...> getById(\n        @PathVariable(\"orderId\") Long orderId) { }  // ❌ 하드코딩\n\n@GetMapping(\"/{order_id}\")  // ❌ 불일치\npublic ResponseEntity<...> getById2(\n        @PathVariable(\"orderId\") Long orderId) { }','java','PathVariable 하드코딩 시 경로와 불일치 위험',NULL,NULL,NULL,'2026-01-28 14:19:43.000000','2026-01-28 14:19:43.000000',NULL),(197,204,'GOOD','// 도메인별 분리\npublic final class OrderApiEndpoints { \n    public static final String ORDERS = \"/orders\";\n    // ...\n}\n\npublic final class CustomerApiEndpoints {\n    public static final String CUSTOMERS = \"/customers\";\n    // ...\n}\n\npublic final class ProductApiEndpoints {\n    public static final String PRODUCTS = \"/products\";\n    // ...\n}','java','각 도메인별로 별도의 *ApiEndpoints 클래스 생성',NULL,NULL,NULL,'2026-01-28 14:19:43.000000','2026-01-28 14:19:43.000000',NULL),(198,204,'BAD','// ❌ 모든 도메인 경로를 하나의 클래스에\npublic final class ApiEndpoints {\n    public static final String ORDERS = \"/orders\";\n    public static final String CUSTOMERS = \"/customers\";\n    public static final String PRODUCTS = \"/products\";\n    // ... 모든 도메인이 섞여있음\n}','java','단일 클래스에 모든 도메인 혼재 - 관심사 분리 위반',NULL,NULL,NULL,'2026-01-28 14:19:43.000000','2026-01-28 14:19:43.000000',NULL),(199,193,'GOOD','// RFC 7807 ProblemDetail 형식 응답\n{\n    \"type\": \"https://api.example.com/errors/order-not-found\",\n    \"title\": \"Order Not Found\",\n    \"status\": 404,\n    \"detail\": \"Order with ID 123 was not found\",\n    \"instance\": \"/orders/123\"\n}','json','RFC 7807 ProblemDetail 형식으로 에러 응답',NULL,NULL,NULL,'2026-01-28 14:20:07.000000','2026-01-28 14:20:07.000000',NULL),(200,193,'BAD','// ❌ 비표준 에러 응답 형식\n{\n    \"error\": true,\n    \"message\": \"Order not found\",\n    \"code\": 404\n}','json','비표준 형식 - ProblemDetail 사용 필수',NULL,NULL,NULL,'2026-01-28 14:20:07.000000','2026-01-28 14:20:07.000000',NULL),(201,194,'GOOD','// ProblemDetail에 x-error-code 확장\n{\n    \"type\": \"https://api.example.com/errors/order-not-found\",\n    \"title\": \"Order Not Found\",\n    \"status\": 404,\n    \"detail\": \"Order with ID 123 was not found\",\n    \"properties\": {\n        \"x-error-code\": \"ORDER_NOT_FOUND\"\n    }\n}\n\n// ErrorMapper에서 설정\npublic ProblemDetail toProblemDetail(OrderNotFoundException ex) {\n    ProblemDetail problem = ProblemDetail.forStatus(HttpStatus.NOT_FOUND);\n    problem.setProperty(\"x-error-code\", ex.getErrorCode().name());\n    return problem;\n}','java','x-error-code로 클라이언트가 에러 유형 식별 가능',NULL,NULL,NULL,'2026-01-28 14:20:07.000000','2026-01-28 14:20:07.000000',NULL),(202,194,'BAD','// ❌ x-error-code 없음 - 클라이언트가 에러 유형 식별 불가\n{\n    \"type\": \"https://api.example.com/errors/order-not-found\",\n    \"title\": \"Order Not Found\",\n    \"status\": 404,\n    \"detail\": \"Order with ID 123 was not found\"\n}','json','x-error-code 누락 시 클라이언트 에러 처리 어려움',NULL,NULL,NULL,'2026-01-28 14:20:07.000000','2026-01-28 14:20:07.000000',NULL),(203,195,'GOOD','@RestControllerAdvice\npublic class GlobalExceptionHandler {\n    \n    private final List<ErrorMapper> errorMappers;\n    \n    @ExceptionHandler(DomainException.class)\n    public ResponseEntity<ProblemDetail> handleDomainException(DomainException ex) {\n        ErrorMapper mapper = findMapper(ex);\n        ProblemDetail problem = mapper.toProblemDetail(ex);\n        return ResponseEntity.status(problem.getStatus())\n            .contentType(MediaType.APPLICATION_PROBLEM_JSON)\n            .body(problem);\n    }\n    \n    @ExceptionHandler(MethodArgumentNotValidException.class)\n    public ResponseEntity<ProblemDetail> handleValidation(MethodArgumentNotValidException ex) {\n        // Validation 에러 처리\n    }\n}','java','GlobalExceptionHandler로 전역 예외 처리. ErrorMapper 위임',NULL,NULL,NULL,'2026-01-28 14:20:24.000000','2026-01-28 14:20:24.000000',NULL),(204,195,'BAD','// ❌ Controller에서 직접 예외 처리\n@RestController\npublic class OrderController {\n    \n    @GetMapping(\"/{id}\")\n    public ResponseEntity<?> getOrder(@PathVariable Long id) {\n        try {\n            return ResponseEntity.ok(orderService.getOrder(id));\n        } catch (OrderNotFoundException ex) {\n            // ❌ Controller에서 직접 처리 금지\n            return ResponseEntity.notFound().build();\n        }\n    }\n}','java','Controller에서 직접 예외 처리 금지 - GlobalExceptionHandler 사용',NULL,NULL,NULL,'2026-01-28 14:20:24.000000','2026-01-28 14:20:24.000000',NULL),(205,196,'GOOD','@ExceptionHandler(DomainException.class)\npublic ResponseEntity<ProblemDetail> handleDomainException(DomainException ex) {\n    ProblemDetail problem = errorMapper.toProblemDetail(ex);\n    return ResponseEntity.status(problem.getStatus())\n        .contentType(MediaType.APPLICATION_PROBLEM_JSON)  // application/problem+json\n        .body(problem);\n}\n\n// HTTP Response\n// Content-Type: application/problem+json','java','에러 응답 Content-Type은 application/problem+json',NULL,NULL,NULL,'2026-01-28 14:20:24.000000','2026-01-28 14:20:24.000000',NULL),(206,196,'BAD','@ExceptionHandler(DomainException.class)\npublic ResponseEntity<ProblemDetail> handleDomainException(DomainException ex) {\n    ProblemDetail problem = errorMapper.toProblemDetail(ex);\n    return ResponseEntity.status(problem.getStatus())\n        // ❌ Content-Type 미지정 또는 application/json 사용\n        .body(problem);\n}\n\n// HTTP Response  \n// Content-Type: application/json  ❌','java','application/json 사용 금지 - problem+json 필수',NULL,NULL,NULL,'2026-01-28 14:20:24.000000','2026-01-28 14:20:24.000000',NULL),(207,186,'GOOD','@Component\npublic class OrderApiMapper {\n    \n    public CreateOrderCommand toCommand(CreateOrderRequest request) { ... }\n    public OrderResponse toResponse(Order order) { ... }\n}','java','Mapper는 @Component로 Spring Bean 등록',NULL,NULL,NULL,'2026-01-28 14:20:47.000000','2026-01-28 14:20:47.000000',NULL),(208,186,'BAD','// ❌ @Component 누락 - Bean 등록 안됨\npublic class OrderApiMapper {\n    public CreateOrderCommand toCommand(CreateOrderRequest request) { ... }\n}\n\n// ❌ static 메서드 사용 - DI 불가\npublic class OrderApiMapper {\n    public static CreateOrderCommand toCommand(CreateOrderRequest request) { ... }\n}','java','@Component 누락 또는 static 사용 시 DI 불가',NULL,NULL,NULL,'2026-01-28 14:20:47.000000','2026-01-28 14:20:47.000000',NULL),(209,187,'GOOD','@Component\npublic class OrderApiMapper {\n    \n    // Request -> Command/Query\n    public CreateOrderCommand toCommand(CreateOrderRequest request) {\n        return new CreateOrderCommand(request.customerId(), request.items());\n    }\n    \n    public GetOrderQuery toQuery(Long orderId) {\n        return new GetOrderQuery(orderId);\n    }\n    \n    // Domain/Result -> Response\n    public OrderResponse toResponse(Order order) {\n        return new OrderResponse(order.id(), order.status().name(), ...);\n    }\n    \n    public SliceApiResponse<OrderSummary> toSliceResponse(OrderSliceResult result) {\n        return SliceApiResponse.of(result.content(), result.hasNext(), result.cursor());\n    }\n}','java','Request→Command/Query, Result→Response 양방향 변환 지원',NULL,NULL,NULL,'2026-01-28 14:20:48.000000','2026-01-28 14:20:48.000000',NULL),(210,187,'BAD','@Component\npublic class OrderApiMapper {\n    // ❌ 단방향만 지원\n    public CreateOrderCommand toCommand(CreateOrderRequest request) { ... }\n    // Response 변환 메서드 누락\n}','java','양방향 변환 메서드 모두 제공 필요',NULL,NULL,NULL,'2026-01-28 14:20:48.000000','2026-01-28 14:20:48.000000',NULL),(211,188,'GOOD','@Component\npublic class OrderApiMapper {\n    \n    public OrderResponse toResponse(Order order) {\n        return new OrderResponse(\n            order.id(),\n            order.status().name(),\n            DateTimeFormatUtils.formatIso8601(order.createdAt()),\n            DateTimeFormatUtils.formatIso8601(order.updatedAt())\n        );\n    }\n}','java','Mapper에서 DateTimeFormatUtils로 날짜 포맷팅',NULL,NULL,NULL,'2026-01-28 14:21:01.000000','2026-01-28 14:21:01.000000',NULL),(212,188,'BAD','@Component\npublic class OrderApiMapper {\n    \n    public OrderResponse toResponse(Order order) {\n        return new OrderResponse(\n            order.id(),\n            order.status().name(),\n            order.createdAt().toString(),  // ❌ toString() 사용 금지\n            order.updatedAt().toString()\n        );\n    }\n}','java','Instant.toString() 직접 사용 금지 - 포맷 불일치',NULL,NULL,NULL,'2026-01-28 14:21:01.000000','2026-01-28 14:21:01.000000',NULL),(213,189,'GOOD','@Component\npublic class OrderApiMapper {\n    \n    // SliceResult -> SliceApiResponse\n    public SliceApiResponse<OrderSummaryResponse> toSliceResponse(\n            SliceResult<OrderSummary> result) {\n        List<OrderSummaryResponse> content = result.content().stream()\n            .map(this::toSummaryResponse)\n            .toList();\n        return SliceApiResponse.of(content, result.hasNext(), result.cursor());\n    }\n    \n    // PageResult -> PageApiResponse  \n    public PageApiResponse<OrderSummaryResponse> toPageResponse(\n            PageResult<OrderSummary> result) {\n        List<OrderSummaryResponse> content = result.content().stream()\n            .map(this::toSummaryResponse)\n            .toList();\n        return PageApiResponse.of(content, result.totalCount(), result.page(), result.size());\n    }\n}','java','SliceResult/PageResult를 ApiResponse로 변환하는 메서드 제공',NULL,NULL,NULL,'2026-01-28 14:21:01.000000','2026-01-28 14:21:01.000000',NULL),(214,189,'BAD','// ❌ Controller에서 직접 변환\n@GetMapping\npublic ResponseEntity<ApiResponse<SliceApiResponse<OrderSummary>>> search(...) {\n    SliceResult<OrderSummary> result = searchUseCase.execute(query);\n    // Controller에서 변환 - Mapper에 위임해야 함\n    SliceApiResponse<OrderSummary> response = SliceApiResponse.of(\n        result.content(), result.hasNext(), result.cursor()\n    );\n}','java','Slice/Page 변환은 Mapper에서 수행',NULL,NULL,NULL,'2026-01-28 14:21:01.000000','2026-01-28 14:21:01.000000',NULL),(215,190,'GOOD','@Component\npublic class OrderApiMapper {\n    \n    // 순수 변환 로직만\n    public CreateOrderCommand toCommand(CreateOrderRequest request) {\n        return new CreateOrderCommand(\n            request.customerId(),\n            request.orderName(),\n            request.items()\n        );\n    }\n}','java','Mapper는 순수 변환 로직만 담당. 비즈니스 로직 금지',NULL,NULL,NULL,'2026-01-28 14:21:16.000000','2026-01-28 14:21:16.000000',NULL),(216,190,'BAD','@Component\npublic class OrderApiMapper {\n    \n    private final OrderRepository orderRepository;  // ❌ Repository 의존 금지\n    \n    public CreateOrderCommand toCommand(CreateOrderRequest request) {\n        // ❌ 비즈니스 로직 금지\n        if (orderRepository.existsByCustomerId(request.customerId())) {\n            throw new DuplicateOrderException();\n        }\n        return new CreateOrderCommand(...);\n    }\n}','java','Mapper에서 비즈니스 로직/DB 조회 금지',NULL,NULL,NULL,'2026-01-28 14:21:16.000000','2026-01-28 14:21:16.000000',NULL),(217,191,'GOOD','@Component\npublic class OrderApiMapper {\n    \n    public SearchOrdersByOffsetQuery toQuery(SearchOrdersByOffsetRequest request) {\n        return new SearchOrdersByOffsetQuery(\n            request.status(),\n            request.customerId(),\n            request.page() != null ? request.page() : 0,        // 기본값 처리\n            request.size() != null ? request.size() : 20        // 기본값 처리\n        );\n    }\n}','java','Request null 필드의 기본값 처리는 Mapper에서 수행',NULL,NULL,NULL,'2026-01-28 14:21:16.000000','2026-01-28 14:21:16.000000',NULL),(218,191,'BAD','// ❌ Controller에서 기본값 처리\n@GetMapping\npublic ResponseEntity<...> search(SearchOrdersByOffsetRequest request) {\n    int page = request.page() != null ? request.page() : 0;  // Controller에서 처리 금지\n    int size = request.size() != null ? request.size() : 20;\n    ...\n}\n\n// ❌ DTO에서 기본값 처리\npublic record SearchOrdersByOffsetRequest(\n    String status,\n    Integer page\n) {\n    public SearchOrdersByOffsetRequest {\n        if (page == null) page = 0;  // DTO에서 처리 금지\n    }\n}','java','Controller/DTO에서 기본값 처리 금지 - Mapper 담당',NULL,NULL,NULL,'2026-01-28 14:21:16.000000','2026-01-28 14:21:16.000000',NULL),(219,205,'GOOD','@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\nclass OrderControllerIntegrationTest {\n    \n    @Autowired\n    private TestRestTemplate restTemplate;\n    \n    @Test\n    void createOrder_success() {\n        // 실제 HTTP 요청\n        ResponseEntity<ApiResponse<Long>> response = restTemplate.postForEntity(\n            \"/orders\",\n            CreateOrderApiRequestFixture.valid(),\n            new ParameterizedTypeReference<>() {}\n        );\n        \n        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.CREATED);\n    }\n}','java','TestRestTemplate으로 실제 HTTP 요청/응답 테스트',NULL,NULL,NULL,'2026-01-28 14:21:37.000000','2026-01-28 14:21:37.000000',NULL),(220,205,'BAD','// ❌ MockMvc 사용 금지\n@WebMvcTest(OrderController.class)\nclass OrderControllerTest {\n    \n    @Autowired\n    private MockMvc mockMvc;\n    \n    @Test\n    void createOrder_success() throws Exception {\n        mockMvc.perform(post(\"/orders\")\n            .contentType(MediaType.APPLICATION_JSON)\n            .content(\"...\"))\n            .andExpect(status().isCreated());\n    }\n}','java','MockMvc는 실제 서블릿 컨테이너 미사용 - 통합 테스트 부적합',NULL,NULL,NULL,'2026-01-28 14:21:37.000000','2026-01-28 14:21:37.000000',NULL),(221,206,'GOOD','@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\nclass OrderControllerIntegrationTest {\n    \n    @Autowired\n    private TestRestTemplate restTemplate;\n    \n    @LocalServerPort\n    private int port;\n    \n    @Test\n    void getOrder_success() {\n        ResponseEntity<ApiResponse<OrderResponse>> response = restTemplate.exchange(\n            \"/orders/{id}\",\n            HttpMethod.GET,\n            null,\n            new ParameterizedTypeReference<>() {},\n            1L\n        );\n        \n        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);\n        assertThat(response.getBody().data().id()).isEqualTo(1L);\n    }\n}','java','@SpringBootTest(RANDOM_PORT) + TestRestTemplate 조합',NULL,NULL,NULL,'2026-01-28 14:21:37.000000','2026-01-28 14:21:37.000000',NULL),(222,206,'BAD','// ❌ WebEnvironment 미설정\n@SpringBootTest  // webEnvironment 누락\nclass OrderControllerTest {\n    \n    @Autowired\n    private TestRestTemplate restTemplate;  // 주입 실패\n}','java','RANDOM_PORT 없이 TestRestTemplate 사용 불가',NULL,NULL,NULL,'2026-01-28 14:21:37.000000','2026-01-28 14:21:37.000000',NULL),(223,207,'GOOD','@Test\nvoid searchOrders_success() {\n    // ParameterizedTypeReference로 제네릭 응답 처리\n    ResponseEntity<ApiResponse<SliceApiResponse<OrderSummary>>> response = \n        restTemplate.exchange(\n            \"/orders\",\n            HttpMethod.GET,\n            null,\n            new ParameterizedTypeReference<ApiResponse<SliceApiResponse<OrderSummary>>>() {}\n        );\n    \n    assertThat(response.getBody().data().content()).hasSize(10);\n}','java','ApiResponse<T> 제네릭 역직렬화 시 ParameterizedTypeReference 필수',NULL,NULL,NULL,'2026-01-28 14:21:54.000000','2026-01-28 14:21:54.000000',NULL),(224,207,'BAD','@Test\nvoid searchOrders_success() {\n    // ❌ Class 타입으로 역직렬화 시 제네릭 정보 손실\n    ResponseEntity<ApiResponse> response = restTemplate.getForEntity(\n        \"/orders\",\n        ApiResponse.class  // 제네릭 타입 정보 손실\n    );\n    \n    // response.getBody().data()가 LinkedHashMap으로 반환됨\n}','java','Class 타입 사용 시 제네릭 정보 손실 - LinkedHashMap 반환',NULL,NULL,NULL,'2026-01-28 14:21:54.000000','2026-01-28 14:21:54.000000',NULL),(225,208,'GOOD','// Fixture 클래스\npublic class CreateOrderApiRequestFixture {\n    \n    public static CreateOrderApiRequest valid() {\n        return new CreateOrderApiRequest(1L, \"테스트 주문\", List.of(\n            new OrderItemRequest(100L, 2)\n        ));\n    }\n    \n    public static CreateOrderApiRequest withCustomerId(Long customerId) {\n        return new CreateOrderApiRequest(customerId, \"테스트 주문\", List.of());\n    }\n    \n    public static CreateOrderApiRequest invalid() {\n        return new CreateOrderApiRequest(null, \"\", List.of());  // 검증 실패용\n    }\n}\n\n// 테스트에서 사용\n@Test\nvoid createOrder_success() {\n    var response = restTemplate.postForEntity(\n        \"/orders\",\n        CreateOrderApiRequestFixture.valid(),\n        ...\n    );\n}','java','Fixture 클래스의 static factory 메서드로 테스트 데이터 생성',NULL,NULL,NULL,'2026-01-28 14:21:54.000000','2026-01-28 14:21:54.000000',NULL),(226,208,'BAD','@Test\nvoid createOrder_success() {\n    // ❌ 테스트 메서드 내에서 직접 객체 생성\n    CreateOrderApiRequest request = new CreateOrderApiRequest(\n        1L,\n        \"테스트 주문\",\n        List.of(new OrderItemRequest(100L, 2))\n    );\n    // 중복 코드 발생, 재사용 불가\n}','java','테스트 내 직접 생성 - 중복 코드, 재사용 불가',NULL,NULL,NULL,'2026-01-28 14:21:54.000000','2026-01-28 14:21:54.000000',NULL),(227,209,'GOOD','class OrderErrorMapperTest {\n    \n    private final OrderErrorMapper mapper = new OrderErrorMapper();\n    \n    @Test\n    void supports_orderNotFoundException_returnsTrue() {\n        var exception = new OrderNotFoundException(1L);\n        assertThat(mapper.supports(exception)).isTrue();\n    }\n    \n    @Test\n    void supports_otherException_returnsFalse() {\n        var exception = new CustomerNotFoundException(1L);\n        assertThat(mapper.supports(exception)).isFalse();\n    }\n    \n    @Test\n    void map_orderNotFoundException_returns404() {\n        var exception = new OrderNotFoundException(1L);\n        \n        ProblemDetail result = mapper.map(exception);\n        \n        assertThat(result.getStatus()).isEqualTo(404);\n        assertThat(result.getTitle()).isEqualTo(\"Order Not Found\");\n        assertThat(result.getProperties()).containsEntry(\"x-error-code\", \"ORDER_NOT_FOUND\");\n    }\n}','java','ErrorMapper의 supports() + map() 메서드 단위 테스트',NULL,NULL,NULL,'2026-01-28 14:22:09.000000','2026-01-28 14:22:09.000000',NULL),(228,209,'BAD','// ❌ ErrorMapper 테스트 누락\n// ErrorMapper가 올바른 HTTP 상태 코드를 반환하는지 검증 없음\n\n// ❌ 통합 테스트에서만 간접 테스트\n@Test\nvoid getOrder_notFound_returns404() {\n    // ErrorMapper 로직이 변경되어도 테스트 통과할 수 있음\n}','java','ErrorMapper 단위 테스트 없이 통합 테스트만 의존 - 격리 검증 불가',NULL,NULL,NULL,'2026-01-28 14:22:09.000000','2026-01-28 14:22:09.000000',NULL),(229,28,'GOOD','public class Order {\n    \n    // DB에서 복원용 팩토리 메서드 - 비즈니스 검증 없음\n    public static Order reconstitute(\n            OrderId id,\n            CustomerId customerId,\n            OrderStatus status,\n            Instant createdAt,\n            Instant updatedAt) {\n        return new Order(id, customerId, status, createdAt, updatedAt);\n    }\n    \n    private Order(OrderId id, CustomerId customerId, OrderStatus status,\n                  Instant createdAt, Instant updatedAt) {\n        this.id = id;\n        this.customerId = customerId;\n        this.status = status;\n        this.createdAt = createdAt;\n        this.updatedAt = updatedAt;\n    }\n}','java','reconstitute()는 DB 복원용. 비즈니스 검증 없이 필드 할당만 수행',NULL,NULL,NULL,'2026-01-28 14:24:28.000000','2026-01-28 14:24:28.000000',NULL),(230,28,'BAD','public class Order {\n    \n    // ❌ reconstitute 없이 생성자만 사용\n    public Order(OrderId id, CustomerId customerId, OrderStatus status) {\n        // 비즈니스 검증이 포함되면 DB 복원 시 문제 발생\n        if (status == OrderStatus.CANCELLED) {\n            throw new IllegalStateException();\n        }\n    }\n}','java','reconstitute 없으면 DB 복원 시 비즈니스 검증으로 인한 오류 발생',NULL,NULL,NULL,'2026-01-28 14:24:28.000000','2026-01-28 14:24:28.000000',NULL),(231,29,'GOOD','public class Order {\n    \n    // JPA/직렬화 프레임워크용 기본 생성자\n    protected Order() {\n        // 외부 직접 호출 방지\n    }\n    \n    public static Order forNew(...) { ... }\n    public static Order reconstitute(...) { ... }\n}','java','protected 기본 생성자로 프레임워크 지원 + 외부 호출 방지',NULL,NULL,NULL,'2026-01-28 14:24:28.000000','2026-01-28 14:24:28.000000',NULL),(232,29,'BAD','public class Order {\n    \n    // ❌ public 기본 생성자 - 무분별한 생성 가능\n    public Order() { }\n    \n    // ❌ 기본 생성자 없음 - JPA 프록시 생성 불가\n}','java','public 기본 생성자는 무분별한 생성 허용, 없으면 JPA 오류',NULL,NULL,NULL,'2026-01-28 14:24:28.000000','2026-01-28 14:24:28.000000',NULL),(233,30,'GOOD','public class Order {\n    \n    private final OrderId id;        // ID VO 사용\n    private final CustomerId customerId;  // 관계 ID도 VO\n    \n    public static Order forNew(CustomerId customerId, Instant now) {\n        return new Order(OrderId.generate(), customerId, now);\n    }\n    \n    public OrderId id() { return id; }\n    public Long idValue() { return id.value(); }  // 원시값 반환 편의 메서드\n}\n\n// ID VO (domain/{bc}/id 패키지)\npublic record OrderId(Long value) {\n    public static OrderId generate() {\n        return new OrderId(null);  // DB 시퀀스 사용 시\n    }\n    public boolean isNew() { return value == null; }\n}','java','ID는 전용 VO 사용. domain/{bc}/id 패키지에 위치',NULL,NULL,NULL,'2026-01-28 14:24:43.000000','2026-01-28 14:24:43.000000',NULL),(234,30,'BAD','public class Order {\n    \n    private final Long id;           // ❌ 원시 타입 금지\n    private final Long customerId;   // ❌ 원시 타입 금지\n    \n    public Long getId() { return id; }\n}','java','원시 타입 ID는 타입 안전성 없음. OrderId와 CustomerId 혼동 가능',NULL,NULL,NULL,'2026-01-28 14:24:43.000000','2026-01-28 14:24:43.000000',NULL),(235,31,'GOOD','public class Order {\n    \n    private final OrderId id;\n    \n    public boolean isNew() {\n        return id.isNew();  // ID VO에 위임\n    }\n}\n\n// ID VO\npublic record OrderId(Long value) {\n    public boolean isNew() {\n        return value == null;\n    }\n}','java','isNew()로 신규 생성 객체 판단. persist/merge 구분에 사용',NULL,NULL,NULL,'2026-01-28 14:24:43.000000','2026-01-28 14:24:43.000000',NULL),(236,31,'BAD','public class Order {\n    \n    private final OrderId id;\n    \n    // ❌ isNew() 메서드 없음\n    // CommandPort에서 신규/수정 판단 불가\n}','java','isNew() 없으면 persist/merge 구분 불가',NULL,NULL,NULL,'2026-01-28 14:24:43.000000','2026-01-28 14:24:43.000000',NULL),(237,32,'GOOD','public class Order {\n    \n    private final Instant createdAt;\n    private Instant updatedAt;\n    private Instant cancelledAt;\n    private Instant expiredAt;\n    \n    // 모든 시간 필드는 java.time.Instant 사용\n}','java','모든 시간 필드는 Instant 타입 사용. 타임존 독립적 시점 표현',NULL,NULL,NULL,'2026-01-28 14:25:02.000000','2026-01-28 14:25:02.000000',NULL),(238,32,'BAD','public class Order {\n    \n    // ❌ LocalDateTime 금지 - 타임존 정보 없음\n    private final LocalDateTime createdAt;\n    \n    // ❌ LocalDate 금지\n    private LocalDate cancelledDate;\n    \n    // ❌ java.util.Date 금지 - 레거시 API\n    private Date expiredAt;\n}','java','LocalDateTime/LocalDate/Date 금지. 타임존 처리 일관성 문제',NULL,NULL,NULL,'2026-01-28 14:25:02.000000','2026-01-28 14:25:02.000000',NULL),(239,33,'GOOD','public class Order {\n    \n    public static Order forNew(CustomerId customerId, Instant createdAt) {\n        return new Order(OrderId.generate(), customerId, createdAt, createdAt);\n    }\n    \n    public void cancel(Instant cancelledAt) {\n        this.status = OrderStatus.CANCELLED;\n        this.cancelledAt = cancelledAt;\n        this.updatedAt = cancelledAt;\n    }\n}','java','시간은 파라미터로 주입. Factory/Service에서 TimeProvider 사용',NULL,NULL,NULL,'2026-01-28 14:25:02.000000','2026-01-28 14:25:02.000000',NULL),(240,33,'BAD','public class Order {\n    \n    public static Order forNew(CustomerId customerId) {\n        Instant now = Instant.now();  // ❌ 내부에서 직접 호출 금지\n        return new Order(OrderId.generate(), customerId, now, now);\n    }\n    \n    public void cancel() {\n        this.cancelledAt = System.currentTimeMillis();  // ❌ 금지\n    }\n}','java','Instant.now() 직접 호출 시 테스트 불가, 시간 제어 불가',NULL,NULL,NULL,'2026-01-28 14:25:02.000000','2026-01-28 14:25:02.000000',NULL),(241,34,'GOOD','public class Order {\n    \n    private Instant updatedAt;\n    \n    public void updateAddress(Address newAddress, Instant updatedAt) {\n        this.address = newAddress;\n        this.updatedAt = updatedAt;  // 상태 변경 시 updatedAt 갱신\n    }\n    \n    public void cancel(Instant cancelledAt) {\n        this.status = OrderStatus.CANCELLED;\n        this.cancelledAt = cancelledAt;\n        this.updatedAt = cancelledAt;  // 상태 변경 시 updatedAt 갱신\n    }\n}','java','모든 상태 변경 메서드에서 updatedAt 갱신 필수',NULL,NULL,NULL,'2026-01-28 14:25:02.000000','2026-01-28 14:25:02.000000',NULL),(242,34,'BAD','public class Order {\n    \n    public void updateAddress(Address newAddress) {\n        this.address = newAddress;\n        // ❌ updatedAt 갱신 누락\n    }\n}','java','updatedAt 미갱신 시 변경 이력 추적 불가',NULL,NULL,NULL,'2026-01-28 14:25:02.000000','2026-01-28 14:25:02.000000',NULL),(243,36,'GOOD','public class Order {\n    \n    // 필수 Getter만 제공\n    public OrderId id() { return id; }\n    public Long idValue() { return id.value(); }\n    \n    // 상태 조회 대신 판단 메서드 제공\n    public boolean isCancellable() {\n        return status == OrderStatus.PENDING;\n    }\n    \n    public boolean isCompleted() {\n        return status == OrderStatus.COMPLETED;\n    }\n}','java','Getter 최소화. 상태 판단은 Aggregate가 직접 메서드로 제공',NULL,NULL,NULL,'2026-01-28 14:25:28.000000','2026-01-28 14:25:28.000000',NULL),(244,36,'BAD','public class Order {\n    \n    // ❌ 모든 필드에 Getter - 캡슐화 위반\n    public OrderStatus getStatus() { return status; }\n    public CustomerId getCustomerId() { return customerId; }\n    public Address getAddress() { return address; }\n    public List<OrderItem> getItems() { return items; }\n    // ... 모든 필드 노출\n}','java','모든 필드 Getter 노출 - 외부에서 상태 판단하게 됨',NULL,NULL,NULL,'2026-01-28 14:25:28.000000','2026-01-28 14:25:28.000000',NULL),(245,38,'GOOD','public class Order {\n    \n    // Aggregate에게 판단 위임\n    public void cancelIfPending(Instant cancelledAt) {\n        if (status != OrderStatus.PENDING) {\n            throw new OrderCannotBeCancelledException(id);\n        }\n        this.status = OrderStatus.CANCELLED;\n        this.cancelledAt = cancelledAt;\n        this.updatedAt = cancelledAt;\n    }\n}\n\n// Service 호출\norder.cancelIfPending(now);','java','Aggregate가 상태 판단 + 행동을 함께 수행',NULL,NULL,NULL,'2026-01-28 14:25:28.000000','2026-01-28 14:25:28.000000',NULL),(246,38,'BAD','// ❌ 외부에서 상태 조회 후 판단\nif (order.getStatus() == OrderStatus.PENDING) {\n    order.cancel(now);\n} else {\n    throw new OrderCannotBeCancelledException();\n}','java','외부에서 상태 조회 후 판단 - 비즈니스 로직 분산',NULL,NULL,NULL,'2026-01-28 14:25:28.000000','2026-01-28 14:25:28.000000',NULL),(247,39,'GOOD','public class Order {\n    \n    private Money totalAmount;\n    private final List<OrderItem> items;\n    \n    public void recalculateTotal() {\n        // 복잡한 계산은 VO에 위임\n        this.totalAmount = items.stream()\n            .map(OrderItem::subtotal)\n            .reduce(Money.ZERO, Money::add);\n    }\n}\n\n// VO에서 계산 로직 담당\npublic record Money(BigDecimal amount, Currency currency) {\n    public Money add(Money other) {\n        return new Money(amount.add(other.amount), currency);\n    }\n}','java','복잡한 계산/규칙은 VO로 추출. Aggregate는 조율만',NULL,NULL,NULL,'2026-01-28 14:25:49.000000','2026-01-28 14:25:49.000000',NULL),(248,39,'BAD','public class Order {\n    \n    public void recalculateTotal() {\n        // ❌ Aggregate에서 복잡한 계산 직접 수행\n        BigDecimal total = BigDecimal.ZERO;\n        for (OrderItem item : items) {\n            BigDecimal price = item.getPrice();\n            int qty = item.getQuantity();\n            BigDecimal discount = calculateDiscount(price, qty);\n            total = total.add(price.multiply(BigDecimal.valueOf(qty)).subtract(discount));\n        }\n        // ... 복잡한 로직이 Aggregate에 집중\n    }\n}','java','Aggregate에 복잡한 계산 로직 직접 구현 - 응집도 저하',NULL,NULL,NULL,'2026-01-28 14:25:49.000000','2026-01-28 14:25:49.000000',NULL),(249,40,'GOOD','public class Order {\n    \n    public void complete(Instant completedAt) {\n        this.status = OrderStatus.COMPLETED;\n        this.completedAt = completedAt;\n        this.updatedAt = completedAt;\n        \n        // 중요한 상태 변경 시 이벤트 등록\n        registerEvent(new OrderCompletedEvent(id, completedAt));\n    }\n    \n    public void cancel(Instant cancelledAt) {\n        this.status = OrderStatus.CANCELLED;\n        this.cancelledAt = cancelledAt;\n        this.updatedAt = cancelledAt;\n        \n        registerEvent(new OrderCancelledEvent(id, cancelledAt));\n    }\n}','java','중요한 상태 변경 시 도메인 이벤트 발행으로 부수 효과 처리',NULL,NULL,NULL,'2026-01-28 14:25:49.000000','2026-01-28 14:25:49.000000',NULL),(250,40,'BAD','public class Order {\n    \n    public void complete(Instant completedAt) {\n        this.status = OrderStatus.COMPLETED;\n        // ❌ 이벤트 발행 없음 - 후속 처리 불가\n    }\n}','java','이벤트 없이 상태 변경만 - 알림, 통계 등 후속 처리 누락',NULL,NULL,NULL,'2026-01-28 14:25:49.000000','2026-01-28 14:25:49.000000',NULL),(251,41,'GOOD','public abstract class AggregateRoot<ID> {\n    \n    private final List<DomainEvent> events = new ArrayList<>();\n    \n    protected void registerEvent(DomainEvent event) {\n        events.add(event);\n    }\n    \n    public List<DomainEvent> pollEvents() {\n        List<DomainEvent> result = List.copyOf(events);\n        events.clear();\n        return result;\n    }\n}\n\npublic class Order extends AggregateRoot<OrderId> {\n    \n    public void cancel(Instant cancelledAt) {\n        this.status = OrderStatus.CANCELLED;\n        registerEvent(new OrderCancelledEvent(id, cancelledAt));  // protected 호출\n    }\n}','java','registerEvent()는 protected로 Aggregate 내부에서만 호출',NULL,NULL,NULL,'2026-01-28 14:26:06.000000','2026-01-28 14:26:06.000000',NULL),(252,41,'BAD','public class Order {\n    \n    // ❌ public으로 외부에서 이벤트 등록 가능\n    public void registerEvent(DomainEvent event) {\n        events.add(event);\n    }\n}\n\n// 외부에서 직접 이벤트 등록 - 캡슐화 위반\norder.registerEvent(new OrderCompletedEvent(...));','java','public registerEvent()는 외부에서 무분별한 이벤트 등록 허용',NULL,NULL,NULL,'2026-01-28 14:26:06.000000','2026-01-28 14:26:06.000000',NULL),(253,42,'GOOD','public abstract class AggregateRoot<ID> {\n    \n    private final List<DomainEvent> events = new ArrayList<>();\n    \n    public List<DomainEvent> pollEvents() {\n        List<DomainEvent> result = List.copyOf(events);\n        events.clear();  // 수확 후 비우기\n        return result;\n    }\n}\n\n// Manager에서 이벤트 수확 및 발행\n@Transactional\npublic void completeOrder(Order order) {\n    order.complete(now);\n    orderCommandPort.persist(order);\n    \n    // 이벤트 수확 및 등록\n    order.pollEvents().forEach(eventRegistry::register);\n}','java','pollEvents()로 이벤트 수확. 호출 후 내부 목록 비움',NULL,NULL,NULL,'2026-01-28 14:26:06.000000','2026-01-28 14:26:06.000000',NULL),(254,42,'BAD','public class Order {\n    \n    // ❌ getEvents()로 이름 - poll 의미 없음\n    public List<DomainEvent> getEvents() {\n        return events;  // 원본 반환 + 비우기 안함\n    }\n}','java','getEvents()는 poll 의미 불명확. 원본 노출 위험',NULL,NULL,NULL,'2026-01-28 14:26:06.000000','2026-01-28 14:26:06.000000',NULL),(255,43,'GOOD','public class Order {\n    \n    // Command 메서드 - 동사로 시작\n    public void cancel(Instant cancelledAt) { }\n    public void approve(Instant approvedAt) { }\n    public void updateAddress(Address address, Instant updatedAt) { }\n    public void changeStatus(OrderStatus status, Instant changedAt) { }\n    public void addItem(OrderItem item, Instant updatedAt) { }\n    public void removeItem(OrderItemId itemId, Instant updatedAt) { }\n}','java','Command 메서드는 cancel, approve, update, change, add 등 동사로 시작',NULL,NULL,NULL,'2026-01-28 14:26:26.000000','2026-01-28 14:26:26.000000',NULL),(256,43,'BAD','public class Order {\n    \n    // ❌ 동사가 아닌 이름\n    public void cancellation(Instant at) { }     // 명사형\n    public void statusChange(Status s) { }       // 명사형\n    public void itemAddition(Item item) { }      // 명사형\n}','java','명사형 메서드명은 의도 불명확',NULL,NULL,NULL,'2026-01-28 14:26:26.000000','2026-01-28 14:26:26.000000',NULL),(257,44,'GOOD','public class Order {\n    \n    // Query 메서드 - get/is/has/can으로 시작\n    public OrderStatus getStatus() { return status; }\n    public boolean isCompleted() { return status == OrderStatus.COMPLETED; }\n    public boolean hasItems() { return !items.isEmpty(); }\n    public boolean canBeCancelled() { return status == OrderStatus.PENDING; }\n}','java','Query 메서드는 get(값 반환), is/has/can(boolean 반환)으로 시작',NULL,NULL,NULL,'2026-01-28 14:26:26.000000','2026-01-28 14:26:26.000000',NULL),(258,44,'BAD','public class Order {\n    \n    // ❌ 잘못된 Query 메서드 네이밍\n    public OrderStatus status() { }          // get 누락\n    public boolean completed() { }           // is 누락\n    public boolean itemsExist() { }          // has 대신 exist\n    public boolean cancellable() { }         // can 누락\n}','java','Query 메서드 접두사 누락 - 의도 불명확',NULL,NULL,NULL,'2026-01-28 14:26:26.000000','2026-01-28 14:26:26.000000',NULL),(259,45,'GOOD','public class Order {\n    \n    // is/has/can 메서드는 반드시 boolean 반환\n    public boolean isActive() { return status.isActive(); }\n    public boolean hasDiscount() { return discount != null && discount.isPositive(); }\n    public boolean canShip() { return status == OrderStatus.PAID && address != null; }\n}','java','is/has/can 접두사 메서드는 반드시 boolean 반환',NULL,NULL,NULL,'2026-01-28 14:26:26.000000','2026-01-28 14:26:26.000000',NULL),(260,45,'BAD','public class Order {\n    \n    // ❌ is/has/can인데 boolean이 아닌 반환\n    public OrderStatus isActive() { return status; }    // boolean 아님\n    public Discount hasDiscount() { return discount; }  // boolean 아님\n    public String canShip() { return \"yes\"; }          // boolean 아님\n}','java','is/has/can인데 boolean 아닌 반환 - 혼란 유발',NULL,NULL,NULL,'2026-01-28 14:26:26.000000','2026-01-28 14:26:26.000000',NULL),(261,48,'GOOD','public class Order {\n    \n    public static Order forNew(CustomerId customerId, List<OrderItem> items, Instant now) {\n        // 생성 시점 불변식 검증\n        if (items == null || items.isEmpty()) {\n            throw new OrderMustHaveItemsException();\n        }\n        return new Order(OrderId.generate(), customerId, items, now);\n    }\n    \n    public void addItem(OrderItem item, Instant updatedAt) {\n        // 상태 변경 시점 불변식 검증\n        if (status != OrderStatus.PENDING) {\n            throw new OrderNotModifiableException(id);\n        }\n        items.add(item);\n        this.updatedAt = updatedAt;\n    }\n}','java','생성 시점과 상태 변경 시점에 불변식 검증 필수',NULL,NULL,NULL,'2026-01-28 14:26:48.000000','2026-01-28 14:26:48.000000',NULL),(262,48,'BAD','public class Order {\n    \n    public static Order forNew(CustomerId customerId, List<OrderItem> items) {\n        // ❌ 불변식 검증 없이 생성\n        return new Order(OrderId.generate(), customerId, items);\n    }\n    \n    public void addItem(OrderItem item) {\n        // ❌ 상태 검증 없이 변경 허용\n        items.add(item);\n    }\n}','java','불변식 검증 없으면 유효하지 않은 상태 허용',NULL,NULL,NULL,'2026-01-28 14:26:48.000000','2026-01-28 14:26:48.000000',NULL),(263,49,'GOOD','public class Order {\n    \n    private final OrderId id;\n    \n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof Order order)) return false;\n        return Objects.equals(id, order.id);  // ID만 비교\n    }\n    \n    @Override\n    public int hashCode() {\n        return Objects.hash(id);  // ID만 사용\n    }\n}','java','Aggregate 동등성은 ID 기반. 모든 필드 비교 금지',NULL,NULL,NULL,'2026-01-28 14:26:48.000000','2026-01-28 14:26:48.000000',NULL),(264,49,'BAD','public class Order {\n    \n    @Override\n    public boolean equals(Object o) {\n        if (!(o instanceof Order order)) return false;\n        // ❌ 모든 필드 비교 - 상태 변경 시 동등성 깨짐\n        return Objects.equals(id, order.id) &&\n               Objects.equals(status, order.status) &&\n               Objects.equals(items, order.items);\n    }\n}','java','모든 필드 비교 시 상태 변경되면 동등성 깨짐',NULL,NULL,NULL,'2026-01-28 14:26:48.000000','2026-01-28 14:26:48.000000',NULL),(265,50,'GOOD','public class Order {\n    \n    private final OrderId id;          // final - 변경 불가\n    private final CustomerId customerId;  // final - 변경 불가\n    private final Instant createdAt;   // final - 변경 불가\n    \n    private OrderStatus status;        // 가변 - final 아님\n    private Instant updatedAt;         // 가변 - final 아님\n}','java','생성 후 변경 없는 필드는 final로 불변성 보장',NULL,NULL,NULL,'2026-01-28 14:26:48.000000','2026-01-28 14:26:48.000000',NULL),(266,50,'BAD','public class Order {\n    \n    private OrderId id;            // ❌ final 누락\n    private CustomerId customerId; // ❌ final 누락\n    private Instant createdAt;     // ❌ final 누락\n}','java','final 없으면 의도치 않은 변경 가능',NULL,NULL,NULL,'2026-01-28 14:26:48.000000','2026-01-28 14:26:48.000000',NULL),(267,224,'GOOD','public class User {\n    \n    private final UserId id;\n    private final Email email;              // VO 사용\n    private final PhoneNumber phoneNumber;  // VO 사용\n    private final HashedPassword password;  // VO 사용\n    \n    public static User forNew(Email email, PhoneNumber phone, HashedPassword pwd, Instant now) {\n        return new User(UserId.generate(), email, phone, pwd, now);\n    }\n}\n\n// VO는 Compact Constructor에서 검증\npublic record Email(String value) {\n    public Email {\n        if (value == null || !value.contains(\"@\")) {\n            throw new InvalidEmailException(value);\n        }\n    }\n}','java','필수 도메인 값은 VO로 타입 안전성 + 검증 로직 캡슐화',NULL,NULL,NULL,'2026-01-28 14:27:06.000000','2026-01-28 14:27:06.000000',NULL),(268,224,'BAD','public class User {\n    \n    private final Long id;\n    private final String email;        // ❌ 원시 타입 - 검증 없음\n    private final String phoneNumber;  // ❌ 원시 타입\n    private final String password;     // ❌ 원시 타입\n}','java','원시 타입 사용 - 타입 안전성 없음, 검증 로직 분산',NULL,NULL,NULL,'2026-01-28 14:27:06.000000','2026-01-28 14:27:06.000000',NULL),(269,225,'GOOD','public class Order {\n    \n    public static Order forNew(CustomerId customerId, OrderName name, Instant now) {\n        // null 체크 없이 VO에 위임\n        // VO Compact Constructor에서 검증됨\n        return new Order(OrderId.generate(), customerId, name, now);\n    }\n    \n    public void updateName(OrderName newName, Instant updatedAt) {\n        // null 체크 없음 - VO가 이미 검증됨\n        this.name = newName;\n        this.updatedAt = updatedAt;\n    }\n}','java','Aggregate는 null 체크 안함. VO 생성 시점에 이미 검증됨',NULL,NULL,NULL,'2026-01-28 14:27:06.000000','2026-01-28 14:27:06.000000',NULL),(270,225,'BAD','public class Order {\n    \n    public static Order forNew(CustomerId customerId, OrderName name) {\n        // ❌ Aggregate에서 null 체크 - 중복 검증\n        if (customerId == null) {\n            throw new IllegalArgumentException(\"customerId is null\");\n        }\n        if (name == null) {\n            throw new IllegalArgumentException(\"name is null\");\n        }\n        return new Order(...);\n    }\n}','java','Aggregate에서 null 체크 - VO 검증과 중복',NULL,NULL,NULL,'2026-01-28 14:27:06.000000','2026-01-28 14:27:06.000000',NULL),(271,226,'GOOD','// UpdateData - null 체크 없이 VO만 보유\npublic record OrderUpdateData(\n    OrderName name,\n    Address address,\n    Memo memo\n) {\n    // Compact Constructor 없음 또는 단순 복사만\n    // VO들은 이미 생성 시점에 검증 완료\n}\n\n// Aggregate에서 사용\npublic void update(OrderUpdateData data, Instant updatedAt) {\n    this.name = data.name();\n    this.address = data.address();\n    this.memo = data.memo();\n    this.updatedAt = updatedAt;\n}','java','UpdateData는 검증된 VO만 보유. null 체크 불필요',NULL,NULL,NULL,'2026-01-28 14:27:26.000000','2026-01-28 14:27:26.000000',NULL),(272,226,'BAD','public record OrderUpdateData(\n    OrderName name,\n    Address address\n) {\n    public OrderUpdateData {\n        // ❌ UpdateData에서 null 체크 - 중복\n        if (name == null) {\n            throw new IllegalArgumentException();\n        }\n        if (address == null) {\n            throw new IllegalArgumentException();\n        }\n    }\n}','java','UpdateData에서 null 체크 - VO 검증과 중복',NULL,NULL,NULL,'2026-01-28 14:27:26.000000','2026-01-28 14:27:26.000000',NULL),(273,227,'GOOD','public class Order {\n    \n    private final OrderId id;\n    private final Email email;\n    \n    // VO 반환\n    public OrderId id() { return id; }\n    public Email email() { return email; }\n    \n    // 원시값 반환 편의 메서드 (Law of Demeter 준수)\n    public Long idValue() { return id.value(); }\n    public String emailValue() { return email.value(); }\n}\n\n// 사용 측 - 체이닝 불필요\nLong orderId = order.idValue();  // order.id().value() 대신','java','VO 반환 + 원시값 편의 메서드로 체이닝 호출 방지',NULL,NULL,NULL,'2026-01-28 14:27:26.000000','2026-01-28 14:27:26.000000',NULL),(274,227,'BAD','public class Order {\n    \n    private final OrderId id;\n    private final Email email;\n    \n    // VO만 반환\n    public OrderId id() { return id; }\n    public Email email() { return email; }\n    \n    // ❌ 원시값 편의 메서드 없음\n}\n\n// 사용 측 - 체이닝 필요 (Law of Demeter 위반)\nLong orderId = order.id().value();\nString emailStr = order.email().value();','java','원시값 편의 메서드 없으면 외부에서 체이닝 필요',NULL,NULL,NULL,'2026-01-28 14:27:26.000000','2026-01-28 14:27:26.000000',NULL),(275,53,'GOOD','public record Email(String value) {\n    \n    public Email {\n        // Compact Constructor에서 검증\n        if (value == null || value.isBlank()) {\n            throw new InvalidEmailException(\"Email cannot be null or blank\");\n        }\n        if (!value.contains(\"@\")) {\n            throw new InvalidEmailException(\"Invalid email format: \" + value);\n        }\n        value = value.toLowerCase().trim();  // 정규화\n    }\n    \n    public static Email of(String value) {\n        return new Email(value);\n    }\n}','java','Compact Constructor에서 null 체크, 유효성 검증, 정규화 수행',NULL,NULL,NULL,'2026-01-28 14:27:58.000000','2026-01-28 14:27:58.000000',NULL),(276,53,'BAD','public record Email(String value) {\n    // ❌ Compact Constructor 없음 - 검증 없이 생성\n    \n    public static Email of(String value) {\n        return new Email(value);  // null, 빈 값 허용됨\n    }\n}','java','Compact Constructor 없으면 유효하지 않은 VO 생성 가능',NULL,NULL,NULL,'2026-01-28 14:27:58.000000','2026-01-28 14:27:58.000000',NULL),(277,54,'GOOD','public enum OrderStatus {\n    PENDING(\"대기중\"),\n    CONFIRMED(\"확정됨\"),\n    SHIPPED(\"배송중\"),\n    COMPLETED(\"완료\"),\n    CANCELLED(\"취소됨\");\n    \n    private final String displayName;\n    \n    OrderStatus(String displayName) {\n        this.displayName = displayName;\n    }\n    \n    public String displayName() {\n        return displayName;\n    }\n}','java','Enum은 displayName()으로 사용자 표시용 문자열 제공',NULL,NULL,NULL,'2026-01-28 14:27:58.000000','2026-01-28 14:27:58.000000',NULL),(278,54,'BAD','public enum OrderStatus {\n    PENDING,\n    CONFIRMED,\n    SHIPPED;\n    \n    // ❌ displayName() 없음\n    // UI에서 PENDING 그대로 노출\n}','java','displayName 없으면 영문 상수명이 UI에 노출',NULL,NULL,NULL,'2026-01-28 14:27:58.000000','2026-01-28 14:27:58.000000',NULL),(279,55,'GOOD','// LockKey 인터페이스\npublic interface LockKey {\n    String getLockKey();\n}\n\n// ID VO에서 구현\npublic record OrderId(Long value) implements LockKey {\n    \n    @Override\n    public String getLockKey() {\n        return \"order:\" + value;\n    }\n    \n    public boolean isNew() { return value == null; }\n}\n\n// 분산락 사용\nlockManager.executeWithLock(orderId, () -> {\n    // 동시성 제어가 필요한 로직\n});','java','분산락 필요 시 LockKey 구현. getLockKey()로 락 키 제공',NULL,NULL,NULL,'2026-01-28 14:28:13.000000','2026-01-28 14:28:13.000000',NULL),(280,55,'BAD','// ❌ 문자열 직접 생성 - 일관성 없음\nString lockKey = \"order:\" + orderId.value();\nlockManager.executeWithLock(lockKey, () -> { ... });\n\n// 다른 곳에서 다른 형식\nString lockKey2 = \"ORDER_\" + orderId.value();  // 형식 불일치','java','락 키 직접 생성 시 형식 불일치 위험',NULL,NULL,NULL,'2026-01-28 14:28:13.000000','2026-01-28 14:28:13.000000',NULL),(281,56,'GOOD','// CacheKey 인터페이스\npublic interface CacheKey {\n    String getCacheKey();\n}\n\n// ID VO에서 구현\npublic record UserId(Long value) implements CacheKey {\n    \n    @Override\n    public String getCacheKey() {\n        return \"user:\" + value;\n    }\n}\n\n// 캐시 사용\ncacheManager.get(userId, () -> userRepository.findById(userId));','java','캐싱 필요 시 CacheKey 구현. getCacheKey()로 캐시 키 제공',NULL,NULL,NULL,'2026-01-28 14:28:13.000000','2026-01-28 14:28:13.000000',NULL),(282,56,'BAD','// ❌ 캐시 키 직접 생성 - 일관성 없음\nString cacheKey = \"user:\" + userId.value();\ncacheManager.get(cacheKey, () -> ...);\n\n// 다른 곳에서 다른 형식\nString cacheKey2 = \"USER_CACHE_\" + userId.value();  // 형식 불일치','java','캐시 키 직접 생성 시 형식 불일치, 오타 위험',NULL,NULL,NULL,'2026-01-28 14:28:13.000000','2026-01-28 14:28:13.000000',NULL),(283,60,'GOOD','public record OrderId(Long value) {\n    public static OrderId of(Long value) {\n        return new OrderId(value);\n    }\n}\n\npublic record MemberId(Long value) {\n    public static MemberId of(Long value) {\n        return new MemberId(value);\n    }\n}','java','ID VO는 반드시 *Id 형식으로 네이밍 (OrderId, MemberId)',NULL,NULL,NULL,'2026-01-28 14:30:28.000000','2026-01-28 14:30:28.000000',NULL),(284,60,'BAD','// 잘못된 네이밍\npublic record OrderIdentifier(Long value) { }\npublic record OrderID(Long value) { }  // 대문자 ID\npublic record Order_Id(Long value) { } // 언더스코어\npublic record Orderid(Long value) { }  // 소문자 id','java','ID VO 네이밍 규칙 위반 - 반드시 *Id 패턴 준수',NULL,NULL,NULL,'2026-01-28 14:30:28.000000','2026-01-28 14:30:28.000000',NULL),(285,63,'GOOD','public record OrderId(Long value) {\n    // 새 엔티티용 팩토리 메서드\n    public static OrderId forNew() {\n        return new OrderId(null);\n    }\n    \n    // 기존 엔티티용 팩토리 메서드\n    public static OrderId of(Long value) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"ID value cannot be null for existing entity\");\n        }\n        return new OrderId(value);\n    }\n    \n    public boolean isNew() {\n        return value == null;\n    }\n}','java','Long 기반 ID VO는 forNew() 메서드 필수 - 새 엔티티 생성 시 사용',NULL,NULL,NULL,'2026-01-28 14:30:28.000000','2026-01-28 14:30:28.000000',NULL),(286,63,'BAD','public record OrderId(Long value) {\n    // forNew() 메서드 누락!\n    public static OrderId of(Long value) {\n        return new OrderId(value);\n    }\n}\n\n// 사용 시 문제 발생\nOrderId orderId = OrderId.of(null); // 의도가 불명확','java','forNew() 메서드 누락 - 새 엔티티 생성 의도가 명확하지 않음',NULL,NULL,NULL,'2026-01-28 14:30:28.000000','2026-01-28 14:30:28.000000',NULL),(287,64,'GOOD','public record OrderId(Long value) {\n    public static OrderId forNew() {\n        return new OrderId(null);  // null 반환 - DB에서 ID 할당\n    }\n    \n    public boolean isNew() {\n        return value == null;\n    }\n}\n\n// 사용 예시\nOrder order = Order.create(\n    OrderId.forNew(),  // null ID - 새 엔티티\n    memberId,\n    items\n);\n// persist 후 DB에서 ID 할당됨','java','forNew()는 null을 반환하여 DB의 auto-increment ID 할당을 위임',NULL,NULL,NULL,'2026-01-28 14:30:28.000000','2026-01-28 14:30:28.000000',NULL),(288,64,'BAD','public record OrderId(Long value) {\n    private static final AtomicLong counter = new AtomicLong(0);\n    \n    public static OrderId forNew() {\n        return new OrderId(counter.incrementAndGet());  // 임의 ID 생성 - 금지!\n    }\n}\n\n// 또 다른 잘못된 예\npublic static OrderId forNew() {\n    return new OrderId(-1L);  // 임시값 사용 - 금지!\n}','java','forNew()에서 임의 ID 생성 금지 - ID는 DB에서 할당',NULL,NULL,NULL,'2026-01-28 14:30:28.000000','2026-01-28 14:30:28.000000',NULL),(289,65,'GOOD','public record OrderId(Long value) {\n    public static OrderId forNew() {\n        return new OrderId(null);\n    }\n    \n    public static OrderId of(Long value) {\n        return new OrderId(Objects.requireNonNull(value));\n    }\n    \n    // isNew() 메서드 필수\n    public boolean isNew() {\n        return value == null;\n    }\n}\n\n// 사용 예시 - Repository에서\npublic Order save(Order order) {\n    if (order.getId().isNew()) {\n        return insert(order);  // INSERT\n    }\n    return update(order);  // UPDATE\n}','java','Long 기반 ID는 isNew() 메서드로 신규/기존 엔티티 구분',NULL,NULL,NULL,'2026-01-28 14:30:47.000000','2026-01-28 14:30:47.000000',NULL),(290,65,'BAD','public record OrderId(Long value) {\n    public static OrderId forNew() {\n        return new OrderId(null);\n    }\n    // isNew() 메서드 누락!\n}\n\n// 사용 시 문제 - 직접 null 체크 필요\nif (order.getId().value() == null) {  // 캡슐화 위반\n    insert(order);\n}','java','isNew() 누락 시 외부에서 직접 null 체크 필요 - 캡슐화 위반',NULL,NULL,NULL,'2026-01-28 14:30:47.000000','2026-01-28 14:30:47.000000',NULL),(291,66,'GOOD','public record PaymentId(String value) {\n    public PaymentId {\n        Objects.requireNonNull(value, \"PaymentId cannot be null\");\n        if (value.isBlank()) {\n            throw new IllegalArgumentException(\"PaymentId cannot be blank\");\n        }\n    }\n    \n    public static PaymentId of(String value) {\n        return new PaymentId(value);\n    }\n    \n    // isNew() 메서드 없음 - String ID는 항상 값이 있음\n}','java','String 기반 ID는 생성 시 항상 값이 존재 - isNew() 불필요',NULL,NULL,NULL,'2026-01-28 14:30:47.000000','2026-01-28 14:30:47.000000',NULL),(292,66,'BAD','public record PaymentId(String value) {\n    public static PaymentId forNew() {\n        return new PaymentId(null);  // 금지! String ID는 null 허용 안됨\n    }\n    \n    public boolean isNew() {\n        return value == null;  // 금지! String ID에는 isNew() 불필요\n    }\n}','java','String ID에 isNew() 메서드 금지 - String ID는 외부에서 주입받아 항상 값 존재',NULL,NULL,NULL,'2026-01-28 14:30:47.000000','2026-01-28 14:30:47.000000',NULL),(293,67,'GOOD','public record PaymentId(String value) {\n    public PaymentId {\n        Objects.requireNonNull(value);\n    }\n    \n    public static PaymentId of(String value) {\n        return new PaymentId(value);\n    }\n}\n\n// 사용 예시 - 외부 시스템에서 ID 주입\npublic class PaymentService {\n    public Payment processPayment(PaymentCommand command) {\n        // 외부 PG사에서 받은 ID 사용\n        PaymentId paymentId = PaymentId.of(command.pgTransactionId());\n        return Payment.create(paymentId, command.amount());\n    }\n}','java','String ID는 외부 시스템(PG사, 외부 API 등)에서 주입받는 값 사용',NULL,NULL,NULL,'2026-01-28 14:30:47.000000','2026-01-28 14:30:47.000000',NULL),(294,67,'BAD','public record PaymentId(String value) {\n    public static PaymentId forNew() {\n        return new PaymentId(UUID.randomUUID().toString());  // 금지!\n    }\n}\n\n// 도메인 내부에서 ID 생성 - 잘못된 패턴\npublic class PaymentService {\n    public Payment processPayment(PaymentCommand command) {\n        PaymentId paymentId = PaymentId.forNew();  // 내부 생성 금지!\n        return Payment.create(paymentId, command.amount());\n    }\n}','java','String ID 내부 생성 금지 - UUID 등 내부 생성 대신 외부에서 주입받아야 함',NULL,NULL,NULL,'2026-01-28 14:30:47.000000','2026-01-28 14:30:47.000000',NULL),(295,71,'GOOD','public record OrderCreatedEvent(\n    OrderId orderId,\n    MemberId memberId,\n    Money totalAmount,\n    Instant occurredAt\n) implements DomainEvent {\n    \n    public static OrderCreatedEvent from(Order order) {\n        return new OrderCreatedEvent(\n            order.getId(),\n            order.getMemberId(),\n            order.getTotalAmount(),\n            Instant.now()\n        );\n    }\n}','java','Domain Event는 불변성 보장을 위해 Record 타입 사용 필수',NULL,NULL,NULL,'2026-01-28 14:31:18.000000','2026-01-28 14:31:18.000000',NULL),(296,71,'BAD','public class OrderCreatedEvent implements DomainEvent {\n    private OrderId orderId;\n    private MemberId memberId;\n    private Instant occurredAt;\n    \n    // 가변 객체 - 이벤트 불변성 위반!\n    public void setOrderId(OrderId orderId) {\n        this.orderId = orderId;\n    }\n}','java','Class 타입 Event는 불변성 보장 불가 - Record 타입 사용 필수',NULL,NULL,NULL,'2026-01-28 14:31:18.000000','2026-01-28 14:31:18.000000',NULL),(297,72,'GOOD','public record OrderShippedEvent(\n    OrderId orderId,\n    ShippingInfo shippingInfo,\n    Instant occurredAt  // 이벤트 발생 시각 필수\n) implements DomainEvent {\n    \n    public static OrderShippedEvent from(Order order) {\n        return new OrderShippedEvent(\n            order.getId(),\n            order.getShippingInfo(),\n            Instant.now()\n        );\n    }\n}','java','occurredAt 필드로 이벤트 발생 시각 기록 - 이벤트 순서 보장 및 추적에 필수',NULL,NULL,NULL,'2026-01-28 14:31:18.000000','2026-01-28 14:31:18.000000',NULL),(298,72,'BAD','public record OrderShippedEvent(\n    OrderId orderId,\n    ShippingInfo shippingInfo\n    // occurredAt 누락!\n) implements DomainEvent {\n}\n\n// 이벤트 발생 시각을 알 수 없음\n// - 이벤트 순서 판단 불가\n// - 이벤트 소싱 시 타임라인 구성 불가\n// - 디버깅 시 이벤트 추적 어려움','java','occurredAt 누락 시 이벤트 발생 시점 추적 불가',NULL,NULL,NULL,'2026-01-28 14:31:18.000000','2026-01-28 14:31:18.000000',NULL),(299,73,'GOOD','public record OrderCancelledEvent(\n    OrderId orderId,\n    String cancelReason,\n    Money refundAmount,\n    Instant occurredAt\n) implements DomainEvent {\n    \n    // from() 팩토리 메서드 - Aggregate에서 이벤트 생성\n    public static OrderCancelledEvent from(Order order, String reason) {\n        return new OrderCancelledEvent(\n            order.getId(),\n            reason,\n            order.calculateRefundAmount(),\n            Instant.now()\n        );\n    }\n}\n\n// Aggregate에서 사용\npublic class Order {\n    public OrderCancelledEvent cancel(String reason) {\n        this.status = OrderStatus.CANCELLED;\n        return OrderCancelledEvent.from(this, reason);\n    }\n}','java','from() 메서드로 Aggregate에서 일관된 이벤트 생성 보장',NULL,NULL,NULL,'2026-01-28 14:31:18.000000','2026-01-28 14:31:18.000000',NULL),(300,73,'BAD','public record OrderCancelledEvent(\n    OrderId orderId,\n    String cancelReason,\n    Money refundAmount,\n    Instant occurredAt\n) implements DomainEvent {\n    // from() 팩토리 메서드 누락!\n}\n\n// Aggregate에서 직접 생성 - 중복 코드 발생\npublic class Order {\n    public OrderCancelledEvent cancel(String reason) {\n        this.status = OrderStatus.CANCELLED;\n        // 매번 직접 생성 - 일관성 없음\n        return new OrderCancelledEvent(\n            this.id, reason, calculateRefundAmount(), Instant.now()\n        );\n    }\n}','java','from() 없이 직접 생성 시 이벤트 생성 로직 중복 및 불일치 발생',NULL,NULL,NULL,'2026-01-28 14:31:18.000000','2026-01-28 14:31:18.000000',NULL),(301,74,'GOOD','// 과거형 네이밍 - 이미 발생한 사실을 표현\npublic record OrderCreatedEvent(...) implements DomainEvent { }\npublic record OrderShippedEvent(...) implements DomainEvent { }\npublic record OrderCancelledEvent(...) implements DomainEvent { }\npublic record PaymentCompletedEvent(...) implements DomainEvent { }\npublic record MemberRegisteredEvent(...) implements DomainEvent { }','java','Domain Event는 이미 발생한 사실 - 과거형(~ed, ~d) 네이밍 필수',NULL,NULL,NULL,'2026-01-28 14:31:34.000000','2026-01-28 14:31:34.000000',NULL),(302,74,'BAD','// 현재형/명령형 네이밍 - 잘못된 패턴\npublic record OrderCreateEvent(...) { }      // 현재형 - 금지\npublic record CreateOrderEvent(...) { }      // 명령형 - 금지\npublic record OrderShipEvent(...) { }        // 현재형 - 금지\npublic record OrderCancellationEvent(...) { } // 명사형 - 금지\n\n// Event는 Command가 아닌 발생한 사실\n// CreateOrderCommand (O) vs OrderCreatedEvent (O)','java','Event는 명령이 아닌 발생한 사실 - 현재형/명령형 네이밍 금지',NULL,NULL,NULL,'2026-01-28 14:31:34.000000','2026-01-28 14:31:34.000000',NULL),(303,75,'GOOD','// Domain Event는 domain 패키지 내 event 하위 패키지에 위치\ncom.example.order.domain.event.OrderCreatedEvent\ncom.example.order.domain.event.OrderShippedEvent\ncom.example.order.domain.event.OrderCancelledEvent\n\n// 패키지 구조\norder/\n├── domain/\n│   ├── Order.java\n│   ├── OrderId.java\n│   └── event/              # event 패키지\n│       ├── OrderCreatedEvent.java\n│       ├── OrderShippedEvent.java\n│       └── OrderCancelledEvent.java\n└── application/','java','Domain Event는 domain.event 패키지에 위치 - 도메인 계층 소속 명확화',NULL,NULL,NULL,'2026-01-28 14:31:34.000000','2026-01-28 14:31:34.000000',NULL),(304,75,'BAD','// 잘못된 패키지 위치\ncom.example.order.application.event.OrderCreatedEvent  // application 계층 - 금지\ncom.example.order.adapter.event.OrderCreatedEvent     // adapter 계층 - 금지\ncom.example.order.domain.OrderCreatedEvent            // event 하위 패키지 없음 - 금지\ncom.example.common.event.OrderCreatedEvent            // 공통 패키지 - 금지\n\n// Domain Event는 특정 도메인에 속함\n// 해당 도메인의 domain.event 패키지가 정확한 위치','java','Event가 도메인 외부 패키지에 위치 시 도메인 경계 모호화',NULL,NULL,NULL,'2026-01-28 14:31:34.000000','2026-01-28 14:31:34.000000',NULL),(305,102,'GOOD','// *Criteria 네이밍 패턴 필수\npublic record OrderSearchCriteria(\n    OrderStatus status,\n    MemberId memberId,\n    DateRange orderDateRange\n) { }\n\npublic record MemberSearchCriteria(\n    String name,\n    MemberGrade grade,\n    Boolean isActive\n) { }\n\npublic record ProductFilterCriteria(\n    CategoryId categoryId,\n    PriceRange priceRange\n) { }','java','Criteria는 *Criteria 또는 *FilterCriteria 네이밍 패턴 사용',NULL,NULL,NULL,'2026-01-28 14:32:01.000000','2026-01-28 14:32:01.000000',NULL),(306,102,'BAD','// 잘못된 네이밍\npublic record OrderSearch(...) { }        // Criteria 접미사 누락\npublic record OrderQuery(...) { }         // Query는 CQRS Query에 사용\npublic record OrderFilter(...) { }        // FilterCriteria로 해야 함\npublic record SearchOrderCriteria(...) { } // Search가 앞에 위치 - 금지','java','Criteria 네이밍 규칙 위반 - *Criteria 패턴 준수 필수',NULL,NULL,NULL,'2026-01-28 14:32:01.000000','2026-01-28 14:32:01.000000',NULL),(307,103,'GOOD','// public 접근 제어자 - Application/Adapter 계층에서 사용\npublic record OrderSearchCriteria(\n    OrderStatus status,\n    MemberId memberId,\n    DateRange orderDateRange\n) {\n    public static OrderSearchCriteria of(\n        OrderStatus status, \n        MemberId memberId, \n        DateRange dateRange\n    ) {\n        return new OrderSearchCriteria(status, memberId, dateRange);\n    }\n}','java','Criteria는 계층 간 검색 조건 전달용 - public 필수',NULL,NULL,NULL,'2026-01-28 14:32:01.000000','2026-01-28 14:32:01.000000',NULL),(308,103,'BAD','// package-private 또는 private - 계층 간 전달 불가\nrecord OrderSearchCriteria(  // package-private\n    OrderStatus status,\n    MemberId memberId\n) { }\n\n// Application 계층에서 사용 불가\n// public class OrderQueryService {\n//     public List<Order> search(OrderSearchCriteria criteria) { } // 컴파일 에러\n// }','java','package-private Criteria는 다른 계층에서 접근 불가',NULL,NULL,NULL,'2026-01-28 14:32:01.000000','2026-01-28 14:32:01.000000',NULL),(309,104,'GOOD','// Record 타입 - 불변성 및 값 동등성 보장\npublic record OrderSearchCriteria(\n    OrderStatus status,\n    MemberId memberId,\n    DateRange orderDateRange,\n    PageRequest pageRequest\n) {\n    // Compact Constructor로 검증\n    public OrderSearchCriteria {\n        Objects.requireNonNull(pageRequest, \"PageRequest is required\");\n    }\n}','java','Criteria는 Record 타입 - 불변성, 값 동등성, 간결한 코드 보장',NULL,NULL,NULL,'2026-01-28 14:32:01.000000','2026-01-28 14:32:01.000000',NULL),(310,104,'BAD','// Class 타입 - 가변성 문제\npublic class OrderSearchCriteria {\n    private OrderStatus status;\n    private MemberId memberId;\n    \n    // setter로 인한 가변성 - 검색 조건 변경 가능\n    public void setStatus(OrderStatus status) {\n        this.status = status;\n    }\n    \n    // equals/hashCode 직접 구현 필요\n    // toString 직접 구현 필요\n}','java','Class 타입 Criteria는 가변성, 보일러플레이트 코드 문제',NULL,NULL,NULL,'2026-01-28 14:32:01.000000','2026-01-28 14:32:01.000000',NULL),(311,105,'GOOD','public record OrderSearchCriteria(\n    OrderStatus status,\n    MemberId memberId,\n    DateRange orderDateRange,\n    PageRequest pageRequest\n) {\n    // of() 정적 팩토리 메서드 필수\n    public static OrderSearchCriteria of(\n        OrderStatus status,\n        MemberId memberId,\n        DateRange dateRange,\n        PageRequest pageRequest\n    ) {\n        return new OrderSearchCriteria(status, memberId, dateRange, pageRequest);\n    }\n    \n    // 기본 페이징 적용 팩토리\n    public static OrderSearchCriteria ofDefault(OrderStatus status) {\n        return new OrderSearchCriteria(\n            status, null, null, PageRequest.ofDefault()\n        );\n    }\n}','java','of() 팩토리 메서드로 Criteria 생성 일관성 보장',NULL,NULL,NULL,'2026-01-28 14:32:17.000000','2026-01-28 14:32:17.000000',NULL),(312,105,'BAD','public record OrderSearchCriteria(\n    OrderStatus status,\n    MemberId memberId,\n    DateRange orderDateRange\n) {\n    // of() 팩토리 메서드 누락!\n}\n\n// 사용 시 직접 생성자 호출 - 일관성 없음\nOrderSearchCriteria criteria = new OrderSearchCriteria(\n    OrderStatus.PENDING, memberId, dateRange\n);','java','of() 없이 직접 생성자 호출 시 생성 방식 불일치',NULL,NULL,NULL,'2026-01-28 14:32:17.000000','2026-01-28 14:32:17.000000',NULL),(313,110,'GOOD','// 공통 VO를 활용한 Criteria\npublic record OrderSearchCriteria(\n    OrderStatus status,\n    MemberId memberId,\n    DateRange orderDateRange,    // 공통 VO: 날짜 범위\n    PriceRange priceRange,       // 공통 VO: 가격 범위\n    PageRequest pageRequest      // 공통 VO: 페이징\n) { }\n\n// 공통 VO 정의 (domain.common 패키지)\npublic record DateRange(LocalDate startDate, LocalDate endDate) {\n    public DateRange {\n        if (startDate != null && endDate != null && startDate.isAfter(endDate)) {\n            throw new IllegalArgumentException(\"startDate must be before endDate\");\n        }\n    }\n}\n\npublic record PriceRange(Money minPrice, Money maxPrice) { }','java','공통 VO(DateRange, PriceRange, PageRequest)로 재사용성 및 일관성 확보',NULL,NULL,NULL,'2026-01-28 14:32:17.000000','2026-01-28 14:32:17.000000',NULL),(314,110,'BAD','// 원시 타입 사용 - 재사용성 없음\npublic record OrderSearchCriteria(\n    OrderStatus status,\n    LocalDate startDate,      // 공통 VO 미사용\n    LocalDate endDate,        // 공통 VO 미사용\n    BigDecimal minPrice,      // 공통 VO 미사용\n    BigDecimal maxPrice,      // 공통 VO 미사용\n    int page,                 // 공통 VO 미사용\n    int size                  // 공통 VO 미사용\n) { }\n\n// 문제점:\n// - 날짜 범위 검증 로직 중복\n// - 가격 범위 검증 로직 중복\n// - 페이징 검증 로직 중복','java','원시 타입 사용 시 검증 로직 중복 및 재사용성 저하',NULL,NULL,NULL,'2026-01-28 14:32:17.000000','2026-01-28 14:32:17.000000',NULL),(315,82,'GOOD','// ErrorCode Enum은 해당 도메인의 exception 패키지에 위치\ncom.example.order.domain.exception.OrderErrorCode\ncom.example.payment.domain.exception.PaymentErrorCode\ncom.example.member.domain.exception.MemberErrorCode\n\n// 패키지 구조\norder/\n├── domain/\n│   ├── Order.java\n│   └── exception/\n│       ├── OrderErrorCode.java    # ErrorCode Enum\n│       └── OrderNotFoundException.java','java','ErrorCode는 해당 도메인의 domain.exception 패키지에 위치',NULL,NULL,NULL,'2026-01-28 14:32:51.000000','2026-01-28 14:32:51.000000',NULL),(316,82,'BAD','// 잘못된 패키지 위치\ncom.example.order.application.exception.OrderErrorCode  // application - 금지\ncom.example.order.adapter.exception.OrderErrorCode     // adapter - 금지\ncom.example.common.exception.OrderErrorCode            // 공통 패키지 - 도메인별로 분리 필요\ncom.example.order.domain.OrderErrorCode                // exception 하위 패키지 없음 - 금지','java','ErrorCode가 도메인 외부 또는 exception 패키지 외부 위치 시 금지',NULL,NULL,NULL,'2026-01-28 14:32:51.000000','2026-01-28 14:32:51.000000',NULL),(317,84,'GOOD','// public enum - 다른 계층에서 참조 가능\npublic enum OrderErrorCode implements ErrorCode {\n    ORDER_NOT_FOUND(\"ORD-001\", HttpStatus.NOT_FOUND.value(), \"주문을 찾을 수 없습니다\"),\n    ORDER_ALREADY_CANCELLED(\"ORD-002\", HttpStatus.BAD_REQUEST.value(), \"이미 취소된 주문입니다\");\n    \n    // ...\n}\n\n// Adapter 계층에서 사용\n@ExceptionHandler(OrderNotFoundException.class)\npublic ResponseEntity<ErrorResponse> handleOrderNotFound(OrderNotFoundException e) {\n    return ResponseEntity.status(e.getErrorCode().getHttpStatus())\n        .body(ErrorResponse.of(e.getErrorCode()));\n}','java','ErrorCode는 public - 계층 간 에러 코드 공유 필요',NULL,NULL,NULL,'2026-01-28 14:32:51.000000','2026-01-28 14:32:51.000000',NULL),(318,84,'BAD','// package-private enum - 다른 계층 접근 불가\nenum OrderErrorCode implements ErrorCode {  // public 누락\n    ORDER_NOT_FOUND(\"ORD-001\", 404, \"주문을 찾을 수 없습니다\");\n}\n\n// Adapter 계층에서 접근 불가\n// @ExceptionHandler에서 ErrorCode 참조 불가','java','package-private ErrorCode는 계층 간 공유 불가',NULL,NULL,NULL,'2026-01-28 14:32:51.000000','2026-01-28 14:32:51.000000',NULL),(319,85,'GOOD','public enum OrderErrorCode implements ErrorCode {\n    ORDER_NOT_FOUND(\"ORD-001\", 404, \"주문을 찾을 수 없습니다\"),\n    ORDER_ALREADY_CANCELLED(\"ORD-002\", 400, \"이미 취소된 주문입니다\");\n    \n    private final String code;\n    private final int httpStatus;\n    private final String message;\n    \n    // getCode() 필수 - 에러 코드 문자열 반환\n    @Override\n    public String getCode() {\n        return code;\n    }\n    \n    @Override\n    public int getHttpStatus() { return httpStatus; }\n    \n    @Override\n    public String getMessage() { return message; }\n}','java','getCode()로 고유 에러 코드 문자열 반환 - API 응답 및 로깅에 사용',NULL,NULL,NULL,'2026-01-28 14:32:51.000000','2026-01-28 14:32:51.000000',NULL),(320,85,'BAD','public enum OrderErrorCode implements ErrorCode {\n    ORDER_NOT_FOUND(404, \"주문을 찾을 수 없습니다\");\n    \n    private final int httpStatus;\n    private final String message;\n    \n    // getCode() 누락! - 에러 코드 식별 불가\n    \n    @Override\n    public int getHttpStatus() { return httpStatus; }\n    @Override\n    public String getMessage() { return message; }\n}\n\n// 문제점:\n// - API 응답에 고유 에러 코드 포함 불가\n// - 클라이언트에서 에러 유형 구분 불가\n// - 로그 분석 시 에러 추적 어려움','java','getCode() 누락 시 에러 코드 식별 불가',NULL,NULL,NULL,'2026-01-28 14:32:51.000000','2026-01-28 14:32:51.000000',NULL),(321,86,'GOOD','public enum OrderErrorCode implements ErrorCode {\n    ORDER_NOT_FOUND(\"ORD-001\", 404, \"주문을 찾을 수 없습니다\"),\n    INVALID_ORDER_STATUS(\"ORD-003\", 400, \"유효하지 않은 주문 상태입니다\"),\n    ORDER_ACCESS_DENIED(\"ORD-004\", 403, \"주문 접근 권한이 없습니다\");\n    \n    private final String code;\n    private final int httpStatus;  // int 타입\n    private final String message;\n    \n    // int 반환 - 도메인이 HTTP 의존성 없음\n    @Override\n    public int getHttpStatus() {\n        return httpStatus;\n    }\n}','java','getHttpStatus()는 int 반환 - 도메인 계층의 HTTP 라이브러리 의존성 제거',NULL,NULL,NULL,'2026-01-28 14:32:51.000000','2026-01-28 14:32:51.000000',NULL),(322,86,'BAD','import org.springframework.http.HttpStatus;  // 도메인에 Spring 의존성!\n\npublic enum OrderErrorCode implements ErrorCode {\n    ORDER_NOT_FOUND(\"ORD-001\", HttpStatus.NOT_FOUND, \"주문을 찾을 수 없습니다\");\n    \n    private final String code;\n    private final HttpStatus httpStatus;  // HttpStatus 타입 - 금지!\n    private final String message;\n    \n    // HttpStatus 반환 - 도메인이 Spring에 의존\n    public HttpStatus getHttpStatus() {\n        return httpStatus;  // Spring 타입 반환 - 금지!\n    }\n}','java','HttpStatus 타입 사용 시 도메인이 Spring Framework에 의존 - int 사용 필수',NULL,NULL,NULL,'2026-01-28 14:32:51.000000','2026-01-28 14:32:51.000000',NULL),(323,87,'GOOD','public enum OrderErrorCode implements ErrorCode {\n    ORDER_NOT_FOUND(\"ORD-001\", 404, \"주문을 찾을 수 없습니다\"),\n    ORDER_ALREADY_SHIPPED(\"ORD-005\", 400, \"이미 배송된 주문은 취소할 수 없습니다\");\n    \n    private final String code;\n    private final int httpStatus;\n    private final String message;\n    \n    // getMessage() 필수 - 사용자 친화적 메시지 반환\n    @Override\n    public String getMessage() {\n        return message;\n    }\n}\n\n// 사용 예시\nthrow new OrderNotFoundException(OrderErrorCode.ORDER_NOT_FOUND);\n// API 응답: { \"code\": \"ORD-001\", \"message\": \"주문을 찾을 수 없습니다\" }','java','getMessage()로 사용자 친화적 에러 메시지 반환',NULL,NULL,NULL,'2026-01-28 14:33:17.000000','2026-01-28 14:33:17.000000',NULL),(324,87,'BAD','public enum OrderErrorCode implements ErrorCode {\n    ORDER_NOT_FOUND(\"ORD-001\", 404);  // message 필드 누락\n    \n    private final String code;\n    private final int httpStatus;\n    // message 필드 없음!\n    \n    @Override\n    public String getCode() { return code; }\n    @Override\n    public int getHttpStatus() { return httpStatus; }\n    // getMessage() 누락!\n}\n\n// API 응답에 사용자 메시지 포함 불가\n// 클라이언트가 에러 원인 파악 불가','java','getMessage() 누락 시 사용자 친화적 에러 메시지 제공 불가',NULL,NULL,NULL,'2026-01-28 14:33:17.000000','2026-01-28 14:33:17.000000',NULL),(325,89,'GOOD','// 모든 도메인 예외는 DomainException 상속\npublic class OrderNotFoundException extends DomainException {\n    public OrderNotFoundException(ErrorCode errorCode) {\n        super(errorCode);\n    }\n}\n\npublic class InsufficientStockException extends DomainException {\n    public InsufficientStockException(ErrorCode errorCode) {\n        super(errorCode);\n    }\n}\n\n// DomainException 정의 (common 패키지)\npublic abstract class DomainException extends RuntimeException {\n    private final ErrorCode errorCode;\n    \n    protected DomainException(ErrorCode errorCode) {\n        super(errorCode.getMessage());\n        this.errorCode = errorCode;\n    }\n    \n    public ErrorCode getErrorCode() {\n        return errorCode;\n    }\n}','java','모든 도메인 예외는 DomainException 상속 - 일관된 예외 처리 체계',NULL,NULL,NULL,'2026-01-28 14:33:17.000000','2026-01-28 14:33:17.000000',NULL),(326,89,'BAD','// RuntimeException 직접 상속 - 금지\npublic class OrderNotFoundException extends RuntimeException {\n    public OrderNotFoundException(String message) {\n        super(message);\n    }\n}\n\n// IllegalStateException 상속 - 금지\npublic class InvalidOrderStatusException extends IllegalStateException {\n    public InvalidOrderStatusException(String message) {\n        super(message);\n    }\n}\n\n// 문제점:\n// - ErrorCode 연동 불가\n// - 일관된 예외 처리 불가\n// - API 응답 포맷 불일치','java','DomainException 미상속 시 일관된 예외 처리 체계 구축 불가',NULL,NULL,NULL,'2026-01-28 14:33:17.000000','2026-01-28 14:33:17.000000',NULL),(327,90,'GOOD','// Exception은 해당 도메인의 exception 패키지에 위치\ncom.example.order.domain.exception.OrderNotFoundException\ncom.example.order.domain.exception.OrderAlreadyCancelledException\ncom.example.payment.domain.exception.PaymentFailedException\n\n// 패키지 구조\norder/\n├── domain/\n│   ├── Order.java\n│   └── exception/\n│       ├── OrderErrorCode.java\n│       ├── OrderNotFoundException.java\n│       └── OrderAlreadyCancelledException.java','java','Exception은 해당 도메인의 domain.exception 패키지에 위치',NULL,NULL,NULL,'2026-01-28 14:33:17.000000','2026-01-28 14:33:17.000000',NULL),(328,90,'BAD','// 잘못된 패키지 위치\ncom.example.order.application.exception.OrderNotFoundException  // application - 금지\ncom.example.order.domain.OrderNotFoundException                 // exception 패키지 없음 - 금지\ncom.example.common.exception.OrderNotFoundException             // 공통 패키지 - 도메인별 분리 필요\n\n// Exception은 해당 도메인에 속함\n// ErrorCode와 같은 패키지에 위치해야 함','java','Exception이 도메인 외부 또는 exception 패키지 외부 위치 시 금지',NULL,NULL,NULL,'2026-01-28 14:33:17.000000','2026-01-28 14:33:17.000000',NULL),(329,94,'GOOD','// public 클래스 - 다른 계층에서 catch 가능\npublic class OrderNotFoundException extends DomainException {\n    public OrderNotFoundException(ErrorCode errorCode) {\n        super(errorCode);\n    }\n}\n\n// Adapter 계층에서 사용\n@ExceptionHandler(OrderNotFoundException.class)\npublic ResponseEntity<ErrorResponse> handle(OrderNotFoundException e) {\n    return ResponseEntity.status(e.getErrorCode().getHttpStatus())\n        .body(ErrorResponse.of(e.getErrorCode()));\n}','java','Exception은 public - 계층 간 예외 전파 및 처리 필요',NULL,NULL,NULL,'2026-01-28 14:33:17.000000','2026-01-28 14:33:17.000000',NULL),(330,94,'BAD','// package-private 클래스 - 다른 계층에서 catch 불가\nclass OrderNotFoundException extends DomainException {  // public 누락\n    OrderNotFoundException(ErrorCode errorCode) {\n        super(errorCode);\n    }\n}\n\n// Adapter 계층에서 catch 불가\n// @ExceptionHandler(OrderNotFoundException.class) // 컴파일 에러','java','package-private Exception은 계층 간 예외 처리 불가',NULL,NULL,NULL,'2026-01-28 14:33:17.000000','2026-01-28 14:33:17.000000',NULL),(331,95,'GOOD','// DomainException은 RuntimeException 계층\npublic abstract class DomainException extends RuntimeException {\n    private final ErrorCode errorCode;\n    \n    protected DomainException(ErrorCode errorCode) {\n        super(errorCode.getMessage());\n        this.errorCode = errorCode;\n    }\n}\n\n// 도메인 예외들\npublic class OrderNotFoundException extends DomainException { }\npublic class InsufficientStockException extends DomainException { }\n\n// Unchecked Exception - try-catch 강제 없음\npublic Order findById(OrderId id) {\n    return repository.findById(id)\n        .orElseThrow(() -> new OrderNotFoundException(OrderErrorCode.ORDER_NOT_FOUND));\n}','java','DomainException은 RuntimeException 계층 - Unchecked Exception으로 깔끔한 코드',NULL,NULL,NULL,'2026-01-28 14:33:44.000000','2026-01-28 14:33:44.000000',NULL),(332,95,'BAD','// Checked Exception 상속 - 금지\npublic class OrderNotFoundException extends Exception {  // RuntimeException 아님!\n    public OrderNotFoundException(String message) {\n        super(message);\n    }\n}\n\n// try-catch 강제 - 코드 복잡도 증가\npublic Order findById(OrderId id) throws OrderNotFoundException {  // throws 선언 필요\n    return repository.findById(id)\n        .orElseThrow(() -> new OrderNotFoundException(\"Order not found\"));\n}\n\n// 호출부에서도 처리 필요\ntry {\n    Order order = service.findById(id);\n} catch (OrderNotFoundException e) {\n    // 매번 try-catch 필요\n}','java','Checked Exception 사용 시 불필요한 try-catch 강제 - RuntimeException 사용',NULL,NULL,NULL,'2026-01-28 14:33:44.000000','2026-01-28 14:33:44.000000',NULL),(333,98,'GOOD','// 비즈니스 의미가 명확한 네이밍\npublic class OrderNotFoundException extends DomainException { }\npublic class InsufficientStockException extends DomainException { }\npublic class OrderAlreadyCancelledException extends DomainException { }\npublic class PaymentFailedException extends DomainException { }\npublic class MemberNotActiveException extends DomainException { }\npublic class DuplicateOrderException extends DomainException { }','java','비즈니스 도메인 용어를 사용한 명확한 예외 네이밍',NULL,NULL,NULL,'2026-01-28 14:33:44.000000','2026-01-28 14:33:44.000000',NULL),(334,98,'BAD','// 기술적/제네릭 네이밍 - 비즈니스 의미 불명확\npublic class NotFoundException extends DomainException { }       // 무엇을 못 찾았는지 불명확\npublic class InvalidStateException extends DomainException { }   // 어떤 상태가 잘못인지 불명확\npublic class BusinessException extends DomainException { }       // 너무 일반적\npublic class DataException extends DomainException { }           // 기술적 용어\npublic class ValidationException extends DomainException { }     // 무엇의 검증인지 불명확\n\n// 예외명만으로 비즈니스 상황 파악 불가','java','제네릭 네이밍 시 비즈니스 상황 파악 불가 - 도메인 용어 사용 필수',NULL,NULL,NULL,'2026-01-28 14:33:44.000000','2026-01-28 14:33:44.000000',NULL),(335,99,'GOOD','// DomainException은 common 패키지에 위치\ncom.example.common.domain.exception.DomainException\n\n// 패키지 구조\ncommon/\n├── domain/\n│   └── exception/\n│       └── DomainException.java   # 공통 기반 예외\n│\norder/\n├── domain/\n│   └── exception/\n│       ├── OrderErrorCode.java\n│       └── OrderNotFoundException.java  # DomainException 상속\n\n// 모든 도메인 모듈에서 DomainException 참조 가능','java','DomainException은 common 모듈 - 전체 도메인에서 공통 사용',NULL,NULL,NULL,'2026-01-28 14:33:44.000000','2026-01-28 14:33:44.000000',NULL),(336,99,'BAD','// 특정 도메인에 DomainException 위치 - 금지\ncom.example.order.domain.exception.DomainException  // order 도메인에 위치\n\n// 문제점:\n// - payment, member 도메인에서 order 도메인 의존성 발생\n// - 순환 의존성 위험\n// - 도메인 간 불필요한 결합\n\n// DomainException은 모든 도메인의 공통 기반\n// common 모듈에 위치해야 함','java','특정 도메인에 DomainException 위치 시 도메인 간 불필요한 의존성 발생',NULL,NULL,NULL,'2026-01-28 14:33:44.000000','2026-01-28 14:33:44.000000',NULL),(337,100,'GOOD','// ErrorCode 인터페이스는 common 패키지에 위치\ncom.example.common.domain.exception.ErrorCode\n\n// ErrorCode 인터페이스 정의\npublic interface ErrorCode {\n    String getCode();\n    int getHttpStatus();\n    String getMessage();\n}\n\n// 각 도메인에서 구현\npublic enum OrderErrorCode implements ErrorCode {\n    ORDER_NOT_FOUND(\"ORD-001\", 404, \"주문을 찾을 수 없습니다\");\n    // ...\n}\n\npublic enum PaymentErrorCode implements ErrorCode {\n    PAYMENT_FAILED(\"PAY-001\", 400, \"결제에 실패했습니다\");\n    // ...\n}','java','ErrorCode 인터페이스는 common 모듈 - 전체 도메인에서 공통 구현',NULL,NULL,NULL,'2026-01-28 14:33:44.000000','2026-01-28 14:33:44.000000',NULL),(338,100,'BAD','// 특정 도메인에 ErrorCode 인터페이스 위치 - 금지\ncom.example.order.domain.exception.ErrorCode\n\n// 문제점:\n// - payment, member 도메인에서 order 도메인 의존성 발생\n// - 각 도메인이 자체 ErrorCode 인터페이스 정의 시 불일치\n// - GlobalExceptionHandler에서 일관된 처리 불가\n\n// ErrorCode 인터페이스는 모든 ErrorCode enum의 공통 계약\n// common 모듈에 위치해야 함','java','특정 도메인에 ErrorCode 인터페이스 위치 시 도메인 간 계약 불일치',NULL,NULL,NULL,'2026-01-28 14:33:44.000000','2026-01-28 14:33:44.000000',NULL),(339,111,'GOOD','// 순수 자바 객체 - 프레임워크 의존성 없음\npublic class Order {\n    private final OrderId id;\n    private final MemberId memberId;\n    private final List<OrderLineItem> lineItems;\n    private OrderStatus status;\n    \n    // 순수 자바 생성자\n    private Order(OrderId id, MemberId memberId, List<OrderLineItem> lineItems) {\n        this.id = id;\n        this.memberId = memberId;\n        this.lineItems = new ArrayList<>(lineItems);\n        this.status = OrderStatus.CREATED;\n    }\n    \n    // 비즈니스 로직\n    public void cancel() {\n        if (this.status == OrderStatus.SHIPPED) {\n            throw new OrderAlreadyShippedException(OrderErrorCode.ORDER_ALREADY_SHIPPED);\n        }\n        this.status = OrderStatus.CANCELLED;\n    }\n}\n\n// Record도 순수 자바 객체\npublic record OrderId(Long value) {\n    public static OrderId of(Long value) {\n        return new OrderId(value);\n    }\n}','java','Domain 객체는 순수 자바로 구현 - 프레임워크 독립적 비즈니스 로직',NULL,NULL,NULL,'2026-01-28 14:34:18.000000','2026-01-28 14:34:18.000000',NULL),(340,111,'BAD','// Spring 어노테이션 사용 - POJO 위반\n@Entity\n@Table(name = \"orders\")\npublic class Order {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = \"member_id\")\n    private Member member;\n    \n    @Transactional  // Domain에 Spring 의존성!\n    public void cancel() {\n        // ...\n    }\n}\n\n// Lombok 의존성 - 권장하지 않음\n@Data\n@Builder\npublic class Order {\n    private Long id;\n}','java','JPA/Spring/Lombok 어노테이션 사용 시 POJO 원칙 위반 - 프레임워크 결합',NULL,NULL,NULL,'2026-01-28 14:34:18.000000','2026-01-28 14:34:18.000000',NULL),(341,112,'GOOD','// Domain 계층 - 외부 의존성 없음\npackage com.example.order.domain;\n\n// 순수 자바 import만 허용\nimport java.time.Instant;\nimport java.util.List;\nimport java.util.Objects;\n\n// 같은 도메인 내 import 허용\nimport com.example.order.domain.vo.Money;\nimport com.example.order.domain.event.OrderCreatedEvent;\n\n// common 모듈 import 허용\nimport com.example.common.domain.exception.DomainException;\n\npublic class Order {\n    // 순수 비즈니스 로직\n}','java','Domain은 순수 자바와 common 모듈만 의존 - 외부 레이어 의존 금지',NULL,NULL,NULL,'2026-01-28 14:34:18.000000','2026-01-28 14:34:18.000000',NULL),(342,112,'BAD','// 외부 레이어 의존 - 금지\npackage com.example.order.domain;\n\n// Application 계층 의존 - 금지!\nimport com.example.order.application.dto.OrderCommand;\nimport com.example.order.application.service.OrderService;\n\n// Adapter 계층 의존 - 금지!\nimport com.example.order.adapter.out.persistence.OrderJpaEntity;\nimport com.example.order.adapter.in.rest.dto.OrderRequest;\n\n// 외부 라이브러리 의존 - 금지!\nimport org.springframework.stereotype.Component;\nimport jakarta.persistence.Entity;\nimport lombok.Data;\n\npublic class Order {\n    // Domain이 외부 계층/라이브러리에 의존하면\n    // 비즈니스 로직이 기술에 종속됨\n}','java','Domain이 Application/Adapter/외부 라이브러리에 의존 시 헥사고날 아키텍처 위반',NULL,NULL,NULL,'2026-01-28 14:34:18.000000','2026-01-28 14:34:18.000000',NULL),(343,113,'GOOD','public class Order {\n    private final List<OrderLineItem> lineItems;\n    \n    // 생성자에서 방어적 복사\n    private Order(OrderId id, List<OrderLineItem> lineItems) {\n        this.id = id;\n        this.lineItems = new ArrayList<>(lineItems);  // 방어적 복사\n    }\n    \n    // getter에서 불변 컬렉션 반환\n    public List<OrderLineItem> getLineItems() {\n        return Collections.unmodifiableList(lineItems);  // 불변 반환\n    }\n    \n    // 또는 복사본 반환\n    public List<OrderLineItem> getLineItems() {\n        return new ArrayList<>(lineItems);  // 복사본 반환\n    }\n}','java','Collection 필드는 방어적 복사로 불변성 보장 - 외부에서 수정 불가',NULL,NULL,NULL,'2026-01-28 14:34:50.000000','2026-01-28 14:34:50.000000',NULL),(344,113,'BAD','public class Order {\n    private final List<OrderLineItem> lineItems;\n    \n    // 직접 참조 저장 - 외부에서 수정 가능!\n    private Order(OrderId id, List<OrderLineItem> lineItems) {\n        this.lineItems = lineItems;  // 방어적 복사 없음\n    }\n    \n    // 직접 참조 반환 - 외부에서 수정 가능!\n    public List<OrderLineItem> getLineItems() {\n        return lineItems;  // 직접 반환\n    }\n}\n\n// 문제 발생\nList<OrderLineItem> items = new ArrayList<>();\nOrder order = Order.create(id, items);\nitems.add(newItem);  // Order 내부 상태 변경됨!\norder.getLineItems().clear();  // Order 내부 상태 변경됨!','java','방어적 복사 없이 Collection 직접 참조 시 불변성 위반',NULL,NULL,NULL,'2026-01-28 14:34:50.000000','2026-01-28 14:34:50.000000',NULL),(345,114,'GOOD','public class Order {\n    private final OrderId id;\n    private final MemberId memberId;\n    private final ShippingInfo shippingInfo;  // nullable 필드 - null 허용\n    \n    // 반환 타입에서만 Optional 사용\n    public Optional<ShippingInfo> getShippingInfo() {\n        return Optional.ofNullable(shippingInfo);\n    }\n    \n    // 또는 명시적 null 체크 메서드 제공\n    public boolean hasShippingInfo() {\n        return shippingInfo != null;\n    }\n}','java','Optional은 필드가 아닌 반환 타입에서만 사용 - 명시적 null 가능성 표현',NULL,NULL,NULL,'2026-01-28 14:34:50.000000','2026-01-28 14:34:50.000000',NULL),(346,114,'BAD','public class Order {\n    private final OrderId id;\n    private final Optional<ShippingInfo> shippingInfo;  // Optional 필드 - 금지!\n    \n    private Order(OrderId id, Optional<ShippingInfo> shippingInfo) {\n        this.shippingInfo = shippingInfo;  // Optional 필드 저장 - 금지\n    }\n}\n\n// Optional 필드 문제점:\n// - 직렬화/역직렬화 복잡\n// - Optional.empty() vs null 혼동\n// - 메모리 오버헤드\n// - Optional.get() 남용 유발','java','Optional 필드 사용 시 직렬화 문제, 메모리 오버헤드, null 혼동 발생',NULL,NULL,NULL,'2026-01-28 14:34:50.000000','2026-01-28 14:34:50.000000',NULL);
INSERT INTO `tech_stack` VALUES (1,'java21-springboot35-backend','ACTIVE','JAVA','21','[\"VIRTUAL_THREAD\", \"RECORD\", \"SEALED_CLASS\", \"PATTERN_MATCHING\", \"SEQUENCED_COLLECTION\"]','SPRING_BOOT','3.5.x','[\"WEB\", \"JPA\", \"VALIDATION\", \"SECURITY\", \"ACTUATOR\"]','BACKEND','JVM','GRADLE','build.gradle.kts',NULL,'2026-01-20 02:11:19.000000','2026-01-20 02:11:19.000000',NULL);
INSERT INTO `zero_tolerance_rule` VALUES (3,24,'LOMBOK_USAGE','@(Data|Getter|Setter|Builder|AllArgsConstructor|NoArgsConstructor|RequiredArgsConstructor|Value|With|ToString|EqualsAndHashCode)','REGEX',1,'[DOM-AGG-001] Lombok 어노테이션 사용 금지. Aggregate에서는 모든 Lombok 어노테이션을 사용할 수 없습니다.','2026-01-20 15:02:43.000000','2026-01-20 15:02:43.000000',NULL),(4,25,'JPA_IN_DOMAIN','@(Entity|Table|Column|Id|GeneratedValue|ManyToOne|OneToMany|ManyToMany|JoinColumn|Embedded|Embeddable)','REGEX',1,'[DOM-AGG-002] JPA 어노테이션 사용 금지. Domain Layer는 인프라에 독립적이어야 합니다.','2026-01-20 15:02:43.000000','2026-01-20 15:02:43.000000',NULL),(5,26,'SPRING_IN_DOMAIN','@(Component|Service|Repository|Controller|Autowired|Value|Configuration|Bean|Transactional)','REGEX',1,'[DOM-AGG-003] Spring 어노테이션 사용 금지. Domain Layer는 프레임워크에 독립적이어야 합니다.','2026-01-20 15:02:43.000000','2026-01-20 15:02:43.000000',NULL),(6,32,'WRONG_TIME_TYPE','(LocalDateTime|LocalDate|Date|Calendar|ZonedDateTime)\\s+(created|updated|deleted|modified|registered)','REGEX',1,'[DOM-AGG-009] 시간 필드는 Instant 타입만 허용. LocalDateTime, Date 등은 사용할 수 없습니다.','2026-01-20 15:02:43.000000','2026-01-20 15:02:43.000000',NULL),(7,33,'INSTANT_NOW_CALL','Instant\\.now\\(\\)','REGEX',1,'[DOM-AGG-010] Instant.now() 직접 호출 금지. 시간은 반드시 파라미터로 주입받아야 합니다.','2026-01-20 15:02:43.000000','2026-01-20 15:02:43.000000',NULL),(8,35,'SETTER_METHOD','public\\s+void\\s+set[A-Z]\\w*\\s*\\(','REGEX',1,'[DOM-AGG-012] Setter 메서드 금지. 도메인 메서드를 통해 상태를 변경해야 합니다.','2026-01-20 15:02:43.000000','2026-01-20 15:02:43.000000',NULL),(9,37,'GETTER_CHAINING','\\.get[A-Z]\\w*\\(\\)\\.get[A-Z]\\w*\\(\\)','REGEX',1,'[DOM-AGG-014] Getter 체이닝 감지. Law of Demeter를 위반합니다. Tell, Don\'t Ask 원칙을 따르세요.','2026-01-20 15:02:43.000000','2026-01-20 15:02:43.000000',NULL),(10,46,'LAYER_DEPENDENCY','import\\s+com\\.ryuqq\\.(application|adapter|bootstrap)','REGEX',1,'[DOM-AGG-023] Domain Layer 외부 의존 금지. Application, Adapter 레이어를 참조할 수 없습니다.','2026-01-20 15:02:43.000000','2026-01-20 15:02:43.000000',NULL),(11,47,'REPOSITORY_IN_AGGREGATE','(Repository|Port)\\s+\\w+','REGEX',1,'[DOM-AGG-024] Aggregate에서 Repository 참조 금지. DDD 원칙에 따라 Aggregate는 Repository를 알지 못해야 합니다.','2026-01-20 15:02:43.000000','2026-01-20 15:02:43.000000',NULL),(12,51,'VO_NOT_RECORD','public\\s+class\\s+\\w+(?!.*record)','REGEX',0,'[DOM-VO-001] Value Object는 반드시 Record 타입이어야 합니다. class 대신 record를 사용하세요.','2026-01-20 15:02:43.000000','2026-01-20 15:02:43.000000',NULL),(13,57,'LOMBOK_IN_VO','@(Data|Getter|Setter|Builder|Value)','REGEX',1,'[DOM-VO-007] Value Object에서 Lombok 사용 금지. Record는 기본적으로 Lombok이 불필요합니다.','2026-01-20 15:02:43.000000','2026-01-20 15:02:43.000000',NULL),(14,58,'JPA_IN_VO','@(Embeddable|Embedded|Column)','REGEX',1,'[DOM-VO-008] Value Object에서 JPA 어노테이션 사용 금지. Domain은 인프라에 독립적이어야 합니다.','2026-01-20 15:02:43.000000','2026-01-20 15:02:43.000000',NULL),(15,59,'SPRING_IN_VO','@(Component|Service|Value|Autowired)','REGEX',1,'[DOM-VO-009] Value Object에서 Spring 어노테이션 사용 금지.','2026-01-20 15:02:43.000000','2026-01-20 15:02:43.000000',NULL),(16,61,'ID_NOT_RECORD','public\\s+class\\s+\\w+Id\\b','REGEX',1,'[DOM-ID-002] ID VO는 반드시 Record 타입이어야 합니다. public class XxxId → public record XxxId','2026-01-20 15:02:43.000000','2026-01-20 15:02:43.000000',NULL),(17,68,'LOMBOK_IN_ID','@(Data|Getter|Setter|Builder|Value)','REGEX',1,'[DOM-ID-009] ID VO에서 Lombok 사용 금지. Record는 Lombok이 불필요합니다.','2026-01-20 15:02:43.000000','2026-01-20 15:02:43.000000',NULL),(18,69,'JPA_SPRING_IN_ID','@(Entity|Embeddable|Column|Component|Value)','REGEX',1,'[DOM-ID-010] ID VO에서 JPA/Spring 어노테이션 사용 금지.','2026-01-20 15:02:43.000000','2026-01-20 15:02:43.000000',NULL),(19,81,'WRONG_EXCEPTION_PARENT','extends\\s+(RuntimeException|Exception|Throwable)(?!.*DomainException)','REGEX',1,'[DOM-EXC-001] 도메인 예외는 반드시 DomainException을 상속해야 합니다.','2026-01-20 15:02:43.000000','2026-01-20 15:02:43.000000',NULL),(20,84,'LOMBOK_IN_EXCEPTION','@(Data|Getter|Setter|Builder)','REGEX',1,'[DOM-EXC-004] Exception에서 Lombok 사용 금지.','2026-01-20 15:02:43.000000','2026-01-20 15:02:43.000000',NULL),(21,91,'THROW_RUNTIME_EXCEPTION','throw\\s+new\\s+(RuntimeException|Exception|IllegalArgumentException|IllegalStateException)\\s*\\(','REGEX',1,'[DOM-EXC-011] 일반 예외 직접 throw 금지. 반드시 도메인 예외를 사용하세요.','2026-01-20 15:02:43.000000','2026-01-20 15:02:43.000000',NULL),(22,70,'EVENT_NOT_RECORD','public\\s+class\\s+\\w+Event\\b(?!.*record)','REGEX',1,'[DOM-EVT-001] 도메인 이벤트는 반드시 Record 타입이어야 합니다.','2026-01-20 15:02:44.000000','2026-01-20 15:02:44.000000',NULL),(23,79,'LOMBOK_IN_EVENT','@(Data|Getter|Setter|Builder|Value)','REGEX',1,'[DOM-EVT-010] Event에서 Lombok 사용 금지. Record를 사용하세요.','2026-01-20 15:02:44.000000','2026-01-20 15:02:44.000000',NULL),(24,80,'JPA_SPRING_IN_EVENT','@(Entity|Component|Service|EventListener)','REGEX',1,'[DOM-EVT-011] Event에서 JPA/Spring 어노테이션 사용 금지.','2026-01-20 15:02:44.000000','2026-01-20 15:02:44.000000',NULL),(25,101,'CRITERIA_NOT_RECORD','public\\s+class\\s+\\w+Criteria\\b','REGEX',1,'[DOM-CRI-001] Criteria는 반드시 Record 타입이어야 합니다.','2026-01-20 15:02:44.000000','2026-01-20 15:02:44.000000',NULL),(26,109,'LOMBOK_IN_CRITERIA','@(Data|Getter|Setter|Builder)','REGEX',1,'[DOM-CRI-009] Criteria에서 Lombok 사용 금지.','2026-01-20 15:02:44.000000','2026-01-20 15:02:44.000000',NULL),(27,110,'JPA_SPRING_IN_CRITERIA','@(Entity|Component|Service)','REGEX',1,'[DOM-CRI-010] Criteria에서 JPA/Spring 어노테이션 사용 금지.','2026-01-20 15:02:44.000000','2026-01-20 15:02:44.000000',NULL),(28,115,'SERVICE_TRANSACTIONAL','classs+w+Service.*@Transactional','REGEX',1,'Service 클래스에 @Transactional을 사용할 수 없습니다. Manager에서만 사용하세요.','2026-01-24 08:28:08.000000','2026-01-24 08:28:08.000000',NULL),(29,116,'MANAGER_NO_TRANSACTIONAL','classs+w+Manager(?!.*@Transactional)','REGEX',1,'Manager 클래스에는 @Transactional이 필수입니다.','2026-01-24 08:28:08.000000','2026-01-24 08:28:08.000000',NULL),(30,117,'CLIENT_MANAGER_TRANSACTIONAL','classs+w+ClientManager.*@Transactional','REGEX',1,'ClientManager에 @Transactional을 사용할 수 없습니다. 외부 API 호출 클래스입니다.','2026-01-24 08:28:08.000000','2026-01-24 08:28:08.000000',NULL),(31,122,'CQRS_VIOLATION','CommandFacade.*QueryManager|CommandFacade.*ReadManager','REGEX',1,'CommandFacade에서 QueryManager/ReadManager를 의존할 수 없습니다. CQRS 위반입니다.','2026-01-24 08:28:08.000000','2026-01-24 08:28:08.000000',NULL),(32,125,'DTO_NOT_RECORD','classs+(w+Command|w+Query)s','REGEX',1,'Command/Query DTO는 반드시 record 타입이어야 합니다.','2026-01-24 08:28:08.000000','2026-01-24 08:28:08.000000',NULL),(33,126,'DTO_INSTANCE_METHOD','records+w+(Command|Query).*{[^}]*(?:public|private)s+w+s+w+(','REGEX',1,'Command/Query record에 인스턴스 메서드를 정의할 수 없습니다.','2026-01-24 08:28:08.000000','2026-01-24 08:28:08.000000',NULL),(34,131,'QUERY_PORT_FIND_ALL','interfaces+w+QueryPort.*findAll()','REGEX',1,'QueryPort에 findAll() 메서드를 정의할 수 없습니다. OOM 위험이 있습니다.','2026-01-24 08:28:08.000000','2026-01-24 08:28:08.000000',NULL),(35,133,'DIRECT_EVENT_PUBLISHER','ApplicationEventPublishers+w+','REGEX',1,'ApplicationEventPublisher를 직접 주입할 수 없습니다. TransactionEventRegistry를 사용하세요.','2026-01-24 08:28:08.000000','2026-01-24 08:28:08.000000',NULL),(36,134,'NO_EVENT_REGISTRY','publishEvent((?!.*TransactionEventRegistry)','REGEX',1,'이벤트 발행 시 TransactionEventRegistry를 사용해야 합니다.','2026-01-24 08:28:08.000000','2026-01-24 08:28:08.000000',NULL),(37,135,'TIME_PROVIDER_OUTSIDE_FACTORY','(?<!Factory.*)TimeProvider','REGEX',1,'TimeProvider는 Factory 클래스에서만 사용할 수 있습니다.','2026-01-24 08:28:08.000000','2026-01-24 08:28:08.000000',NULL),(38,147,'JPA_REPO_INVALID_METHOD','JpaRepository.*(?:find|delete|exists|count)','REGEX',1,'JpaRepository에서는 save/saveAll만 사용할 수 있습니다. 조회는 QueryDslRepository를 사용하세요.','2026-01-24 08:28:36.000000','2026-01-24 08:28:36.000000',NULL),(39,148,'JPA_REPO_CUSTOM_METHOD','interfaces+w+JpaRepository.*{[^}]*(?:find|delete|exists|count)w+(','REGEX',1,'JpaRepository에 커스텀 메서드를 정의할 수 없습니다.','2026-01-24 08:28:36.000000','2026-01-24 08:28:36.000000',NULL),(40,149,'JPA_REPO_QUERY','JpaRepository.*@Query','REGEX',1,'JpaRepository에 @Query를 사용할 수 없습니다. QueryDslRepository를 사용하세요.','2026-01-24 08:28:36.000000','2026-01-24 08:28:36.000000',NULL),(41,150,'COMMAND_ADAPTER_WRONG_DEP','CommandAdapter.*QueryDslRepository','REGEX',1,'CommandAdapter는 JpaRepository만 의존해야 합니다. QueryDslRepository 사용 금지.','2026-01-24 08:28:36.000000','2026-01-24 08:28:36.000000',NULL),(42,151,'QUERY_ADAPTER_WRONG_DEP','QueryAdapter.*JpaRepository','REGEX',1,'QueryAdapter는 QueryDslRepository만 의존해야 합니다. JpaRepository 사용 금지.','2026-01-24 08:28:36.000000','2026-01-24 08:28:36.000000',NULL),(43,152,'JPA_RELATION_ANNOTATION','@(OneToOne|OneToMany|ManyToOne|ManyToMany|JoinColumn|JoinTable)','REGEX',1,'JPA 관계 어노테이션을 사용할 수 없습니다. Long FK 전략을 사용하세요.','2026-01-24 08:28:36.000000','2026-01-24 08:28:36.000000',NULL),(44,154,'OSIV_ENABLED','open-in-view:s*true','REGEX',1,'OSIV는 반드시 비활성화해야 합니다. open-in-view: false로 설정하세요.','2026-01-24 08:28:36.000000','2026-01-24 08:28:36.000000',NULL),(45,155,'DDL_AUTO_NOT_VALIDATE','ddl-auto:s*(?!validate)(create|update|create-drop|none)','REGEX',1,'ddl-auto는 validate만 허용됩니다.','2026-01-24 08:28:36.000000','2026-01-24 08:28:36.000000',NULL),(46,157,'NO_DELETED_AT_CONDITION','from(Qw+.w+)(?!.*deletedAt)','REGEX',1,'QueryDSL 조회 시 deletedAt IS NULL 조건이 필수입니다.','2026-01-24 08:28:36.000000','2026-01-24 08:28:36.000000',NULL),(47,160,'ADMIN_QUERY_WRONG_MODULE','persistence-mysql/.*admin.*Query','REGEX',1,'Admin용 복잡 쿼리는 persistence-mysql-admin 모듈에 작성해야 합니다.','2026-01-24 08:28:36.000000','2026-01-24 08:28:36.000000',NULL),(48,166,'DELETE_METHOD','@DeleteMapping|@RequestMapping.*DELETE|methods*=s*RequestMethod.DELETE','REGEX',1,'DELETE 메서드를 사용할 수 없습니다. PATCH로 soft delete를 구현하세요.','2026-01-24 08:28:57.000000','2026-01-24 08:28:57.000000',NULL),(49,169,'CONTROLLER_TRANSACTIONAL','@RestController[sS]*@Transactional|@Controller[sS]*@Transactional','REGEX',1,'Controller에 @Transactional을 사용할 수 없습니다. 트랜잭션은 Service/Manager 레이어에서 처리하세요.','2026-01-24 08:28:57.000000','2026-01-24 08:28:57.000000',NULL),(50,175,'LIST_DIRECT_RETURN','ResponseEntity<List<|List<w+>s+w+(','REGEX',1,'List를 직접 반환할 수 없습니다. SliceResult 또는 PageResult로 래핑하세요.','2026-01-24 08:28:57.000000','2026-01-24 08:28:57.000000',NULL);

SET FOREIGN_KEY_CHECKS = 1;
