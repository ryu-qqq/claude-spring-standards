
/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8mb4 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

INSERT INTO `architecture` (`id`, `tech_stack_id`, `name`, `pattern_type`, `pattern_description`, `pattern_principles`, `reference_links`, `created_at`, `updated_at`, `deleted_at`) VALUES (1,1,'hexagonal-multimodule','HEXAGONAL','포트와 어댑터 패턴 기반 멀티모듈 아키텍처. Domain 중심 설계로 외부 의존성을 격리하고, CQRS 패턴을 적용하여 Command/Query를 분리합니다.','[\"DIP\", \"SRP\", \"OCP\", \"ISP\", \"CQRS\", \"DDD\"]',NULL,'2026-01-20 02:11:20.000000','2026-01-20 02:11:20.000000',NULL);

INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (1,1,'ARCH-DOM-AGG-004','forNew() 팩토리 메서드 필수','Aggregate에 static forNew(..., Instant now) 팩토리 메서드가 있는가?','@Test\n@DisplayName(\"[필수] Aggregate는 forNew() 정적 팩토리 메서드가 있어야 한다\")\nvoid aggregate_MustHaveForNewMethod() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..domain..aggregate..\")\n        .and().areNotInterfaces()\n        .and().areNotEnums()\n        .should(haveStaticMethodWithName(\"forNew\"))\n        .because(\"신규 생성용 팩토리 메서드 필수\");\n    rule.check(domainClasses);\n}','AggregateArchTest','aggregate_MustHaveForNewMethod','BLOCKER','2026-01-24 15:40:19.000000','2026-01-24 15:40:19.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (2,1,'ARCH-DOM-AGG-005','reconstitute() 팩토리 메서드 필수','Aggregate에 static reconstitute(...) 팩토리 메서드가 있는가?','@Test\n@DisplayName(\"[필수] Aggregate는 reconstitute() 정적 팩토리 메서드가 있어야 한다\")\nvoid aggregate_MustHaveReconstituteMethod() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..domain..aggregate..\")\n        .and().areNotInterfaces()\n        .and().areNotEnums()\n        .should(haveStaticMethodWithName(\"reconstitute\"))\n        .because(\"영속성 복원용 팩토리 메서드 필수\");\n    rule.check(domainClasses);\n}','AggregateArchTest','aggregate_MustHaveReconstituteMethod','BLOCKER','2026-01-24 15:40:19.000000','2026-01-24 15:40:19.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (3,1,'ARCH-DOM-AGG-007-01','Aggregate ID는 ID VO 사용','Aggregate의 ID 필드가 전용 ID VO를 사용하는가?','@Test\n@DisplayName(\"[필수] Aggregate ID 필드는 ID VO 타입이어야 한다\")\nvoid aggregate_IdFieldMustBeIdVo() {\n    ArchRule rule = fields()\n        .that().areDeclaredInClassesThat().resideInAPackage(\"..domain..aggregate..\")\n        .and().haveName(\"id\")\n        .should().haveRawType(DescribedPredicate.describe(\n            \"ID VO type ending with Id\",\n            field -> field.getSimpleName().endsWith(\"Id\")))\n        .because(\"Aggregate ID는 전용 ID VO 사용 필수\");\n    rule.check(domainClasses);\n}','AggregateArchTest','aggregate_IdFieldMustBeIdVo','BLOCKER','2026-01-24 15:40:19.000000','2026-01-24 15:40:19.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (4,1,'ARCH-DOM-AGG-007-02','Long 원시 타입 ID 금지','Long 원시 타입 ID를 직접 사용하지 않는가?','@Test\n@DisplayName(\"[금지] Aggregate ID 필드에 Long 원시 타입 사용 금지\")\nvoid aggregate_IdFieldMustNotBeLong() {\n    ArchRule rule = noFields()\n        .that().areDeclaredInClassesThat().resideInAPackage(\"..domain..aggregate..\")\n        .and().haveName(\"id\")\n        .should().haveRawType(Long.class)\n        .because(\"Long 원시 타입 대신 ID VO 사용 필수\");\n    rule.check(domainClasses);\n}','AggregateArchTest','aggregate_IdFieldMustNotBeLong','BLOCKER','2026-01-24 15:40:19.000000','2026-01-24 15:40:19.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (5,1,'ARCH-DOM-AGG-008','isNew() 메서드 필수','Aggregate에 isNew() 메서드가 구현되어 있는가?','@Test\n@DisplayName(\"[필수] Aggregate는 isNew() 메서드가 있어야 한다\")\nvoid aggregate_MustHaveIsNewMethod() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..domain..aggregate..\")\n        .and().areNotInterfaces()\n        .and().areNotEnums()\n        .should(haveMethodWithName(\"isNew\"))\n        .because(\"신규 여부 판단 메서드 필수\");\n    rule.check(domainClasses);\n}','AggregateArchTest','aggregate_MustHaveIsNewMethod','BLOCKER','2026-01-24 15:40:19.000000','2026-01-24 15:40:19.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (6,1,'ARCH-DOM-AGG-009-01','시간 필드는 Instant 타입','시간 필드(createdAt, updatedAt)가 Instant 타입인가?','@Test\n@DisplayName(\"[필수] Aggregate 시간 필드는 Instant 타입이어야 한다\")\nvoid aggregate_TimeFieldsMustBeInstant() {\n    ArchRule rule = fields()\n        .that().areDeclaredInClassesThat().resideInAPackage(\"..domain..aggregate..\")\n        .and().haveNameMatching(\"(createdAt|updatedAt)\")\n        .should().haveRawType(java.time.Instant.class)\n        .because(\"시간 필드는 Instant 사용 (LocalDateTime 금지)\");\n    rule.check(domainClasses);\n}','AggregateArchTest','aggregate_TimeFieldsMustBeInstant','BLOCKER','2026-01-24 15:40:19.000000','2026-01-24 15:40:19.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (7,1,'ARCH-DOM-AGG-009-02','LocalDateTime 사용 금지','LocalDateTime, Date, Calendar 등을 사용하지 않는가?','@Test\n@DisplayName(\"[금지] Aggregate에서 LocalDateTime 사용 금지\")\nvoid aggregate_MustNotUseLocalDateTime() {\n    ArchRule rule = noFields()\n        .that().areDeclaredInClassesThat().resideInAPackage(\"..domain..aggregate..\")\n        .should().haveRawType(java.time.LocalDateTime.class)\n        .orShould().haveRawType(java.util.Date.class)\n        .because(\"시간 필드는 Instant 사용 필수\");\n    rule.check(domainClasses);\n}','AggregateArchTest','aggregate_MustNotUseLocalDateTime','BLOCKER','2026-01-24 15:40:19.000000','2026-01-24 15:40:19.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (8,1,'ARCH-DOM-AGG-010','Instant.now() 금지','Aggregate 내부에서 Instant.now() 직접 호출이 없는가?','@Test\n@DisplayName(\"[금지] Aggregate에서 Instant.now() 직접 호출 금지\")\nvoid aggregate_MustNotCallInstantNow() {\n    ArchRule rule = noClasses()\n        .that().resideInAPackage(\"..domain..aggregate..\")\n        .should().callMethod(java.time.Instant.class, \"now\")\n        .because(\"시간은 외부에서 주입받아야 함 (테스트 용이성)\");\n    rule.check(domainClasses);\n}','AggregateArchTest','aggregate_MustNotCallInstantNow','BLOCKER','2026-01-24 15:40:19.000000','2026-01-24 15:40:19.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (9,1,'ARCH-DOM-AGG-012','Setter 메서드 금지','public void setXxx() 형태의 Setter 메서드가 없는가?','@Test\n@DisplayName(\"[금지] Aggregate에 Setter 메서드 금지\")\nvoid aggregate_MustNotHaveSetterMethods() {\n    ArchRule rule = noMethods()\n        .that().areDeclaredInClassesThat().resideInAPackage(\"..domain..aggregate..\")\n        .and().arePublic()\n        .and().haveNameMatching(\"set[A-Z].*\")\n        .should().beDeclared()\n        .because(\"비즈니스 메서드로 상태 변경\");\n    rule.check(domainClasses);\n}','AggregateArchTest','aggregate_MustNotHaveSetterMethods','BLOCKER','2026-01-24 15:40:19.000000','2026-01-24 15:40:19.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (10,1,'ARCH-DOM-AGG-014','Getter 체이닝 금지','getXxx().getYyy() 형태의 Getter 체이닝이 없는가?','@Test\n@DisplayName(\"[금지] Getter 체이닝 금지 (Law of Demeter)\")\nvoid aggregate_MustNotHaveGetterChaining() {\n    // Note: ArchUnit으로 메서드 체이닝을 직접 감지하기 어려움\n    // 코드 리뷰 또는 정적 분석 도구(PMD)로 보완 필요\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..domain..aggregate..\")\n        .should(notExposeInternalObjects())\n        .because(\"Law of Demeter 준수 - 내부 객체 직접 노출 금지\");\n    rule.check(domainClasses);\n}','AggregateArchTest','aggregate_MustNotHaveGetterChaining','BLOCKER','2026-01-24 15:40:19.000000','2026-01-24 15:40:19.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (11,1,'ARCH-DOM-AGG-018','registerEvent() protected 메서드','registerEvent() 메서드가 protected로 선언되어 있는가?','@Test\n@DisplayName(\"[필수] registerEvent()는 protected여야 한다\")\nvoid aggregate_RegisterEventMustBeProtected() {\n    ArchRule rule = methods()\n        .that().areDeclaredInClassesThat().resideInAPackage(\"..domain..aggregate..\")\n        .and().haveName(\"registerEvent\")\n        .should().beProtected()\n        .allowEmptyShould(true)\n        .because(\"이벤트 등록은 내부에서만 가능\");\n    rule.check(domainClasses);\n}','AggregateArchTest','aggregate_RegisterEventMustBeProtected','MAJOR','2026-01-24 15:40:19.000000','2026-01-24 15:40:19.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (12,1,'ARCH-DOM-AGG-019','pollEvents() public 메서드','pollEvents() 메서드가 public으로 구현되어 있는가?','@Test\n@DisplayName(\"[필수] pollEvents()는 public이어야 한다\")\nvoid aggregate_PollEventsMustBePublic() {\n    ArchRule rule = methods()\n        .that().areDeclaredInClassesThat().resideInAPackage(\"..domain..aggregate..\")\n        .and().haveName(\"pollEvents\")\n        .should().bePublic()\n        .allowEmptyShould(true)\n        .because(\"이벤트 수확은 외부에서 호출\");\n    rule.check(domainClasses);\n}','AggregateArchTest','aggregate_PollEventsMustBePublic','MAJOR','2026-01-24 15:40:19.000000','2026-01-24 15:40:19.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (13,1,'ARCH-DOM-AGG-022','판단 메서드 boolean 반환','is, has, can으로 시작하는 메서드가 boolean을 반환하는가?','@Test\n@DisplayName(\"[필수] 판단 메서드(is/has/can)는 boolean 반환\")\nvoid aggregate_PredicateMethodsMustReturnBoolean() {\n    ArchRule rule = methods()\n        .that().areDeclaredInClassesThat().resideInAPackage(\"..domain..aggregate..\")\n        .and().haveNameMatching(\"(is|has|can)[A-Z].*\")\n        .should().haveRawReturnType(boolean.class)\n        .orShould().haveRawReturnType(Boolean.class)\n        .allowEmptyShould(true)\n        .because(\"판단 메서드는 boolean 반환 필수\");\n    rule.check(domainClasses);\n}','AggregateArchTest','aggregate_PredicateMethodsMustReturnBoolean','MAJOR','2026-01-24 15:40:19.000000','2026-01-24 15:40:19.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (14,1,'ARCH-DOM-CMN-001-01','순수 자바 객체 원칙','도메인 객체가 순수 자바 객체(POJO)인가?','@Test\n@DisplayName(\"[금지] Domain에서 Lombok 어노테이션 사용 금지\")\nvoid domain_MustNotUseLombok() {\n    ArchRule rule = noClasses()\n        .that().resideInAPackage(\"..domain..\")\n        .should().beAnnotatedWith(\"lombok.Data\")\n        .orShould().beAnnotatedWith(\"lombok.Builder\")\n        .orShould().beAnnotatedWith(\"lombok.Getter\")\n        .orShould().beAnnotatedWith(\"lombok.Setter\")\n        .orShould().beAnnotatedWith(\"lombok.AllArgsConstructor\")\n        .orShould().beAnnotatedWith(\"lombok.NoArgsConstructor\")\n        .orShould().beAnnotatedWith(\"lombok.RequiredArgsConstructor\")\n        .because(\"Domain Layer는 Pure Java 원칙\");\n    rule.check(domainClasses);\n}','DomainCommonArchTest','domain_MustNotUseLombok','BLOCKER','2026-01-24 15:40:19.000000','2026-01-24 15:40:19.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (15,1,'ARCH-DOM-CMN-001-02','JPA/Spring 어노테이션 금지','Lombok, JPA, Spring 어노테이션을 사용하지 않는가?','@Test\n@DisplayName(\"[금지] Domain에서 JPA/Spring 어노테이션 사용 금지\")\nvoid domain_MustNotUseJpaOrSpring() {\n    ArchRule rule = noClasses()\n        .that().resideInAPackage(\"..domain..\")\n        .should().beAnnotatedWith(\"jakarta.persistence.Entity\")\n        .orShould().beAnnotatedWith(\"jakarta.persistence.Table\")\n        .orShould().beAnnotatedWith(\"org.springframework.stereotype.Component\")\n        .orShould().beAnnotatedWith(\"org.springframework.stereotype.Service\")\n        .because(\"Domain Layer는 JPA/Spring에 독립적\");\n    rule.check(domainClasses);\n}','DomainCommonArchTest','domain_MustNotUseJpaOrSpring','BLOCKER','2026-01-24 15:40:19.000000','2026-01-24 15:40:19.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (16,1,'ARCH-DOM-CMN-002-01','외부 레이어 의존 금지','도메인 객체가 Application, Persistence, REST API 레이어를 의존하지 않는가?','@Test\n@DisplayName(\"[금지] Domain에서 외부 레이어 의존 금지\")\nvoid domain_MustNotDependOnOuterLayers() {\n    ArchRule rule = noClasses()\n        .that().resideInAPackage(\"..domain..\")\n        .should().dependOnClassesThat().resideInAnyPackage(\n            \"..application..\",\n            \"..adapter..\"\n        )\n        .because(\"헥사고날 아키텍처: Domain은 외부 레이어에 의존 금지\");\n    rule.check(domainClasses);\n}','DomainCommonArchTest','domain_MustNotDependOnOuterLayers','BLOCKER','2026-01-24 15:40:19.000000','2026-01-24 15:40:19.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (17,1,'ARCH-DOM-CMN-002-02','특정 클래스 의존 금지','Repository, Port, Service, Controller, Entity, DTO를 import하지 않는가?','@Test\n@DisplayName(\"[금지] Domain에서 특정 클래스 타입 의존 금지\")\nvoid domain_MustNotDependOnSpecificTypes() {\n    ArchRule rule = noClasses()\n        .that().resideInAPackage(\"..domain..\")\n        .should().dependOnClassesThat().haveNameMatching(\".*Repository\")\n        .orShould().dependOnClassesThat().haveNameMatching(\".*Port\")\n        .orShould().dependOnClassesThat().haveNameMatching(\".*Service\")\n        .orShould().dependOnClassesThat().haveNameMatching(\".*Controller\")\n        .orShould().dependOnClassesThat().haveNameMatching(\".*JpaEntity\")\n        .because(\"Domain은 인프라 클래스에 의존 금지\");\n    rule.check(domainClasses);\n}','DomainCommonArchTest','domain_MustNotDependOnSpecificTypes','BLOCKER','2026-01-24 15:40:19.000000','2026-01-24 15:40:19.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (18,2,'ARCH-DOM-VO-001-01','VO Record 타입 필수','Value Object가 Java Record로 정의되어 있는가?','@Test\n@DisplayName(\"[필수] Value Object는 Record 타입이어야 한다\")\nvoid valueObject_MustBeRecord() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..domain..vo..\")\n        .and().areNotEnums()\n        .should().beRecords()\n        .allowEmptyShould(true)\n        .because(\"Value Object는 불변성 보장을 위해 Record 사용\");\n    rule.check(domainClasses);\n}','ValueObjectArchTest','valueObject_MustBeRecord','BLOCKER','2026-01-24 15:40:19.000000','2026-01-24 15:40:19.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (19,2,'ARCH-DOM-VO-001-02','class 대신 record 키워드','class 대신 record 키워드를 사용하는가?','@Test\n@DisplayName(\"[금지] VO 패키지에 일반 class 금지\")\nvoid valueObject_MustNotBeRegularClass() {\n    ArchRule rule = noClasses()\n        .that().resideInAPackage(\"..domain..vo..\")\n        .and().areNotEnums()\n        .and().areNotRecords()\n        .should().bePublic()\n        .allowEmptyShould(true)\n        .because(\"Value Object는 Record 또는 Enum만 허용\");\n    rule.check(domainClasses);\n}','ValueObjectArchTest','valueObject_MustNotBeRegularClass','BLOCKER','2026-01-24 15:40:19.000000','2026-01-24 15:40:19.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (20,2,'ARCH-DOM-VO-002','of() 정적 팩토리 메서드 필수','Value Object에 of() 정적 팩토리 메서드가 있는가?','@Test\n@DisplayName(\"[필수] Value Object는 of() 정적 팩토리 메서드가 있어야 한다\")\nvoid valueObject_MustHaveOfMethod() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..domain..vo..\")\n        .and().areRecords()\n        .should(haveStaticMethodWithName(\"of\"))\n        .allowEmptyShould(true)\n        .because(\"Value Object 생성은 of() 팩토리 메서드 사용\");\n    rule.check(domainClasses);\n}','ValueObjectArchTest','valueObject_MustHaveOfMethod','BLOCKER','2026-01-24 15:40:19.000000','2026-01-24 15:40:19.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (21,2,'ARCH-DOM-VO-004','Enum VO displayName() 필수','Enum 타입의 VO에 displayName() 메서드가 있는가?','@Test\n@DisplayName(\"[필수] Enum VO는 displayName() 메서드가 있어야 한다\")\nvoid enumVo_MustHaveDisplayNameMethod() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..domain..vo..\")\n        .and().areEnums()\n        .should(haveMethodWithName(\"displayName\"))\n        .allowEmptyShould(true)\n        .because(\"Enum VO는 사용자 표시용 displayName 필수\");\n    rule.check(domainClasses);\n}','ValueObjectArchTest','enumVo_MustHaveDisplayNameMethod','MAJOR','2026-01-24 15:40:19.000000','2026-01-24 15:40:19.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (22,3,'ARCH-DOM-ID-001','ID VO *Id 네이밍 필수','ID VO가 {Domain}Id 형태로 네이밍되어 있는가?','@Test\n@DisplayName(\"[필수] ID VO는 *Id 네이밍이어야 한다\")\nvoid idVo_MustEndWithId() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..domain..id..\")\n        .should().haveSimpleNameEndingWith(\"Id\")\n        .allowEmptyShould(true)\n        .because(\"ID VO는 {Domain}Id 네이밍 규칙 필수\");\n    rule.check(domainClasses);\n}','IdVoArchTest','idVo_MustEndWithId','BLOCKER','2026-01-24 15:40:19.000000','2026-01-24 15:40:19.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (23,3,'ARCH-DOM-ID-002','ID VO Record 타입 필수','ID VO가 Java Record로 정의되어 있는가?','@Test\n@DisplayName(\"[필수] ID VO는 Record 타입이어야 한다\")\nvoid idVo_MustBeRecord() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..domain..id..\")\n        .should().beRecords()\n        .allowEmptyShould(true)\n        .because(\"ID VO는 불변성 보장을 위해 Record 사용\");\n    rule.check(domainClasses);\n}','IdVoArchTest','idVo_MustBeRecord','BLOCKER','2026-01-24 15:40:20.000000','2026-01-24 15:40:20.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (24,3,'ARCH-DOM-ID-003','ID VO of() 정적 팩토리 메서드 필수','ID VO에 of() 정적 팩토리 메서드가 있는가?','@Test\n@DisplayName(\"[필수] ID VO는 of() 정적 팩토리 메서드가 있어야 한다\")\nvoid idVo_MustHaveOfMethod() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..domain..id..\")\n        .should(haveStaticMethodWithName(\"of\"))\n        .allowEmptyShould(true)\n        .because(\"ID VO 생성은 of() 팩토리 메서드 사용\");\n    rule.check(domainClasses);\n}','IdVoArchTest','idVo_MustHaveOfMethod','BLOCKER','2026-01-24 15:40:20.000000','2026-01-24 15:40:20.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (25,3,'ARCH-DOM-ID-004','Long ID forNew() 필수','Long 타입 ID VO에 forNew() 정적 팩토리 메서드가 있는가?','@Test\n@DisplayName(\"[필수] Long ID VO는 forNew() 정적 팩토리 메서드가 있어야 한다\")\nvoid longIdVo_MustHaveForNewMethod() {\n    // Note: Long 타입 ID 여부는 필드 타입으로 판단\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..domain..id..\")\n        .and().containAnyFieldsThat(DescribedPredicate.describe(\n            \"Long type field\",\n            field -> field.getRawType().isEquivalentTo(Long.class)))\n        .should(haveStaticMethodWithName(\"forNew\"))\n        .allowEmptyShould(true)\n        .because(\"Long ID는 신규 생성용 forNew() 필수\");\n    rule.check(domainClasses);\n}','IdVoArchTest','longIdVo_MustHaveForNewMethod','BLOCKER','2026-01-24 15:40:20.000000','2026-01-24 15:40:20.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (26,3,'ARCH-DOM-ID-006','Long ID isNew() 필수','Long 타입 ID VO에 isNew() 메서드가 있는가?','@Test\n@DisplayName(\"[필수] Long ID VO는 isNew() 메서드가 있어야 한다\")\nvoid longIdVo_MustHaveIsNewMethod() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..domain..id..\")\n        .and().containAnyFieldsThat(DescribedPredicate.describe(\n            \"Long type field\",\n            field -> field.getRawType().isEquivalentTo(Long.class)))\n        .should(haveMethodWithName(\"isNew\"))\n        .allowEmptyShould(true)\n        .because(\"Long ID는 신규 여부 판단 isNew() 필수\");\n    rule.check(domainClasses);\n}','IdVoArchTest','longIdVo_MustHaveIsNewMethod','BLOCKER','2026-01-24 15:40:20.000000','2026-01-24 15:40:20.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (27,3,'ARCH-DOM-ID-007','String ID isNew() 금지','String 타입 ID VO에 isNew() 메서드가 없는가?','@Test\n@DisplayName(\"[금지] String ID VO는 isNew() 메서드가 없어야 한다\")\nvoid stringIdVo_MustNotHaveIsNewMethod() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..domain..id..\")\n        .and().containAnyFieldsThat(DescribedPredicate.describe(\n            \"String type field\",\n            field -> field.getRawType().isEquivalentTo(String.class)))\n        .should(notHaveMethodWithName(\"isNew\"))\n        .allowEmptyShould(true)\n        .because(\"String ID는 항상 외부 주입이므로 isNew 불필요\");\n    rule.check(domainClasses);\n}','IdVoArchTest','stringIdVo_MustNotHaveIsNewMethod','BLOCKER','2026-01-24 15:40:20.000000','2026-01-24 15:40:20.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (28,3,'ARCH-DOM-ID-008-02','UUID.randomUUID() 호출 금지','Domain에서 UUID.randomUUID() 호출이 없는가?','@Test\n@DisplayName(\"[금지] Domain에서 UUID.randomUUID() 호출 금지\")\nvoid domain_MustNotCallUuidRandomUuid() {\n    ArchRule rule = noClasses()\n        .that().resideInAPackage(\"..domain..\")\n        .should().callMethod(java.util.UUID.class, \"randomUUID\")\n        .because(\"String ID는 외부(Application Layer)에서 생성해서 주입\");\n    rule.check(domainClasses);\n}','IdVoArchTest','domain_MustNotCallUuidRandomUuid','BLOCKER','2026-01-24 15:40:20.000000','2026-01-24 15:40:20.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (29,7,'ARCH-DOM-EVT-001','DomainEvent 인터페이스 구현 필수','도메인 이벤트가 DomainEvent 인터페이스를 구현하는가?','@Test\n@DisplayName(\"[필수] 도메인 이벤트는 DomainEvent 인터페이스를 구현해야 한다\")\nvoid domainEvent_MustImplementDomainEventInterface() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..domain..event..\")\n        .and().haveSimpleNameEndingWith(\"Event\")\n        .and().areNotInterfaces()\n        .should().implement(DomainEvent.class)\n        .allowEmptyShould(true)\n        .because(\"도메인 이벤트 표준 인터페이스 구현 필수\");\n    rule.check(domainClasses);\n}','DomainEventArchTest','domainEvent_MustImplementDomainEventInterface','BLOCKER','2026-01-24 15:40:20.000000','2026-01-24 15:40:20.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (30,7,'ARCH-DOM-EVT-002','Event Record 타입 필수','도메인 이벤트가 Java Record로 정의되어 있는가?','@Test\n@DisplayName(\"[필수] 도메인 이벤트는 Record 타입이어야 한다\")\nvoid domainEvent_MustBeRecord() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..domain..event..\")\n        .and().haveSimpleNameEndingWith(\"Event\")\n        .and().areNotInterfaces()\n        .should().beRecords()\n        .allowEmptyShould(true)\n        .because(\"도메인 이벤트는 불변성 보장을 위해 Record 사용\");\n    rule.check(domainClasses);\n}','DomainEventArchTest','domainEvent_MustBeRecord','BLOCKER','2026-01-24 15:40:20.000000','2026-01-24 15:40:20.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (31,7,'ARCH-DOM-EVT-003','Event occurredAt 필드 필수','도메인 이벤트에 occurredAt(Instant) 필드가 있는가?','@Test\n@DisplayName(\"[필수] 도메인 이벤트는 occurredAt 필드가 있어야 한다\")\nvoid domainEvent_MustHaveOccurredAtField() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..domain..event..\")\n        .and().haveSimpleNameEndingWith(\"Event\")\n        .and().areRecords()\n        .should(haveFieldWithName(\"occurredAt\"))\n        .allowEmptyShould(true)\n        .because(\"이벤트 발생 시각 기록 필수\");\n    rule.check(domainClasses);\n}','DomainEventArchTest','domainEvent_MustHaveOccurredAtField','BLOCKER','2026-01-24 15:40:20.000000','2026-01-24 15:40:20.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (32,7,'ARCH-DOM-EVT-004','Event from() 팩토리 메서드 필수','도메인 이벤트에 from(Aggregate, Instant) 정적 팩토리 메서드가 있는가?','@Test\n@DisplayName(\"[필수] 도메인 이벤트는 from() 정적 팩토리 메서드가 있어야 한다\")\nvoid domainEvent_MustHaveFromMethod() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..domain..event..\")\n        .and().haveSimpleNameEndingWith(\"Event\")\n        .and().areRecords()\n        .should(haveStaticMethodWithName(\"from\"))\n        .allowEmptyShould(true)\n        .because(\"도메인 이벤트는 from(Aggregate, Instant) 팩토리 메서드 사용\");\n    rule.check(domainClasses);\n}','DomainEventArchTest','domainEvent_MustHaveFromMethod','BLOCKER','2026-01-24 15:40:20.000000','2026-01-24 15:40:20.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (33,7,'ARCH-DOM-EVT-006','Event 패키지 위치','도메인 이벤트가 domain.{bc}.event 패키지에 위치하는가?','@Test\n@DisplayName(\"[필수] 도메인 이벤트는 event 패키지에 위치해야 한다\")\nvoid domainEvent_MustBeInEventPackage() {\n    ArchRule rule = classes()\n        .that().haveSimpleNameEndingWith(\"Event\")\n        .and().areNotInterfaces()\n        .and().resideInAPackage(\"..domain..\")\n        .should().resideInAPackage(\"..event..\")\n        .allowEmptyShould(true)\n        .because(\"도메인 이벤트는 event 패키지에 위치\");\n    rule.check(domainClasses);\n}','DomainEventArchTest','domainEvent_MustBeInEventPackage','BLOCKER','2026-01-24 15:40:20.000000','2026-01-24 15:40:20.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (34,4,'ARCH-DOM-EXC-001','ErrorCode 인터페이스 구현 필수','ErrorCode enum이 ErrorCode 인터페이스를 구현하는가?','@Test\n@DisplayName(\"[필수] ErrorCode enum은 ErrorCode 인터페이스를 구현해야 한다\")\nvoid errorCode_MustImplementErrorCodeInterface() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..domain..exception..\")\n        .and().areEnums()\n        .and().haveSimpleNameEndingWith(\"ErrorCode\")\n        .should().implement(ErrorCode.class)\n        .allowEmptyShould(true)\n        .because(\"ErrorCode 표준 인터페이스 구현 필수\");\n    rule.check(domainClasses);\n}','ExceptionArchTest','errorCode_MustImplementErrorCodeInterface','BLOCKER','2026-01-24 15:40:20.000000','2026-01-24 15:40:20.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (35,4,'ARCH-DOM-EXC-002','ErrorCode 패키지 위치','ErrorCode가 domain.{bc}.exception 패키지에 위치하는가?','@Test\n@DisplayName(\"[필수] ErrorCode는 exception 패키지에 위치해야 한다\")\nvoid errorCode_MustBeInExceptionPackage() {\n    ArchRule rule = classes()\n        .that().haveSimpleNameEndingWith(\"ErrorCode\")\n        .and().areEnums()\n        .should().resideInAPackage(\"..exception..\")\n        .allowEmptyShould(true)\n        .because(\"ErrorCode는 exception 패키지에 위치\");\n    rule.check(domainClasses);\n}','ExceptionArchTest','errorCode_MustBeInExceptionPackage','BLOCKER','2026-01-24 15:40:20.000000','2026-01-24 15:40:20.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (36,4,'ARCH-DOM-EXC-004','Exception Lombok 금지','Exception에서 Lombok을 사용하지 않는가?','@Test\n@DisplayName(\"[금지] Exception에서 Lombok 사용 금지\")\nvoid exception_MustNotUseLombok() {\n    ArchRule rule = noClasses()\n        .that().resideInAPackage(\"..domain..exception..\")\n        .should().beAnnotatedWith(\"lombok.Getter\")\n        .orShould().beAnnotatedWith(\"lombok.Data\")\n        .because(\"Exception은 Plain Java 사용\");\n    rule.check(domainClasses);\n}','ExceptionArchTest','exception_MustNotUseLombok','BLOCKER','2026-01-24 15:40:20.000000','2026-01-24 15:40:20.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (37,4,'ARCH-DOM-EXC-005','ErrorCode getCode() 메서드 필수','ErrorCode에 getCode() 메서드가 있는가?','@Test\n@DisplayName(\"[필수] ErrorCode는 getCode() 메서드가 있어야 한다\")\nvoid errorCode_MustHaveGetCodeMethod() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..domain..exception..\")\n        .and().areEnums()\n        .and().haveSimpleNameEndingWith(\"ErrorCode\")\n        .should(haveMethodWithName(\"getCode\"))\n        .allowEmptyShould(true)\n        .because(\"ErrorCode 식별자 메서드 필수\");\n    rule.check(domainClasses);\n}','ExceptionArchTest','errorCode_MustHaveGetCodeMethod','BLOCKER','2026-01-24 15:40:20.000000','2026-01-24 15:40:20.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (38,4,'ARCH-DOM-EXC-006-01','ErrorCode getHttpStatus() int 반환','ErrorCode의 getHttpStatus()가 int 타입을 반환하는가?','@Test\n@DisplayName(\"[필수] ErrorCode getHttpStatus()는 int 반환\")\nvoid errorCode_GetHttpStatusMustReturnInt() {\n    ArchRule rule = methods()\n        .that().areDeclaredInClassesThat().resideInAPackage(\"..domain..exception..\")\n        .and().areDeclaredInClassesThat().areEnums()\n        .and().haveName(\"getHttpStatus\")\n        .should().haveRawReturnType(int.class)\n        .allowEmptyShould(true)\n        .because(\"HTTP 상태 코드는 int 타입\");\n    rule.check(domainClasses);\n}','ExceptionArchTest','errorCode_GetHttpStatusMustReturnInt','BLOCKER','2026-01-24 15:40:20.000000','2026-01-24 15:40:20.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (39,4,'ARCH-DOM-EXC-006-02','Spring HttpStatus 사용 금지','Spring HttpStatus를 사용하지 않는가?','@Test\n@DisplayName(\"[금지] Domain에서 Spring HttpStatus 사용 금지\")\nvoid domain_MustNotUseSpringHttpStatus() {\n    ArchRule rule = noClasses()\n        .that().resideInAPackage(\"..domain..\")\n        .should().dependOnClassesThat().haveFullyQualifiedName(\"org.springframework.http.HttpStatus\")\n        .because(\"Domain은 Spring에 독립적\");\n    rule.check(domainClasses);\n}','ExceptionArchTest','domain_MustNotUseSpringHttpStatus','BLOCKER','2026-01-24 15:40:20.000000','2026-01-24 15:40:20.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (40,4,'ARCH-DOM-EXC-007','ErrorCode getMessage() 메서드 필수','ErrorCode에 getMessage() 메서드가 있는가?','@Test\n@DisplayName(\"[필수] ErrorCode는 getMessage() 메서드가 있어야 한다\")\nvoid errorCode_MustHaveGetMessageMethod() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..domain..exception..\")\n        .and().areEnums()\n        .and().haveSimpleNameEndingWith(\"ErrorCode\")\n        .should(haveMethodWithName(\"getMessage\"))\n        .allowEmptyShould(true)\n        .because(\"에러 메시지 조회 메서드 필수\");\n    rule.check(domainClasses);\n}','ExceptionArchTest','errorCode_MustHaveGetMessageMethod','BLOCKER','2026-01-24 15:40:20.000000','2026-01-24 15:40:20.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (41,4,'ARCH-DOM-EXC-009','DomainException 상속 필수','도메인 예외 클래스가 DomainException을 상속받는가?','@Test\n@DisplayName(\"[필수] 도메인 예외는 DomainException을 상속해야 한다\")\nvoid domainException_MustExtendDomainException() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..domain..exception..\")\n        .and().haveSimpleNameEndingWith(\"Exception\")\n        .and().areNotInterfaces()\n        .and().doNotHaveSimpleName(\"DomainException\")\n        .should().beAssignableTo(DomainException.class)\n        .allowEmptyShould(true)\n        .because(\"도메인 예외 계층 구조 통일\");\n    rule.check(domainClasses);\n}','ExceptionArchTest','domainException_MustExtendDomainException','BLOCKER','2026-01-24 15:40:20.000000','2026-01-24 15:40:20.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (42,4,'ARCH-DOM-EXC-010','Exception 패키지 위치','도메인 예외가 domain.{bc}.exception 패키지에 위치하는가?','@Test\n@DisplayName(\"[필수] 도메인 예외는 exception 패키지에 위치해야 한다\")\nvoid domainException_MustBeInExceptionPackage() {\n    ArchRule rule = classes()\n        .that().haveSimpleNameEndingWith(\"Exception\")\n        .and().resideInAPackage(\"..domain..\")\n        .and().areNotInterfaces()\n        .should().resideInAPackage(\"..exception..\")\n        .allowEmptyShould(true)\n        .because(\"도메인 예외는 exception 패키지에 위치\");\n    rule.check(domainClasses);\n}','ExceptionArchTest','domainException_MustBeInExceptionPackage','BLOCKER','2026-01-24 15:40:20.000000','2026-01-24 15:40:20.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (43,4,'ARCH-DOM-EXC-014','Exception public 클래스','도메인 예외가 public 클래스로 선언되어 있는가?','@Test\n@DisplayName(\"[필수] 도메인 예외는 public이어야 한다\")\nvoid domainException_MustBePublic() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..domain..exception..\")\n        .and().haveSimpleNameEndingWith(\"Exception\")\n        .should().bePublic()\n        .allowEmptyShould(true)\n        .because(\"다른 레이어에서 사용\");\n    rule.check(domainClasses);\n}','ExceptionArchTest','domainException_MustBePublic','BLOCKER','2026-01-24 15:40:20.000000','2026-01-24 15:40:20.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (44,4,'ARCH-DOM-EXC-015','Exception RuntimeException 계층','도메인 예외가 RuntimeException 계층인가?','@Test\n@DisplayName(\"[필수] 도메인 예외는 RuntimeException 계층이어야 한다\")\nvoid domainException_MustBeRuntimeException() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..domain..exception..\")\n        .and().haveSimpleNameEndingWith(\"Exception\")\n        .should().beAssignableTo(RuntimeException.class)\n        .allowEmptyShould(true)\n        .because(\"Unchecked Exception 사용\");\n    rule.check(domainClasses);\n}','ExceptionArchTest','domainException_MustBeRuntimeException','BLOCKER','2026-01-24 15:40:20.000000','2026-01-24 15:40:20.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (45,6,'ARCH-DOM-EXC-019','DomainException common 패키지','DomainException 추상 클래스가 domain.common.exception 패키지에 있는가?','@Test\n@DisplayName(\"[필수] DomainException은 common.exception 패키지에 위치\")\nvoid domainException_MustBeInCommonPackage() {\n    ArchRule rule = classes()\n        .that().haveSimpleName(\"DomainException\")\n        .should().resideInAPackage(\"..common.exception..\")\n        .allowEmptyShould(true)\n        .because(\"공통 예외 추상 클래스는 common 패키지\");\n    rule.check(domainClasses);\n}','ExceptionArchTest','domainException_MustBeInCommonPackage','BLOCKER','2026-01-24 15:40:20.000000','2026-01-24 15:40:20.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (46,6,'ARCH-DOM-EXC-020','ErrorCode 인터페이스 common 패키지','ErrorCode 인터페이스가 domain.common.exception 패키지에 있는가?','@Test\n@DisplayName(\"[필수] ErrorCode 인터페이스는 common.exception 패키지에 위치\")\nvoid errorCodeInterface_MustBeInCommonPackage() {\n    ArchRule rule = classes()\n        .that().haveSimpleName(\"ErrorCode\")\n        .and().areInterfaces()\n        .should().resideInAPackage(\"..common.exception..\")\n        .allowEmptyShould(true)\n        .because(\"공통 ErrorCode 인터페이스는 common 패키지\");\n    rule.check(domainClasses);\n}','ExceptionArchTest','errorCodeInterface_MustBeInCommonPackage','BLOCKER','2026-01-24 15:40:21.000000','2026-01-24 15:40:21.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (47,8,'ARCH-DOM-CRI-001','Criteria 패키지 위치','Criteria가 domain.{bc}.query.criteria 패키지에 위치하는가?','@Test\n@DisplayName(\"[필수] Criteria는 query 패키지에 위치해야 한다\")\nvoid criteria_MustBeInQueryPackage() {\n    ArchRule rule = classes()\n        .that().haveSimpleNameEndingWith(\"Criteria\")\n        .and().resideInAPackage(\"..domain..\")\n        .should().resideInAPackage(\"..query..\")\n        .allowEmptyShould(true)\n        .because(\"Criteria는 query 패키지에 위치\");\n    rule.check(domainClasses);\n}','CriteriaArchTest','criteria_MustBeInQueryPackage','BLOCKER','2026-01-24 15:40:21.000000','2026-01-24 15:40:21.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (48,8,'ARCH-DOM-CRI-003','Criteria public 접근 제어자','Criteria가 public으로 선언되어 있는가?','@Test\n@DisplayName(\"[필수] Criteria는 public이어야 한다\")\nvoid criteria_MustBePublic() {\n    ArchRule rule = classes()\n        .that().haveSimpleNameEndingWith(\"Criteria\")\n        .and().resideInAPackage(\"..domain..query..\")\n        .should().bePublic()\n        .allowEmptyShould(true)\n        .because(\"다른 레이어에서 사용\");\n    rule.check(domainClasses);\n}','CriteriaArchTest','criteria_MustBePublic','BLOCKER','2026-01-24 15:40:21.000000','2026-01-24 15:40:21.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (49,8,'ARCH-DOM-CRI-004','Criteria Record 타입 필수','Criteria가 Java Record로 정의되어 있는가?','@Test\n@DisplayName(\"[필수] Criteria는 Record 타입이어야 한다\")\nvoid criteria_MustBeRecord() {\n    ArchRule rule = classes()\n        .that().haveSimpleNameEndingWith(\"Criteria\")\n        .and().resideInAPackage(\"..domain..query..\")\n        .should().beRecords()\n        .allowEmptyShould(true)\n        .because(\"Criteria는 불변 조회 조건\");\n    rule.check(domainClasses);\n}','CriteriaArchTest','criteria_MustBeRecord','BLOCKER','2026-01-24 15:40:21.000000','2026-01-24 15:40:21.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (50,8,'ARCH-DOM-CRI-005','Criteria of() 팩토리 메서드 필수','Criteria에 of() 정적 팩토리 메서드가 있는가?','@Test\n@DisplayName(\"[필수] Criteria는 of() 정적 팩토리 메서드가 있어야 한다\")\nvoid criteria_MustHaveOfMethod() {\n    ArchRule rule = classes()\n        .that().haveSimpleNameEndingWith(\"Criteria\")\n        .and().resideInAPackage(\"..domain..query..\")\n        .should(haveStaticMethodWithName(\"of\"))\n        .allowEmptyShould(true)\n        .because(\"Criteria 생성은 of() 팩토리 메서드 사용\");\n    rule.check(domainClasses);\n}','CriteriaArchTest','criteria_MustHaveOfMethod','BLOCKER','2026-01-24 15:40:21.000000','2026-01-24 15:40:21.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (51,8,'ARCH-DOM-CRI-010','Criteria JPA/Spring 어노테이션 금지','Criteria에서 JPA/Spring 어노테이션을 사용하지 않는가?','@Test\n@DisplayName(\"[금지] Criteria에서 JPA/Spring 어노테이션 사용 금지\")\nvoid criteria_MustNotUseJpaOrSpring() {\n    ArchRule rule = noClasses()\n        .that().haveSimpleNameEndingWith(\"Criteria\")\n        .and().resideInAPackage(\"..domain..query..\")\n        .should().beAnnotatedWith(\"jakarta.persistence.Entity\")\n        .orShould().beAnnotatedWith(\"org.springframework.stereotype.Component\")\n        .because(\"Criteria는 순수 자바 객체\");\n    rule.check(domainClasses);\n}','CriteriaArchTest','criteria_MustNotUseJpaOrSpring','BLOCKER','2026-01-24 15:40:21.000000','2026-01-24 15:40:21.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (52,14,'ARCH-APP-TRX-001','Service @Transactional 금지','Service 클래스에 @Transactional 어노테이션이 없는가?','@Test\n@DisplayName(\"[금지] Service에 @Transactional 금지\")\nvoid service_MustNotHaveTransactional() {\n    ArchRule rule = noClasses()\n        .that().resideInAPackage(\"..application..service..\")\n        .and().haveSimpleNameEndingWith(\"Service\")\n        .should().beAnnotatedWith(\"org.springframework.transaction.annotation.Transactional\")\n        .because(\"트랜잭션 경계는 Manager/Facade 책임\");\n    rule.check(applicationClasses);\n}','ApplicationTransactionArchTest','service_MustNotHaveTransactional','BLOCKER','2026-01-24 15:40:21.000000','2026-01-24 15:40:21.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (53,18,'ARCH-APP-TRX-002','Manager @Transactional 필수','CommandManager/QueryManager에 @Transactional이 있는가?','@Test\n@DisplayName(\"[필수] Manager에 @Transactional 필수\")\nvoid manager_MustHaveTransactional() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..application..manager..\")\n        .and().haveSimpleNameEndingWith(\"Manager\")\n        .and().haveSimpleNameNotContaining(\"Client\")\n        .should().beAnnotatedWith(\"org.springframework.transaction.annotation.Transactional\")\n        .allowEmptyShould(true)\n        .because(\"Manager가 트랜잭션 경계\");\n    rule.check(applicationClasses);\n}','ApplicationTransactionArchTest','manager_MustHaveTransactional','BLOCKER','2026-01-24 15:40:21.000000','2026-01-24 15:40:21.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (54,20,'ARCH-APP-TRX-003','ClientManager @Transactional 금지','ClientManager에 @Transactional 어노테이션이 없는가?','@Test\n@DisplayName(\"[금지] ClientManager에 @Transactional 금지\")\nvoid clientManager_MustNotHaveTransactional() {\n    ArchRule rule = noClasses()\n        .that().resideInAPackage(\"..application..manager.client..\")\n        .and().haveSimpleNameEndingWith(\"Manager\")\n        .should().beAnnotatedWith(\"org.springframework.transaction.annotation.Transactional\")\n        .because(\"외부 API 호출은 트랜잭션 밖에서\");\n    rule.check(applicationClasses);\n}','ApplicationTransactionArchTest','clientManager_MustNotHaveTransactional','BLOCKER','2026-01-24 15:40:21.000000','2026-01-24 15:40:21.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (55,17,'ARCH-APP-TRX-005','QueryFacade @Transactional(readOnly=true)','QueryFacade에 @Transactional(readOnly=true)가 있는가?','@Test\n@DisplayName(\"[필수] QueryFacade에 @Transactional(readOnly=true) 필수\")\nvoid queryFacade_MustHaveReadOnlyTransactional() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..application..facade.query..\")\n        .and().haveSimpleNameEndingWith(\"Facade\")\n        .should().beAnnotatedWith(\n            DescribedPredicate.describe(\n                \"@Transactional(readOnly=true)\",\n                annotation -> annotation.getName().contains(\"Transactional\")))\n        .allowEmptyShould(true)\n        .because(\"조회 전용 트랜잭션 최적화\");\n    rule.check(applicationClasses);\n}','ApplicationTransactionArchTest','queryFacade_MustHaveReadOnlyTransactional','MAJOR','2026-01-24 15:40:21.000000','2026-01-24 15:40:21.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (56,27,'ARCH-APP-DTO-001-01','Command/Query Record 필수','Command/Query DTO가 Java Record로 정의되어 있는가?','@Test\n@DisplayName(\"[필수] Command/Query는 Record 타입이어야 한다\")\nvoid commandQuery_MustBeRecord() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..application..dto..\")\n        .and().haveSimpleNameEndingWith(\"Command\")\n        .or().haveSimpleNameEndingWith(\"Query\")\n        .should().beRecords()\n        .allowEmptyShould(true)\n        .because(\"Command/Query DTO는 불변\");\n    rule.check(applicationClasses);\n}','ApplicationDtoArchTest','commandQuery_MustBeRecord','BLOCKER','2026-01-24 15:40:21.000000','2026-01-24 15:40:21.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (57,27,'ARCH-APP-DTO-001-02','Command/Query Lombok 금지','Lombok을 사용하지 않는가?','@Test\n@DisplayName(\"[금지] Command/Query에서 Lombok 사용 금지\")\nvoid commandQuery_MustNotUseLombok() {\n    ArchRule rule = noClasses()\n        .that().resideInAPackage(\"..application..dto..\")\n        .should().beAnnotatedWith(\"lombok.Data\")\n        .orShould().beAnnotatedWith(\"lombok.Builder\")\n        .because(\"Record 사용으로 Lombok 불필요\");\n    rule.check(applicationClasses);\n}','ApplicationDtoArchTest','commandQuery_MustNotUseLombok','BLOCKER','2026-01-24 15:40:21.000000','2026-01-24 15:40:21.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (58,27,'ARCH-APP-DTO-002','Command/Query 인스턴스 메서드 금지','Command/Query에 인스턴스 메서드가 없는가?','@Test\n@DisplayName(\"[금지] Command/Query에 비즈니스 로직 메서드 금지\")\nvoid commandQuery_MustNotHaveBusinessMethods() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..application..dto..\")\n        .and().areRecords()\n        .should(notHaveBusinessLogicMethods())\n        .allowEmptyShould(true)\n        .because(\"Command/Query는 순수 데이터 운반 객체\");\n    rule.check(applicationClasses);\n}','ApplicationDtoArchTest','commandQuery_MustNotHaveBusinessMethods','BLOCKER','2026-01-24 15:40:21.000000','2026-01-24 15:40:21.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (59,14,'ARCH-APP-DEP-001','Service → Facade/Manager 의존','Service가 Facade 또는 Manager에 의존하는가?','@Test\n@DisplayName(\"[필수] Service는 Facade/Manager에 의존\")\nvoid service_MustDependOnFacadeOrManager() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..application..service..\")\n        .and().haveSimpleNameEndingWith(\"Service\")\n        .should().dependOnClassesThat().haveSimpleNameEndingWith(\"Facade\")\n        .orShould().dependOnClassesThat().haveSimpleNameEndingWith(\"Manager\")\n        .allowEmptyShould(true)\n        .because(\"Service는 Facade/Manager를 조율\");\n    rule.check(applicationClasses);\n}','ApplicationDependencyArchTest','service_MustDependOnFacadeOrManager','MAJOR','2026-01-24 15:40:21.000000','2026-01-24 15:40:21.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (60,16,'ARCH-APP-DEP-003','CommandFacade → QueryManager 금지','CommandFacade에서 QueryManager를 의존하지 않는가?','@Test\n@DisplayName(\"[금지] CommandFacade에서 QueryManager 의존 금지 (CQRS)\")\nvoid commandFacade_MustNotDependOnQueryManager() {\n    ArchRule rule = noClasses()\n        .that().resideInAPackage(\"..application..facade.command..\")\n        .should().dependOnClassesThat().resideInAPackage(\"..manager.query..\")\n        .because(\"CQRS 원칙: Command와 Query 분리\");\n    rule.check(applicationClasses);\n}','ApplicationDependencyArchTest','commandFacade_MustNotDependOnQueryManager','BLOCKER','2026-01-24 15:40:21.000000','2026-01-24 15:40:21.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (61,14,'ARCH-APP-EVT-001','ApplicationEventPublisher 직접 주입 금지','Service에 ApplicationEventPublisher가 직접 주입되지 않는가?','@Test\n@DisplayName(\"[금지] Service에 ApplicationEventPublisher 직접 주입 금지\")\nvoid service_MustNotInjectEventPublisher() {\n    ArchRule rule = noClasses()\n        .that().resideInAPackage(\"..application..service..\")\n        .should().dependOnClassesThat().haveFullyQualifiedName(\n            \"org.springframework.context.ApplicationEventPublisher\")\n        .because(\"이벤트 발행은 TransactionEventRegistry 사용\");\n    rule.check(applicationClasses);\n}','ApplicationEventArchTest','service_MustNotInjectEventPublisher','BLOCKER','2026-01-24 15:40:21.000000','2026-01-24 15:40:21.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (62,36,'ARCH-APP-LSN-002-01','EventListener Manager 의존','EventListener가 Manager에 의존하는가?','@Test\n@DisplayName(\"[필수] EventListener는 Manager에 의존\")\nvoid eventListener_MustDependOnManager() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..application..listener..\")\n        .and().haveSimpleNameEndingWith(\"Listener\")\n        .should().dependOnClassesThat().haveSimpleNameEndingWith(\"Manager\")\n        .allowEmptyShould(true)\n        .because(\"EventListener는 Manager를 통해 처리\");\n    rule.check(applicationClasses);\n}','ApplicationEventArchTest','eventListener_MustDependOnManager','MAJOR','2026-01-24 15:40:21.000000','2026-01-24 15:40:21.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (63,36,'ARCH-APP-LSN-002-02','EventListener Port 직접 의존 금지','Port를 직접 의존하지 않는가?','@Test\n@DisplayName(\"[금지] EventListener에서 Port 직접 의존 금지\")\nvoid eventListener_MustNotDependOnPort() {\n    ArchRule rule = noClasses()\n        .that().resideInAPackage(\"..application..listener..\")\n        .should().dependOnClassesThat().haveSimpleNameEndingWith(\"Port\")\n        .because(\"EventListener는 Manager를 통해 Port 접근\");\n    rule.check(applicationClasses);\n}','ApplicationEventArchTest','eventListener_MustNotDependOnPort','MAJOR','2026-01-24 15:40:21.000000','2026-01-24 15:40:21.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (64,12,'ARCH-APP-PRT-002','QueryPort findAll 금지','QueryPort에 findAll() 메서드가 없는가?','@Test\n@DisplayName(\"[금지] QueryPort에 findAll() 금지 (OOM 위험)\")\nvoid queryPort_MustNotHaveFindAll() {\n    ArchRule rule = noMethods()\n        .that().areDeclaredInClassesThat().resideInAPackage(\"..port.out.query..\")\n        .and().areDeclaredInClassesThat().areInterfaces()\n        .and().haveName(\"findAll\")\n        .should().beDeclared()\n        .because(\"전체 조회는 OOM 위험, 페이징 필수\");\n    rule.check(applicationClasses);\n}','ApplicationPortArchTest','queryPort_MustNotHaveFindAll','BLOCKER','2026-01-24 15:40:21.000000','2026-01-24 15:40:21.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (65,14,'ARCH-APP-SVC-001','UseCase 1:1 Service 구현','1 UseCase = 1 Service로 구현되어 있는가?','@Test\n@DisplayName(\"[필수] Service는 UseCase 인터페이스를 구현해야 한다\")\nvoid service_MustImplementUseCase() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..application..service..\")\n        .and().haveSimpleNameEndingWith(\"Service\")\n        .and().areNotInterfaces()\n        .should().implement(\n            DescribedPredicate.describe(\n                \"UseCase interface\",\n                javaClass -> javaClass.getAllRawInterfaces().stream()\n                    .anyMatch(i -> i.getSimpleName().endsWith(\"UseCase\"))))\n        .allowEmptyShould(true)\n        .because(\"Service는 UseCase 구현체\");\n    rule.check(applicationClasses);\n}','ApplicationServiceArchTest','service_MustImplementUseCase','MAJOR','2026-01-24 15:40:21.000000','2026-01-24 15:40:21.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (66,21,'ARCH-APP-TIM-001-01','TimeProvider Factory에서만','TimeProvider.now()가 Factory에서만 호출되는가?','@Test\n@DisplayName(\"[필수] TimeProvider는 Factory에서만 사용\")\nvoid timeProvider_OnlyInFactory() {\n    ArchRule rule = noClasses()\n        .that().resideInAPackage(\"..application..\")\n        .and().haveSimpleNameNotEndingWith(\"Factory\")\n        .should().callMethodWhere(\n            target(name(\"now\")).and(target(owner(name(\"TimeProvider\")))))\n        .allowEmptyShould(true)\n        .because(\"시간 생성은 Factory 책임\");\n    rule.check(applicationClasses);\n}','ApplicationTimeArchTest','timeProvider_OnlyInFactory','BLOCKER','2026-01-24 15:40:23.000000','2026-01-24 15:40:23.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (67,14,'ARCH-APP-TIM-001-02','Service TimeProvider 직접 사용 금지','Service에서 TimeProvider를 직접 사용하지 않는가?','@Test\n@DisplayName(\"[금지] Service에서 TimeProvider 직접 사용 금지\")\nvoid service_MustNotUseTimeProvider() {\n    ArchRule rule = noClasses()\n        .that().resideInAPackage(\"..application..service..\")\n        .should().dependOnClassesThat().haveSimpleName(\"TimeProvider\")\n        .because(\"Service는 Factory가 생성한 시간 사용\");\n    rule.check(applicationClasses);\n}','ApplicationTimeArchTest','service_MustNotUseTimeProvider','BLOCKER','2026-01-24 15:40:23.000000','2026-01-24 15:40:23.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (68,38,'ARCH-PER-ENT-001','JPA 관계 어노테이션 금지','@OneToMany, @ManyToOne 등이 없는가?','@Test\n@DisplayName(\"[금지] JPA Entity에 관계 어노테이션 금지\")\nvoid jpaEntity_MustNotUseRelationshipAnnotations() {\n    ArchRule rule = noFields()\n        .that().areDeclaredInClassesThat().areAnnotatedWith(\"jakarta.persistence.Entity\")\n        .should().beAnnotatedWith(\"jakarta.persistence.ManyToOne\")\n        .orShould().beAnnotatedWith(\"jakarta.persistence.OneToMany\")\n        .orShould().beAnnotatedWith(\"jakarta.persistence.OneToOne\")\n        .orShould().beAnnotatedWith(\"jakarta.persistence.ManyToMany\")\n        .because(\"Long FK 전략 사용 (관계 어노테이션 금지)\");\n    rule.check(persistenceClasses);\n}','PersistenceEntityArchTest','jpaEntity_MustNotUseRelationshipAnnotations','BLOCKER','2026-01-24 15:40:23.000000','2026-01-24 15:40:23.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (69,38,'ARCH-PER-ENT-002','Entity는 BaseAuditEntity 상속','JpaEntity가 BaseAuditEntity를 상속하는가?','@Test\n@DisplayName(\"[필수] JPA Entity는 BaseAuditEntity 상속\")\nvoid jpaEntity_MustExtendBaseAuditEntity() {\n    ArchRule rule = classes()\n        .that().areAnnotatedWith(\"jakarta.persistence.Entity\")\n        .should().beAssignableTo(\n            DescribedPredicate.describe(\n                \"BaseAuditEntity or SoftDeletableEntity\",\n                javaClass -> javaClass.getName().contains(\"BaseAuditEntity\")\n                    || javaClass.getName().contains(\"SoftDeletableEntity\")))\n        .allowEmptyShould(true)\n        .because(\"감사 필드 자동 관리\");\n    rule.check(persistenceClasses);\n}','PersistenceEntityArchTest','jpaEntity_MustExtendBaseAuditEntity','MAJOR','2026-01-24 15:40:23.000000','2026-01-24 15:40:23.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (70,40,'ARCH-PER-REP-001','JpaRepository save/saveAll만 사용','JpaRepository에서 save, saveAll만 사용하는가?','@Test\n@DisplayName(\"[필수] JpaRepository는 save/saveAll만 사용\")\nvoid jpaRepository_OnlySaveMethods() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..persistence..repository..\")\n        .and().haveSimpleNameEndingWith(\"JpaRepository\")\n        .and().areInterfaces()\n        .should(onlyDeclareSaveAndSaveAllMethods())\n        .allowEmptyShould(true)\n        .because(\"조회는 QueryDslRepository 사용\");\n    rule.check(persistenceClasses);\n}','PersistenceRepositoryArchTest','jpaRepository_OnlySaveMethods','BLOCKER','2026-01-24 15:40:23.000000','2026-01-24 15:40:23.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (71,40,'ARCH-PER-REP-002','JpaRepository 커스텀 메서드 금지','@Query, findBy* 등이 없는가?','@Test\n@DisplayName(\"[금지] JpaRepository에 커스텀 쿼리 메서드 금지\")\nvoid jpaRepository_MustNotHaveCustomQueryMethods() {\n    ArchRule rule = noMethods()\n        .that().areDeclaredInClassesThat().resideInAPackage(\"..persistence..repository..\")\n        .and().areDeclaredInClassesThat().haveSimpleNameEndingWith(\"JpaRepository\")\n        .and().haveNameMatching(\"find.*\")\n        .should().beDeclared()\n        .allowEmptyShould(true)\n        .because(\"조회 로직은 QueryDslRepository에서 구현\");\n    rule.check(persistenceClasses);\n}','PersistenceRepositoryArchTest','jpaRepository_MustNotHaveCustomQueryMethods','BLOCKER','2026-01-24 15:40:23.000000','2026-01-24 15:40:23.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (72,40,'ARCH-PER-REP-003','모든 조회는 QueryDslRepository','조회 쿼리가 QueryDslRepository에 구현되어 있는가?','@Test\n@DisplayName(\"[필수] 조회 로직은 QueryDslRepository에 구현\")\nvoid queryLogic_MustBeInQueryDslRepository() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..persistence..repository..\")\n        .and().haveSimpleNameEndingWith(\"QueryDslRepository\")\n        .should().bePublic()\n        .allowEmptyShould(true)\n        .because(\"QueryDsl로 타입 세이프한 쿼리 작성\");\n    rule.check(persistenceClasses);\n}','PersistenceRepositoryArchTest','queryLogic_MustBeInQueryDslRepository','BLOCKER','2026-01-24 15:40:23.000000','2026-01-24 15:40:23.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (73,37,'ARCH-PER-ADP-001-01','CommandAdapter JpaRepository만 의존','CommandAdapter가 JpaRepository만 의존하는가?','@Test\n@DisplayName(\"[필수] CommandAdapter는 JpaRepository만 의존\")\nvoid commandAdapter_OnlyJpaRepository() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..persistence..adapter..\")\n        .and().haveSimpleNameContaining(\"Command\")\n        .and().haveSimpleNameEndingWith(\"Adapter\")\n        .should().dependOnClassesThat().haveSimpleNameEndingWith(\"JpaRepository\")\n        .allowEmptyShould(true)\n        .because(\"CommandAdapter는 저장만 담당\");\n    rule.check(persistenceClasses);\n}','PersistenceAdapterArchTest','commandAdapter_OnlyJpaRepository','BLOCKER','2026-01-24 15:40:23.000000','2026-01-24 15:40:23.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (74,37,'ARCH-PER-ADP-001-02','CommandAdapter QueryDslRepository 금지','QueryDslRepository를 주입받지 않는가?','@Test\n@DisplayName(\"[금지] CommandAdapter에서 QueryDslRepository 금지\")\nvoid commandAdapter_MustNotUseQueryDslRepository() {\n    ArchRule rule = noClasses()\n        .that().resideInAPackage(\"..persistence..adapter..\")\n        .and().haveSimpleNameContaining(\"Command\")\n        .should().dependOnClassesThat().haveSimpleNameEndingWith(\"QueryDslRepository\")\n        .because(\"CommandAdapter는 조회하지 않음 (CQRS)\");\n    rule.check(persistenceClasses);\n}','PersistenceAdapterArchTest','commandAdapter_MustNotUseQueryDslRepository','BLOCKER','2026-01-24 15:40:23.000000','2026-01-24 15:40:23.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (75,37,'ARCH-PER-ADP-002-01','QueryAdapter QueryDslRepository만 의존','QueryAdapter가 QueryDslRepository만 의존하는가?','@Test\n@DisplayName(\"[필수] QueryAdapter는 QueryDslRepository만 의존\")\nvoid queryAdapter_OnlyQueryDslRepository() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..persistence..adapter..\")\n        .and().haveSimpleNameContaining(\"Query\")\n        .and().haveSimpleNameEndingWith(\"Adapter\")\n        .should().dependOnClassesThat().haveSimpleNameEndingWith(\"QueryDslRepository\")\n        .allowEmptyShould(true)\n        .because(\"QueryAdapter는 조회만 담당\");\n    rule.check(persistenceClasses);\n}','PersistenceAdapterArchTest','queryAdapter_OnlyQueryDslRepository','BLOCKER','2026-01-24 15:40:23.000000','2026-01-24 15:40:23.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (76,37,'ARCH-PER-ADP-002-02','QueryAdapter JpaRepository 금지','JpaRepository를 주입받지 않는가?','@Test\n@DisplayName(\"[금지] QueryAdapter에서 JpaRepository 금지\")\nvoid queryAdapter_MustNotUseJpaRepository() {\n    ArchRule rule = noClasses()\n        .that().resideInAPackage(\"..persistence..adapter..\")\n        .and().haveSimpleNameContaining(\"Query\")\n        .should().dependOnClassesThat().haveSimpleNameEndingWith(\"JpaRepository\")\n        .because(\"QueryAdapter는 저장하지 않음 (CQRS)\");\n    rule.check(persistenceClasses);\n}','PersistenceAdapterArchTest','queryAdapter_MustNotUseJpaRepository','BLOCKER','2026-01-24 15:40:23.000000','2026-01-24 15:40:23.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (77,46,'ARCH-PER-ADM-001','Admin 복잡 쿼리 분리','복잡한 쿼리가 admin 모듈에만 있는가?','@Test\n@DisplayName(\"[필수] Admin 복잡 쿼리는 admin 모듈에 위치\")\nvoid complexQuery_MustBeInAdminModule() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..persistence..admin..\")\n        .should().bePublic()\n        .allowEmptyShould(true)\n        .because(\"복잡한 조인/서브쿼리는 admin 모듈 전용\");\n    rule.check(persistenceClasses);\n}','PersistenceAdminArchTest','complexQuery_MustBeInAdminModule','BLOCKER','2026-01-24 15:40:23.000000','2026-01-24 15:40:23.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (78,60,'ARCH-API-CTR-001','@RestController 어노테이션 필수','Controller에 @RestController가 있는가?','@Test\n@DisplayName(\"[필수] Controller는 @RestController 필수\")\nvoid controller_MustHaveRestController() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..rest..controller..\")\n        .and().haveSimpleNameEndingWith(\"Controller\")\n        .should().beAnnotatedWith(\"org.springframework.web.bind.annotation.RestController\")\n        .allowEmptyShould(true)\n        .because(\"REST API Controller 명시\");\n    rule.check(restApiClasses);\n}','RestApiControllerArchTest','controller_MustHaveRestController','MAJOR','2026-01-24 15:40:23.000000','2026-01-24 15:40:23.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (79,60,'ARCH-API-CTR-002','DELETE 메서드 금지','HTTP DELETE를 사용하지 않는가?','@Test\n@DisplayName(\"[금지] Controller에서 @DeleteMapping 금지\")\nvoid controller_MustNotUseDeleteMapping() {\n    ArchRule rule = noMethods()\n        .that().areDeclaredInClassesThat().resideInAPackage(\"..rest..controller..\")\n        .should().beAnnotatedWith(\"org.springframework.web.bind.annotation.DeleteMapping\")\n        .because(\"Soft Delete 정책: DELETE 대신 PATCH 사용\");\n    rule.check(restApiClasses);\n}','RestApiControllerArchTest','controller_MustNotUseDeleteMapping','BLOCKER','2026-01-24 15:40:23.000000','2026-01-24 15:40:23.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (80,60,'ARCH-API-CTR-003-01','UseCase 인터페이스 의존','Controller가 UseCase에 의존하는가?','@Test\n@DisplayName(\"[필수] Controller는 UseCase에 의존\")\nvoid controller_MustDependOnUseCase() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..rest..controller..\")\n        .and().haveSimpleNameEndingWith(\"Controller\")\n        .should().dependOnClassesThat().haveSimpleNameEndingWith(\"UseCase\")\n        .allowEmptyShould(true)\n        .because(\"헥사고날 아키텍처: Port-In 의존\");\n    rule.check(restApiClasses);\n}','RestApiControllerArchTest','controller_MustDependOnUseCase','MAJOR','2026-01-24 15:40:23.000000','2026-01-24 15:40:23.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (81,60,'ARCH-API-CTR-003-02','Service 직접 의존 금지','구체 Service를 직접 의존하지 않는가?','@Test\n@DisplayName(\"[금지] Controller에서 Service 직접 의존 금지\")\nvoid controller_MustNotDependOnService() {\n    ArchRule rule = noClasses()\n        .that().resideInAPackage(\"..rest..controller..\")\n        .should().dependOnClassesThat().haveSimpleNameEndingWith(\"Service\")\n        .because(\"UseCase 인터페이스를 통해 의존\");\n    rule.check(restApiClasses);\n}','RestApiControllerArchTest','controller_MustNotDependOnService','MAJOR','2026-01-24 15:40:23.000000','2026-01-24 15:40:23.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (82,60,'ARCH-API-CTR-005','Controller @Transactional 금지','Controller에 @Transactional이 없는가?','@Test\n@DisplayName(\"[금지] Controller에 @Transactional 금지\")\nvoid controller_MustNotHaveTransactional() {\n    ArchRule rule = noClasses()\n        .that().resideInAPackage(\"..rest..controller..\")\n        .should().beAnnotatedWith(\"org.springframework.transaction.annotation.Transactional\")\n        .because(\"트랜잭션 경계는 Application Layer 책임\");\n    rule.check(restApiClasses);\n}','RestApiControllerArchTest','controller_MustNotHaveTransactional','BLOCKER','2026-01-24 15:40:23.000000','2026-01-24 15:40:23.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (83,60,'ARCH-API-CTR-011','List 직접 반환 금지','목록 조회 시 List를 직접 반환하지 않는가?','@Test\n@DisplayName(\"[금지] Controller에서 List 직접 반환 금지\")\nvoid controller_MustNotReturnListDirectly() {\n    ArchRule rule = noMethods()\n        .that().areDeclaredInClassesThat().resideInAPackage(\"..rest..controller..\")\n        .and().arePublic()\n        .should().haveRawReturnType(java.util.List.class)\n        .because(\"ApiResponse<List<T>> 또는 페이징 응답 사용\");\n    rule.check(restApiClasses);\n}','RestApiControllerArchTest','controller_MustNotReturnListDirectly','BLOCKER','2026-01-24 15:40:23.000000','2026-01-24 15:40:23.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (84,62,'ARCH-API-DTO-001','API DTO Record 타입 필수','Request/Response DTO가 Record인가?','@Test\n@DisplayName(\"[필수] API DTO는 Record 타입\")\nvoid apiDto_MustBeRecord() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..rest..dto..\")\n        .and().haveSimpleNameEndingWith(\"ApiRequest\")\n        .or().haveSimpleNameEndingWith(\"ApiResponse\")\n        .should().beRecords()\n        .allowEmptyShould(true)\n        .because(\"API DTO는 불변 Record 사용\");\n    rule.check(restApiClasses);\n}','RestApiDtoArchTest','apiDto_MustBeRecord','MAJOR','2026-01-24 15:40:23.000000','2026-01-24 15:40:23.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (85,62,'ARCH-API-DTO-002','DTO 불변성 보장','DTO가 불변이고 Setter가 없는가?','@Test\n@DisplayName(\"[금지] API DTO에 Setter 금지\")\nvoid apiDto_MustNotHaveSetter() {\n    ArchRule rule = noMethods()\n        .that().areDeclaredInClassesThat().resideInAPackage(\"..rest..dto..\")\n        .and().haveNameMatching(\"set[A-Z].*\")\n        .should().beDeclared()\n        .because(\"DTO는 불변\");\n    rule.check(restApiClasses);\n}','RestApiDtoArchTest','apiDto_MustNotHaveSetter','MAJOR','2026-01-24 15:40:23.000000','2026-01-24 15:40:23.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (86,53,'ARCH-API-MAP-001','Mapper @Component 필수','Mapper에 @Component가 있는가?','@Test\n@DisplayName(\"[필수] Mapper는 @Component 필수\")\nvoid mapper_MustHaveComponent() {\n    ArchRule rule = classes()\n        .that().resideInAPackage(\"..rest..mapper..\")\n        .and().haveSimpleNameEndingWith(\"Mapper\")\n        .should().beAnnotatedWith(\"org.springframework.stereotype.Component\")\n        .allowEmptyShould(true)\n        .because(\"Spring Bean으로 관리\");\n    rule.check(restApiClasses);\n}','RestApiMapperArchTest','mapper_MustHaveComponent','MAJOR','2026-01-24 15:40:23.000000','2026-01-24 15:40:23.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (87,49,'ARCH-API-END-001','Endpoints final class','Endpoints가 final + private 생성자인가?','@Test\n@DisplayName(\"[필수] Endpoints는 final class\")\nvoid endpoints_MustBeFinalClass() {\n    ArchRule rule = classes()\n        .that().haveSimpleNameEndingWith(\"Endpoints\")\n        .should().haveModifier(JavaModifier.FINAL)\n        .allowEmptyShould(true)\n        .because(\"상수 클래스는 final\");\n    rule.check(restApiClasses);\n}','RestApiEndpointsArchTest','endpoints_MustBeFinalClass','MAJOR','2026-01-24 15:40:24.000000','2026-01-24 15:40:24.000000',NULL);
INSERT INTO `archunit_test` (`id`, `structure_id`, `code`, `name`, `description`, `test_code`, `test_class_name`, `test_method_name`, `severity`, `created_at`, `updated_at`, `deleted_at`) VALUES (88,60,'ARCH-API-TST-001','MockMvc 금지','테스트에서 MockMvc를 사용하지 않는가?','@Test\n@DisplayName(\"[금지] 테스트에서 MockMvc 금지\")\nvoid test_MustNotUseMockMvc() {\n    ArchRule rule = noClasses()\n        .that().resideInAPackage(\"..rest..\")\n        .should().dependOnClassesThat().haveFullyQualifiedName(\n            \"org.springframework.test.web.servlet.MockMvc\")\n        .because(\"TestRestTemplate 사용 권장\");\n    rule.check(restApiClasses);\n}','RestApiTestArchTest','test_MustNotUseMockMvc','MAJOR','2026-01-24 15:40:24.000000','2026-01-24 15:40:24.000000',NULL);

INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (1,27,1,'Aggregate에 static forNew(..., Instant now) 팩토리 메서드가 있는가?','AUTOMATED','archunit','DOM-AGG-004-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:32.000000','2026-01-24 09:23:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (2,27,2,'forNew()에서 ID는 null(Long) 또는 외부 주입(String)으로 처리되는가?','REVIEW',NULL,'DOM-AGG-004-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:32.000000','2026-01-24 09:23:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (3,28,1,'Aggregate에 static reconstitute(...) 팩토리 메서드가 있는가?','AUTOMATED','archunit','DOM-AGG-005-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:32.000000','2026-01-24 09:23:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (4,28,2,'reconstitute()에서 비즈니스 검증 없이 객체를 복원하는가?','REVIEW',NULL,'DOM-AGG-005-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:32.000000','2026-01-24 09:23:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (5,29,1,'Aggregate에 protected 기본 생성자가 있는가?','REVIEW',NULL,'DOM-AGG-006-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:32.000000','2026-01-24 09:23:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (6,30,1,'Aggregate의 ID 필드가 전용 ID VO(예: OrderId)를 사용하는가?','AUTOMATED','archunit','DOM-AGG-007-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:32.000000','2026-01-24 09:23:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (7,30,2,'Long 원시 타입 ID를 직접 사용하지 않는가?','AUTOMATED','archunit','DOM-AGG-007-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:32.000000','2026-01-24 09:23:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (8,31,1,'Aggregate에 isNew() 메서드가 구현되어 있는가?','AUTOMATED','archunit','DOM-AGG-008-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:32.000000','2026-01-24 09:23:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (9,32,1,'시간 필드(createdAt, updatedAt 등)가 java.time.Instant 타입인가?','AUTOMATED','archunit','DOM-AGG-009-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:32.000000','2026-01-24 09:23:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (10,32,2,'LocalDateTime, Date, Calendar 등을 사용하지 않는가?','AUTOMATED','archunit','DOM-AGG-009-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:32.000000','2026-01-24 09:23:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (11,33,1,'Aggregate 내부에서 Instant.now() 직접 호출이 없는가?','AUTOMATED','archunit','DOM-AGG-010-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:32.000000','2026-01-24 09:23:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (12,33,2,'시간이 필요한 메서드는 Instant 파라미터로 받는가?','REVIEW',NULL,'DOM-AGG-010-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:32.000000','2026-01-24 09:23:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (13,34,1,'상태 변경 메서드에서 updatedAt을 갱신하는가?','REVIEW',NULL,'DOM-AGG-011-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:32.000000','2026-01-24 09:23:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (14,35,1,'public void setXxx() 형태의 Setter 메서드가 없는가?','AUTOMATED','archunit','DOM-AGG-012-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:32.000000','2026-01-24 09:23:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (15,35,2,'상태 변경은 비즈니스 의미가 담긴 메서드(cancel, approve 등)를 통하는가?','REVIEW',NULL,'DOM-AGG-012-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:32.000000','2026-01-24 09:23:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (16,36,1,'불필요한 Getter가 없고 Tell, Don\'t Ask 원칙을 따르는가?','REVIEW',NULL,'DOM-AGG-013-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:32.000000','2026-01-24 09:23:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (17,37,1,'getXxx().getYyy() 형태의 Getter 체이닝이 없는가?','AUTOMATED','archunit','DOM-AGG-014-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:32.000000','2026-01-24 09:23:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (18,37,2,'필요한 정보는 Aggregate가 직접 제공하는 메서드를 통해 접근하는가?','REVIEW',NULL,'DOM-AGG-014-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:32.000000','2026-01-24 09:23:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (19,38,1,'외부에서 상태를 물어보고 판단하는 대신 Aggregate에게 판단을 위임하는가?','REVIEW',NULL,'DOM-AGG-015-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:32.000000','2026-01-24 09:23:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (20,39,1,'복잡한 비즈니스 규칙이 Value Object로 분리되어 있는가?','REVIEW',NULL,'DOM-AGG-016-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:32.000000','2026-01-24 09:23:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (21,40,1,'중요한 상태 변경 시 도메인 이벤트를 발행하는가?','REVIEW',NULL,'DOM-AGG-017-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:32.000000','2026-01-24 09:23:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (22,40,2,'registerEvent() 메서드를 통해 이벤트를 등록하는가?','REVIEW',NULL,'DOM-AGG-017-02',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:32.000000','2026-01-24 09:23:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (23,41,1,'registerEvent() 메서드가 protected로 선언되어 있는가?','AUTOMATED','archunit','DOM-AGG-018-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:32.000000','2026-01-24 09:23:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (24,42,1,'pollEvents() 메서드가 public으로 구현되어 있는가?','AUTOMATED','archunit','DOM-AGG-019-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (25,42,2,'pollEvents() 호출 후 내부 이벤트 목록이 비워지는가?','REVIEW',NULL,'DOM-AGG-019-02',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (26,43,1,'상태 변경 메서드가 동사로 시작하는가? (cancel, approve, update 등)','REVIEW',NULL,'DOM-AGG-020-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (27,44,1,'조회 메서드가 get, is, has, can으로 시작하는가?','REVIEW',NULL,'DOM-AGG-021-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (28,45,1,'is, has, can으로 시작하는 메서드가 boolean을 반환하는가?','AUTOMATED','archunit','DOM-AGG-022-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (29,48,1,'생성 시점과 상태 변경 시점에 불변식을 검증하는가?','REVIEW',NULL,'DOM-AGG-025-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (30,49,1,'equals/hashCode가 ID 필드만을 기반으로 구현되어 있는가?','REVIEW',NULL,'DOM-AGG-026-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (31,50,1,'id, createdAt 등 불변 필드가 final로 선언되어 있는가?','REVIEW',NULL,'DOM-AGG-027-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (32,51,1,'Value Object가 Java Record로 정의되어 있는가?','AUTOMATED','archunit','DOM-VO-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (33,51,2,'class 대신 record 키워드를 사용하는가?','AUTOMATED','archunit','DOM-VO-001-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (34,52,1,'Value Object에 of() 정적 팩토리 메서드가 있는가?','AUTOMATED','archunit','DOM-VO-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (35,53,1,'Record의 Compact Constructor에서 필수 검증을 수행하는가?','REVIEW',NULL,'DOM-VO-003-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (36,53,2,'null 체크, 범위 검증 등이 포함되어 있는가?','REVIEW',NULL,'DOM-VO-003-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (37,54,1,'Enum 타입의 VO에 displayName() 메서드가 있는가?','AUTOMATED','archunit','DOM-VO-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (38,55,1,'분산락이 필요한 VO가 LockKey 인터페이스를 구현하는가?','REVIEW',NULL,'DOM-VO-005-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (39,56,1,'캐싱이 필요한 VO가 CacheKey 인터페이스를 구현하는가?','REVIEW',NULL,'DOM-VO-006-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (40,60,1,'ID VO가 {Domain}Id 형태로 네이밍되어 있는가? (OrderId, CustomerId)','AUTOMATED','archunit','DOM-ID-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (41,61,1,'ID VO가 Java Record로 정의되어 있는가?','AUTOMATED','archunit','DOM-ID-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (42,62,1,'ID VO에 of() 정적 팩토리 메서드가 있는가?','AUTOMATED','archunit','DOM-ID-003-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (43,63,1,'Long 타입 ID VO에 forNew() 정적 팩토리 메서드가 있는가?','AUTOMATED','archunit','DOM-ID-004-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (44,64,1,'forNew()가 value가 null인 ID를 반환하는가?','REVIEW',NULL,'DOM-ID-005-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (45,65,1,'Long 타입 ID VO에 isNew() 메서드가 있는가?','AUTOMATED','archunit','DOM-ID-006-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (46,66,1,'String 타입 ID VO에 isNew() 메서드가 없는가?','AUTOMATED','archunit','DOM-ID-007-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (47,67,1,'String ID가 Application Layer(Factory)에서 생성되어 주입되는가?','REVIEW',NULL,'DOM-ID-008-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (48,67,2,'Domain에서 UUID.randomUUID() 호출이 없는가?','AUTOMATED','archunit','DOM-ID-008-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (49,70,1,'도메인 이벤트가 DomainEvent 인터페이스를 구현하는가?','AUTOMATED','archunit','DOM-EVT-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (50,71,1,'도메인 이벤트가 Java Record로 정의되어 있는가?','AUTOMATED','archunit','DOM-EVT-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:33.000000','2026-01-24 09:23:33.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (51,72,1,'도메인 이벤트에 occurredAt(Instant) 필드가 있는가?','AUTOMATED','archunit','DOM-EVT-003-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (52,73,1,'도메인 이벤트에 from(Aggregate, Instant) 정적 팩토리 메서드가 있는가?','AUTOMATED','archunit','DOM-EVT-004-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (53,74,1,'도메인 이벤트가 과거형으로 네이밍되어 있는가? (OrderCreatedEvent)','REVIEW',NULL,'DOM-EVT-005-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (54,75,1,'도메인 이벤트가 domain.{bc}.event 패키지에 위치하는가?','AUTOMATED','archunit','DOM-EVT-006-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (55,81,1,'ErrorCode enum이 ErrorCode 인터페이스를 구현하는가?','AUTOMATED','archunit','DOM-EXC-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (56,82,1,'ErrorCode가 domain.{bc}.exception 패키지에 위치하는가?','AUTOMATED','archunit','DOM-EXC-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (57,84,1,'Exception에서 Lombok(@Getter 등)을 사용하지 않는가?','AUTOMATED','archunit','DOM-EXC-004-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (58,85,1,'ErrorCode에 getCode() 메서드가 있는가?','AUTOMATED','archunit','DOM-EXC-005-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (59,85,2,'getCode() 반환 형식이 {DOMAIN}-{NUMBER}인가? (ORD-001)','REVIEW',NULL,'DOM-EXC-005-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (60,86,1,'ErrorCode의 getHttpStatus()가 int 타입을 반환하는가?','AUTOMATED','archunit','DOM-EXC-006-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (61,86,2,'Spring HttpStatus를 사용하지 않는가?','AUTOMATED','archunit','DOM-EXC-006-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (62,87,1,'ErrorCode에 getMessage() 메서드가 있는가?','AUTOMATED','archunit','DOM-EXC-007-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (63,89,1,'도메인 예외 클래스가 DomainException을 상속받는가?','AUTOMATED','archunit','DOM-EXC-009-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (64,90,1,'도메인 예외가 domain.{bc}.exception 패키지에 위치하는가?','AUTOMATED','archunit','DOM-EXC-010-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (65,94,1,'도메인 예외가 public 클래스로 선언되어 있는가?','AUTOMATED','archunit','DOM-EXC-014-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (66,95,1,'도메인 예외가 RuntimeException 계층인가?','AUTOMATED','archunit','DOM-EXC-015-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (67,95,2,'Checked Exception을 사용하지 않는가?','REVIEW',NULL,'DOM-EXC-015-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (68,98,1,'도메인 예외가 비즈니스 의미가 명확한 이름인가? (OrderNotFoundException)','REVIEW',NULL,'DOM-EXC-018-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (69,99,1,'DomainException 추상 클래스가 domain.common.exception 패키지에 있는가?','AUTOMATED','archunit','DOM-EXC-019-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (70,100,1,'ErrorCode 인터페이스가 domain.common.exception 패키지에 있는가?','AUTOMATED','archunit','DOM-EXC-020-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (71,101,1,'Criteria가 domain.{bc}.query.criteria 패키지에 위치하는가?','AUTOMATED','archunit','DOM-CRI-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (72,102,1,'Criteria가 {Domain}SliceCriteria 또는 {Domain}SearchCriteria 형태인가?','REVIEW',NULL,'DOM-CRI-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (73,103,1,'Criteria가 public으로 선언되어 있는가?','AUTOMATED','archunit','DOM-CRI-003-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (74,104,1,'Criteria가 Java Record로 정의되어 있는가?','AUTOMATED','archunit','DOM-CRI-004-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (75,105,1,'Criteria에 of() 정적 팩토리 메서드가 있는가?','AUTOMATED','archunit','DOM-CRI-005-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (76,110,1,'Criteria에서 JPA/Spring 어노테이션을 사용하지 않는가?','AUTOMATED','archunit','DOM-CRI-010-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (77,110,2,'DateRange, CursorQueryContext 등 공통 VO를 활용하는가?','REVIEW',NULL,'DOM-CRI-010-02',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:34.000000','2026-01-24 09:23:34.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (78,111,1,'도메인 객체가 순수 자바 객체(POJO)인가?','AUTOMATED','archunit','DOM-CMN-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (79,111,2,'Lombok, JPA, Spring 어노테이션을 사용하지 않는가?','AUTOMATED','archunit','DOM-CMN-001-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (80,112,1,'도메인 객체가 Application, Persistence, REST API 레이어를 의존하지 않는가?','AUTOMATED','archunit','DOM-CMN-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (81,112,2,'Repository, Port, Service, Controller, Entity, DTO를 import하지 않는가?','AUTOMATED','archunit','DOM-CMN-002-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (82,115,1,'Service 클래스에 @Transactional 어노테이션이 없는가?','AUTOMATED','archunit','APP-TRX-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (83,116,1,'CommandManager/QueryManager에 @Transactional이 있는가?','AUTOMATED','archunit','APP-TRX-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (84,116,2,'QueryManager는 @Transactional(readOnly=true)를 사용하는가?','REVIEW',NULL,'APP-TRX-002-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (85,117,1,'ClientManager에 @Transactional 어노테이션이 없는가?','AUTOMATED','archunit','APP-TRX-003-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (86,118,1,'CommandFacade에서 DB 원자성 필요 시에만 @Transactional을 사용하는가?','REVIEW',NULL,'APP-TRX-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (87,119,1,'QueryFacade에 @Transactional(readOnly=true)가 있는가?','AUTOMATED','archunit','APP-TRX-005-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (88,120,1,'Service가 Facade 또는 Manager에 의존하는가?','AUTOMATED','archunit','APP-DEP-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (89,120,2,'Manager 2개 이상 조합 시 Facade를 사용하는가?','REVIEW',NULL,'APP-DEP-001-02',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (90,121,1,'Facade가 같은 CQRS 범위의 Manager만 의존하는가?','AUTOMATED','archunit','APP-DEP-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (91,121,2,'CommandFacade가 CommandManager만 의존하는가?','AUTOMATED','archunit','APP-DEP-002-02',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (92,122,1,'CommandFacade에서 QueryManager를 의존하지 않는가?','AUTOMATED','archunit','APP-DEP-003-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (93,123,1,'Validator가 자기 도메인의 ReadManager만 의존하는가?','AUTOMATED','archunit','APP-DEP-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (94,124,1,'Calculator, Resolver 등이 Manager를 통해 데이터에 접근하는가?','AUTOMATED','archunit','APP-DEP-005-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (95,124,2,'Port를 직접 의존하지 않는가?','AUTOMATED','archunit','APP-DEP-005-02',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (96,125,1,'Command/Query DTO가 Java Record로 정의되어 있는가?','AUTOMATED','archunit','APP-DTO-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (97,125,2,'Lombok(@Data, @Builder 등)을 사용하지 않는가?','AUTOMATED','archunit','APP-DTO-001-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (98,126,1,'Command/Query에 인스턴스 메서드가 없는가?','AUTOMATED','archunit','APP-DTO-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (99,126,2,'Compact Constructor에 로직이 없는가?','REVIEW',NULL,'APP-DTO-002-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (100,127,1,'*SearchParams가 CommonSearchParams를 포함하는가?','REVIEW',NULL,'APP-DTO-003-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (101,128,1,'*CursorParams가 CommonCursorParams를 포함하는가?','REVIEW',NULL,'APP-DTO-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (102,129,1,'Bundle DTO에 withId() 메서드가 있는가?','REVIEW',NULL,'APP-DTO-005-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (103,130,1,'CommandPort에 persist, persistAll 메서드만 있는가?','AUTOMATED','archunit','APP-PRT-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:35.000000','2026-01-24 09:23:35.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (104,130,2,'update 메서드가 없는가? (Dirty Checking 사용)','REVIEW',NULL,'APP-PRT-001-02',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (105,131,1,'QueryPort에 findAll() 메서드가 없는가?','AUTOMATED','archunit','APP-PRT-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (106,131,2,'전체 데이터 로딩 대신 findBySliceCriteria를 사용하는가?','REVIEW',NULL,'APP-PRT-002-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (107,132,1,'QueryPort 메서드가 findById, findBy*, existsBy*, countBy* 패턴을 따르는가?','REVIEW',NULL,'APP-PRT-003-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (108,210,1,'Port 파라미터가 원시타입 대신 Domain VO를 사용하는가?','REVIEW',NULL,'APP-PRT-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (109,133,1,'Service에 ApplicationEventPublisher가 직접 주입되지 않는가?','AUTOMATED','archunit','APP-EVT-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (110,134,1,'도메인 이벤트 발행 시 TransactionEventRegistry를 사용하는가?','REVIEW',NULL,'APP-EVT-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (111,135,1,'TimeProvider.now()가 Factory에서만 호출되는가?','AUTOMATED','archunit','APP-TIM-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (112,135,2,'Service에서 TimeProvider를 직접 사용하지 않는가?','AUTOMATED','archunit','APP-TIM-001-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (113,136,1,'Factory가 복잡한 객체 생성과 TimeProvider 필요 작업에만 사용되는가?','REVIEW',NULL,'APP-FAC-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (114,137,1,'Validator의 validate*Exists 메서드가 Domain 객체를 반환하는가?','REVIEW',NULL,'APP-VAL-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (115,138,1,'Validator가 도메인 전용 예외(OrderNotFoundException 등)를 발생시키는가?','REVIEW',NULL,'APP-VAL-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (116,139,1,'Assembler가 도메인별 구체 Result 클래스(OrderSliceResult)를 반환하는가?','REVIEW',NULL,'APP-ASM-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (117,139,2,'제네릭 래퍼(SliceResult<T>)를 사용하지 않는가?','REVIEW',NULL,'APP-ASM-001-02',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (118,140,1,'생성(Create) UseCase가 원시타입(Long)만 반환하는가?','REVIEW',NULL,'APP-ASM-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (119,141,1,'1 UseCase = 1 Service로 구현되어 있는가?','AUTOMATED','archunit','APP-SVC-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (120,142,1,'UseCase 네이밍이 Create*, Update*, Get*, Search* 패턴을 따르는가?','REVIEW',NULL,'APP-SVC-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (121,143,1,'범용 예외 클래스(EntityNotFoundException) 대신 도메인 전용 예외를 사용하는가?','REVIEW',NULL,'APP-EXC-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (122,144,1,'DomainException을 직접 throw하지 않고 상속 클래스를 사용하는가?','REVIEW',NULL,'APP-EXC-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (123,145,1,'EventListener에 @Async가 있는가?','REVIEW',NULL,'APP-LSN-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (124,146,1,'EventListener가 Manager에 의존하는가?','AUTOMATED','archunit','APP-LSN-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (125,146,2,'Port를 직접 의존하지 않는가?','AUTOMATED','archunit','APP-LSN-002-02',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (126,213,1,'커서 기반 조회가 Search{Domain}ByCursorUseCase 네이밍인가?','REVIEW',NULL,'APP-UC-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (127,214,1,'Delete 네이밍 대신 Archive/Deactivate/Disable을 사용하는가?','REVIEW',NULL,'APP-UC-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (128,215,1,'Factory 메서드에 DTO를 통째로 전달하는가?','REVIEW',NULL,'FAC-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (129,215,2,'개별 파라미터로 풀어서 전달하지 않는가?','REVIEW',NULL,'FAC-002-02',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (130,216,1,'Factory에서 UpdateContext(id, updateData, changedAt)를 한 번에 생성하는가?','REVIEW',NULL,'FAC-008-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:36.000000','2026-01-24 09:23:36.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (131,147,1,'JpaRepository에서 save, saveAll 메서드만 사용하는가?','AUTOMATED','archunit','PER-REP-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (132,148,1,'JpaRepository에 커스텀 쿼리 메서드(@Query, findBy* 등)가 없는가?','AUTOMATED','archunit','PER-REP-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (133,149,1,'모든 조회 쿼리가 QueryDslRepository에서 구현되어 있는가?','AUTOMATED','archunit','PER-REP-003-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (134,149,2,'JPQL, Native Query를 사용하지 않는가?','REVIEW',NULL,'PER-REP-003-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (135,150,1,'CommandAdapter가 JpaRepository만 의존하는가?','AUTOMATED','archunit','PER-ADP-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (136,150,2,'QueryDslRepository를 주입받지 않는가?','AUTOMATED','archunit','PER-ADP-001-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (137,151,1,'QueryAdapter가 QueryDslRepository만 의존하는가?','AUTOMATED','archunit','PER-ADP-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (138,151,2,'JpaRepository를 주입받지 않는가?','AUTOMATED','archunit','PER-ADP-002-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (139,152,1,'@OneToMany, @ManyToOne, @OneToOne, @ManyToMany 어노테이션이 없는가?','AUTOMATED','archunit','PER-ENT-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (140,152,2,'FK는 Long 타입으로 관리하는가?','REVIEW',NULL,'PER-ENT-001-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (141,153,1,'JpaEntity가 BaseAuditEntity 또는 SoftDeletableEntity를 상속하는가?','AUTOMATED','archunit','PER-ENT-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (142,154,1,'spring.jpa.open-in-view=false 설정이 있는가?','MANUAL',NULL,'PER-CFG-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (143,155,1,'spring.jpa.hibernate.ddl-auto=validate 설정이 있는가?','MANUAL',NULL,'PER-CFG-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (144,155,2,'create, update, create-drop을 사용하지 않는가?','MANUAL',NULL,'PER-CFG-002-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (145,156,1,'QueryDslRepository의 where절 조건이 ConditionBuilder로 분리되어 있는가?','REVIEW',NULL,'PER-CND-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (146,157,1,'Soft Delete 테이블 조회 시 deletedAt IS NULL 조건이 있는가?','REVIEW',NULL,'PER-CND-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (147,158,1,'EntityMapper에 toDomain(Entity), toEntity(Domain) 양방향 변환 메서드가 있는가?','REVIEW',NULL,'PER-MAP-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (148,159,1,'MySQL MATCH AGAINST 사용 시 Hibernate FunctionContributor가 등록되어 있는가?','MANUAL',NULL,'PER-FTS-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (149,160,1,'조인, 서브쿼리 등 복잡한 쿼리가 persistence-mysql-admin 모듈에만 있는가?','AUTOMATED','archunit','PER-ADM-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (150,160,2,'도메인용 persistence-mysql에서는 단일 테이블 쿼리만 사용하는가?','REVIEW',NULL,'PER-ADM-001-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (151,161,1,'persistence-mysql-admin 모듈에서 조인 사용 시 DTO Projection을 사용하는가?','REVIEW',NULL,'PER-ADM-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (152,165,1,'Controller 클래스에 @RestController 어노테이션이 있는가?','AUTOMATED','archunit','API-CTR-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (153,166,1,'HTTP DELETE 메서드를 사용하지 않는가?','AUTOMATED','archunit','API-CTR-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (154,166,2,'soft delete는 PATCH /{id}/delete로 구현되어 있는가?','REVIEW',NULL,'API-CTR-002-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (155,167,1,'Controller가 UseCase(Port-In) 인터페이스에만 의존하는가?','AUTOMATED','archunit','API-CTR-003-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (156,167,2,'구체 Service 클래스를 직접 의존하지 않는가?','AUTOMATED','archunit','API-CTR-003-02',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:37.000000','2026-01-24 09:23:37.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (157,168,1,'모든 응답이 ResponseEntity<ApiResponse<T>> 형태로 래핑되어 있는가?','REVIEW',NULL,'API-CTR-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (158,169,1,'Controller에 @Transactional 어노테이션이 없는가?','AUTOMATED','archunit','API-CTR-005-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (159,170,1,'@Tag, @Operation, @ApiResponses 어노테이션이 있는가?','REVIEW',NULL,'API-CTR-006-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (160,171,1,'Controller에 비즈니스 로직이 없고 Mapper에 위임하는가?','REVIEW',NULL,'API-CTR-007-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (161,172,1,'경로를 하드코딩하지 않고 *ApiEndpoints 상수 클래스를 사용하는가?','REVIEW',NULL,'API-CTR-008-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (162,173,1,'Request DTO 파라미터에 @Valid 어노테이션이 있는가?','REVIEW',NULL,'API-CTR-009-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (163,174,1,'Command(CUD)와 Query(R) Controller가 별도 클래스로 분리되어 있는가?','REVIEW',NULL,'API-CTR-010-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (164,175,1,'목록 조회 시 List를 직접 반환하지 않는가?','AUTOMATED','archunit','API-CTR-011-01',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (165,175,2,'SliceApiResponse 또는 PageApiResponse를 사용하는가?','REVIEW',NULL,'API-CTR-011-02',1,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (166,176,1,'URL 경로가 소문자 + 복수형을 사용하는가? (/conventions, /modules)','REVIEW',NULL,'API-CTR-012-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (167,211,1,'조회 메서드가 search{Bc}, search{Bc}ByCursor, list{Bc} 패턴을 따르는가?','REVIEW',NULL,'API-CTR-013-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (168,177,1,'Request/Response DTO가 Java Record로 정의되어 있는가?','AUTOMATED','archunit','API-DTO-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (169,178,1,'DTO가 불변 객체이고 Setter가 없는가?','AUTOMATED','archunit','API-DTO-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (170,179,1,'Request DTO에 Jakarta Validation 어노테이션(@NotNull, @NotBlank 등)이 있는가?','REVIEW',NULL,'API-DTO-003-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (171,180,1,'Response DTO에 createdAt, updatedAt 필드가 있는가?','REVIEW',NULL,'API-DTO-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (172,181,1,'Instant 타입이 DateTimeFormatUtils.formatIso8601()로 String 변환되는가?','REVIEW',NULL,'API-DTO-005-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (173,182,1,'복잡한 구조가 중첩 Record로 표현되어 있는가?','REVIEW',NULL,'API-DTO-006-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (174,183,1,'OpenAPI 문서화를 위해 @Schema 어노테이션이 있는가?','REVIEW',NULL,'API-DTO-007-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (175,184,1,'Optional 대신 @Nullable 또는 기본값을 사용하는가?','REVIEW',NULL,'API-DTO-008-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (176,185,1,'List 필드가 생성자에서 List.copyOf()로 방어적 복사되는가?','REVIEW',NULL,'API-DTO-009-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (177,212,1,'Request DTO가 Search{Bc}ApiRequest, Search{Bc}CursorApiRequest, List{Bc}ApiRequest 패턴을 따르는가?','REVIEW',NULL,'API-DTO-010-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (178,186,1,'Mapper 클래스에 @Component 어노테이션이 있는가?','AUTOMATED','archunit','API-MAP-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (179,187,1,'Mapper가 Request→Query/Command, Result→Response 양방향 변환을 지원하는가?','REVIEW',NULL,'API-MAP-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (180,188,1,'Mapper에서 DateTimeFormatUtils.formatIso8601()로 날짜를 포맷팅하는가?','REVIEW',NULL,'API-MAP-003-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (181,189,1,'Mapper에 SliceResult/PageResult를 SliceApiResponse/PageApiResponse로 변환하는 메서드가 있는가?','REVIEW',NULL,'API-MAP-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (182,190,1,'Mapper가 순수 변환 로직만 담당하고 비즈니스 로직이 없는가?','REVIEW',NULL,'API-MAP-005-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:38.000000','2026-01-24 09:23:38.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (183,191,1,'Request에서 null인 필드의 기본값 처리를 Mapper에서 수행하는가?','REVIEW',NULL,'API-MAP-006-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:39.000000','2026-01-24 09:23:39.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (184,192,1,'도메인별 ErrorMapper가 구현되어 있는가?','REVIEW',NULL,'API-ERR-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:39.000000','2026-01-24 09:23:39.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (185,192,2,'ErrorMapper가 supports() + map() 메서드를 구현하는가?','REVIEW',NULL,'API-ERR-001-02',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:39.000000','2026-01-24 09:23:39.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (186,193,1,'에러 응답이 RFC 7807 ProblemDetail 형식을 사용하는가?','REVIEW',NULL,'API-ERR-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:39.000000','2026-01-24 09:23:39.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (187,194,1,'ProblemDetail에 x-error-code 확장 헤더가 있는가?','REVIEW',NULL,'API-ERR-003-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:39.000000','2026-01-24 09:23:39.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (188,195,1,'GlobalExceptionHandler를 통한 전역 예외 처리가 있는가?','REVIEW',NULL,'API-ERR-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:39.000000','2026-01-24 09:23:39.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (189,196,1,'에러 응답의 Content-Type이 application/problem+json인가?','REVIEW',NULL,'API-ERR-005-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:39.000000','2026-01-24 09:23:39.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (190,197,1,'JacksonConfig에 SNAKE_CASE, JavaTimeModule이 설정되어 있는가?','MANUAL',NULL,'API-CFG-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:39.000000','2026-01-24 09:23:39.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (191,198,1,'OpenApiConfig에 GroupedOpenApi가 설정되어 있는가?','MANUAL',NULL,'API-CFG-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:39.000000','2026-01-24 09:23:39.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (192,199,1,'WebMvcConfig에 CORS, Interceptor, ArgumentResolver가 설정되어 있는가?','MANUAL',NULL,'API-CFG-003-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:39.000000','2026-01-24 09:23:39.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (193,200,1,'server.servlet.context-path가 설정되어 있는가?','MANUAL',NULL,'API-CFG-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:39.000000','2026-01-24 09:23:39.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (194,201,1,'Endpoints 상수 클래스가 final class + private 생성자인가?','AUTOMATED','archunit','API-END-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:39.000000','2026-01-24 09:23:39.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (195,202,1,'모든 경로 상수가 public static final String으로 선언되어 있는가?','REVIEW',NULL,'API-END-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:39.000000','2026-01-24 09:23:39.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (196,203,1,'PathVariable 이름도 상수로 관리되는가?','REVIEW',NULL,'API-END-003-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:39.000000','2026-01-24 09:23:39.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (197,204,1,'각 도메인별로 별도의 *ApiEndpoints 클래스가 있는가?','REVIEW',NULL,'API-END-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:39.000000','2026-01-24 09:23:39.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (198,205,1,'테스트에서 MockMvc를 사용하지 않는가?','AUTOMATED','archunit','API-TST-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:39.000000','2026-01-24 09:23:39.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (199,206,1,'@SpringBootTest(webEnvironment = RANDOM_PORT) + TestRestTemplate을 사용하는가?','REVIEW',NULL,'API-TST-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:39.000000','2026-01-24 09:23:39.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (200,207,1,'ApiResponse<T> 역직렬화 시 ParameterizedTypeReference를 사용하는가?','REVIEW',NULL,'API-TST-003-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:39.000000','2026-01-24 09:23:39.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (201,208,1,'테스트 데이터 생성이 *Fixture 클래스의 static factory 메서드로 제공되는가?','REVIEW',NULL,'API-TST-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:39.000000','2026-01-24 09:23:39.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (202,209,1,'ErrorMapper에 supports() + map() 메서드 단위 테스트가 있는가?','REVIEW',NULL,'API-TST-005-01',0,'CONVENTION_HUB',NULL,'2026-01-24 09:23:39.000000','2026-01-24 09:23:39.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (203,27,1,'Aggregate에 static forNew(..., Instant now) 팩토리 메서드가 있는가?','AUTOMATED','archunit','DOM-AGG-004-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (204,27,2,'forNew()에서 ID는 null(Long) 또는 외부 주입(String)으로 처리되는가?','REVIEW',NULL,'DOM-AGG-004-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (205,28,1,'Aggregate에 static reconstitute(...) 팩토리 메서드가 있는가?','AUTOMATED','archunit','DOM-AGG-005-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (206,28,2,'reconstitute()에서 비즈니스 검증 없이 객체를 복원하는가?','REVIEW',NULL,'DOM-AGG-005-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (207,29,1,'Aggregate에 protected 기본 생성자가 있는가?','REVIEW',NULL,'DOM-AGG-006-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (208,30,1,'Aggregate의 ID 필드가 전용 ID VO(예: OrderId)를 사용하는가?','AUTOMATED','archunit','DOM-AGG-007-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (209,30,2,'Long 원시 타입 ID를 직접 사용하지 않는가?','AUTOMATED','archunit','DOM-AGG-007-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (210,31,1,'Aggregate에 isNew() 메서드가 구현되어 있는가?','AUTOMATED','archunit','DOM-AGG-008-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (211,32,1,'시간 필드(createdAt, updatedAt 등)가 java.time.Instant 타입인가?','AUTOMATED','archunit','DOM-AGG-009-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (212,32,2,'LocalDateTime, Date, Calendar 등을 사용하지 않는가?','AUTOMATED','archunit','DOM-AGG-009-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (213,33,1,'Aggregate 내부에서 Instant.now() 직접 호출이 없는가?','AUTOMATED','archunit','DOM-AGG-010-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (214,33,2,'시간이 필요한 메서드는 Instant 파라미터로 받는가?','REVIEW',NULL,'DOM-AGG-010-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (215,34,1,'상태 변경 메서드에서 updatedAt을 갱신하는가?','REVIEW',NULL,'DOM-AGG-011-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (216,35,1,'public void setXxx() 형태의 Setter 메서드가 없는가?','AUTOMATED','archunit','DOM-AGG-012-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (217,35,2,'상태 변경은 비즈니스 의미가 담긴 메서드(cancel, approve 등)를 통하는가?','REVIEW',NULL,'DOM-AGG-012-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (218,36,1,'불필요한 Getter가 없고 Tell, Don\'t Ask 원칙을 따르는가?','REVIEW',NULL,'DOM-AGG-013-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (219,37,1,'getXxx().getYyy() 형태의 Getter 체이닝이 없는가?','AUTOMATED','archunit','DOM-AGG-014-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (220,37,2,'필요한 정보는 Aggregate가 직접 제공하는 메서드를 통해 접근하는가?','REVIEW',NULL,'DOM-AGG-014-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (221,38,1,'외부에서 상태를 물어보고 판단하는 대신 Aggregate에게 판단을 위임하는가?','REVIEW',NULL,'DOM-AGG-015-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (222,39,1,'복잡한 비즈니스 규칙이 Value Object로 분리되어 있는가?','REVIEW',NULL,'DOM-AGG-016-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (223,40,1,'중요한 상태 변경 시 도메인 이벤트를 발행하는가?','REVIEW',NULL,'DOM-AGG-017-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (224,40,2,'registerEvent() 메서드를 통해 이벤트를 등록하는가?','REVIEW',NULL,'DOM-AGG-017-02',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (225,41,1,'registerEvent() 메서드가 protected로 선언되어 있는가?','AUTOMATED','archunit','DOM-AGG-018-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (226,42,1,'pollEvents() 메서드가 public으로 구현되어 있는가?','AUTOMATED','archunit','DOM-AGG-019-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (227,42,2,'pollEvents() 호출 후 내부 이벤트 목록이 비워지는가?','REVIEW',NULL,'DOM-AGG-019-02',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (228,43,1,'상태 변경 메서드가 동사로 시작하는가? (cancel, approve, update 등)','REVIEW',NULL,'DOM-AGG-020-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (229,44,1,'조회 메서드가 get, is, has, can으로 시작하는가?','REVIEW',NULL,'DOM-AGG-021-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (230,45,1,'is, has, can으로 시작하는 메서드가 boolean을 반환하는가?','AUTOMATED','archunit','DOM-AGG-022-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (231,48,1,'생성 시점과 상태 변경 시점에 불변식을 검증하는가?','REVIEW',NULL,'DOM-AGG-025-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (232,49,1,'equals/hashCode가 ID 필드만을 기반으로 구현되어 있는가?','REVIEW',NULL,'DOM-AGG-026-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (233,50,1,'id, createdAt 등 불변 필드가 final로 선언되어 있는가?','REVIEW',NULL,'DOM-AGG-027-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (234,51,1,'Value Object가 Java Record로 정의되어 있는가?','AUTOMATED','archunit','DOM-VO-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (235,51,2,'class 대신 record 키워드를 사용하는가?','AUTOMATED','archunit','DOM-VO-001-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (236,52,1,'Value Object에 of() 정적 팩토리 메서드가 있는가?','AUTOMATED','archunit','DOM-VO-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (237,53,1,'Record의 Compact Constructor에서 필수 검증을 수행하는가?','REVIEW',NULL,'DOM-VO-003-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (238,53,2,'null 체크, 범위 검증 등이 포함되어 있는가?','REVIEW',NULL,'DOM-VO-003-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (239,54,1,'Enum 타입의 VO에 displayName() 메서드가 있는가?','AUTOMATED','archunit','DOM-VO-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (240,55,1,'분산락이 필요한 VO가 LockKey 인터페이스를 구현하는가?','REVIEW',NULL,'DOM-VO-005-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (241,56,1,'캐싱이 필요한 VO가 CacheKey 인터페이스를 구현하는가?','REVIEW',NULL,'DOM-VO-006-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (242,60,1,'ID VO가 {Domain}Id 형태로 네이밍되어 있는가? (OrderId, CustomerId)','AUTOMATED','archunit','DOM-ID-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (243,61,1,'ID VO가 Java Record로 정의되어 있는가?','AUTOMATED','archunit','DOM-ID-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (244,62,1,'ID VO에 of() 정적 팩토리 메서드가 있는가?','AUTOMATED','archunit','DOM-ID-003-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (245,63,1,'Long 타입 ID VO에 forNew() 정적 팩토리 메서드가 있는가?','AUTOMATED','archunit','DOM-ID-004-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (246,64,1,'forNew()가 value가 null인 ID를 반환하는가?','REVIEW',NULL,'DOM-ID-005-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (247,65,1,'Long 타입 ID VO에 isNew() 메서드가 있는가?','AUTOMATED','archunit','DOM-ID-006-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (248,66,1,'String 타입 ID VO에 isNew() 메서드가 없는가?','AUTOMATED','archunit','DOM-ID-007-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (249,67,1,'String ID가 Application Layer(Factory)에서 생성되어 주입되는가?','REVIEW',NULL,'DOM-ID-008-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (250,67,2,'Domain에서 UUID.randomUUID() 호출이 없는가?','AUTOMATED','archunit','DOM-ID-008-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (251,70,1,'도메인 이벤트가 DomainEvent 인터페이스를 구현하는가?','AUTOMATED','archunit','DOM-EVT-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (252,71,1,'도메인 이벤트가 Java Record로 정의되어 있는가?','AUTOMATED','archunit','DOM-EVT-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (253,72,1,'도메인 이벤트에 occurredAt(Instant) 필드가 있는가?','AUTOMATED','archunit','DOM-EVT-003-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (254,73,1,'도메인 이벤트에 from(Aggregate, Instant) 정적 팩토리 메서드가 있는가?','AUTOMATED','archunit','DOM-EVT-004-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (255,74,1,'도메인 이벤트가 과거형으로 네이밍되어 있는가? (OrderCreatedEvent)','REVIEW',NULL,'DOM-EVT-005-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (256,75,1,'도메인 이벤트가 domain.{bc}.event 패키지에 위치하는가?','AUTOMATED','archunit','DOM-EVT-006-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (257,81,1,'ErrorCode enum이 ErrorCode 인터페이스를 구현하는가?','AUTOMATED','archunit','DOM-EXC-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (258,82,1,'ErrorCode가 domain.{bc}.exception 패키지에 위치하는가?','AUTOMATED','archunit','DOM-EXC-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (259,84,1,'Exception에서 Lombok(@Getter 등)을 사용하지 않는가?','AUTOMATED','archunit','DOM-EXC-004-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (260,85,1,'ErrorCode에 getCode() 메서드가 있는가?','AUTOMATED','archunit','DOM-EXC-005-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:31.000000','2026-01-24 15:41:31.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (261,85,2,'getCode() 반환 형식이 {DOMAIN}-{NUMBER}인가? (ORD-001)','REVIEW',NULL,'DOM-EXC-005-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (262,86,1,'ErrorCode의 getHttpStatus()가 int 타입을 반환하는가?','AUTOMATED','archunit','DOM-EXC-006-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (263,86,2,'Spring HttpStatus를 사용하지 않는가?','AUTOMATED','archunit','DOM-EXC-006-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (264,87,1,'ErrorCode에 getMessage() 메서드가 있는가?','AUTOMATED','archunit','DOM-EXC-007-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (265,89,1,'도메인 예외 클래스가 DomainException을 상속받는가?','AUTOMATED','archunit','DOM-EXC-009-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (266,90,1,'도메인 예외가 domain.{bc}.exception 패키지에 위치하는가?','AUTOMATED','archunit','DOM-EXC-010-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (267,94,1,'도메인 예외가 public 클래스로 선언되어 있는가?','AUTOMATED','archunit','DOM-EXC-014-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (268,95,1,'도메인 예외가 RuntimeException 계층인가?','AUTOMATED','archunit','DOM-EXC-015-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (269,95,2,'Checked Exception을 사용하지 않는가?','REVIEW',NULL,'DOM-EXC-015-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (270,98,1,'도메인 예외가 비즈니스 의미가 명확한 이름인가? (OrderNotFoundException)','REVIEW',NULL,'DOM-EXC-018-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (271,99,1,'DomainException 추상 클래스가 domain.common.exception 패키지에 있는가?','AUTOMATED','archunit','DOM-EXC-019-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (272,100,1,'ErrorCode 인터페이스가 domain.common.exception 패키지에 있는가?','AUTOMATED','archunit','DOM-EXC-020-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (273,101,1,'Criteria가 domain.{bc}.query.criteria 패키지에 위치하는가?','AUTOMATED','archunit','DOM-CRI-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (274,102,1,'Criteria가 {Domain}SliceCriteria 또는 {Domain}SearchCriteria 형태인가?','REVIEW',NULL,'DOM-CRI-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (275,103,1,'Criteria가 public으로 선언되어 있는가?','AUTOMATED','archunit','DOM-CRI-003-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (276,104,1,'Criteria가 Java Record로 정의되어 있는가?','AUTOMATED','archunit','DOM-CRI-004-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (277,105,1,'Criteria에 of() 정적 팩토리 메서드가 있는가?','AUTOMATED','archunit','DOM-CRI-005-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (278,110,1,'Criteria에서 JPA/Spring 어노테이션을 사용하지 않는가?','AUTOMATED','archunit','DOM-CRI-010-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (279,110,2,'DateRange, CursorQueryContext 등 공통 VO를 활용하는가?','REVIEW',NULL,'DOM-CRI-010-02',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (280,111,1,'도메인 객체가 순수 자바 객체(POJO)인가?','AUTOMATED','archunit','DOM-CMN-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (281,111,2,'Lombok, JPA, Spring 어노테이션을 사용하지 않는가?','AUTOMATED','archunit','DOM-CMN-001-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (282,112,1,'도메인 객체가 Application, Persistence, REST API 레이어를 의존하지 않는가?','AUTOMATED','archunit','DOM-CMN-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (283,112,2,'Repository, Port, Service, Controller, Entity, DTO를 import하지 않는가?','AUTOMATED','archunit','DOM-CMN-002-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (284,115,1,'Service 클래스에 @Transactional 어노테이션이 없는가?','AUTOMATED','archunit','APP-TRX-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (285,116,1,'CommandManager/QueryManager에 @Transactional이 있는가?','AUTOMATED','archunit','APP-TRX-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (286,116,2,'QueryManager는 @Transactional(readOnly=true)를 사용하는가?','REVIEW',NULL,'APP-TRX-002-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (287,117,1,'ClientManager에 @Transactional 어노테이션이 없는가?','AUTOMATED','archunit','APP-TRX-003-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (288,118,1,'CommandFacade에서 DB 원자성 필요 시에만 @Transactional을 사용하는가?','REVIEW',NULL,'APP-TRX-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (289,119,1,'QueryFacade에 @Transactional(readOnly=true)가 있는가?','AUTOMATED','archunit','APP-TRX-005-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (290,120,1,'Service가 Facade 또는 Manager에 의존하는가?','AUTOMATED','archunit','APP-DEP-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (291,120,2,'Manager 2개 이상 조합 시 Facade를 사용하는가?','REVIEW',NULL,'APP-DEP-001-02',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (292,121,1,'Facade가 같은 CQRS 범위의 Manager만 의존하는가?','AUTOMATED','archunit','APP-DEP-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (293,121,2,'CommandFacade가 CommandManager만 의존하는가?','AUTOMATED','archunit','APP-DEP-002-02',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (294,122,1,'CommandFacade에서 QueryManager를 의존하지 않는가?','AUTOMATED','archunit','APP-DEP-003-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (295,123,1,'Validator가 자기 도메인의 ReadManager만 의존하는가?','AUTOMATED','archunit','APP-DEP-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (296,124,1,'Calculator, Resolver 등이 Manager를 통해 데이터에 접근하는가?','AUTOMATED','archunit','APP-DEP-005-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (297,124,2,'Port를 직접 의존하지 않는가?','AUTOMATED','archunit','APP-DEP-005-02',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (298,125,1,'Command/Query DTO가 Java Record로 정의되어 있는가?','AUTOMATED','archunit','APP-DTO-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (299,125,2,'Lombok(@Data, @Builder 등)을 사용하지 않는가?','AUTOMATED','archunit','APP-DTO-001-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (300,126,1,'Command/Query에 인스턴스 메서드가 없는가?','AUTOMATED','archunit','APP-DTO-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (301,126,2,'Compact Constructor에 로직이 없는가?','REVIEW',NULL,'APP-DTO-002-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (302,127,1,'*SearchParams가 CommonSearchParams를 포함하는가?','REVIEW',NULL,'APP-DTO-003-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (303,128,1,'*CursorParams가 CommonCursorParams를 포함하는가?','REVIEW',NULL,'APP-DTO-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (304,129,1,'Bundle DTO에 withId() 메서드가 있는가?','REVIEW',NULL,'APP-DTO-005-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (305,130,1,'CommandPort에 persist, persistAll 메서드만 있는가?','AUTOMATED','archunit','APP-PRT-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (306,130,2,'update 메서드가 없는가? (Dirty Checking 사용)','REVIEW',NULL,'APP-PRT-001-02',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (307,131,1,'QueryPort에 findAll() 메서드가 없는가?','AUTOMATED','archunit','APP-PRT-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (308,131,2,'전체 데이터 로딩 대신 findBySliceCriteria를 사용하는가?','REVIEW',NULL,'APP-PRT-002-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (309,132,1,'QueryPort 메서드가 findById, findBy*, existsBy*, countBy* 패턴을 따르는가?','REVIEW',NULL,'APP-PRT-003-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (310,210,1,'Port 파라미터가 원시타입 대신 Domain VO를 사용하는가?','REVIEW',NULL,'APP-PRT-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (311,133,1,'Service에 ApplicationEventPublisher가 직접 주입되지 않는가?','AUTOMATED','archunit','APP-EVT-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (312,134,1,'도메인 이벤트 발행 시 TransactionEventRegistry를 사용하는가?','REVIEW',NULL,'APP-EVT-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (313,135,1,'TimeProvider.now()가 Factory에서만 호출되는가?','AUTOMATED','archunit','APP-TIM-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (314,135,2,'Service에서 TimeProvider를 직접 사용하지 않는가?','AUTOMATED','archunit','APP-TIM-001-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (315,136,1,'Factory가 복잡한 객체 생성과 TimeProvider 필요 작업에만 사용되는가?','REVIEW',NULL,'APP-FAC-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (316,137,1,'Validator의 validate*Exists 메서드가 Domain 객체를 반환하는가?','REVIEW',NULL,'APP-VAL-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (317,138,1,'Validator가 도메인 전용 예외(OrderNotFoundException 등)를 발생시키는가?','REVIEW',NULL,'APP-VAL-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (318,139,1,'Assembler가 도메인별 구체 Result 클래스(OrderSliceResult)를 반환하는가?','REVIEW',NULL,'APP-ASM-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (319,139,2,'제네릭 래퍼(SliceResult<T>)를 사용하지 않는가?','REVIEW',NULL,'APP-ASM-001-02',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (320,140,1,'생성(Create) UseCase가 원시타입(Long)만 반환하는가?','REVIEW',NULL,'APP-ASM-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (321,141,1,'1 UseCase = 1 Service로 구현되어 있는가?','AUTOMATED','archunit','APP-SVC-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (322,142,1,'UseCase 네이밍이 Create*, Update*, Get*, Search* 패턴을 따르는가?','REVIEW',NULL,'APP-SVC-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (323,143,1,'범용 예외 클래스(EntityNotFoundException) 대신 도메인 전용 예외를 사용하는가?','REVIEW',NULL,'APP-EXC-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (324,144,1,'DomainException을 직접 throw하지 않고 상속 클래스를 사용하는가?','REVIEW',NULL,'APP-EXC-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (325,145,1,'EventListener에 @Async가 있는가?','REVIEW',NULL,'APP-LSN-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (326,146,1,'EventListener가 Manager에 의존하는가?','AUTOMATED','archunit','APP-LSN-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (327,146,2,'Port를 직접 의존하지 않는가?','AUTOMATED','archunit','APP-LSN-002-02',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (328,213,1,'커서 기반 조회가 Search{Domain}ByCursorUseCase 네이밍인가?','REVIEW',NULL,'APP-UC-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (329,214,1,'Delete 네이밍 대신 Archive/Deactivate/Disable을 사용하는가?','REVIEW',NULL,'APP-UC-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (330,215,1,'Factory 메서드에 DTO를 통째로 전달하는가?','REVIEW',NULL,'FAC-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (331,215,2,'개별 파라미터로 풀어서 전달하지 않는가?','REVIEW',NULL,'FAC-002-02',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (332,216,1,'Factory에서 UpdateContext(id, updateData, changedAt)를 한 번에 생성하는가?','REVIEW',NULL,'FAC-008-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (333,147,1,'JpaRepository에서 save, saveAll 메서드만 사용하는가?','AUTOMATED','archunit','PER-REP-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (334,148,1,'JpaRepository에 커스텀 쿼리 메서드(@Query, findBy* 등)가 없는가?','AUTOMATED','archunit','PER-REP-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (335,149,1,'모든 조회 쿼리가 QueryDslRepository에서 구현되어 있는가?','AUTOMATED','archunit','PER-REP-003-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (336,149,2,'JPQL, Native Query를 사용하지 않는가?','REVIEW',NULL,'PER-REP-003-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (337,150,1,'CommandAdapter가 JpaRepository만 의존하는가?','AUTOMATED','archunit','PER-ADP-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (338,150,2,'QueryDslRepository를 주입받지 않는가?','AUTOMATED','archunit','PER-ADP-001-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (339,151,1,'QueryAdapter가 QueryDslRepository만 의존하는가?','AUTOMATED','archunit','PER-ADP-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (340,151,2,'JpaRepository를 주입받지 않는가?','AUTOMATED','archunit','PER-ADP-002-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (341,152,1,'@OneToMany, @ManyToOne, @OneToOne, @ManyToMany 어노테이션이 없는가?','AUTOMATED','archunit','PER-ENT-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (342,152,2,'FK는 Long 타입으로 관리하는가?','REVIEW',NULL,'PER-ENT-001-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (343,153,1,'JpaEntity가 BaseAuditEntity 또는 SoftDeletableEntity를 상속하는가?','AUTOMATED','archunit','PER-ENT-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (344,154,1,'spring.jpa.open-in-view=false 설정이 있는가?','MANUAL',NULL,'PER-CFG-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (345,155,1,'spring.jpa.hibernate.ddl-auto=validate 설정이 있는가?','MANUAL',NULL,'PER-CFG-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (346,155,2,'create, update, create-drop을 사용하지 않는가?','MANUAL',NULL,'PER-CFG-002-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (347,156,1,'QueryDslRepository의 where절 조건이 ConditionBuilder로 분리되어 있는가?','REVIEW',NULL,'PER-CND-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (348,157,1,'Soft Delete 테이블 조회 시 deletedAt IS NULL 조건이 있는가?','REVIEW',NULL,'PER-CND-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (349,158,1,'EntityMapper에 toDomain(Entity), toEntity(Domain) 양방향 변환 메서드가 있는가?','REVIEW',NULL,'PER-MAP-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (350,159,1,'MySQL MATCH AGAINST 사용 시 Hibernate FunctionContributor가 등록되어 있는가?','MANUAL',NULL,'PER-FTS-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (351,160,1,'조인, 서브쿼리 등 복잡한 쿼리가 persistence-mysql-admin 모듈에만 있는가?','AUTOMATED','archunit','PER-ADM-001-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (352,160,2,'도메인용 persistence-mysql에서는 단일 테이블 쿼리만 사용하는가?','REVIEW',NULL,'PER-ADM-001-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (353,161,1,'persistence-mysql-admin 모듈에서 조인 사용 시 DTO Projection을 사용하는가?','REVIEW',NULL,'PER-ADM-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (354,165,1,'Controller 클래스에 @RestController 어노테이션이 있는가?','AUTOMATED','archunit','API-CTR-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (355,166,1,'HTTP DELETE 메서드를 사용하지 않는가?','AUTOMATED','archunit','API-CTR-002-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (356,166,2,'soft delete는 PATCH /{id}/delete로 구현되어 있는가?','REVIEW',NULL,'API-CTR-002-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (357,167,1,'Controller가 UseCase(Port-In) 인터페이스에만 의존하는가?','AUTOMATED','archunit','API-CTR-003-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (358,167,2,'구체 Service 클래스를 직접 의존하지 않는가?','AUTOMATED','archunit','API-CTR-003-02',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (359,168,1,'모든 응답이 ResponseEntity<ApiResponse<T>> 형태로 래핑되어 있는가?','REVIEW',NULL,'API-CTR-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (360,169,1,'Controller에 @Transactional 어노테이션이 없는가?','AUTOMATED','archunit','API-CTR-005-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (361,170,1,'@Tag, @Operation, @ApiResponses 어노테이션이 있는가?','REVIEW',NULL,'API-CTR-006-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (362,171,1,'Controller에 비즈니스 로직이 없고 Mapper에 위임하는가?','REVIEW',NULL,'API-CTR-007-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (363,172,1,'경로를 하드코딩하지 않고 *ApiEndpoints 상수 클래스를 사용하는가?','REVIEW',NULL,'API-CTR-008-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (364,173,1,'Request DTO 파라미터에 @Valid 어노테이션이 있는가?','REVIEW',NULL,'API-CTR-009-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (365,174,1,'Command(CUD)와 Query(R) Controller가 별도 클래스로 분리되어 있는가?','REVIEW',NULL,'API-CTR-010-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (366,175,1,'목록 조회 시 List를 직접 반환하지 않는가?','AUTOMATED','archunit','API-CTR-011-01',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (367,175,2,'SliceApiResponse 또는 PageApiResponse를 사용하는가?','REVIEW',NULL,'API-CTR-011-02',1,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (368,176,1,'URL 경로가 소문자 + 복수형을 사용하는가? (/conventions, /modules)','REVIEW',NULL,'API-CTR-012-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (369,211,1,'조회 메서드가 search{Bc}, search{Bc}ByCursor, list{Bc} 패턴을 따르는가?','REVIEW',NULL,'API-CTR-013-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (370,177,1,'Request/Response DTO가 Java Record로 정의되어 있는가?','AUTOMATED','archunit','API-DTO-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (371,178,1,'DTO가 불변 객체이고 Setter가 없는가?','AUTOMATED','archunit','API-DTO-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (372,179,1,'Request DTO에 Jakarta Validation 어노테이션(@NotNull, @NotBlank 등)이 있는가?','REVIEW',NULL,'API-DTO-003-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (373,180,1,'Response DTO에 createdAt, updatedAt 필드가 있는가?','REVIEW',NULL,'API-DTO-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (374,181,1,'Instant 타입이 DateTimeFormatUtils.formatIso8601()로 String 변환되는가?','REVIEW',NULL,'API-DTO-005-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (375,182,1,'복잡한 구조가 중첩 Record로 표현되어 있는가?','REVIEW',NULL,'API-DTO-006-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (376,183,1,'OpenAPI 문서화를 위해 @Schema 어노테이션이 있는가?','REVIEW',NULL,'API-DTO-007-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (377,184,1,'Optional 대신 @Nullable 또는 기본값을 사용하는가?','REVIEW',NULL,'API-DTO-008-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (378,185,1,'List 필드가 생성자에서 List.copyOf()로 방어적 복사되는가?','REVIEW',NULL,'API-DTO-009-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (379,212,1,'Request DTO가 Search{Bc}ApiRequest, Search{Bc}CursorApiRequest, List{Bc}ApiRequest 패턴을 따르는가?','REVIEW',NULL,'API-DTO-010-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (380,186,1,'Mapper 클래스에 @Component 어노테이션이 있는가?','AUTOMATED','archunit','API-MAP-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (381,187,1,'Mapper가 Request→Query/Command, Result→Response 양방향 변환을 지원하는가?','REVIEW',NULL,'API-MAP-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (382,188,1,'Mapper에서 DateTimeFormatUtils.formatIso8601()로 날짜를 포맷팅하는가?','REVIEW',NULL,'API-MAP-003-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (383,189,1,'Mapper에 SliceResult/PageResult를 SliceApiResponse/PageApiResponse로 변환하는 메서드가 있는가?','REVIEW',NULL,'API-MAP-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (384,190,1,'Mapper가 순수 변환 로직만 담당하고 비즈니스 로직이 없는가?','REVIEW',NULL,'API-MAP-005-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (385,191,1,'Request에서 null인 필드의 기본값 처리를 Mapper에서 수행하는가?','REVIEW',NULL,'API-MAP-006-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (386,192,1,'도메인별 ErrorMapper가 구현되어 있는가?','REVIEW',NULL,'API-ERR-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (387,192,2,'ErrorMapper가 supports() + map() 메서드를 구현하는가?','REVIEW',NULL,'API-ERR-001-02',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (388,193,1,'에러 응답이 RFC 7807 ProblemDetail 형식을 사용하는가?','REVIEW',NULL,'API-ERR-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (389,194,1,'ProblemDetail에 x-error-code 확장 헤더가 있는가?','REVIEW',NULL,'API-ERR-003-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (390,195,1,'GlobalExceptionHandler를 통한 전역 예외 처리가 있는가?','REVIEW',NULL,'API-ERR-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (391,196,1,'에러 응답의 Content-Type이 application/problem+json인가?','REVIEW',NULL,'API-ERR-005-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (392,197,1,'JacksonConfig에 SNAKE_CASE, JavaTimeModule이 설정되어 있는가?','MANUAL',NULL,'API-CFG-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (393,198,1,'OpenApiConfig에 GroupedOpenApi가 설정되어 있는가?','MANUAL',NULL,'API-CFG-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (394,199,1,'WebMvcConfig에 CORS, Interceptor, ArgumentResolver가 설정되어 있는가?','MANUAL',NULL,'API-CFG-003-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (395,200,1,'server.servlet.context-path가 설정되어 있는가?','MANUAL',NULL,'API-CFG-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (396,201,1,'Endpoints 상수 클래스가 final class + private 생성자인가?','AUTOMATED','archunit','API-END-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (397,202,1,'모든 경로 상수가 public static final String으로 선언되어 있는가?','REVIEW',NULL,'API-END-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (398,203,1,'PathVariable 이름도 상수로 관리되는가?','REVIEW',NULL,'API-END-003-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (399,204,1,'각 도메인별로 별도의 *ApiEndpoints 클래스가 있는가?','REVIEW',NULL,'API-END-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (400,205,1,'테스트에서 MockMvc를 사용하지 않는가?','AUTOMATED','archunit','API-TST-001-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (401,206,1,'@SpringBootTest(webEnvironment = RANDOM_PORT) + TestRestTemplate을 사용하는가?','REVIEW',NULL,'API-TST-002-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (402,207,1,'ApiResponse<T> 역직렬화 시 ParameterizedTypeReference를 사용하는가?','REVIEW',NULL,'API-TST-003-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (403,208,1,'테스트 데이터 생성이 *Fixture 클래스의 static factory 메서드로 제공되는가?','REVIEW',NULL,'API-TST-004-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);
INSERT INTO `checklist_item` (`id`, `rule_id`, `sequence_order`, `check_description`, `check_type`, `automation_tool`, `automation_rule_id`, `is_critical`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (404,209,1,'ErrorMapper에 supports() + map() 메서드 단위 테스트가 있는가?','REVIEW',NULL,'API-TST-005-01',0,'CONVENTION_HUB',NULL,'2026-01-24 15:41:32.000000','2026-01-24 15:41:32.000000',NULL);

INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (5,6,'ERROR_CODE_INTERFACE','/**\n * ErrorCode - 도메인 에러 코드 인터페이스\n *\n * 모든 도메인별 ErrorCode enum은 이 인터페이스를 구현해야 합니다.\n *\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic interface ErrorCode {\n    String getCode();\n    int getHttpStatus();\n    String getMessage();\n}','{Domain}ErrorCode',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"getCode\", \"getHttpStatus\", \"getMessage\"]','ErrorCode 인터페이스 - 도메인별 예외 코드 정의를 위한 기본 인터페이스','2026-01-20 07:36:31.000000','2026-01-20 07:36:31.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (6,6,'DOMAIN_EXCEPTION','/**\n * DomainException - 도메인 예외 기본 클래스\n *\n * 모든 도메인 예외의 부모 클래스입니다.\n * ErrorCode를 통해 구조화된 예외 정보를 제공합니다.\n *\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic class DomainException extends RuntimeException {\n\n    private final ErrorCode errorCode;\n    private final Map<String, Object> args;\n\n    protected DomainException(ErrorCode errorCode) {\n        super(errorCode.getMessage());\n        this.errorCode = errorCode;\n        this.args = Collections.emptyMap();\n    }\n\n    protected DomainException(ErrorCode errorCode, String message) {\n        super(message);\n        this.errorCode = errorCode;\n        this.args = Collections.emptyMap();\n    }\n\n    protected DomainException(ErrorCode errorCode, String message, Map<String, Object> args) {\n        super(message);\n        this.errorCode = errorCode;\n        this.args = args != null ? Map.copyOf(args) : Collections.emptyMap();\n    }\n\n    public ErrorCode getErrorCode() {\n        return errorCode;\n    }\n\n    public Map<String, Object> getArgs() {\n        return args;\n    }\n}','{Domain}Exception',NULL,'[\"lombok.*\"]',NULL,'[\"DomainException\"]','[\"getErrorCode\", \"getArgs\"]','DomainException 클래스 - 모든 도메인 예외의 부모 클래스','2026-01-20 07:36:41.000000','2026-01-20 07:36:41.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (7,7,'DOMAIN_EVENT_INTERFACE','/**\n * DomainEvent - 도메인 이벤트 마커 인터페이스\n *\n * 모든 도메인 이벤트가 구현해야 하는 기본 인터페이스입니다.\n * 이벤트 발생 시각과 이벤트 타입을 제공합니다.\n *\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic interface DomainEvent {\n\n    /**\n     * 이벤트 발생 시각을 반환합니다.\n     *\n     * @return 이벤트가 발생한 시각 (UTC)\n     */\n    Instant occurredAt();\n\n    /**\n     * 이벤트 타입을 반환합니다.\n     *\n     * @return 이벤트 타입 문자열\n     */\n    default String eventType() {\n        return this.getClass().getSimpleName();\n    }\n}','{Domain}{Action}Event',NULL,'[\"lombok.*\"]','[\"DomainEvent\"]',NULL,'[\"occurredAt\"]','DomainEvent 인터페이스 - 모든 도메인 이벤트가 구현해야 하는 마커 인터페이스','2026-01-20 07:36:50.000000','2026-01-20 07:36:50.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (8,5,'CACHE_KEY_INTERFACE','/**\n * CacheKey - Redis 캐시 키 인터페이스\n *\n * <p>캐시 키 값을 제공하는 Value Object가 구현해야 하는 인터페이스입니다.\n * 각 도메인별 캐시 키는 이 인터페이스를 구현한 record로 정의합니다.\n *\n * <p>키 패턴: {@code cache:{domain}:{entity}:{id}}\n *\n * <p>구현 예시:\n * <pre>{@code\n * public record OrderCacheKey(Long orderId) implements CacheKey {\n *     @Override\n *     public String value() {\n *         return String.format(\"cache:order:order:%d\", orderId);\n *     }\n * }\n * }</pre>\n *\n * <p>VO-001: Value Object는 불변이어야 합니다.\n *\n * <p>VO-002: Lombok 사용이 금지됩니다.\n *\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic interface CacheKey {\n\n    /**\n     * 캐시 키 값을 반환합니다.\n     *\n     * <p>키 형식: {@code cache:{domain}:{entity}:{identifier}}\n     *\n     * @return Redis 캐시에서 사용할 키 문자열\n     */\n    String value();\n}','{Domain}CacheKey',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"value\"]',NULL,'2026-01-20 07:10:53.000000','2026-01-20 07:10:53.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (9,5,'LOCK_KEY_INTERFACE','/**\n * LockKey - 분산 락 키 인터페이스\n *\n * <p>분산 락 키 값을 제공하는 Value Object가 구현해야 하는 인터페이스입니다.\n * 각 도메인별 락 키는 이 인터페이스를 구현한 record로 정의합니다.\n *\n * <p>키 패턴: {@code lock:{domain}:{entity}:{id}}\n *\n * <p>구현 예시:\n * <pre>{@code\n * public record OrderLockKey(Long orderId) implements LockKey {\n *     @Override\n *     public String value() {\n *         return String.format(\"lock:order:order:%d\", orderId);\n *     }\n * }\n * }</pre>\n *\n * <p>VO-001: Value Object는 불변이어야 합니다.\n *\n * <p>VO-002: Lombok 사용이 금지됩니다.\n *\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic interface LockKey {\n\n    /**\n     * 분산 락 키 값을 반환합니다.\n     *\n     * <p>키 형식: {@code lock:{domain}:{entity}:{identifier}}\n     *\n     * @return Redis 분산 락에서 사용할 키 문자열\n     */\n    String value();\n}','{Domain}LockKey',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"value\"]',NULL,'2026-01-20 07:10:53.000000','2026-01-20 07:10:53.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (10,5,'SORT_KEY_INTERFACE','/**\n * SortKey - 정렬 키 마커 인터페이스\n *\n * <p>정렬 가능한 필드를 나타내는 enum이 구현해야 하는 마커 인터페이스입니다.\n * 각 BC(Bounded Context)별로 고유한 정렬 키 enum을 정의합니다.\n *\n * <p>구현 예시:\n * <pre>{@code\n * public enum OrderSortKey implements SortKey {\n *     ID(\"id\"),\n *     CREATED_AT(\"createdAt\"),\n *     TOTAL_AMOUNT(\"totalAmount\");\n *\n *     private final String fieldName;\n *\n *     OrderSortKey(String fieldName) {\n *         this.fieldName = fieldName;\n *     }\n *\n *     @Override\n *     public String fieldName() {\n *         return fieldName;\n *     }\n * }\n * }</pre>\n *\n * <p>VO-002: Lombok 사용이 금지됩니다.\n *\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic interface SortKey {\n\n    /**\n     * 정렬에 사용될 실제 필드명을 반환합니다.\n     *\n     * <p>이 값은 QueryDSL이나 JPA에서 정렬 시 사용됩니다.\n     *\n     * @return 엔티티의 실제 필드명\n     */\n    String fieldName();\n\n    /**\n     * 정렬 키의 이름을 반환합니다.\n     *\n     * <p>기본 구현은 enum의 name()을 반환합니다.\n     *\n     * @return 정렬 키 이름 (enum name)\n     */\n    default String name() {\n        return this.toString();\n    }\n}','{Domain}SortKey',NULL,'[\"lombok.*\"]','[\"SortKey\"]',NULL,'[\"fieldName\"]',NULL,'2026-01-20 07:10:53.000000','2026-01-20 07:10:53.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (11,5,'SORT_DIRECTION_ENUM','/**\n * SortDirection - 정렬 방향 enum\n *\n * <p>정렬 방향(오름차순/내림차순)을 나타내는 공통 enum입니다.\n * 모든 도메인에서 재사용됩니다.\n *\n * <p>사용 예시:\n * <pre>{@code\n * SortDirection direction = SortDirection.fromString(\"desc\");\n * boolean isAsc = direction.isAscending();\n * SortDirection reversed = direction.reverse();\n * }</pre>\n *\n * <p>VO-002: Lombok 사용이 금지됩니다.\n *\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic enum SortDirection {\n\n    /** 오름차순 정렬 */\n    ASC,\n\n    /** 내림차순 정렬 */\n    DESC;\n\n    /**\n     * 기본 정렬 방향을 반환합니다.\n     *\n     * @return DESC (내림차순)\n     */\n    public static SortDirection defaultDirection() {\n        return DESC;\n    }\n\n    /**\n     * 오름차순인지 확인합니다.\n     *\n     * @return 오름차순이면 true\n     */\n    public boolean isAscending() {\n        return this == ASC;\n    }\n\n    /**\n     * 내림차순인지 확인합니다.\n     *\n     * @return 내림차순이면 true\n     */\n    public boolean isDescending() {\n        return this == DESC;\n    }\n\n    /**\n     * 반대 방향을 반환합니다.\n     *\n     * @return ASC면 DESC, DESC면 ASC\n     */\n    public SortDirection reverse() {\n        return this == ASC ? DESC : ASC;\n    }\n\n    /**\n     * 문자열에서 SortDirection을 파싱합니다.\n     *\n     * <p>대소문자를 구분하지 않습니다.\n     *\n     * @param value 파싱할 문자열 (\"asc\", \"ASC\", \"desc\", \"DESC\")\n     * @return 해당하는 SortDirection, null이거나 빈 문자열이면 기본값(DESC)\n     * @throws IllegalArgumentException 유효하지 않은 값인 경우\n     */\n    public static SortDirection fromString(String value) {\n        if (value == null || value.isBlank()) {\n            return defaultDirection();\n        }\n        try {\n            return valueOf(value.toUpperCase());\n        } catch (IllegalArgumentException e) {\n            throw new IllegalArgumentException(\n                    \"Invalid sort direction: \" + value + \". Use ASC or DESC.\");\n        }\n    }\n\n    /**\n     * 표시용 이름을 반환합니다.\n     *\n     * @return \"Ascending\" 또는 \"Descending\"\n     */\n    public String displayName() {\n        return this == ASC ? \"Ascending\" : \"Descending\";\n    }\n}','SortDirection',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"isAscending\", \"isDescending\", \"reverse\", \"fromString\"]',NULL,'2026-01-20 07:10:53.000000','2026-01-20 07:10:53.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (12,5,'PAGE_REQUEST_RECORD','/**\n * PageRequest - 오프셋 기반 페이지네이션 요청 VO\n *\n * <p>전통적인 오프셋 기반 페이지네이션을 위한 요청 정보를 담는 불변 Value Object입니다.\n *\n * <p>사용 예시:\n * <pre>{@code\n * PageRequest request = PageRequest.of(0, 20);\n * long offset = request.offset();\n * PageRequest next = request.next();\n * }</pre>\n *\n * <p>VO-001: Value Object는 불변이어야 합니다.\n *\n * <p>VO-002: Lombok 사용이 금지됩니다.\n *\n * @param page 0-based 페이지 번호\n * @param size 페이지 당 항목 수\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic record PageRequest(int page, int size) {\n\n    /** 기본 페이지 크기 */\n    public static final int DEFAULT_SIZE = 20;\n\n    /** 최대 페이지 크기 */\n    public static final int MAX_SIZE = 100;\n\n    /**\n     * Compact constructor - 유효성 검증\n     */\n    public PageRequest {\n        if (page < 0) {\n            throw new IllegalArgumentException(\"Page must be non-negative\");\n        }\n        if (size < 1) {\n            throw new IllegalArgumentException(\"Size must be positive\");\n        }\n        if (size > MAX_SIZE) {\n            size = MAX_SIZE;\n        }\n    }\n\n    /**\n     * 페이지 번호와 크기로 PageRequest를 생성합니다.\n     *\n     * @param page 0-based 페이지 번호\n     * @param size 페이지 당 항목 수\n     * @return PageRequest 인스턴스\n     */\n    public static PageRequest of(int page, int size) {\n        return new PageRequest(page, size);\n    }\n\n    /**\n     * 첫 페이지 요청을 생성합니다.\n     *\n     * @param size 페이지 당 항목 수\n     * @return 첫 페이지 PageRequest\n     */\n    public static PageRequest first(int size) {\n        return new PageRequest(0, size);\n    }\n\n    /**\n     * 기본 설정의 첫 페이지 요청을 생성합니다.\n     *\n     * @return 기본 크기의 첫 페이지 PageRequest\n     */\n    public static PageRequest defaultPage() {\n        return new PageRequest(0, DEFAULT_SIZE);\n    }\n\n    /**\n     * SQL OFFSET 값을 계산합니다.\n     *\n     * @return 오프셋 값\n     */\n    public long offset() {\n        return (long) page * size;\n    }\n\n    /**\n     * 다음 페이지 요청을 반환합니다.\n     *\n     * @return 다음 페이지 PageRequest\n     */\n    public PageRequest next() {\n        return new PageRequest(page + 1, size);\n    }\n\n    /**\n     * 이전 페이지 요청을 반환합니다.\n     *\n     * @return 이전 페이지 PageRequest, 첫 페이지면 자기 자신\n     */\n    public PageRequest previous() {\n        return page == 0 ? this : new PageRequest(page - 1, size);\n    }\n\n    /**\n     * 첫 페이지인지 확인합니다.\n     *\n     * @return 첫 페이지면 true\n     */\n    public boolean isFirst() {\n        return page == 0;\n    }\n\n    /**\n     * 전체 페이지 수를 계산합니다.\n     *\n     * @param totalElements 전체 항목 수\n     * @return 전체 페이지 수\n     */\n    public int totalPages(long totalElements) {\n        return (int) Math.ceil((double) totalElements / size);\n    }\n\n    /**\n     * 마지막 페이지인지 확인합니다.\n     *\n     * @param totalElements 전체 항목 수\n     * @return 마지막 페이지면 true\n     */\n    public boolean isLast(long totalElements) {\n        return page >= totalPages(totalElements) - 1;\n    }\n}','PageRequest',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"of\", \"first\", \"offset\", \"next\", \"previous\", \"isFirst\"]',NULL,'2026-01-20 07:10:53.000000','2026-01-20 07:10:53.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (13,5,'PAGE_META_RECORD','/**\n * PageMeta - 오프셋 기반 페이지네이션 메타데이터 VO\n *\n * <p>페이지네이션 결과의 메타 정보를 담는 불변 Value Object입니다.\n *\n * <p>사용 예시:\n * <pre>{@code\n * PageMeta meta = PageMeta.of(0, 20, 150);\n * boolean hasNext = meta.hasNext();\n * int totalPages = meta.totalPages();\n * }</pre>\n *\n * <p>VO-001: Value Object는 불변이어야 합니다.\n *\n * <p>VO-002: Lombok 사용이 금지됩니다.\n *\n * @param page 현재 페이지 번호 (0-based)\n * @param size 페이지 당 항목 수\n * @param totalElements 전체 항목 수\n * @param totalPages 전체 페이지 수\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic record PageMeta(int page, int size, long totalElements, int totalPages) {\n\n    /**\n     * Compact constructor - 유효성 검증\n     */\n    public PageMeta {\n        if (page < 0) {\n            throw new IllegalArgumentException(\"Page must be non-negative\");\n        }\n        if (size < 1) {\n            throw new IllegalArgumentException(\"Size must be positive\");\n        }\n        if (totalElements < 0) {\n            throw new IllegalArgumentException(\"Total elements must be non-negative\");\n        }\n        if (totalPages < 0) {\n            throw new IllegalArgumentException(\"Total pages must be non-negative\");\n        }\n    }\n\n    /**\n     * 페이지 정보로 PageMeta를 생성합니다.\n     *\n     * <p>totalPages는 자동으로 계산됩니다.\n     *\n     * @param page 현재 페이지 번호\n     * @param size 페이지 당 항목 수\n     * @param totalElements 전체 항목 수\n     * @return PageMeta 인스턴스\n     */\n    public static PageMeta of(int page, int size, long totalElements) {\n        int totalPages = size == 0 ? 0 : (int) Math.ceil((double) totalElements / size);\n        return new PageMeta(page, size, totalElements, totalPages);\n    }\n\n    /**\n     * 빈 결과를 위한 PageMeta를 생성합니다.\n     *\n     * @param size 요청된 페이지 크기\n     * @return 빈 PageMeta\n     */\n    public static PageMeta empty(int size) {\n        return new PageMeta(0, size, 0, 0);\n    }\n\n    /**\n     * 다음 페이지가 있는지 확인합니다.\n     *\n     * @return 다음 페이지가 있으면 true\n     */\n    public boolean hasNext() {\n        return page < totalPages - 1;\n    }\n\n    /**\n     * 이전 페이지가 있는지 확인합니다.\n     *\n     * @return 이전 페이지가 있으면 true\n     */\n    public boolean hasPrevious() {\n        return page > 0;\n    }\n\n    /**\n     * 첫 페이지인지 확인합니다.\n     *\n     * @return 첫 페이지면 true\n     */\n    public boolean isFirst() {\n        return page == 0;\n    }\n\n    /**\n     * 마지막 페이지인지 확인합니다.\n     *\n     * @return 마지막 페이지면 true\n     */\n    public boolean isLast() {\n        return page >= totalPages - 1;\n    }\n\n    /**\n     * 결과가 비어있는지 확인합니다.\n     *\n     * @return 비어있으면 true\n     */\n    public boolean isEmpty() {\n        return totalElements == 0;\n    }\n\n    /**\n     * 현재 페이지의 시작 항목 번호를 반환합니다 (1-based).\n     *\n     * @return 시작 항목 번호\n     */\n    public long startElement() {\n        return isEmpty() ? 0 : (long) page * size + 1;\n    }\n\n    /**\n     * 현재 페이지의 마지막 항목 번호를 반환합니다 (1-based).\n     *\n     * @return 마지막 항목 번호\n     */\n    public long endElement() {\n        return isEmpty() ? 0 : Math.min((long) (page + 1) * size, totalElements);\n    }\n\n    /**\n     * SQL OFFSET 값을 계산합니다.\n     *\n     * @return 오프셋 값\n     */\n    public long offset() {\n        return (long) page * size;\n    }\n}','PageMeta',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"of\", \"empty\", \"hasNext\", \"hasPrevious\", \"isFirst\", \"isLast\", \"isEmpty\"]',NULL,'2026-01-20 07:10:54.000000','2026-01-20 07:10:54.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (14,5,'SLICE_META_RECORD','/**\n * SliceMeta - 커서 기반 페이지네이션 메타데이터 VO\n *\n * <p>무한 스크롤 등 커서 기반 페이지네이션 결과의 메타 정보를 담는 불변 Value Object입니다.\n *\n * <p>사용 예시:\n * <pre>{@code\n * SliceMeta meta = SliceMeta.of(20, true, \"cursor123\", 20);\n * boolean hasNext = meta.hasNext();\n * String nextCursor = meta.cursor();\n * }</pre>\n *\n * <p>VO-001: Value Object는 불변이어야 합니다.\n *\n * <p>VO-002: Lombok 사용이 금지됩니다.\n *\n * @param size 요청된 페이지 크기\n * @param hasNext 다음 페이지 존재 여부\n * @param cursor 다음 페이지를 위한 커서 (nullable)\n * @param count 현재 페이지의 항목 수\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic record SliceMeta(int size, boolean hasNext, String cursor, int count) {\n\n    /**\n     * Compact constructor - 유효성 검증\n     */\n    public SliceMeta {\n        if (size < 1) {\n            throw new IllegalArgumentException(\"Size must be positive\");\n        }\n        if (count < 0) {\n            throw new IllegalArgumentException(\"Count must be non-negative\");\n        }\n    }\n\n    /**\n     * SliceMeta를 생성합니다.\n     *\n     * @param size 요청된 페이지 크기\n     * @param hasNext 다음 페이지 존재 여부\n     * @param cursor 다음 페이지 커서\n     * @param count 현재 페이지 항목 수\n     * @return SliceMeta 인스턴스\n     */\n    public static SliceMeta of(int size, boolean hasNext, String cursor, int count) {\n        return new SliceMeta(size, hasNext, cursor, count);\n    }\n\n    /**\n     * 커서 없이 SliceMeta를 생성합니다.\n     *\n     * @param size 요청된 페이지 크기\n     * @param hasNext 다음 페이지 존재 여부\n     * @param count 현재 페이지 항목 수\n     * @return SliceMeta 인스턴스\n     */\n    public static SliceMeta withCursor(int size, boolean hasNext, int count) {\n        return new SliceMeta(size, hasNext, null, count);\n    }\n\n    /**\n     * 빈 결과를 위한 SliceMeta를 생성합니다.\n     *\n     * @param size 요청된 페이지 크기\n     * @return 빈 SliceMeta\n     */\n    public static SliceMeta empty(int size) {\n        return new SliceMeta(size, false, null, 0);\n    }\n\n    /**\n     * 커서가 있는지 확인합니다.\n     *\n     * @return 커서가 있으면 true\n     */\n    public boolean hasCursor() {\n        return cursor != null && !cursor.isBlank();\n    }\n\n    /**\n     * 마지막 페이지인지 확인합니다.\n     *\n     * @return 마지막 페이지면 true\n     */\n    public boolean isLast() {\n        return !hasNext;\n    }\n\n    /**\n     * 결과가 비어있는지 확인합니다.\n     *\n     * @return 비어있으면 true\n     */\n    public boolean isEmpty() {\n        return count == 0;\n    }\n\n    /**\n     * 커서를 Long으로 파싱합니다.\n     *\n     * @return 파싱된 Long 값, 커서가 없으면 null\n     * @throws NumberFormatException 숫자로 변환 불가능한 경우\n     */\n    public Long cursorAsLong() {\n        return hasCursor() ? Long.valueOf(cursor) : null;\n    }\n\n    /**\n     * 다음 페이지 정보를 위한 SliceMeta를 생성합니다.\n     *\n     * @param newCursor 새 커서\n     * @param newCount 새 항목 수\n     * @param newHasNext 다음 페이지 존재 여부\n     * @return 새 SliceMeta\n     */\n    public SliceMeta next(String newCursor, int newCount, boolean newHasNext) {\n        return new SliceMeta(size, newHasNext, newCursor, newCount);\n    }\n}','SliceMeta',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"of\", \"empty\", \"hasCursor\", \"isLast\", \"isEmpty\"]',NULL,'2026-01-20 07:10:54.000000','2026-01-20 07:10:54.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (15,5,'DATE_RANGE_RECORD','/**\n * DateRange - 날짜 범위 VO\n *\n * <p>시작일과 종료일로 구성된 날짜 범위를 나타내는 불변 Value Object입니다.\n * 조회 조건에서 기간 필터링에 사용됩니다.\n *\n * <p>사용 예시:\n * <pre>{@code\n * DateRange range = DateRange.lastDays(7);\n * DateRange thisMonth = DateRange.thisMonth();\n * boolean contains = range.contains(LocalDate.now());\n * }</pre>\n *\n * <p>VO-001: Value Object는 불변이어야 합니다.\n *\n * <p>VO-002: Lombok 사용이 금지됩니다.\n *\n * @param startDate 시작일 (nullable - null이면 시작 제한 없음)\n * @param endDate 종료일 (nullable - null이면 종료 제한 없음)\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic record DateRange(LocalDate startDate, LocalDate endDate) {\n\n    /**\n     * Compact constructor - 유효성 검증\n     */\n    public DateRange {\n        if (startDate != null && endDate != null && startDate.isAfter(endDate)) {\n            throw new IllegalArgumentException(\"Start date must not be after end date\");\n        }\n    }\n\n    /**\n     * 시작일과 종료일로 DateRange를 생성합니다.\n     *\n     * @param startDate 시작일\n     * @param endDate 종료일\n     * @return DateRange 인스턴스\n     */\n    public static DateRange of(LocalDate startDate, LocalDate endDate) {\n        return new DateRange(startDate, endDate);\n    }\n\n    /**\n     * 최근 N일 범위를 생성합니다.\n     *\n     * @param days 일 수\n     * @return 최근 N일 DateRange\n     */\n    public static DateRange lastDays(int days) {\n        LocalDate today = LocalDate.now();\n        return new DateRange(today.minusDays(days), today);\n    }\n\n    /**\n     * 이번 달 범위를 생성합니다.\n     *\n     * @return 이번 달 DateRange\n     */\n    public static DateRange thisMonth() {\n        LocalDate today = LocalDate.now();\n        return new DateRange(today.withDayOfMonth(1), today);\n    }\n\n    /**\n     * 지난 달 범위를 생성합니다.\n     *\n     * @return 지난 달 DateRange\n     */\n    public static DateRange lastMonth() {\n        LocalDate today = LocalDate.now();\n        LocalDate firstDayLastMonth = today.minusMonths(1).withDayOfMonth(1);\n        LocalDate lastDayLastMonth = today.withDayOfMonth(1).minusDays(1);\n        return new DateRange(firstDayLastMonth, lastDayLastMonth);\n    }\n\n    /**\n     * 종료일만 지정된 범위를 생성합니다.\n     *\n     * @param endDate 종료일\n     * @return 시작 제한 없는 DateRange\n     */\n    public static DateRange until(LocalDate endDate) {\n        return new DateRange(null, endDate);\n    }\n\n    /**\n     * 시작일만 지정된 범위를 생성합니다.\n     *\n     * @param startDate 시작일\n     * @return 종료 제한 없는 DateRange\n     */\n    public static DateRange from(LocalDate startDate) {\n        return new DateRange(startDate, null);\n    }\n\n    /**\n     * 시작일을 Instant로 변환합니다 (00:00:00 UTC).\n     *\n     * @return Instant, startDate가 null이면 null\n     */\n    public Instant startInstant() {\n        return startDate != null ? startDate.atStartOfDay(ZoneOffset.UTC).toInstant() : null;\n    }\n\n    /**\n     * 종료일을 Instant로 변환합니다 (다음날 00:00:00 UTC - exclusive).\n     *\n     * @return Instant, endDate가 null이면 null\n     */\n    public Instant endInstant() {\n        return endDate != null ? endDate.plusDays(1).atStartOfDay(ZoneOffset.UTC).toInstant() : null;\n    }\n\n    /**\n     * 범위가 비어있는지 (둘 다 null인지) 확인합니다.\n     *\n     * @return 비어있으면 true\n     */\n    public boolean isEmpty() {\n        return startDate == null && endDate == null;\n    }\n\n    /**\n     * 특정 날짜가 범위 내에 있는지 확인합니다.\n     *\n     * @param date 확인할 날짜\n     * @return 범위 내에 있으면 true\n     */\n    public boolean contains(LocalDate date) {\n        if (date == null) {\n            return false;\n        }\n        boolean afterStart = startDate == null || !date.isBefore(startDate);\n        boolean beforeEnd = endDate == null || !date.isAfter(endDate);\n        return afterStart && beforeEnd;\n    }\n}','DateRange',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"of\", \"lastDays\", \"thisMonth\", \"isEmpty\", \"contains\"]',NULL,'2026-01-20 07:10:54.000000','2026-01-20 07:10:54.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (16,5,'DELETION_STATUS_RECORD','/**\n * DeletionStatus - 소프트 삭제 상태 VO\n *\n * <p>엔티티의 삭제 상태(소프트 삭제)를 나타내는 불변 Value Object입니다.\n *\n * <p>사용 예시:\n * <pre>{@code\n * DeletionStatus active = DeletionStatus.active();\n * DeletionStatus deleted = DeletionStatus.deletedAt(timeProvider.now()); // 또는 외부 주입\n * boolean isDeleted = status.isDeleted();\n * }</pre>\n *\n * <p>VO-001: Value Object는 불변이어야 합니다.\n *\n * <p>VO-002: Lombok 사용이 금지됩니다.\n *\n * @param deleted 삭제 여부\n * @param deletedAt 삭제 시각 (삭제되지 않았으면 null)\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic record DeletionStatus(boolean deleted, Instant deletedAt) {\n\n    /**\n     * Compact constructor - 유효성 검증\n     */\n    public DeletionStatus {\n        if (deleted && deletedAt == null) {\n            throw new IllegalArgumentException(\"Deleted status requires deletedAt timestamp\");\n        }\n        if (!deleted && deletedAt != null) {\n            throw new IllegalArgumentException(\"Active status should not have deletedAt timestamp\");\n        }\n    }\n\n    /**\n     * 활성 상태를 생성합니다.\n     *\n     * @return 활성 DeletionStatus\n     */\n    public static DeletionStatus active() {\n        return new DeletionStatus(false, null);\n    }\n\n    /**\n     * 삭제 상태를 생성합니다.\n     *\n     * @param deletedAt 삭제 시각\n     * @return 삭제된 DeletionStatus\n     */\n    public static DeletionStatus deletedAt(Instant deletedAt) {\n        return new DeletionStatus(true, deletedAt);\n    }\n\n    /**\n     * DB에서 복원할 때 사용합니다.\n     *\n     * @param deleted 삭제 여부\n     * @param deletedAt 삭제 시각\n     * @return DeletionStatus 인스턴스\n     */\n    public static DeletionStatus reconstitute(boolean deleted, Instant deletedAt) {\n        if (!deleted) {\n            return active();\n        }\n        return deletedAt(deletedAt);\n    }\n\n    /**\n     * 삭제되었는지 확인합니다.\n     *\n     * @return 삭제되었으면 true\n     */\n    public boolean isDeleted() {\n        return deleted;\n    }\n\n    /**\n     * 활성 상태인지 확인합니다.\n     *\n     * @return 활성 상태면 true\n     */\n    public boolean isActive() {\n        return !deleted;\n    }\n}','DeletionStatus',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"active\", \"deletedAt\", \"reconstitute\", \"isDeleted\", \"isActive\"]',NULL,'2026-01-20 07:10:54.000000','2026-01-21 14:58:35.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (17,5,'CURSOR_PAGE_REQUEST_RECORD','/**\n * CursorPageRequest - 제네릭 커서 기반 페이지네이션 요청 VO\n *\n * <p>타입 안전한 커서 기반 페이지네이션을 위한 요청 정보를 담는 불변 Value Object입니다.\n * 커서 타입을 제네릭으로 지정하여 다양한 타입의 커서를 지원합니다.\n *\n * <p>사용 예시:\n * <pre>{@code\n * CursorPageRequest<Long> request = CursorPageRequest.afterId(100L);\n * CursorPageRequest<String> strRequest = CursorPageRequest.ofString(\"cursor123\", 20);\n * boolean isFirst = request.isFirstPage();\n * }</pre>\n *\n * <p>VO-001: Value Object는 불변이어야 합니다.\n *\n * <p>VO-002: Lombok 사용이 금지됩니다.\n *\n * @param <C> 커서 타입\n * @param cursor 현재 커서 값 (nullable - null이면 첫 페이지)\n * @param size 페이지 당 항목 수\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic record CursorPageRequest<C>(C cursor, int size) {\n\n    /** 기본 페이지 크기 */\n    public static final int DEFAULT_SIZE = 20;\n\n    /** 최대 페이지 크기 */\n    public static final int MAX_SIZE = 100;\n\n    /**\n     * Compact constructor - 유효성 검증\n     */\n    public CursorPageRequest {\n        if (size < 1) {\n            throw new IllegalArgumentException(\"Size must be positive\");\n        }\n        if (size > MAX_SIZE) {\n            size = MAX_SIZE;\n        }\n    }\n\n    /**\n     * 커서와 크기로 CursorPageRequest를 생성합니다.\n     *\n     * @param <C> 커서 타입\n     * @param cursor 커서 값\n     * @param size 페이지 크기\n     * @return CursorPageRequest 인스턴스\n     */\n    public static <C> CursorPageRequest<C> of(C cursor, int size) {\n        return new CursorPageRequest<>(cursor, size);\n    }\n\n    /**\n     * 첫 페이지 요청을 생성합니다.\n     *\n     * @param <C> 커서 타입\n     * @param size 페이지 크기\n     * @return 첫 페이지 CursorPageRequest\n     */\n    public static <C> CursorPageRequest<C> first(int size) {\n        return new CursorPageRequest<>(null, size);\n    }\n\n    /**\n     * 기본 설정의 첫 페이지 요청을 생성합니다.\n     *\n     * @param <C> 커서 타입\n     * @return 기본 크기의 첫 페이지 CursorPageRequest\n     */\n    public static <C> CursorPageRequest<C> defaultPage() {\n        return new CursorPageRequest<>(null, DEFAULT_SIZE);\n    }\n\n    /**\n     * Long ID 기반 커서 요청을 생성합니다.\n     *\n     * @param afterId 이 ID 이후 항목 조회\n     * @return Long 커서 CursorPageRequest\n     */\n    public static CursorPageRequest<Long> afterId(Long afterId) {\n        return new CursorPageRequest<>(afterId, DEFAULT_SIZE);\n    }\n\n    /**\n     * String 커서 기반 요청을 생성합니다.\n     *\n     * @param cursor 문자열 커서\n     * @param size 페이지 크기\n     * @return String 커서 CursorPageRequest\n     */\n    public static CursorPageRequest<String> ofString(String cursor, int size) {\n        return new CursorPageRequest<>(cursor, size);\n    }\n\n    /**\n     * 첫 페이지인지 확인합니다.\n     *\n     * @return 커서가 없으면 true\n     */\n    public boolean isFirstPage() {\n        return cursor == null;\n    }\n\n    /**\n     * 커서가 있는지 확인합니다.\n     *\n     * @return 커서가 있으면 true\n     */\n    public boolean hasCursor() {\n        return cursor != null;\n    }\n\n    /**\n     * 다음 페이지 요청을 생성합니다.\n     *\n     * @param nextCursor 다음 커서\n     * @return 다음 페이지 CursorPageRequest\n     */\n    public CursorPageRequest<C> next(C nextCursor) {\n        return new CursorPageRequest<>(nextCursor, size);\n    }\n\n    /**\n     * 실제 조회할 크기를 반환합니다 (hasNext 판단을 위해 +1).\n     *\n     * @return size + 1\n     */\n    public int fetchSize() {\n        return size + 1;\n    }\n}','CursorPageRequest',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"of\", \"first\", \"afterId\", \"isFirstPage\", \"hasCursor\", \"next\", \"fetchSize\"]',NULL,'2026-01-20 07:10:54.000000','2026-01-20 07:10:54.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (18,5,'QUERY_CONTEXT_RECORD','/**\n * QueryContext - 제네릭 조회 컨텍스트 VO\n *\n * <p>정렬 + 페이지네이션 정보를 결합한 조회 컨텍스트를 나타내는 불변 Value Object입니다.\n * SortKey 타입을 제네릭으로 지정하여 도메인별 정렬 키를 지원합니다.\n *\n * <p>사용 예시:\n * <pre>{@code\n * QueryContext<OrderSortKey> context = QueryContext.of(\n *     OrderSortKey.CREATED_AT,\n *     SortDirection.DESC,\n *     PageRequest.of(0, 20)\n * );\n * long offset = context.offset();\n * boolean isAsc = context.isAscending();\n * }</pre>\n *\n * <p>VO-001: Value Object는 불변이어야 합니다.\n *\n * <p>VO-002: Lombok 사용이 금지됩니다.\n *\n * @param <K> SortKey를 구현하는 정렬 키 타입\n * @param sortKey 정렬 키\n * @param sortDirection 정렬 방향\n * @param pageRequest 페이지 요청\n * @param includeDeleted 삭제된 항목 포함 여부\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic record QueryContext<K extends SortKey>(\n        K sortKey,\n        SortDirection sortDirection,\n        PageRequest pageRequest,\n        boolean includeDeleted) {\n\n    /**\n     * Compact constructor - 유효성 검증\n     */\n    public QueryContext {\n        if (sortKey == null) {\n            throw new IllegalArgumentException(\"SortKey must not be null\");\n        }\n        if (sortDirection == null) {\n            sortDirection = SortDirection.defaultDirection();\n        }\n        if (pageRequest == null) {\n            pageRequest = PageRequest.defaultPage();\n        }\n    }\n\n    /**\n     * 모든 파라미터로 QueryContext를 생성합니다.\n     *\n     * @param <K> 정렬 키 타입\n     * @param sortKey 정렬 키\n     * @param sortDirection 정렬 방향\n     * @param pageRequest 페이지 요청\n     * @param includeDeleted 삭제 항목 포함 여부\n     * @return QueryContext 인스턴스\n     */\n    public static <K extends SortKey> QueryContext<K> of(\n            K sortKey, SortDirection sortDirection, PageRequest pageRequest, boolean includeDeleted) {\n        return new QueryContext<>(sortKey, sortDirection, pageRequest, includeDeleted);\n    }\n\n    /**\n     * 기본 설정으로 QueryContext를 생성합니다.\n     *\n     * @param <K> 정렬 키 타입\n     * @param sortKey 정렬 키\n     * @param sortDirection 정렬 방향\n     * @param pageRequest 페이지 요청\n     * @return 삭제 항목 미포함 QueryContext\n     */\n    public static <K extends SortKey> QueryContext<K> of(\n            K sortKey, SortDirection sortDirection, PageRequest pageRequest) {\n        return new QueryContext<>(sortKey, sortDirection, pageRequest, false);\n    }\n\n    /**\n     * 기본 정렬 방향과 첫 페이지로 QueryContext를 생성합니다.\n     *\n     * @param <K> 정렬 키 타입\n     * @param sortKey 정렬 키\n     * @return 기본 설정 QueryContext\n     */\n    public static <K extends SortKey> QueryContext<K> defaultOf(K sortKey) {\n        return new QueryContext<>(sortKey, SortDirection.defaultDirection(), PageRequest.defaultPage(), false);\n    }\n\n    /**\n     * 첫 페이지 QueryContext를 생성합니다.\n     *\n     * @param <K> 정렬 키 타입\n     * @param sortKey 정렬 키\n     * @param sortDirection 정렬 방향\n     * @param size 페이지 크기\n     * @return 첫 페이지 QueryContext\n     */\n    public static <K extends SortKey> QueryContext<K> firstPage(\n            K sortKey, SortDirection sortDirection, int size) {\n        return new QueryContext<>(sortKey, sortDirection, PageRequest.first(size), false);\n    }\n\n    /**\n     * 다음 페이지 QueryContext를 반환합니다.\n     *\n     * @return 다음 페이지 QueryContext\n     */\n    public QueryContext<K> nextPage() {\n        return new QueryContext<>(sortKey, sortDirection, pageRequest.next(), includeDeleted);\n    }\n\n    /**\n     * 이전 페이지 QueryContext를 반환합니다.\n     *\n     * @return 이전 페이지 QueryContext\n     */\n    public QueryContext<K> previousPage() {\n        return new QueryContext<>(sortKey, sortDirection, pageRequest.previous(), includeDeleted);\n    }\n\n    /**\n     * 정렬 방향을 반전한 QueryContext를 반환합니다.\n     *\n     * @return 정렬 방향 반전 QueryContext\n     */\n    public QueryContext<K> reverseSortDirection() {\n        return new QueryContext<>(sortKey, sortDirection.reverse(), pageRequest, includeDeleted);\n    }\n\n    /**\n     * 정렬 키를 변경한 QueryContext를 반환합니다.\n     *\n     * @param newSortKey 새 정렬 키\n     * @return 정렬 키 변경 QueryContext\n     */\n    public QueryContext<K> withSortKey(K newSortKey) {\n        return new QueryContext<>(newSortKey, sortDirection, pageRequest, includeDeleted);\n    }\n\n    /**\n     * 페이지 크기를 변경한 QueryContext를 반환합니다.\n     *\n     * @param newSize 새 페이지 크기\n     * @return 페이지 크기 변경 QueryContext\n     */\n    public QueryContext<K> withPageSize(int newSize) {\n        return new QueryContext<>(sortKey, sortDirection, PageRequest.of(pageRequest.page(), newSize), includeDeleted);\n    }\n\n    /**\n     * 삭제 항목 포함 여부를 변경한 QueryContext를 반환합니다.\n     *\n     * @param include 삭제 항목 포함 여부\n     * @return 삭제 항목 포함 여부 변경 QueryContext\n     */\n    public QueryContext<K> withIncludeDeleted(boolean include) {\n        return new QueryContext<>(sortKey, sortDirection, pageRequest, include);\n    }\n\n    /**\n     * SQL OFFSET 값을 반환합니다.\n     *\n     * @return 오프셋 값\n     */\n    public long offset() {\n        return pageRequest.offset();\n    }\n\n    /**\n     * 페이지 크기를 반환합니다.\n     *\n     * @return 페이지 크기\n     */\n    public int size() {\n        return pageRequest.size();\n    }\n\n    /**\n     * 현재 페이지 번호를 반환합니다.\n     *\n     * @return 페이지 번호\n     */\n    public int page() {\n        return pageRequest.page();\n    }\n\n    /**\n     * 첫 페이지인지 확인합니다.\n     *\n     * @return 첫 페이지면 true\n     */\n    public boolean isFirstPage() {\n        return pageRequest.isFirst();\n    }\n\n    /**\n     * 오름차순인지 확인합니다.\n     *\n     * @return 오름차순이면 true\n     */\n    public boolean isAscending() {\n        return sortDirection.isAscending();\n    }\n}','{Domain}QueryContext',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"of\", \"defaultOf\", \"firstPage\", \"nextPage\", \"previousPage\", \"offset\", \"size\", \"page\", \"isFirstPage\", \"isAscending\"]',NULL,'2026-01-20 07:10:54.000000','2026-01-20 07:10:54.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (19,5,'CURSOR_QUERY_CONTEXT_RECORD','/**\n * CursorQueryContext - 커서 기반 조회 컨텍스트 VO\n *\n * <p>정렬 + 커서 페이지네이션 정보를 결합한 조회 컨텍스트를 나타내는 불변 Value Object입니다.\n * SortKey 타입과 Cursor 타입을 제네릭으로 지정하여 도메인별 정렬 키와 커서를 지원합니다.\n *\n * <p>사용 예시:\n * <pre>{@code\n * CursorQueryContext<OrderSortKey, Long> context = CursorQueryContext.of(\n *     OrderSortKey.CREATED_AT,\n *     SortDirection.DESC,\n *     CursorPageRequest.afterId(100L)\n * );\n * boolean isFirst = context.isFirstPage();\n * }</pre>\n *\n * <p>VO-001: Value Object는 불변이어야 합니다.\n *\n * <p>VO-002: Lombok 사용이 금지됩니다.\n *\n * @param <K> SortKey를 구현하는 정렬 키 타입\n * @param <C> 커서 타입\n * @param sortKey 정렬 키\n * @param sortDirection 정렬 방향\n * @param cursorPageRequest 커서 페이지 요청\n * @param includeDeleted 삭제된 항목 포함 여부\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic record CursorQueryContext<K extends SortKey, C>(\n        K sortKey,\n        SortDirection sortDirection,\n        CursorPageRequest<C> cursorPageRequest,\n        boolean includeDeleted) {\n\n    public CursorQueryContext {\n        if (sortKey == null) {\n            throw new IllegalArgumentException(\"SortKey must not be null\");\n        }\n        if (sortDirection == null) {\n            sortDirection = SortDirection.defaultDirection();\n        }\n        if (cursorPageRequest == null) {\n            cursorPageRequest = CursorPageRequest.defaultPage();\n        }\n    }\n\n    public static <K extends SortKey, C> CursorQueryContext<K, C> of(\n            K sortKey, SortDirection sortDirection, CursorPageRequest<C> cursorPageRequest, boolean includeDeleted) {\n        return new CursorQueryContext<>(sortKey, sortDirection, cursorPageRequest, includeDeleted);\n    }\n\n    public static <K extends SortKey, C> CursorQueryContext<K, C> of(\n            K sortKey, SortDirection sortDirection, CursorPageRequest<C> cursorPageRequest) {\n        return new CursorQueryContext<>(sortKey, sortDirection, cursorPageRequest, false);\n    }\n\n    public static <K extends SortKey, C> CursorQueryContext<K, C> defaultOf(K sortKey) {\n        return new CursorQueryContext<>(sortKey, SortDirection.defaultDirection(), CursorPageRequest.defaultPage(), false);\n    }\n\n    public CursorQueryContext<K, C> nextPage(C nextCursor) {\n        return new CursorQueryContext<>(sortKey, sortDirection, cursorPageRequest.next(nextCursor), includeDeleted);\n    }\n\n    public boolean isFirstPage() { return cursorPageRequest.isFirstPage(); }\n    public boolean hasCursor() { return cursorPageRequest.hasCursor(); }\n    public C cursor() { return cursorPageRequest.cursor(); }\n    public int size() { return cursorPageRequest.size(); }\n    public int fetchSize() { return cursorPageRequest.fetchSize(); }\n    public boolean isAscending() { return sortDirection.isAscending(); }\n}','CursorQueryContext',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"sortKey\", \"sortDirection\", \"cursorPageRequest\", \"isFirstPage\", \"hasCursor\", \"cursor\", \"size\"]','CursorQueryContext - 커서 기반 조회 컨텍스트. CursorPageRequest를 포함합니다.','2026-01-20 07:57:44.000000','2026-01-20 07:57:44.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (20,8,'PAGE_CRITERIA_RECORD','/**\n * {Domain}PageCriteria - 페이지 기반 조회 조건 VO\n *\n * <p>페이지 기반 조회를 위한 조건을 담는 불변 Value Object입니다.\n * QueryContext를 필수로 포함하며, 도메인별 필터 조건을 추가합니다.\n *\n * <p>사용 예시:\n * <pre>{@code\n * OrderPageCriteria criteria = OrderPageCriteria.of(\n *     queryContext,\n *     OrderStatus.COMPLETED,\n *     DateRange.lastDays(30)\n * );\n * }</pre>\n *\n * <p>QRY-001: Criteria는 반드시 QueryContext 또는 CursorQueryContext를 포함해야 합니다.\n *\n * <p>QRY-002: 날짜 범위 필터는 반드시 DateRange VO를 사용해야 합니다.\n *\n * <p>VO-001: Value Object는 불변이어야 합니다.\n *\n * <p>VO-002: Lombok 사용이 금지됩니다.\n *\n * @param queryContext 조회 컨텍스트 (정렬 + 페이지네이션)\n * @param status 상태 필터 (선택)\n * @param dateRange 날짜 범위 필터 (선택)\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic record {Domain}PageCriteria<K extends SortKey>(\n        QueryContext<K> queryContext,\n        {Domain}Status status,\n        DateRange dateRange) {\n\n    public {Domain}PageCriteria {\n        if (queryContext == null) {\n            throw new IllegalArgumentException(\"QueryContext must not be null\");\n        }\n    }\n\n    public static <K extends SortKey> {Domain}PageCriteria<K> of(QueryContext<K> queryContext) {\n        return new {Domain}PageCriteria<>(queryContext, null, null);\n    }\n\n    public static <K extends SortKey> {Domain}PageCriteria<K> of(\n            QueryContext<K> queryContext, {Domain}Status status, DateRange dateRange) {\n        return new {Domain}PageCriteria<>(queryContext, status, dateRange);\n    }\n\n    public boolean hasStatusFilter() { return status != null; }\n    public boolean hasDateRangeFilter() { return dateRange != null; }\n\n    public long offset() { return queryContext.offset(); }\n    public int size() { return queryContext.size(); }\n    public int page() { return queryContext.page(); }\n    public boolean isFirstPage() { return queryContext.isFirstPage(); }\n    public boolean isAscending() { return queryContext.isAscending(); }\n}','{Domain}PageCriteria',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"queryContext\"]','PageCriteria 템플릿 - 페이지 기반 조회 조건. QueryContext를 필수로 포함합니다.','2026-01-20 07:57:58.000000','2026-01-20 07:57:58.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (21,8,'CURSOR_CRITERIA_RECORD','/**\n * {Domain}CursorCriteria - 커서 기반 조회 조건 VO\n *\n * <p>커서 기반 조회를 위한 조건을 담는 불변 Value Object입니다.\n * CursorQueryContext를 필수로 포함하며, 도메인별 필터 조건을 추가합니다.\n *\n * <p>사용 예시:\n * <pre>{@code\n * OrderCursorCriteria criteria = OrderCursorCriteria.of(\n *     cursorQueryContext,\n *     OrderStatus.PENDING,\n *     DateRange.lastWeek()\n * );\n * }</pre>\n *\n * <p>QRY-001: Criteria는 반드시 QueryContext 또는 CursorQueryContext를 포함해야 합니다.\n *\n * <p>QRY-002: 날짜 범위 필터는 반드시 DateRange VO를 사용해야 합니다.\n *\n * <p>VO-001: Value Object는 불변이어야 합니다.\n *\n * <p>VO-002: Lombok 사용이 금지됩니다.\n *\n * @param cursorQueryContext 커서 조회 컨텍스트 (정렬 + 커서 페이지네이션)\n * @param status 상태 필터 (선택)\n * @param dateRange 날짜 범위 필터 (선택)\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic record {Domain}CursorCriteria<K extends SortKey, C>(\n        CursorQueryContext<K, C> cursorQueryContext,\n        {Domain}Status status,\n        DateRange dateRange) {\n\n    public {Domain}CursorCriteria {\n        if (cursorQueryContext == null) {\n            throw new IllegalArgumentException(\"CursorQueryContext must not be null\");\n        }\n    }\n\n    public static <K extends SortKey, C> {Domain}CursorCriteria<K, C> of(\n            CursorQueryContext<K, C> cursorQueryContext) {\n        return new {Domain}CursorCriteria<>(cursorQueryContext, null, null);\n    }\n\n    public static <K extends SortKey, C> {Domain}CursorCriteria<K, C> of(\n            CursorQueryContext<K, C> cursorQueryContext, {Domain}Status status, DateRange dateRange) {\n        return new {Domain}CursorCriteria<>(cursorQueryContext, status, dateRange);\n    }\n\n    public boolean hasStatusFilter() { return status != null; }\n    public boolean hasDateRangeFilter() { return dateRange != null; }\n\n    public boolean isFirstPage() { return cursorQueryContext.isFirstPage(); }\n    public boolean hasCursor() { return cursorQueryContext.hasCursor(); }\n    public C cursor() { return cursorQueryContext.cursor(); }\n    public int size() { return cursorQueryContext.size(); }\n    public int fetchSize() { return cursorQueryContext.fetchSize(); }\n    public boolean isAscending() { return cursorQueryContext.isAscending(); }\n}','{Domain}CursorCriteria',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"cursorQueryContext\"]','CursorCriteria 템플릿 - 커서 기반 조회 조건. CursorQueryContext를 필수로 포함합니다.','2026-01-20 07:58:09.000000','2026-01-20 07:58:09.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (22,1,'AGGREGATE_ROOT','/**\n * {Domain} - {Domain} Aggregate Root\n *\n * <p>도메인의 핵심 비즈니스 로직을 캡슐화하는 Aggregate Root입니다.\n *\n * <p><strong>설계 원칙:</strong>\n * <ul>\n *   <li>AGG-001: Lombok 사용 금지 - 모든 필드와 메서드를 명시적으로 작성\n *   <li>AGG-002: 불변성 우선 - 필드는 final, 상태 변경은 새 인스턴스 반환 또는 명시적 메서드\n *   <li>AGG-014: Law of Demeter - 체이닝 금지, convenience 메서드 제공\n *   <li>DOM-AGG-015: Tell, Don\'t Ask - 상태 조회 후 외부 결정 금지, 객체가 스스로 판단\n *   <li>DOM-AGG-016: 팩토리 메서드 필수 - forNew(), of(), reconstitute()\n *   <li>DOM-AGG-017: 생성자 접근 제한 - private/protected, new 직접 호출 금지\n *   <li>DOM-AGG-018: 시간 필드 규칙 - Instant 타입, At 접미사 (createdAt, updatedAt)\n *   <li>DOM-AGG-019: DeletionStatus 필수 - 소프트 삭제 상태 관리\n *   <li>DOM-AGG-020: Aggregate 참조 규칙 - 다른 Aggregate는 ID로만 참조\n *   <li>DOM-AGG-021: 컬렉션 불변 반환 - List.copyOf() 또는 Collections.unmodifiableList()\n *   <li>DOM-AGG-022: 시간 외부 주입 - Instant.now() 금지, 파라미터로 주입\n *   <li>DOM-AGG-023: 이벤트 내부 발행 - 비즈니스 메서드 내에서 이벤트 생성 및 저장\n * </ul>\n *\n * <p><strong>팩토리 메서드:</strong>\n * <ul>\n *   <li>{@link #forNew} - 새 엔티티 생성 (ID 없음, Auto-increment용)\n *   <li>{@link #of} - 기존 엔티티 (ID 있음)\n *   <li>{@link #reconstitute} - 영속성 레이어에서 복원\n * </ul>\n *\n * <p><strong>이벤트 발행:</strong>\n * <ul>\n *   <li>비즈니스 메서드 내에서 이벤트 생성 후 events 컬렉션에 저장\n *   <li>Application 레이어에서 pollEvents()로 이벤트 수집 후 발행\n *   <li>이벤트 생성 시 occurredAt은 비즈니스 메서드 파라미터로 주입받음\n * </ul>\n *\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic class {Domain} {\n\n    private final {Domain}Id id;\n    // 다른 Aggregate 참조 시 ID만 보유 (DOM-AGG-020)\n    // 예: private final OtherAggregateId otherAggregateId;\n    \n    // Value Object 필드들\n    private DeletionStatus deletionStatus;\n    private final Instant createdAt;\n    private Instant updatedAt;\n    \n    // 도메인 이벤트 컬렉션 (DOM-AGG-023)\n    private final List<DomainEvent> events = new ArrayList<>();\n\n    /**\n     * Framework 전용 기본 생성자\n     *\n     * <p>JPA/Hibernate 프록시 생성용으로만 사용됩니다.\n     * 직접 호출하지 마세요.\n     */\n    protected {Domain}() {\n        this.id = null;\n        this.deletionStatus = DeletionStatus.active();\n        this.createdAt = null;\n        this.updatedAt = null;\n    }\n\n    /**\n     * 전체 필드 초기화 생성자 (private)\n     *\n     * <p>팩토리 메서드를 통해서만 인스턴스를 생성합니다.\n     * 외부에서 new 키워드로 직접 호출 불가 (DOM-AGG-017)\n     */\n    private {Domain}(\n            {Domain}Id id,\n            // 다른 필드들...\n            DeletionStatus deletionStatus,\n            Instant createdAt,\n            Instant updatedAt) {\n        this.id = id;\n        this.deletionStatus = deletionStatus;\n        this.createdAt = createdAt;\n        this.updatedAt = updatedAt;\n    }\n\n    /**\n     * 새 {Domain} 생성 (Auto-increment ID용)\n     *\n     * <p>아직 영속화되지 않은 새 엔티티를 생성합니다.\n     * ID는 영속화 시점에 DB에서 할당됩니다.\n     *\n     * <p>시간은 외부에서 주입받습니다 (DOM-AGG-022).\n     * Instant.now() 직접 호출 금지.\n     *\n     * @param occurredAt 생성 시각 (외부 주입)\n     * @param ... 생성에 필요한 파라미터들\n     * @return 새 {Domain} 인스턴스\n     */\n    public static {Domain} forNew(\n            /* 필요한 파라미터들, */\n            Instant occurredAt) {\n        return new {Domain}(\n                {Domain}Id.forNew(),\n                // 다른 필드들...\n                DeletionStatus.active(),\n                occurredAt,\n                occurredAt);\n    }\n\n    /**\n     * 기존 {Domain} 조회/복원\n     *\n     * <p>이미 영속화된 엔티티를 ID로 참조할 때 사용합니다.\n     *\n     * @param id 기존 엔티티 ID\n     * @param occurredAt 생성/수정 시각 (외부 주입)\n     * @param ... 다른 필드들\n     * @return {Domain} 인스턴스\n     */\n    public static {Domain} of(\n            {Domain}Id id,\n            /* 다른 필드들, */\n            Instant occurredAt) {\n        return new {Domain}(\n                id,\n                // 다른 필드들...\n                DeletionStatus.active(),\n                occurredAt,\n                occurredAt);\n    }\n\n    /**\n     * 영속성 레이어에서 {Domain} 복원\n     *\n     * <p>JPA Entity → Domain Aggregate 변환 시 사용합니다.\n     * 모든 필드를 그대로 복원합니다.\n     *\n     * @param ... 모든 필드\n     * @return 복원된 {Domain} 인스턴스\n     */\n    public static {Domain} reconstitute(\n            {Domain}Id id,\n            // 모든 필드들...\n            DeletionStatus deletionStatus,\n            Instant createdAt,\n            Instant updatedAt) {\n        return new {Domain}(\n                id,\n                // 모든 필드들...\n                deletionStatus,\n                createdAt,\n                updatedAt);\n    }\n\n    // ==========================================\n    // Convenience 메서드 (Law of Demeter 준수)\n    // ==========================================\n\n    /**\n     * ID 값 반환 (Law of Demeter 준수)\n     *\n     * @return ID의 Long 값\n     */\n    public Long idValue() {\n        return id != null ? id.value() : null;\n    }\n\n    /**\n     * 새 엔티티인지 확인\n     *\n     * @return ID가 없으면 true\n     */\n    public boolean isNew() {\n        return id == null || id.isNew();\n    }\n\n    /**\n     * 삭제되었는지 확인 (Tell, Don\'t Ask - DOM-AGG-015)\n     *\n     * <p>외부에서 deletionStatus().isDeleted() 체이닝 금지.\n     * Aggregate가 직접 판단하여 결과 반환.\n     *\n     * @return 삭제 상태이면 true\n     */\n    public boolean isDeleted() {\n        return deletionStatus.isDeleted();\n    }\n\n    // ==========================================\n    // 비즈니스 메서드 (Tell, Don\'t Ask + 이벤트 발행)\n    // ==========================================\n\n    /**\n     * 엔티티 업데이트\n     *\n     * <p>비즈니스 규칙을 검증하고 상태를 변경합니다.\n     * 시간은 외부에서 주입받습니다 (DOM-AGG-022).\n     *\n     * @param updateData 업데이트 데이터\n     * @param occurredAt 업데이트 시각 (외부 주입)\n     */\n    public void update({Domain}UpdateData updateData, Instant occurredAt) {\n        // 비즈니스 규칙 검증\n        // 필드 업데이트\n        this.updatedAt = occurredAt;\n        \n        // 이벤트 발행이 필요한 경우 (DOM-AGG-023)\n        // events.add(new {Domain}UpdatedEvent(this.id, ..., occurredAt));\n    }\n\n    /**\n     * 소프트 삭제\n     *\n     * <p>물리적 삭제 대신 삭제 상태로 표시합니다.\n     * DeletionStatus의 팩토리 메서드를 사용합니다.\n     *\n     * @param occurredAt 삭제 시각 (외부 주입)\n     */\n    public void delete(Instant occurredAt) {\n        this.deletionStatus = DeletionStatus.deletedAt(occurredAt);\n        this.updatedAt = occurredAt;\n        \n        // 이벤트 발행이 필요한 경우 (DOM-AGG-023)\n        // events.add(new {Domain}DeletedEvent(this.id, occurredAt));\n    }\n\n    /**\n     * 비즈니스 액션 예시 (이벤트 발행 포함)\n     *\n     * <p>비즈니스 로직 수행 후 도메인 이벤트를 생성하여 저장합니다.\n     * Application 레이어에서 pollEvents()로 수집 후 발행합니다.\n     *\n     * @param ... 비즈니스 로직에 필요한 파라미터\n     * @param occurredAt 이벤트 발생 시각 (외부 주입)\n     */\n    public void complete(/* 필요한 파라미터, */ Instant occurredAt) {\n        // 비즈니스 규칙 검증\n        // if (!canComplete()) {\n        //     throw new DomainException({Domain}ErrorCode.CANNOT_COMPLETE, ...);\n        // }\n        \n        // 상태 변경\n        // this.status = {Domain}Status.COMPLETED;\n        this.updatedAt = occurredAt;\n        \n        // 도메인 이벤트 생성 및 저장 (DOM-AGG-023)\n        // 이벤트는 비즈니스 메서드 내부에서 생성\n        events.add(new {Domain}CompletedEvent(\n                this.id,\n                // 이벤트에 필요한 데이터...\n                occurredAt));\n    }\n\n    // ==========================================\n    // 도메인 이벤트 관리 (DOM-AGG-023)\n    // ==========================================\n\n    /**\n     * 발행 대기 중인 도메인 이벤트 수집 및 초기화\n     *\n     * <p>Application 레이어에서 호출하여 이벤트를 수집합니다.\n     * 호출 후 내부 이벤트 목록은 초기화됩니다.\n     *\n     * @return 발행 대기 중인 이벤트 목록 (불변)\n     */\n    public List<DomainEvent> pollEvents() {\n        List<DomainEvent> polledEvents = List.copyOf(events);\n        events.clear();\n        return polledEvents;\n    }\n\n    /**\n     * 발행 대기 중인 이벤트가 있는지 확인\n     *\n     * @return 이벤트가 있으면 true\n     */\n    public boolean hasEvents() {\n        return !events.isEmpty();\n    }\n\n    // ==========================================\n    // Getter (필요한 경우에만)\n    // ==========================================\n\n    public {Domain}Id id() {\n        return id;\n    }\n\n    public DeletionStatus deletionStatus() {\n        return deletionStatus;\n    }\n\n    public Instant createdAt() {\n        return createdAt;\n    }\n\n    public Instant updatedAt() {\n        return updatedAt;\n    }\n}','{Domain}',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"idValue\", \"isNew\", \"isDeleted\", \"update\", \"delete\"]','Aggregate Root 클래스 - 도메인의 핵심 비즈니스 로직을 캡슐화하는 루트 엔티티. forNew/of/reconstitute 팩토리 메서드 필수.','2026-01-20 08:29:58.000000','2026-01-20 08:57:57.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (23,1,'UPDATE_DATA','/**\n * {Domain}UpdateData - {Domain} 업데이트 데이터\n *\n * <p>Aggregate Root의 update() 메서드에 전달되는 불변 데이터 객체입니다.\n *\n * <p><strong>설계 원칙:</strong>\n * <ul>\n *   <li>Record로 정의하여 불변성 보장\n *   <li>Compact Constructor에서 필수 필드 검증\n *   <li>null 허용 필드는 Optional 대신 nullable로 표현\n * </ul>\n *\n * <p><strong>사용 예시:</strong>\n * <pre>{@code\n * {Domain}UpdateData updateData = new {Domain}UpdateData(\n *     newName,\n *     newDescription\n * );\n * aggregate.update(updateData);\n * }</pre>\n *\n * @param ... 업데이트할 필드들\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic record {Domain}UpdateData(\n        // 업데이트 가능한 필드들 (Value Object 타입 사용)\n        // 예: {Domain}Name name,\n        // 예: {Domain}Description description\n) {\n\n    /**\n     * Compact Constructor - 필수 필드 검증\n     */\n    public {Domain}UpdateData {\n        // 필수 필드 검증\n        // if (name == null) {\n        //     throw new IllegalArgumentException(\"name must not be null\");\n        // }\n    }\n}','{Domain}UpdateData',NULL,'[\"lombok.*\"]',NULL,NULL,NULL,'UpdateData Record - Aggregate Root update() 메서드에 전달되는 불변 데이터 객체. Compact Constructor에서 검증 수행.','2026-01-20 08:29:59.000000','2026-01-20 08:29:59.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (24,2,'VALUE_OBJECT','/**\n * {ValueObject} - {Description} Value Object\n *\n * <p>불변 값 객체로, 동등성은 값으로 판단합니다.\n *\n * <p><strong>설계 원칙:</strong>\n * <ul>\n *   <li>Record로 정의하여 불변성과 equals/hashCode 자동 생성\n *   <li>Compact Constructor에서 유효성 검증 수행\n *   <li>정적 팩토리 메서드 of() 제공\n *   <li>Lombok 사용 금지\n * </ul>\n *\n * <p><strong>사용 예시:</strong>\n * <pre>{@code\n * {ValueObject} vo = {ValueObject}.of(\"value\");\n * String value = vo.value();\n * }</pre>\n *\n * @param value 값\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic record {ValueObject}(String value) {\n\n    /**\n     * 최대 길이 상수 (필요한 경우)\n     */\n    private static final int MAX_LENGTH = 100;\n\n    /**\n     * Compact Constructor - 유효성 검증\n     *\n     * <p>null, 빈 값, 최대 길이 등을 검증합니다.\n     */\n    public {ValueObject} {\n        if (value == null || value.isBlank()) {\n            throw new IllegalArgumentException(\"{ValueObject} must not be blank\");\n        }\n        if (value.length() > MAX_LENGTH) {\n            throw new IllegalArgumentException(\n                    String.format(\"{ValueObject} must not exceed %d characters, but was %d\",\n                            MAX_LENGTH, value.length()));\n        }\n    }\n\n    /**\n     * 정적 팩토리 메서드\n     *\n     * @param value 값\n     * @return {ValueObject} 인스턴스\n     * @throws IllegalArgumentException 유효성 검증 실패 시\n     */\n    public static {ValueObject} of(String value) {\n        return new {ValueObject}(value);\n    }\n}','{Domain}{Name}',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"of\"]','Value Object Record - 불변 값 객체. Compact Constructor에서 검증, of() 정적 팩토리 메서드 필수.','2026-01-20 08:29:59.000000','2026-01-20 08:29:59.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (25,3,'AUTO_INCREMENT_ID','/**\n * {Domain}Id - {Domain} 식별자 Value Object (Auto-increment)\n *\n * <p>DB Auto-increment로 생성되는 ID를 타입 안전하게 표현합니다.\n *\n * <p><strong>설계 원칙:</strong>\n * <ul>\n *   <li>Record로 정의하여 불변성 보장\n *   <li>forNew() - 새 엔티티용 (null 값, DB에서 생성)\n *   <li>of(Long) - 기존 엔티티용 (non-null 필수)\n *   <li>isNew() - 새 엔티티 여부 확인\n * </ul>\n *\n * <p><strong>사용 시점:</strong>\n * <ul>\n *   <li>RDS Auto-increment PK 사용 시\n *   <li>ID 생성을 DB에 위임하는 경우\n * </ul>\n *\n * @param value ID 값 (새 엔티티는 null, 영속화 후 DB에서 할당)\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic record {Domain}Id(Long value) {\n\n    /**\n     * 새 엔티티용 ID 생성\n     *\n     * <p>아직 영속화되지 않은 새 엔티티에 사용됩니다.\n     * 실제 ID는 DB 영속화 시점에 Auto-increment로 할당됩니다.\n     *\n     * @return null 값을 가진 {Domain}Id\n     */\n    public static {Domain}Id forNew() {\n        return new {Domain}Id(null);\n    }\n\n    /**\n     * 기존 엔티티용 ID 생성\n     *\n     * @param value ID 값 (non-null)\n     * @return {Domain}Id 인스턴스\n     * @throws IllegalArgumentException value가 null인 경우\n     */\n    public static {Domain}Id of(Long value) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"{Domain}Id value must not be null for existing entity\");\n        }\n        return new {Domain}Id(value);\n    }\n\n    /**\n     * 새 엔티티인지 확인\n     *\n     * @return value가 null이면 true\n     */\n    public boolean isNew() {\n        return value == null;\n    }\n}','{Domain}Id',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"forNew\", \"of\", \"isNew\"]','Auto-increment Long ID - DB에서 ID 생성 (forNew() 시 null 반환)','2026-01-20 08:29:59.000000','2026-01-20 08:41:05.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (26,4,'ERROR_CODE','/**\n * {Domain}ErrorCode - {Domain} 도메인 에러 코드\n *\n * <p>해당 도메인에서 발생하는 모든 예외의 에러 코드를 정의합니다.\n *\n * <p><strong>코드 형식:</strong> {DOMAIN_PREFIX}-{NUMBER}\n * <ul>\n *   <li>예: ORD-001, PAY-002, USR-003\n * </ul>\n *\n * <p><strong>HTTP 상태 코드 가이드:</strong>\n * <ul>\n *   <li>400 - 잘못된 요청 (유효성 검증 실패)\n *   <li>404 - 리소스 없음\n *   <li>409 - 충돌 (중복, 상태 불일치)\n *   <li>422 - 처리 불가 (비즈니스 규칙 위반)\n *   <li>500 - 서버 오류\n * </ul>\n *\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic enum {Domain}ErrorCode implements ErrorCode {\n\n    /**\n     * {Domain}을(를) 찾을 수 없음\n     */\n    {DOMAIN}_NOT_FOUND(\"{PREFIX}-001\", 404, \"{Domain}을(를) 찾을 수 없습니다\"),\n\n    /**\n     * {Domain} 중복\n     */\n    {DOMAIN}_DUPLICATE(\"{PREFIX}-002\", 409, \"이미 존재하는 {Domain}입니다\"),\n\n    /**\n     * 유효하지 않은 {Domain} 상태\n     */\n    INVALID_{DOMAIN}_STATUS(\"{PREFIX}-003\", 422, \"유효하지 않은 {Domain} 상태입니다\");\n\n    private final String code;\n    private final int httpStatus;\n    private final String message;\n\n    {Domain}ErrorCode(String code, int httpStatus, String message) {\n        this.code = code;\n        this.httpStatus = httpStatus;\n        this.message = message;\n    }\n\n    @Override\n    public String getCode() {\n        return code;\n    }\n\n    @Override\n    public int getHttpStatus() {\n        return httpStatus;\n    }\n\n    @Override\n    public String getMessage() {\n        return message;\n    }\n}','{Domain}ErrorCode',NULL,'[\"lombok.*\"]','[\"ErrorCode\"]',NULL,'[\"getCode\", \"getHttpStatus\", \"getMessage\"]','ErrorCode Enum - 도메인별 에러 코드. ErrorCode 인터페이스 구현 필수.','2026-01-20 08:29:59.000000','2026-01-20 08:29:59.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (27,4,'DOMAIN_EXCEPTION','/**\n * {Domain}NotFoundException - {Domain} 조회 실패 예외\n *\n * <p>요청한 {Domain}을(를) 찾을 수 없을 때 발생합니다.\n *\n * <p><strong>사용 예시:</strong>\n * <pre>{@code\n * {Domain} domain = repository.findById(id)\n *     .orElseThrow(() -> new {Domain}NotFoundException(id));\n * }</pre>\n *\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic class {Domain}NotFoundException extends DomainException {\n\n    /**\n     * ID로 조회 실패 시 생성\n     *\n     * @param {domain}Id 조회 실패한 {Domain} ID\n     */\n    public {Domain}NotFoundException(Long {domain}Id) {\n        super(\n                {Domain}ErrorCode.{DOMAIN}_NOT_FOUND,\n                String.format(\"{Domain} not found: %d\", {domain}Id),\n                Map.of(\"{domain}Id\", {domain}Id));\n    }\n\n    /**\n     * 다른 식별자로 조회 실패 시 생성\n     *\n     * @param identifier 조회에 사용된 식별자\n     * @param identifierName 식별자 이름 (예: \"code\", \"name\")\n     */\n    public {Domain}NotFoundException(String identifier, String identifierName) {\n        super(\n                {Domain}ErrorCode.{DOMAIN}_NOT_FOUND,\n                String.format(\"{Domain} not found by %s: %s\", identifierName, identifier),\n                Map.of(identifierName, identifier));\n    }\n}','{Domain}*Exception',NULL,'[\"lombok.*\"]',NULL,'[\"DomainException\"]',NULL,'Domain Exception 클래스 - DomainException 상속 필수. ErrorCode와 args Map 전달.','2026-01-20 08:29:59.000000','2026-01-20 08:29:59.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (28,3,'GENERATED_LONG_ID','/**\n * {Domain}Id - {Domain} 식별자 Value Object (외부 생성 Long)\n *\n * <p>Snowflake, TSID 등 외부에서 생성된 Long ID를 타입 안전하게 표현합니다.\n *\n * <p><strong>설계 원칙:</strong>\n * <ul>\n *   <li>Record로 정의하여 불변성 보장\n *   <li>forNew() 없음 - 도메인에서 ID 생성 금지\n *   <li>of(Long) - Factory에서 IdGenerator 통해 생성된 값을 받음\n *   <li>ID는 항상 non-null (생성 시점에 이미 결정됨)\n * </ul>\n *\n * <p><strong>사용 시점:</strong>\n * <ul>\n *   <li>Snowflake, TSID 등 분산 ID 생성기 사용 시\n *   <li>시간 기반 정렬이 필요한 Long ID\n *   <li>Application Factory에서 IdGenerator로 생성 후 주입\n * </ul>\n *\n * <p><strong>Factory 사용 예시:</strong>\n * <pre>{@code\n * // Application Factory\n * public class {Domain}Factory {\n *     private final IdGenerator idGenerator;\n *\n *     public {Domain} create(Create{Domain}Command cmd) {\n *         {Domain}Id id = {Domain}Id.of(idGenerator.nextId());\n *         return {Domain}.forNew(id, ...);\n *     }\n * }\n * }</pre>\n *\n * @param value ID 값 (non-null, 외부에서 생성됨)\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic record {Domain}Id(Long value) {\n\n    /** Compact Constructor - null 검증 */\n    public {Domain}Id {\n        if (value == null) {\n            throw new IllegalArgumentException(\"{Domain}Id value must not be null\");\n        }\n    }\n\n    /**\n     * ID 생성\n     *\n     * <p>IdGenerator에서 생성된 값을 받아 ID를 생성합니다.\n     *\n     * @param value IdGenerator에서 생성된 ID 값\n     * @return {Domain}Id 인스턴스\n     * @throws IllegalArgumentException value가 null인 경우\n     */\n    public static {Domain}Id of(Long value) {\n        return new {Domain}Id(value);\n    }\n}','{Domain}Id',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"of\"]','Generated Long ID - Snowflake/TSID 등 외부 생성 Long ID (forNew 없음, Factory에서 IdGenerator 통해 주입)','2026-01-20 08:41:21.000000','2026-01-20 08:41:21.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (29,3,'GENERATED_STRING_ID','/**\n * {Domain}Id - {Domain} 식별자 Value Object (외부 생성 String)\n *\n * <p>UUIDv7, ULID 등 외부에서 생성된 String ID를 타입 안전하게 표현합니다.\n *\n * <p><strong>설계 원칙:</strong>\n * <ul>\n *   <li>Record로 정의하여 불변성 보장\n *   <li>forNew() 없음 - 도메인에서 ID 생성 금지 (UUID.randomUUID() 호출 금지)\n *   <li>of(String) - Factory에서 IdGenerator 통해 생성된 값을 받음\n *   <li>ID는 항상 non-null, non-blank (생성 시점에 이미 결정됨)\n * </ul>\n *\n * <p><strong>사용 시점:</strong>\n * <ul>\n *   <li>UUIDv7, ULID 등 시간 기반 정렬 가능한 String ID\n *   <li>외부 노출용으로 추측 불가능한 ID가 필요한 경우\n *   <li>Application Factory에서 IdGenerator로 생성 후 주입\n * </ul>\n *\n * <p><strong>Factory 사용 예시:</strong>\n * <pre>{@code\n * // Application Factory\n * public class {Domain}Factory {\n *     private final IdGenerator idGenerator;\n *\n *     public {Domain} create(Create{Domain}Command cmd) {\n *         {Domain}Id id = {Domain}Id.of(idGenerator.nextStringId());\n *         return {Domain}.forNew(id, ...);\n *     }\n * }\n * }</pre>\n *\n * @param value ID 값 (non-null, non-blank, 외부에서 생성됨)\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic record {Domain}Id(String value) {\n\n    /** Compact Constructor - null/blank 검증 */\n    public {Domain}Id {\n        if (value == null || value.isBlank()) {\n            throw new IllegalArgumentException(\"{Domain}Id value must not be null or blank\");\n        }\n    }\n\n    /**\n     * ID 생성\n     *\n     * <p>IdGenerator에서 생성된 값을 받아 ID를 생성합니다.\n     *\n     * @param value IdGenerator에서 생성된 ID 값 (UUIDv7, ULID 등)\n     * @return {Domain}Id 인스턴스\n     * @throws IllegalArgumentException value가 null이거나 blank인 경우\n     */\n    public static {Domain}Id of(String value) {\n        return new {Domain}Id(value);\n    }\n}','{Domain}Id',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"of\"]','Generated String ID - UUIDv7/ULID 등 외부 생성 String ID (forNew 없음, Factory에서 IdGenerator 통해 주입)','2026-01-20 08:41:33.000000','2026-01-20 08:41:33.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (30,9,'COMMAND_USECASE','/**\n * {UseCase} - {Description}\n *\n * <p>단일 책임: {Responsibility}\n *\n * @author ryu-qqq\n */\npublic interface {UseCase} {\n\n    /**\n     * UseCase 실행\n     *\n     * @param command {Command} 커맨드\n     * @return 생성된 ID (생성의 경우) 또는 void\n     */\n    Long execute({Command} command);\n}',NULL,NULL,NULL,NULL,NULL,NULL,NULL,'2026-01-21 05:27:30.000000','2026-01-21 05:27:30.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (31,10,'QUERY_USECASE','/**\n * {UseCase} - {Description}\n *\n * <p>단일 책임: {Responsibility}\n *\n * @author ryu-qqq\n */\npublic interface {UseCase} {\n\n    /**\n     * UseCase 실행\n     *\n     * @param query {Query} 쿼리\n     * @return {Result} 조회 결과\n     */\n    {Result} execute({Query} query);\n}',NULL,NULL,NULL,NULL,NULL,NULL,NULL,'2026-01-21 05:27:30.000000','2026-01-21 05:27:30.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (32,11,'COMMAND_PORT','/**\n * {Domain}CommandPort - {Domain} 명령 Port\n *\n * <p>영속성 계층으로의 {Domain} CUD 아웃바운드 포트입니다.\n *\n * <p>CPRT-002: CommandPort는 persist(Domain) 메서드만 제공합니다.\n *\n * @author ryu-qqq\n */\npublic interface {Domain}CommandPort {\n\n    /**\n     * {Domain} 영속화 (생성/수정/삭제)\n     *\n     * @param {domain} 영속화할 {Domain}\n     * @return 영속화된 {Domain} ID\n     */\n    Long persist({Domain} {domain});\n}',NULL,NULL,NULL,NULL,NULL,NULL,NULL,'2026-01-21 05:27:30.000000','2026-01-21 05:27:30.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (33,12,'QUERY_PORT','/**\n * {Domain}QueryPort - {Domain} 조회 Port\n *\n * <p>영속성 계층으로의 {Domain} 조회 아웃바운드 포트입니다.\n *\n * <p>QPRT-002: 표준 메서드를 제공합니다.\n *\n * <p>QPRT-003: Unique 필드 조회 메서드를 추가 제공합니다.\n *\n * <p>QPRT-004: 원시타입 대신 VO를 파라미터로 사용합니다.\n *\n * @author ryu-qqq\n */\npublic interface {Domain}QueryPort {\n\n    /**\n     * ID로 {Domain} 조회\n     *\n     * @param id {Domain} ID (VO)\n     * @return {Domain} (Optional)\n     */\n    Optional<{Domain}> findById({Domain}Id id);\n\n    /**\n     * ID로 존재 여부 확인\n     *\n     * @param id {Domain} ID (VO)\n     * @return 존재 여부\n     */\n    boolean existsById({Domain}Id id);\n\n    /**\n     * 커서 기반 슬라이스 조건으로 {Domain} 목록 조회\n     *\n     * @param criteria 슬라이스 조건 (커서 기반)\n     * @return {Domain} 목록\n     */\n    List<{Domain}> findBySliceCriteria({Domain}SliceCriteria criteria);\n}',NULL,NULL,NULL,NULL,NULL,NULL,NULL,'2026-01-21 05:27:30.000000','2026-01-21 05:27:30.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (34,13,'CLIENT_PORT','/**\n * {Client}ClientPort - {Client} 외부 연동 Port\n *\n * <p>외부 시스템({Client})과의 연동을 위한 아웃바운드 포트입니다.\n *\n * @author ryu-qqq\n */\npublic interface {Client}ClientPort {\n\n    /**\n     * {Operation} 요청\n     *\n     * @param request 요청 데이터\n     * @return 응답 결과\n     */\n    {Response} {operation}({Request} request);\n}',NULL,NULL,NULL,NULL,NULL,NULL,NULL,'2026-01-21 05:27:30.000000','2026-01-21 05:27:30.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (35,14,'COMMAND_SERVICE','/**\n * {Service} - {UseCase} 구현체\n *\n * <p>{Responsibility}\n *\n * <p>SVC-001: Service에서 @Transactional 금지\n *\n * @author ryu-qqq\n */\n@Service\npublic class {Service} implements {UseCase} {\n\n    private final {Factory} {factory};\n    private final {Facade} {facade};\n\n    public {Service}({Factory} {factory}, {Facade} {facade}) {\n        this.{factory} = {factory};\n        this.{facade} = {facade};\n    }\n\n    @Override\n    public Long execute({Command} command) {\n        // 1. Factory: Command → Bundle/Context\n        {Bundle} bundle = {factory}.create(command);\n        \n        // 2. Facade/Manager: 저장\n        return {facade}.create(bundle);\n    }\n}',NULL,'[\"@Service\"]',NULL,NULL,NULL,NULL,NULL,'2026-01-21 05:27:30.000000','2026-01-21 05:27:30.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (36,15,'QUERY_SERVICE','/**\n * {Service} - {UseCase} 구현체\n *\n * <p>{Responsibility}\n *\n * @author ryu-qqq\n */\n@Service\npublic class {Service} implements {UseCase} {\n\n    private final {Factory} {factory};\n    private final {Facade} {facade};\n    private final {Assembler} {assembler};\n\n    public {Service}({Factory} {factory}, {Facade} {facade}, {Assembler} {assembler}) {\n        this.{factory} = {factory};\n        this.{facade} = {facade};\n        this.{assembler} = {assembler};\n    }\n\n    @Override\n    public {Result} execute({Query} query) {\n        // 1. Factory: Query → Criteria\n        {Criteria} criteria = {factory}.create(query);\n        \n        // 2. Facade: 조회\n        List<{Domain}> domains = {facade}.findBySliceCriteria(criteria);\n        \n        // 3. Assembler: Domain → Response\n        return {assembler}.toSliceResult(domains, criteria.sliceMeta());\n    }\n}',NULL,'[\"@Service\"]',NULL,NULL,NULL,NULL,NULL,'2026-01-21 05:27:30.000000','2026-01-21 05:27:30.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (37,16,'COMMAND_FACADE','/**\n * {Facade} - {Domain} 쓰기 Facade\n *\n * <p>Manager 2개 이상 조합 시 사용합니다.\n *\n * <p>FAC-001: CommandFacade → QueryManager 의존 금지 (CQRS)\n *\n * @author ryu-qqq\n */\n@Component\npublic class {Facade} {\n\n    private final {MainManager} {mainManager};\n    private final {SubManager} {subManager};\n\n    public {Facade}({MainManager} {mainManager}, {SubManager} {subManager}) {\n        this.{mainManager} = {mainManager};\n        this.{subManager} = {subManager};\n    }\n\n    @Transactional\n    public Long create({Bundle} bundle) {\n        Long id = {mainManager}.persist(bundle.main());\n        {Bundle} withId = bundle.withId(id);\n        {subManager}.persistAll(withId.subs());\n        return id;\n    }\n}',NULL,'[\"@Component\"]',NULL,NULL,NULL,NULL,NULL,'2026-01-21 05:27:30.000000','2026-01-21 05:27:30.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (38,17,'QUERY_FACADE','/**\n * {Facade} - {Domain} 읽기 Facade\n *\n * <p>Manager 2개 이상 조합하여 복합 조회 수행.\n *\n * @author ryu-qqq\n */\n@Component\npublic class {Facade} {\n\n    private final {MainManager} {mainManager};\n    private final {SubManager} {subManager};\n\n    public {Facade}({MainManager} {mainManager}, {SubManager} {subManager}) {\n        this.{mainManager} = {mainManager};\n        this.{subManager} = {subManager};\n    }\n\n    @Transactional(readOnly = true)\n    public List<{Domain}> findBySliceCriteria({Criteria} criteria) {\n        return {mainManager}.findBySliceCriteria(criteria);\n    }\n}',NULL,'[\"@Component\"]',NULL,NULL,NULL,NULL,NULL,'2026-01-21 05:27:30.000000','2026-01-21 05:27:30.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (39,18,'COMMAND_MANAGER','package {package};\n\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\n/**\n * {ClassName} - {도메인} 명령 매니저\n *\n * <p>단일 Aggregate의 생성/수정/삭제 트랜잭션을 관리합니다.\n *\n * @author {author}\n */\n@Service\n@Transactional\npublic class {ClassName} {\n\n    private final {AggregateRoot}CommandPort {aggregateRoot}CommandPort;\n\n    public {ClassName}({AggregateRoot}CommandPort {aggregateRoot}CommandPort) {\n        this.{aggregateRoot}CommandPort = {aggregateRoot}CommandPort;\n    }\n\n    public Long create({AggregateRoot} {aggregateRoot}) {\n        return {aggregateRoot}CommandPort.persist({aggregateRoot});\n    }\n\n    public void update({AggregateRoot} {aggregateRoot}) {\n        {aggregateRoot}CommandPort.persist({aggregateRoot});\n    }\n}','*Manager','[\"@Service\", \"@Transactional\"]','[\"@Transactional(readOnly = true)\"]',NULL,NULL,NULL,'단일 Aggregate의 생성/수정/삭제 트랜잭션을 관리하는 매니저 클래스 템플릿','2026-01-21 05:29:19.000000','2026-01-21 05:29:19.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (40,19,'QUERY_MANAGER','package {package};\n\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\nimport java.util.Optional;\n\n/**\n * {ClassName} - {도메인} 조회 매니저\n *\n * <p>단일 Aggregate의 조회를 담당합니다.\n *\n * @author {author}\n */\n@Service\n@Transactional(readOnly = true)\npublic class {ClassName} {\n\n    private final {AggregateRoot}QueryPort {aggregateRoot}QueryPort;\n\n    public {ClassName}({AggregateRoot}QueryPort {aggregateRoot}QueryPort) {\n        this.{aggregateRoot}QueryPort = {aggregateRoot}QueryPort;\n    }\n\n    public Optional<{AggregateRoot}> findById({AggregateRoot}Id id) {\n        return {aggregateRoot}QueryPort.findById(id);\n    }\n\n    public {AggregateRoot} getById({AggregateRoot}Id id) {\n        return findById(id)\n            .orElseThrow(() -> new DomainException({AggregateRoot}ErrorCode.NOT_FOUND, id));\n    }\n}','*Manager','[\"@Service\", \"@Transactional(readOnly = true)\"]','[\"@Transactional\"]',NULL,NULL,NULL,'단일 Aggregate의 조회를 담당하는 매니저 클래스 템플릿','2026-01-21 05:29:19.000000','2026-01-21 05:29:19.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (41,20,'CLIENT_MANAGER','package {package};\n\nimport org.springframework.stereotype.Service;\n\n/**\n * {ClassName} - {외부시스템} 클라이언트 매니저\n *\n * <p>외부 시스템 연동을 담당합니다. 트랜잭션 없음 (외부 호출).\n *\n * @author {author}\n */\n@Service\npublic class {ClassName} {\n\n    private final {ExternalSystem}ClientPort {externalSystem}ClientPort;\n\n    public {ClassName}({ExternalSystem}ClientPort {externalSystem}ClientPort) {\n        this.{externalSystem}ClientPort = {externalSystem}ClientPort;\n    }\n\n    public {Response} call{Operation}({Request} request) {\n        return {externalSystem}ClientPort.{operation}(request);\n    }\n}','*Manager','[\"@Service\"]','[\"@Transactional\"]',NULL,NULL,NULL,'외부 시스템 연동을 담당하는 클라이언트 매니저 클래스 템플릿. 트랜잭션 어노테이션 금지.','2026-01-21 05:29:19.000000','2026-01-21 05:29:19.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (42,21,'COMMAND_FACTORY','package {package};\n\nimport com.ryuqq.application.common.dto.command.UpdateContext;\nimport com.ryuqq.application.common.time.TimeProvider;\nimport org.springframework.stereotype.Component;\nimport java.time.Instant;\n\n/**\n * {ClassName} - {도메인} Command Factory\n *\n * <p>Command DTO를 Domain 객체로 변환합니다.\n *\n * <p>C-006: 시간/ID 생성은 Factory에서만 허용됩니다.\n *\n * <p>SVC-003: Service에서 Domain 객체 직접 생성 금지 → Factory에 위임.\n *\n * <p>FAC-008: createUpdateContext()로 ID, UpdateData, changedAt 한 번에 생성.\n *\n * @author {author}\n */\n@Component\npublic class {ClassName} {\n\n    private final TimeProvider timeProvider;\n\n    public {ClassName}(TimeProvider timeProvider) {\n        this.timeProvider = timeProvider;\n    }\n\n    // ==================== Domain 객체 생성 ====================\n\n    /**\n     * Create Command로부터 Domain 객체 생성\n     *\n     * @param command 생성 Command\n     * @return Domain 객체\n     */\n    public {AggregateRoot} create(Create{AggregateRoot}Command command) {\n        Instant now = timeProvider.now();\n        return {AggregateRoot}.forNew(\n            // command 필드들을 VO로 변환하여 전달\n            now\n        );\n    }\n\n    /**\n     * Update Command로부터 UpdateData 생성\n     *\n     * @param command 수정 Command\n     * @return UpdateData\n     */\n    public {AggregateRoot}UpdateData createUpdateData(Update{AggregateRoot}Command command) {\n        return new {AggregateRoot}UpdateData(\n            // command 필드들을 VO로 변환하여 전달\n        );\n    }\n\n    /**\n     * Update Command로부터 UpdateContext 생성\n     *\n     * <p>FAC-008: ID, UpdateData, changedAt을 한 번에 생성합니다.\n     *\n     * @param command 수정 Command\n     * @return UpdateContext (id, updateData, changedAt)\n     */\n    public UpdateContext<{AggregateRoot}Id, {AggregateRoot}UpdateData> createUpdateContext(\n            Update{AggregateRoot}Command command) {\n        {AggregateRoot}Id id = {AggregateRoot}Id.of(command.id());\n        {AggregateRoot}UpdateData updateData = createUpdateData(command);\n        Instant changedAt = timeProvider.now();\n        return new UpdateContext<>(id, updateData, changedAt);\n    }\n\n    // ==================== VO 생성 ====================\n\n    public {AggregateRoot}Id createId(Long id) {\n        return {AggregateRoot}Id.of(id);\n    }\n}','*Factory','[\"@Component\"]',NULL,NULL,NULL,'[\"create*\"]','도메인 객체 생성을 담당하는 팩토리 클래스 템플릿. TimeProvider를 주입받아 시간 값 생성.','2026-01-21 05:29:34.000000','2026-01-22 03:18:16.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (43,22,'QUERY_FACTORY','package {package};\n\nimport org.springframework.stereotype.Component;\n\n/**\n * {ClassName} - {도메인} 조회 팩토리\n *\n * <p>조회 조건 및 검색 DTO 생성을 담당합니다.\n *\n * @author {author}\n */\n@Component\npublic class {ClassName} {\n\n    public {Domain}SearchCondition createSearchCondition({Domain}Query query) {\n        return {Domain}SearchCondition.builder()\n            .keyword(query.keyword())\n            .status(query.status())\n            .build();\n    }\n\n    public {Domain}SliceCriteria createSliceCriteria({Domain}Query query) {\n        return new {Domain}SliceCriteria(\n            query.cursor(),\n            query.size()\n        );\n    }\n}','*Factory','[\"@Component\"]',NULL,NULL,NULL,'[\"create*\"]','조회 조건 및 검색 DTO 생성을 담당하는 팩토리 클래스 템플릿','2026-01-21 05:29:34.000000','2026-01-21 05:29:34.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (44,23,'ASSEMBLER','package {package};\n\nimport org.springframework.stereotype.Component;\nimport java.util.List;\n\n/**\n * {ClassName} - {도메인} 어셈블러\n *\n * <p>도메인 객체를 응답 DTO로 변환합니다.\n *\n * @author {author}\n */\n@Component\npublic class {ClassName} {\n\n    public {AggregateRoot}Response toResponse({AggregateRoot} aggregate) {\n        return new {AggregateRoot}Response(\n            aggregate.getId().value(),\n            aggregate.getName(),\n            aggregate.getStatus().name()\n        );\n    }\n\n    public List<{AggregateRoot}Response> toResponseList(List<{AggregateRoot}> aggregates) {\n        return aggregates.stream()\n            .map(this::toResponse)\n            .toList();\n    }\n}','*Assembler','[\"@Component\"]',NULL,NULL,NULL,'[\"toResponse*\", \"toResponseList*\"]','도메인 객체를 응답 DTO로 변환하는 어셈블러 클래스 템플릿','2026-01-21 05:29:34.000000','2026-01-21 05:29:34.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (45,24,'VALIDATOR','package {package};\n\nimport org.springframework.stereotype.Component;\n\n/**\n * {ClassName} - {도메인} 검증기\n *\n * <p>비즈니스 규칙 검증을 담당합니다.\n *\n * @author {author}\n */\n@Component\npublic class {ClassName} {\n\n    public void validate{Operation}({Command} command) {\n        if (command.{field}() == null) {\n            throw new DomainException({ErrorCode}.INVALID_{FIELD});\n        }\n        // 추가 검증 로직\n    }\n\n    public void validateBusinessRule({AggregateRoot} aggregate, {Context} context) {\n        // 비즈니스 규칙 검증\n    }\n}','*Validator','[\"@Component\"]',NULL,NULL,NULL,'[\"validate*\"]','비즈니스 규칙 검증을 담당하는 검증기 클래스 템플릿','2026-01-21 05:29:49.000000','2026-01-21 05:29:49.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (48,27,'COMMAND_DTO','package {package};\n\n/**\n * {ClassName} - {도메인} 명령 DTO\n *\n * <p>UseCase/Service의 파라미터로 사용되는 명령 DTO입니다.\n * 반드시 record로 정의하며, 인스턴스 메서드를 포함하지 않습니다.\n *\n * @author {author}\n */\npublic record {ClassName}(\n    Long {field1},\n    String {field2},\n    {Type} {field3}\n) {\n    // 인스턴스 메서드 금지 - 정적 팩토리만 허용\n    public static {ClassName} of(Long {field1}, String {field2}) {\n        return new {ClassName}({field1}, {field2}, null);\n    }\n}','*Command',NULL,'[\"@Data\", \"@Builder\", \"@Getter\", \"@Setter\"]',NULL,NULL,NULL,'UseCase/Service 파라미터로 사용되는 명령 DTO 템플릿. record 필수, 인스턴스 메서드 금지.','2026-01-21 05:30:06.000000','2026-01-21 05:30:06.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (49,28,'QUERY_DTO','package {package};\n\nimport com.ryuqq.application.common.dto.query.CommonCursorParams;\n\n/**\n * {ClassName} - {도메인} 조회 Query DTO\n *\n * <p>조회 요청 파라미터를 담는 Query DTO입니다.\n * 반드시 record로 정의하며, CommonCursorParams를 포함합니다.\n *\n * <p>APP-DTO-001: Query DTO는 Record로 정의.\n * <p>APP-DTO-004: 목록 조회 Query는 CommonCursorParams 포함 필수.\n *\n * @param keyword 검색 키워드 (null이면 전체 조회)\n * @param status 상태 필터 (null이면 전체 조회)\n * @param cursorParams 커서 기반 페이징 파라미터\n * @author {author}\n */\npublic record {ClassName}(\n    String keyword,\n    {StatusType} status,\n    CommonCursorParams cursorParams\n) {\n\n    public static {ClassName} of(CommonCursorParams cursorParams) {\n        return new {ClassName}(null, null, cursorParams);\n    }\n\n    public static {ClassName} of(String keyword, {StatusType} status, CommonCursorParams cursorParams) {\n        return new {ClassName}(keyword, status, cursorParams);\n    }\n\n    // ==================== Delegate Methods ====================\n\n    /** 커서 값 반환 (delegate) */\n    public Long cursor() {\n        return cursorParams.cursor();\n    }\n\n    /** 페이지 크기 반환 (delegate) */\n    public Integer size() {\n        return cursorParams.size();\n    }\n\n    /** 첫 페이지인지 확인 (delegate) */\n    public boolean isFirstPage() {\n        return cursorParams.isFirstPage();\n    }\n}','*Query',NULL,'[\"@Data\", \"@Builder\", \"@Getter\", \"@Setter\"]',NULL,NULL,NULL,'조회 요청 파라미터를 담는 DTO 템플릿. record 필수.','2026-01-21 05:30:06.000000','2026-01-21 05:30:06.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (50,29,'RESPONSE_DTO','package {package};\n\nimport java.time.Instant;\n\n/**\n * {ClassName} - {도메인} 조회 결과 DTO\n *\n * <p>Application Layer에서 사용하는 불변 결과 객체입니다.\n *\n * <p>APP-DTO-001: Response DTO는 Record로 정의.\n * <p>RDTO-008: Response DTO는 Domain 타입 의존 금지.\n *\n * @param id ID\n * @param name 이름\n * @param status 상태\n * @param createdAt 생성 시각\n * @param updatedAt 수정 시각\n * @author {author}\n */\npublic record {ClassName}(\n    Long id,\n    String name,\n    String status,\n    Instant createdAt,\n    Instant updatedAt\n) {}','*Result',NULL,'[\"@Data\", \"@Builder\", \"@Getter\", \"@Setter\"]',NULL,NULL,NULL,'Application 레이어 조회 결과 Result DTO 템플릿. record 필수.','2026-01-21 05:30:06.000000','2026-01-21 05:30:06.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (51,30,'BUNDLE_DTO','package {package};\n\nimport java.util.List;\n\n/**\n * {ClassName} - {도메인} 번들 DTO\n *\n * <p>여러 도메인 데이터를 묶어서 반환하는 DTO입니다.\n * 복잡한 조회 결과를 하나의 객체로 묶습니다.\n *\n * @author {author}\n */\npublic record {ClassName}(\n    {MainEntity}Response main,\n    List<{RelatedEntity}Response> related,\n    {SummaryData} summary\n) {\n    public static {ClassName} of({MainEntity}Response main, List<{RelatedEntity}Response> related) {\n        return new {ClassName}(main, related, null);\n    }\n}','*Bundle',NULL,'[\"@Data\", \"@Builder\", \"@Getter\", \"@Setter\"]',NULL,NULL,NULL,'여러 도메인 데이터를 묶어서 반환하는 번들 DTO 템플릿. record 필수.','2026-01-21 05:30:06.000000','2026-01-21 05:30:06.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (52,31,'COMMON_QUERY_DTO','package {package};\n\n/**\n * {ClassName} - 공통 조회 DTO\n *\n * <p>여러 도메인에서 공통으로 사용하는 조회 조건 DTO입니다.\n * 페이징, 정렬 등 공통 조회 조건을 정의합니다.\n *\n * @author {author}\n */\npublic record {ClassName}(\n    Long cursor,\n    int size,\n    String sortField,\n    String sortDirection\n) {\n    public static {ClassName} defaultPaging() {\n        return new {ClassName}(null, 20, \"id\", \"DESC\");\n    }\n\n    public static {ClassName} of(Long cursor, int size) {\n        return new {ClassName}(cursor, size, \"id\", \"DESC\");\n    }\n}','*Query | *Criteria | *Condition',NULL,'[\"@Data\", \"@Builder\", \"@Getter\", \"@Setter\"]',NULL,NULL,NULL,'여러 도메인에서 공통으로 사용하는 조회 조건 DTO 템플릿. record 필수.','2026-01-21 05:30:22.000000','2026-01-21 05:30:22.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (54,33,'COMMON_FACTORY','package {package};\n\nimport org.springframework.stereotype.Component;\n\n/**\n * {ClassName} - 공통 팩토리\n *\n * <p>여러 도메인에서 공통으로 사용하는 객체 생성 로직을 담당합니다.\n * TimeProvider를 주입받아 시간 관련 필드를 설정합니다.\n *\n * @author {author}\n */\n@Component\npublic class {ClassName} {\n\n    private final TimeProvider timeProvider;\n\n    public {ClassName}(TimeProvider timeProvider) {\n        this.timeProvider = timeProvider;\n    }\n\n    public ExecutionContext createExecutionContext(Long userId, String role) {\n        return ExecutionContext.user(userId, role, timeProvider.now());\n    }\n\n    public ExecutionContext createSystemContext() {\n        return ExecutionContext.system(timeProvider.now());\n    }\n}','*Factory','[\"@Component\"]',NULL,NULL,NULL,'[\"create*\"]','여러 도메인에서 공통으로 사용하는 객체 생성 팩토리 템플릿. TimeProvider 주입 필수.','2026-01-21 05:30:22.000000','2026-01-21 05:30:22.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (55,25,'INTERNAL_HELPER','package {package};\n\nimport org.springframework.stereotype.Component;\n\n/**\n * {ClassName} - 내부 헬퍼 컴포넌트\n *\n * <p>Manager에서만 사용하는 내부 헬퍼입니다.\n * package-private으로 외부 노출을 제한합니다.\n *\n * @author {author}\n */\n@Component\nclass {ClassName} {\n\n    {ReturnType} {operation}({Parameters} params) {\n        // 헬퍼 로직\n        return result;\n    }\n}','*Calculator | *Resolver | *Converter | *Helper','[\"@Component\"]',NULL,NULL,NULL,NULL,'내부 헬퍼 컴포넌트 템플릿. package-private으로 Manager에서만 사용.','2026-01-21 05:39:01.000000','2026-01-21 05:39:01.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (56,32,'COMMON_COMMAND_DTO','package {package};\n\n/**\n * {ClassName} - 공통 Command 컨텍스트\n *\n * <p>여러 도메인에서 공통으로 사용하는 Command DTO입니다.\n *\n * @author {author}\n */\npublic record {ClassName}(\n    Long actorId,\n    String actorType,\n    String reason,\n    java.time.Instant occurredAt\n) {\n    public static {ClassName} system(String reason, java.time.Instant now) {\n        return new {ClassName}(0L, \"SYSTEM\", reason, now);\n    }\n\n    public static {ClassName} user(Long userId, String reason, java.time.Instant now) {\n        return new {ClassName}(userId, \"USER\", reason, now);\n    }\n}','*Context',NULL,NULL,NULL,NULL,NULL,'공통 Command 컨텍스트 DTO 템플릿. StatusChangeContext 등.','2026-01-21 05:39:01.000000','2026-01-21 05:39:01.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (57,34,'COMMON_INTERNAL_HELPER','package {package};\n\nimport org.springframework.stereotype.Component;\n\n/**\n * {ClassName} - 공통 내부 헬퍼\n *\n * <p>여러 도메인에서 공유하는 내부 헬퍼 컴포넌트입니다.\n *\n * @author {author}\n */\n@Component\npublic class {ClassName} {\n\n    public {ReturnType} {operation}({Parameters} params) {\n        // 공통 헬퍼 로직\n        return result;\n    }\n}','*Calculator | *Resolver | *Converter | *Helper','[\"@Component\"]',NULL,NULL,NULL,NULL,'여러 도메인에서 공유하는 공통 내부 헬퍼 템플릿','2026-01-21 05:39:16.000000','2026-01-21 05:39:16.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (58,35,'EVENT_REGISTRY','package {package};\n\nimport org.springframework.context.ApplicationEventPublisher;\nimport org.springframework.stereotype.Component;\nimport org.springframework.transaction.support.TransactionSynchronization;\nimport org.springframework.transaction.support.TransactionSynchronizationManager;\n\n/**\n * TransactionEventRegistry - 트랜잭션 이벤트 레지스트리\n *\n * <p>트랜잭션 커밋 후 이벤트를 발행합니다.\n * Manager에서 이 컴포넌트를 통해 이벤트를 등록합니다.\n *\n * @author {author}\n */\n@Component\npublic class TransactionEventRegistry {\n\n    private final ApplicationEventPublisher eventPublisher;\n\n    public TransactionEventRegistry(ApplicationEventPublisher eventPublisher) {\n        this.eventPublisher = eventPublisher;\n    }\n\n    public void register(Object event) {\n        TransactionSynchronizationManager.registerSynchronization(\n            new TransactionSynchronization() {\n                @Override\n                public void afterCommit() {\n                    eventPublisher.publishEvent(event);\n                }\n            }\n        );\n    }\n}','*Registry | *Publisher','[\"@Component\"]',NULL,NULL,NULL,NULL,'트랜잭션 커밋 후 이벤트 발행을 위한 레지스트리 템플릿','2026-01-21 05:39:16.000000','2026-01-21 05:39:16.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (59,36,'EVENT_LISTENER','package {package};\n\nimport org.springframework.context.event.EventListener;\nimport org.springframework.scheduling.annotation.Async;\nimport org.springframework.stereotype.Component;\n\n/**\n * {ClassName} - {도메인} 이벤트 리스너\n *\n * <p>도메인 이벤트를 수신하여 후속 처리를 수행합니다.\n *\n * @author {author}\n */\n@Component\npublic class {ClassName} {\n\n    private final {DependencyManager} {dependencyManager};\n\n    public {ClassName}({DependencyManager} {dependencyManager}) {\n        this.{dependencyManager} = {dependencyManager};\n    }\n\n    @Async\n    @EventListener\n    public void handle({DomainEvent} event) {\n        // 이벤트 처리 로직\n    }\n}','*EventListener','[\"@Component\"]',NULL,NULL,NULL,NULL,'도메인 이벤트를 처리하는 리스너 템플릿. @Async + @EventListener 사용.','2026-01-21 05:39:16.000000','2026-01-21 05:39:16.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (60,37,'COMMAND_ADAPTER','@Repository\npublic class {Entity}CommandAdapter implements {Entity}CommandPort {\n\n    private final {Entity}JpaRepository jpaRepository;\n    private final {Entity}EntityMapper mapper;\n\n    public {Entity}CommandAdapter({Entity}JpaRepository jpaRepository, {Entity}EntityMapper mapper) {\n        this.jpaRepository = jpaRepository;\n        this.mapper = mapper;\n    }\n\n    @Override\n    public Long persist({Entity} domain) {\n        {Entity}JpaEntity entity = mapper.toEntity(domain);\n        return jpaRepository.save(entity).getId();\n    }\n}','{Entity}CommandAdapter','[\"@Repository\"]',NULL,'[\"{Entity}CommandPort\"]',NULL,NULL,'CommandPort 구현체. JpaRepository만 의존, 커스텀 메서드 추가 금지','2026-01-21 07:43:17.000000','2026-01-21 07:43:17.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (61,37,'QUERY_ADAPTER','@Repository\npublic class {Entity}QueryAdapter implements {Entity}QueryPort {\n\n    private final {Entity}QueryDslRepository queryDslRepository;\n    private final {Entity}EntityMapper mapper;\n\n    public {Entity}QueryAdapter({Entity}QueryDslRepository queryDslRepository, {Entity}EntityMapper mapper) {\n        this.queryDslRepository = queryDslRepository;\n        this.mapper = mapper;\n    }\n\n    @Override\n    public Optional<{Entity}> findById({Entity}Id id) {\n        return queryDslRepository.findById(id.value())\n            .map(mapper::toDomain);\n    }\n}','{Entity}QueryAdapter','[\"@Repository\"]',NULL,'[\"{Entity}QueryPort\"]',NULL,NULL,'QueryPort 구현체. QueryDslRepository만 의존','2026-01-21 07:43:17.000000','2026-01-21 07:43:17.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (62,38,'JPA_ENTITY','@Entity\n@Table(name = \"{table_name}\")\npublic class {Entity}JpaEntity extends SoftDeletableEntity {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    // Long FK 전략 (JPA 관계 어노테이션 금지)\n    @Column(name = \"{fk_column}_id\", nullable = false)\n    private Long {fk}Id;\n\n    // 비즈니스 필드\n    @Column(name = \"{column}\", nullable = false)\n    private {Type} {field};\n\n    protected {Entity}JpaEntity() {}\n\n    public {Entity}JpaEntity(Long id, Long {fk}Id, {Type} {field}, \n                             Instant createdAt, Instant updatedAt, Instant deletedAt) {\n        super(createdAt, updatedAt, deletedAt);\n        this.id = id;\n        this.{fk}Id = {fk}Id;\n        this.{field} = {field};\n    }\n\n    public Long getId() { return id; }\n    public Long get{Fk}Id() { return {fk}Id; }\n    public {Type} get{Field}() { return {field}; }\n}','{Entity}JpaEntity','[\"@Entity\", \"@Table\"]','[\"@OneToMany\", \"@ManyToOne\", \"@OneToOne\", \"@ManyToMany\", \"@JoinColumn\"]',NULL,NULL,NULL,'JPA 엔티티. Long FK 전략 필수. JPA 관계 어노테이션 금지','2026-01-21 07:43:26.000000','2026-01-21 07:43:26.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (63,39,'ENTITY_MAPPER','@Component\npublic class {Entity}EntityMapper {\n\n    /**\n     * Domain → Entity 변환\n     */\n    public {Entity}JpaEntity toEntity({Entity} domain) {\n        return new {Entity}JpaEntity(\n            domain.getId().value(),\n            domain.get{Fk}Id().value(),\n            domain.get{Field}(),\n            domain.getCreatedAt(),\n            domain.getUpdatedAt(),\n            domain.getDeletedAt()\n        );\n    }\n\n    /**\n     * Entity → Domain 변환\n     */\n    public {Entity} toDomain({Entity}JpaEntity entity) {\n        return {Entity}.reconstitute(\n            new {Entity}Id(entity.getId()),\n            new {Fk}Id(entity.get{Fk}Id()),\n            entity.get{Field}(),\n            entity.getCreatedAt(),\n            entity.getUpdatedAt(),\n            entity.getDeletedAt()\n        );\n    }\n\n    /**\n     * Entity 리스트 → Domain 리스트 변환\n     */\n    public List<{Entity}> toDomains(List<{Entity}JpaEntity> entities) {\n        return entities.stream()\n            .map(this::toDomain)\n            .toList();\n    }\n}','{Entity}EntityMapper','[\"@Component\"]',NULL,NULL,NULL,NULL,'Domain ↔ Entity 변환. Component로 DI 지원','2026-01-21 07:43:34.000000','2026-01-21 07:43:34.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (64,40,'JPA_REPOSITORY','/**\n * {Entity}JpaRepository - Command용 JPA Repository\n *\n * <p>⚠️ save, saveAll만 사용. 커스텀 메서드 추가 금지!\n * <p>조회는 QueryDslRepository에서 수행\n */\npublic interface {Entity}JpaRepository extends JpaRepository<{Entity}JpaEntity, Long> {\n    // ❌ 커스텀 메서드 추가 금지\n    // ✅ save(), saveAll()만 사용\n}','{Entity}JpaRepository',NULL,NULL,'[\"JpaRepository<{Entity}JpaEntity, Long>\"]',NULL,NULL,'Command용. save/saveAll만 사용. 커스텀 메서드 추가 절대 금지','2026-01-21 07:43:45.000000','2026-01-21 07:43:45.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (65,40,'QUERYDSL_REPOSITORY','@Repository\npublic class {Entity}QueryDslRepository {\n\n    private final JPAQueryFactory queryFactory;\n    private final {Entity}ConditionBuilder conditionBuilder;\n\n    public {Entity}QueryDslRepository(JPAQueryFactory queryFactory, \n                                       {Entity}ConditionBuilder conditionBuilder) {\n        this.queryFactory = queryFactory;\n        this.conditionBuilder = conditionBuilder;\n    }\n\n    public Optional<{Entity}JpaEntity> findById(Long id) {\n        {Entity}JpaEntity entity = queryFactory\n            .selectFrom({entity}JpaEntity)\n            .where(\n                {entity}JpaEntity.id.eq(id),\n                conditionBuilder.deletedAtIsNull()\n            )\n            .fetchOne();\n        return Optional.ofNullable(entity);\n    }\n\n    public List<{Entity}JpaEntity> findBySliceCriteria({Entity}SliceCriteria criteria) {\n        return queryFactory\n            .selectFrom({entity}JpaEntity)\n            .where(conditionBuilder.buildFromCriteria(criteria))\n            .orderBy({entity}JpaEntity.id.desc())\n            .limit(criteria.size())\n            .fetch();\n    }\n}','{Entity}QueryDslRepository',NULL,NULL,NULL,NULL,NULL,'Query용. 모든 조회 담당. ConditionBuilder 주입','2026-01-21 07:43:45.000000','2026-01-21 07:43:45.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (66,41,'CONDITION_BUILDER','import static {base_package}.{domain}.entity.Q{Entity}JpaEntity.{entity}JpaEntity;\n\n@Component\npublic class {Entity}ConditionBuilder {\n\n    public BooleanExpression deletedAtIsNull() {\n        return {entity}JpaEntity.deletedAt.isNull();\n    }\n\n    public BooleanExpression idEq(Long id) {\n        return id != null ? {entity}JpaEntity.id.eq(id) : null;\n    }\n\n    public BooleanExpression cursorLt(Long cursor) {\n        return cursor != null ? {entity}JpaEntity.id.lt(cursor) : null;\n    }\n\n    public BooleanBuilder buildFromCriteria({Entity}SliceCriteria criteria) {\n        BooleanBuilder builder = new BooleanBuilder();\n        builder.and(deletedAtIsNull());\n        builder.and(cursorLt(criteria.cursor()));\n        // 추가 조건...\n        return builder;\n    }\n\n    /**\n     * 풀텍스트 검색 조건 (MySQL MATCH AGAINST)\n     */\n    public BooleanExpression fullTextSearch(String keyword) {\n        if (keyword == null || keyword.isBlank()) {\n            return null;\n        }\n        return Expressions.numberTemplate(\n            Double.class,\n            \"function(\'match_against\', {0}, {1})\",\n            {entity}JpaEntity.name,\n            \"+\" + keyword + \"*\"\n        ).gt(0);\n    }\n}','{Entity}ConditionBuilder','[\"@Component\"]',NULL,NULL,NULL,NULL,'BooleanExpression/BooleanBuilder 생성 전담. FullText 검색 지원','2026-01-21 07:43:56.000000','2026-01-21 07:43:56.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (67,42,'BASE_AUDIT_ENTITY','@MappedSuperclass\npublic abstract class BaseAuditEntity {\n\n    @Column(name = \"created_at\", nullable = false, updatable = false)\n    private Instant createdAt;\n\n    @Column(name = \"updated_at\", nullable = false)\n    private Instant updatedAt;\n\n    protected BaseAuditEntity() {}\n\n    protected BaseAuditEntity(Instant createdAt, Instant updatedAt) {\n        this.createdAt = createdAt;\n        this.updatedAt = updatedAt;\n    }\n\n    public Instant getCreatedAt() { return createdAt; }\n    public Instant getUpdatedAt() { return updatedAt; }\n}','BaseAuditEntity','[\"@MappedSuperclass\"]',NULL,NULL,NULL,NULL,'감사 필드 제공. 모든 Entity의 상위 클래스','2026-01-21 07:44:05.000000','2026-01-21 07:44:05.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (68,42,'SOFT_DELETABLE_ENTITY','@MappedSuperclass\npublic abstract class SoftDeletableEntity extends BaseAuditEntity {\n\n    @Column(name = \"deleted_at\")\n    private Instant deletedAt;\n\n    protected SoftDeletableEntity() { super(); }\n\n    protected SoftDeletableEntity(Instant createdAt, Instant updatedAt) {\n        super(createdAt, updatedAt);\n        this.deletedAt = null;\n    }\n\n    protected SoftDeletableEntity(Instant createdAt, Instant updatedAt, Instant deletedAt) {\n        super(createdAt, updatedAt);\n        this.deletedAt = deletedAt;\n    }\n\n    public Instant getDeletedAt() { return deletedAt; }\n    public boolean isDeleted() { return deletedAt != null; }\n    public boolean isActive() { return deletedAt == null; }\n}','SoftDeletableEntity','[\"@MappedSuperclass\"]',NULL,NULL,NULL,NULL,'소프트 삭제 지원. BaseAuditEntity 상속','2026-01-21 07:44:05.000000','2026-01-21 07:44:05.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (69,43,'JPA_CONFIG','@Configuration\n@EntityScan(basePackages = \"{base_package}\")\n@EnableJpaRepositories(basePackages = \"{base_package}\")\n@EnableJpaAuditing\n@EnableTransactionManagement\npublic class JpaConfig {\n\n    @Bean\n    public JPAQueryFactory jpaQueryFactory(EntityManager entityManager) {\n        return new JPAQueryFactory(entityManager);\n    }\n\n    @Bean(name = \"persistenceJsonObjectMapper\")\n    public ObjectMapper persistenceJsonObjectMapper() {\n        ObjectMapper objectMapper = new ObjectMapper();\n        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n        return objectMapper;\n    }\n}','JpaConfig','[\"@Configuration\", \"@EntityScan\", \"@EnableJpaRepositories\", \"@EnableJpaAuditing\", \"@EnableTransactionManagement\"]',NULL,NULL,NULL,NULL,'JPA/QueryDSL/ObjectMapper 설정','2026-01-21 07:44:16.000000','2026-01-21 07:44:16.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (70,43,'PERSISTENCE_OBJECT_MAPPER','@Component\npublic class PersistenceObjectMapper {\n\n    private static final TypeReference<List<String>> LIST_STRING_TYPE = new TypeReference<>() {};\n    private final ObjectMapper objectMapper;\n\n    public PersistenceObjectMapper(\n            @Qualifier(\"persistenceJsonObjectMapper\") ObjectMapper objectMapper) {\n        this.objectMapper = objectMapper;\n    }\n\n    public <T> T readValue(String json, TypeReference<T> typeReference) {\n        if (json == null || json.isBlank()) {\n            throw new IllegalArgumentException(\"JSON string cannot be null or blank\");\n        }\n        try {\n            return objectMapper.readValue(json, typeReference);\n        } catch (JsonProcessingException e) {\n            throw new IllegalArgumentException(\"Failed to parse JSON: \" + e.getMessage(), e);\n        }\n    }\n\n    public List<String> readValueAsStringList(String json) {\n        if (json == null || json.isBlank()) return List.of();\n        try {\n            return objectMapper.readValue(json, LIST_STRING_TYPE);\n        } catch (JsonProcessingException e) {\n            throw new IllegalArgumentException(\"Failed to parse JSON array: \" + e.getMessage(), e);\n        }\n    }\n\n    public <T> String writeValueAsString(T value) {\n        if (value == null) return \"null\";\n        try {\n            return objectMapper.writeValueAsString(value);\n        } catch (JsonProcessingException e) {\n            throw new IllegalArgumentException(\"Failed to serialize: \" + e.getMessage(), e);\n        }\n    }\n}','PersistenceObjectMapper','[\"@Component\"]',NULL,NULL,NULL,NULL,'JSON 파싱 래퍼. 에러 처리 중앙화','2026-01-21 07:44:16.000000','2026-01-21 07:44:16.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (71,44,'SLICE_CRITERIA','/**\n * SliceCriteria - 커서 기반 페이징 조건\n *\n * @param cursor 마지막 조회 ID (nullable, 첫 페이지면 null)\n * @param size 조회 크기\n * @param direction 정렬 방향 (기본: DESC)\n */\npublic record SliceCriteria(\n    Long cursor,\n    int size,\n    SortDirection direction\n) {\n    public SliceCriteria {\n        if (size <= 0) {\n            throw new IllegalArgumentException(\"Size must be positive\");\n        }\n        if (direction == null) {\n            direction = SortDirection.DESC;\n        }\n    }\n\n    public static SliceCriteria of(Long cursor, int size) {\n        return new SliceCriteria(cursor, size, SortDirection.DESC);\n    }\n\n    public enum SortDirection { ASC, DESC }\n}','SliceCriteria',NULL,NULL,NULL,NULL,NULL,'커서 기반 페이징 조건. Persistence DTO','2026-01-21 07:44:28.000000','2026-01-21 07:44:28.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (72,44,'SORT_CRITERIA','/**\n * SortCriteria - 정렬 조건\n *\n * @param field 정렬 필드명\n * @param direction 정렬 방향\n */\npublic record SortCriteria(\n    String field,\n    SortDirection direction\n) {\n    public SortCriteria {\n        if (field == null || field.isBlank()) {\n            throw new IllegalArgumentException(\"Sort field cannot be blank\");\n        }\n        if (direction == null) {\n            direction = SortDirection.DESC;\n        }\n    }\n\n    public enum SortDirection { ASC, DESC }\n}','SortCriteria',NULL,NULL,NULL,NULL,NULL,'정렬 조건. Persistence DTO','2026-01-21 07:44:28.000000','2026-01-21 07:44:28.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (73,44,'SEARCH_CRITERIA','/**\n * SearchCriteria - 검색 조건\n *\n * @param keyword 검색어\n * @param searchType 검색 타입 (LIKE / FULL_TEXT)\n */\npublic record SearchCriteria(\n    String keyword,\n    SearchType searchType\n) {\n    public SearchCriteria {\n        if (searchType == null) {\n            searchType = SearchType.LIKE;\n        }\n    }\n\n    public static SearchCriteria fullText(String keyword) {\n        return new SearchCriteria(keyword, SearchType.FULL_TEXT);\n    }\n\n    public static SearchCriteria like(String keyword) {\n        return new SearchCriteria(keyword, SearchType.LIKE);\n    }\n\n    public enum SearchType { LIKE, FULL_TEXT }\n}','SearchCriteria',NULL,NULL,NULL,NULL,NULL,'검색 조건. FullText 검색 지원. Persistence DTO','2026-01-21 07:44:28.000000','2026-01-21 07:44:28.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (74,45,'FUNCTION_CONTRIBUTOR','import org.hibernate.boot.model.FunctionContributions;\nimport org.hibernate.boot.model.FunctionContributor;\nimport org.hibernate.type.BasicTypeRegistry;\nimport org.hibernate.type.StandardBasicTypes;\n\n/**\n * MatchAgainstFunctionContributor - MySQL MATCH AGAINST 함수 등록\n *\n * <p>Hibernate 6에서 커스텀 SQL 함수를 등록합니다.\n *\n * <p>사용: resources/META-INF/services/org.hibernate.boot.model.FunctionContributor\n *       에 FQCN 등록 필요\n */\npublic class MatchAgainstFunctionContributor implements FunctionContributor {\n\n    @Override\n    public void contributeFunctions(FunctionContributions functionContributions) {\n        functionContributions.getFunctionRegistry().registerPattern(\n            \"match_against\",\n            \"MATCH(?1) AGAINST(?2 IN BOOLEAN MODE)\",\n            functionContributions.getTypeConfiguration()\n                .getBasicTypeRegistry()\n                .resolve(StandardBasicTypes.DOUBLE)\n        );\n    }\n}','MatchAgainstFunctionContributor',NULL,NULL,'[\"FunctionContributor\"]',NULL,NULL,'MySQL MATCH AGAINST 함수 등록. META-INF/services 등록 필요','2026-01-21 07:44:38.000000','2026-01-21 07:44:38.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (75,46,'ADMIN_QUERY_ADAPTER','@Component\npublic class {Entity}AdminQueryAdapter implements {Entity}AdminQueryPort {\n    \n    private final {Entity}AdminQueryDslRepository adminQueryDslRepository;\n    private final {Entity}EntityMapper mapper;\n    \n    public {Entity}AdminQueryAdapter(\n            {Entity}AdminQueryDslRepository adminQueryDslRepository,\n            {Entity}EntityMapper mapper) {\n        this.adminQueryDslRepository = adminQueryDslRepository;\n        this.mapper = mapper;\n    }\n    \n    // Admin용 복잡 조회 메서드 구현\n    // 조인, 서브쿼리 등 허용\n}','{Entity}AdminQueryAdapter','[\"@Component\"]',NULL,NULL,NULL,NULL,'Admin용 QueryPort 구현체. AdminQueryDslRepository만 의존.','2026-01-21 07:58:32.000000','2026-01-21 07:58:32.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (76,46,'ADMIN_QUERYDSL_REPOSITORY','@Repository\npublic class {Entity}AdminQueryDslRepository {\n    \n    private final JPAQueryFactory queryFactory;\n    \n    public {Entity}AdminQueryDslRepository(JPAQueryFactory queryFactory) {\n        this.queryFactory = queryFactory;\n    }\n    \n    // 조인 허용\n    public List<{Entity}WithDetailDto> findWithDetails(Long id) {\n        return queryFactory\n            .select(Projections.constructor({Entity}WithDetailDto.class,\n                entity.id,\n                entity.name,\n                detail.value\n            ))\n            .from(entity)\n            .leftJoin(detail).on(detail.entityId.eq(entity.id))\n            .where(entity.id.eq(id))\n            .fetch();\n    }\n    \n    // 서브쿼리 허용\n    // 복잡한 통계 쿼리 허용\n}','{Entity}AdminQueryDslRepository','[\"@Repository\"]',NULL,NULL,NULL,NULL,'Admin용 복잡 쿼리 처리. 조인/서브쿼리 허용.','2026-01-21 07:58:32.000000','2026-01-21 07:58:32.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (77,47,'ADMIN_PROJECTION_DTO','/**\n * Admin용 Projection DTO\n * 여러 테이블 조인 결과를 담는 DTO\n */\npublic record {Purpose}Dto(\n    Long id,\n    String name,\n    // 조인된 테이블 데이터\n    String relatedValue,\n    Long relatedCount\n) {\n    // 정적 팩토리 메서드 (필요시)\n    public static {Purpose}Dto of(Long id, String name, String relatedValue, Long relatedCount) {\n        return new {Purpose}Dto(id, name, relatedValue, relatedCount);\n    }\n}','{Purpose}Dto',NULL,NULL,NULL,NULL,NULL,'조인 결과를 담는 Admin DTO. Record 사용 권장.','2026-01-21 07:58:32.000000','2026-01-21 07:58:32.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (78,48,'ADMIN_JPA_CONFIG','@Configuration\npublic class AdminJpaConfig {\n    \n    // Read Replica DataSource 설정 (필요시)\n    // @Bean\n    // @Qualifier(\"adminDataSource\")\n    // public DataSource adminDataSource() { ... }\n    \n    // Admin 전용 EntityManagerFactory 설정 (필요시)\n    // Admin 전용 TransactionManager 설정 (필요시)\n}','AdminJpaConfig','[\"@Configuration\"]',NULL,NULL,NULL,NULL,'Admin 전용 JPA 설정. Read Replica 연결 등.','2026-01-21 07:58:32.000000','2026-01-21 07:58:32.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (79,60,'COMMAND_CONTROLLER','/**\n * {Domain}CommandController - {Domain} 커맨드 API\n *\n * <p>생성, 수정, 삭제 등 상태 변경 엔드포인트를 제공합니다.\n *\n * <p>CTR-001: @RestController 어노테이션 필수\n * <p>CTR-003: UseCase(Port-In) 인터페이스 의존\n * <p>CTR-010: CQRS Controller 분리\n *\n * @author ryu-qqq\n */\n@Tag(name = \"{Domain}\", description = \"{Domain} 커맨드 API\")\n@RestController\n@RequestMapping({Domain}ApiEndpoints.{DOMAIN}S)\npublic class {Domain}CommandController {\n\n    private final Create{Domain}UseCase create{Domain}UseCase;\n    private final Update{Domain}UseCase update{Domain}UseCase;\n    private final Delete{Domain}UseCase delete{Domain}UseCase;\n    private final {Domain}CommandApiMapper mapper;\n\n    public {Domain}CommandController(\n            Create{Domain}UseCase create{Domain}UseCase,\n            Update{Domain}UseCase update{Domain}UseCase,\n            Delete{Domain}UseCase delete{Domain}UseCase,\n            {Domain}CommandApiMapper mapper) {\n        this.create{Domain}UseCase = create{Domain}UseCase;\n        this.update{Domain}UseCase = update{Domain}UseCase;\n        this.delete{Domain}UseCase = delete{Domain}UseCase;\n        this.mapper = mapper;\n    }\n\n    @Operation(summary = \"{Domain} 생성\")\n    @PostMapping\n    public ResponseEntity<ApiResponse<{Domain}IdApiResponse>> create(\n            @Valid @RequestBody Create{Domain}ApiRequest request) {\n        Create{Domain}Command command = mapper.toCommand(request);\n        Long id = create{Domain}UseCase.execute(command);\n        return ResponseEntity.status(HttpStatus.CREATED)\n                .body(ApiResponse.of({Domain}IdApiResponse.from(id)));\n    }\n\n    @Operation(summary = \"{Domain} 수정\")\n    @PutMapping({Domain}ApiEndpoints.{DOMAIN}_ID)\n    public ResponseEntity<ApiResponse<Void>> update(\n            @PathVariable({Domain}ApiEndpoints.PATH_{DOMAIN}_ID) Long {domain}Id,\n            @Valid @RequestBody Update{Domain}ApiRequest request) {\n        Update{Domain}Command command = mapper.toCommand({domain}Id, request);\n        update{Domain}UseCase.execute(command);\n        return ResponseEntity.ok(ApiResponse.empty());\n    }\n\n    @Operation(summary = \"{Domain} 삭제 (Soft Delete)\")\n    @PatchMapping({Domain}ApiEndpoints.{DOMAIN}_ID + \"/delete\")\n    public ResponseEntity<ApiResponse<Void>> delete(\n            @PathVariable({Domain}ApiEndpoints.PATH_{DOMAIN}_ID) Long {domain}Id) {\n        delete{Domain}UseCase.execute({domain}Id);\n        return ResponseEntity.ok(ApiResponse.empty());\n    }\n}','{Domain}CommandController','[\"@RestController\", \"@RequestMapping\", \"@Tag\"]','[\"@Transactional\", \"@Service\"]',NULL,NULL,'[\"create\", \"update\", \"delete\"]','CQRS 패턴의 커맨드 컨트롤러. POST/PUT/PATCH 엔드포인트 담당. DELETE 메서드 금지.','2026-01-21 13:29:19.000000','2026-01-21 13:29:19.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (80,61,'QUERY_CONTROLLER','/**\n * {Domain}QueryController - {Domain} 조회 API\n *\n * <p>단건 조회, 목록 조회 등 읽기 엔드포인트를 제공합니다.\n *\n * <p>CTR-001: @RestController 어노테이션 필수\n * <p>CTR-003: UseCase(Port-In) 인터페이스 의존\n * <p>CTR-011: List 직접 반환 금지 -> SliceApiResponse 페이징 필수\n *\n * @author ryu-qqq\n */\n@Tag(name = \"{Domain}\", description = \"{Domain} 조회 API\")\n@RestController\n@RequestMapping({Domain}ApiEndpoints.{DOMAIN}S)\npublic class {Domain}QueryController {\n\n    private final Get{Domain}ByIdUseCase get{Domain}ByIdUseCase;\n    private final GetAll{Domain}sUseCase getAll{Domain}sUseCase;\n    private final {Domain}QueryApiMapper mapper;\n\n    public {Domain}QueryController(\n            Get{Domain}ByIdUseCase get{Domain}ByIdUseCase,\n            GetAll{Domain}sUseCase getAll{Domain}sUseCase,\n            {Domain}QueryApiMapper mapper) {\n        this.get{Domain}ByIdUseCase = get{Domain}ByIdUseCase;\n        this.getAll{Domain}sUseCase = getAll{Domain}sUseCase;\n        this.mapper = mapper;\n    }\n\n    @Operation(summary = \"{Domain} 목록 조회\")\n    @GetMapping\n    public ResponseEntity<ApiResponse<SliceApiResponse<{Domain}ApiResponse>>> findAll(\n            @Valid GetAll{Domain}sApiRequest request) {\n        GetAll{Domain}sQuery query = mapper.toQuery(request);\n        {Domain}SliceResult sliceResult = getAll{Domain}sUseCase.execute(query);\n        SliceApiResponse<{Domain}ApiResponse> response = mapper.toSliceResponse(sliceResult);\n        return ResponseEntity.ok(ApiResponse.of(response));\n    }\n\n    @Operation(summary = \"{Domain} 단건 조회\")\n    @GetMapping({Domain}ApiEndpoints.{DOMAIN}_ID)\n    public ResponseEntity<ApiResponse<{Domain}ApiResponse>> findById(\n            @PathVariable({Domain}ApiEndpoints.PATH_{DOMAIN}_ID) Long {domain}Id) {\n        {Domain}Result result = get{Domain}ByIdUseCase.execute({domain}Id);\n        {Domain}ApiResponse response = mapper.toResponse(result);\n        return ResponseEntity.ok(ApiResponse.of(response));\n    }\n}','{Domain}QueryController','[\"@RestController\", \"@RequestMapping\", \"@Tag\"]','[\"@Transactional\", \"@Service\"]',NULL,NULL,'[\"findAll\", \"findById\"]','CQRS 패턴의 쿼리 컨트롤러. GET 엔드포인트 담당. List 직접 반환 금지.','2026-01-21 13:29:30.000000','2026-01-21 13:29:30.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (81,53,'COMMAND_API_MAPPER','/**\n * {Domain}CommandApiMapper - {Domain} 커맨드 API 매퍼\n *\n * <p>API Request → Application Command 변환을 담당합니다.\n *\n * <p>MAP-001: @Component 필수\n * <p>MAP-005: 순수 변환 로직만 포함\n * <p>MAP-006: 기본값 처리 담당\n *\n * @author ryu-qqq\n */\n@Component\npublic class {Domain}CommandApiMapper {\n\n    public Create{Domain}Command toCommand(Create{Domain}ApiRequest request) {\n        return Create{Domain}Command.of(\n                request.name(),\n                request.description()\n        );\n    }\n\n    public Update{Domain}Command toCommand(Long {domain}Id, Update{Domain}ApiRequest request) {\n        return Update{Domain}Command.of(\n                {domain}Id,\n                request.name(),\n                request.description()\n        );\n    }\n}','{Domain}CommandApiMapper','[\"@Component\"]','[\"@Service\", \"@Repository\", \"@Transactional\"]',NULL,NULL,'[\"toCommand\"]','커맨드 API 매퍼. Request DTO → Command 변환. 기본값 처리 담당.','2026-01-21 13:29:39.000000','2026-01-21 13:29:39.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (82,53,'QUERY_API_MAPPER','/**\n * {Domain}QueryApiMapper - {Domain} 쿼리 API 매퍼\n *\n * <p>Request → Query 변환 및 Result → Response 변환을 담당합니다.\n *\n * <p>MAP-001: @Component 필수\n * <p>MAP-003: 날짜 포맷팅 담당 (Instant → String)\n * <p>MAP-004: Slice/Page 변환 지원\n * <p>MAP-006: 기본값 처리 담당\n *\n * @author ryu-qqq\n */\n@Component\npublic class {Domain}QueryApiMapper {\n\n    private static final int DEFAULT_SIZE = 20;\n\n    public GetAll{Domain}sQuery toQuery(GetAll{Domain}sApiRequest request) {\n        Long cursor = request.cursor();\n        int size = request.size() != null && request.size() > 0 \n                ? request.size() \n                : DEFAULT_SIZE;\n        CommonCursorParams cursorParams = CommonCursorParams.of(cursor, size);\n        return GetAll{Domain}sQuery.of(request.filterField(), cursorParams);\n    }\n\n    public SliceApiResponse<{Domain}ApiResponse> toSliceResponse({Domain}SliceResult sliceResult) {\n        List<{Domain}ApiResponse> content = sliceResult.content().stream()\n                .map(this::toResponse)\n                .toList();\n        SliceMeta sliceMeta = sliceResult.sliceMeta();\n        return SliceApiResponse.of(content, sliceMeta.size(), sliceMeta.hasNext(), sliceMeta.cursor());\n    }\n\n    public {Domain}ApiResponse toResponse({Domain}Result result) {\n        return {Domain}ApiResponse.of(\n                result.id(),\n                result.name(),\n                result.description(),\n                DateTimeFormatUtils.toIso8601(result.createdAt()),\n                DateTimeFormatUtils.toIso8601(result.updatedAt())\n        );\n    }\n}','{Domain}QueryApiMapper','[\"@Component\"]','[\"@Service\", \"@Repository\", \"@Transactional\"]',NULL,NULL,'[\"toQuery\", \"toSliceResponse\", \"toResponse\"]','쿼리 API 매퍼. Request → Query, Result → Response 변환. 날짜 포맷팅 및 기본값 처리 담당.','2026-01-21 13:29:50.000000','2026-01-21 13:29:50.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (83,62,'API_REQUEST','/**\n * Create{Domain}ApiRequest - {Domain} 생성 요청 DTO\n *\n * <p>DTO-001: Record 타입 필수\n * <p>DTO-003: Validation 어노테이션 필수\n *\n * @author ryu-qqq\n */\n@Schema(description = \"{Domain} 생성 요청\")\npublic record Create{Domain}ApiRequest(\n        @Schema(description = \"이름\", example = \"예시 이름\")\n        @NotBlank(message = \"이름은 필수입니다\")\n        String name,\n\n        @Schema(description = \"설명\", example = \"예시 설명\")\n        String description\n) {\n    public static Create{Domain}ApiRequest of(String name, String description) {\n        return new Create{Domain}ApiRequest(name, description);\n    }\n}','Create{Domain}ApiRequest','[\"@Schema\"]','[\"@Data\", \"@Getter\", \"@Setter\", \"@Builder\"]',NULL,NULL,NULL,'API 요청 DTO. Record 타입 + Validation 어노테이션 필수.','2026-01-21 13:30:01.000000','2026-01-21 13:30:01.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (84,63,'API_RESPONSE','/**\n * {Domain}ApiResponse - {Domain} 응답 DTO\n *\n * <p>DTO-001: Record 타입 필수\n * <p>DTO-004: createdAt/updatedAt 필수\n * <p>DTO-005: 날짜 String 변환 필수 (Mapper에서 처리)\n *\n * @author ryu-qqq\n */\n@Schema(description = \"{Domain} 응답\")\npublic record {Domain}ApiResponse(\n        @Schema(description = \"ID\")\n        Long id,\n\n        @Schema(description = \"이름\")\n        String name,\n\n        @Schema(description = \"설명\")\n        String description,\n\n        @Schema(description = \"생성일시\", example = \"2024-01-01T00:00:00Z\")\n        String createdAt,\n\n        @Schema(description = \"수정일시\", example = \"2024-01-01T00:00:00Z\")\n        String updatedAt\n) {\n    public static {Domain}ApiResponse of(\n            Long id, String name, String description, \n            String createdAt, String updatedAt) {\n        return new {Domain}ApiResponse(id, name, description, createdAt, updatedAt);\n    }\n}','{Domain}ApiResponse','[\"@Schema\"]','[\"@Data\", \"@Getter\", \"@Setter\", \"@Builder\"]',NULL,NULL,'[\"of\"]','API 응답 DTO. Record 타입 + createdAt/updatedAt 필수. 날짜는 ISO8601 String.','2026-01-21 13:30:09.000000','2026-01-21 13:30:09.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (85,52,'ERROR_MAPPER','/**\n * {Domain}ErrorMapper - {Domain} 예외 매핑\n *\n * <p>도메인 예외를 HTTP 응답으로 변환합니다.\n *\n * <p>API-ERR-001: ErrorMapper 패턴\n * <p>API-ERR-002: ProblemDetail 응답 (RFC 7807)\n *\n * @author ryu-qqq\n */\n@Component\npublic class {Domain}ErrorMapper implements ErrorMapper {\n\n    @Override\n    public boolean supports(DomainException ex) {\n        return ex instanceof {Domain}NotFoundException\n                || ex instanceof {Domain}DuplicateException;\n    }\n\n    @Override\n    public MappedError map(DomainException ex, Locale locale) {\n        if (ex instanceof {Domain}NotFoundException) {\n            return MappedError.of(\n                    HttpStatus.NOT_FOUND,\n                    \"{Domain} Not Found\",\n                    ex.getMessage(),\n                    URI.create(\"/errors/{domain}/not-found\")\n            );\n        }\n        if (ex instanceof {Domain}DuplicateException) {\n            return MappedError.of(\n                    HttpStatus.CONFLICT,\n                    \"{Domain} Duplicate\",\n                    ex.getMessage(),\n                    URI.create(\"/errors/{domain}/duplicate\")\n            );\n        }\n        throw new IllegalArgumentException(\"Unsupported exception: \" + ex.getClass());\n    }\n}','{Domain}ErrorMapper','[\"@Component\"]','[\"@Service\", \"@Repository\"]','[\"ErrorMapper\"]',NULL,'[\"supports\", \"map\"]','도메인 예외 매퍼. DomainException → ProblemDetail(RFC 7807) 변환.','2026-01-21 13:30:18.000000','2026-01-21 13:30:18.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (86,49,'API_ENDPOINTS','/**\n * {Domain}ApiEndpoints - {Domain} API 엔드포인트 상수\n *\n * <p>API-END-001: final class로 선언\n * <p>API-END-002: static final 상수\n * <p>API-END-003: Path Variable 상수\n *\n * @author ryu-qqq\n */\npublic final class {Domain}ApiEndpoints {\n\n    private {Domain}ApiEndpoints() {\n        // 인스턴스화 방지\n    }\n\n    /** 기본 경로: /{domain}s */\n    public static final String {DOMAIN}S = \"/{domain}s\";\n\n    /** 단건 경로: /{domain}s/{id} */\n    public static final String {DOMAIN}_ID = \"/{\" + PATH_{DOMAIN}_ID + \"}\";\n\n    /** Path Variable: {domain}Id */\n    public static final String PATH_{DOMAIN}_ID = \"{domain}Id\";\n}','{Domain}ApiEndpoints',NULL,'[\"@Component\", \"@Service\", \"@Repository\"]',NULL,NULL,NULL,'API 엔드포인트 상수 클래스. final class + private 생성자 + static final 상수.','2026-01-21 13:30:27.000000','2026-01-21 13:30:27.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (87,5,'DATE_FIELD_INTERFACE','/**\n * DateField - 날짜 필드 마커 인터페이스\n *\n * <p>각 Bounded Context에서 날짜 범위 필터링에 사용할 수 있는 날짜 필드를 enum으로 정의할 때 구현합니다.\n *\n * <p><strong>설계 원칙:</strong>\n *\n * <ul>\n *   <li>각 BC는 자신만의 DateField enum을 정의\n *   <li>날짜 범위 필터링 가능한 필드만 enum 값으로 노출\n *   <li>DB 컬럼명은 Adapter에서 매핑 (도메인 언어 유지)\n * </ul>\n *\n * <p><strong>구현 예시:</strong>\n *\n * <pre>{@code\n * public enum OrderDateField implements DateField {\n *     ORDER_DATE(\"orderDate\"), PAYMENT_DATE(\"paymentDate\"), DELIVERY_DATE(\"deliveryDate\");\n *\n *     private final String fieldName;\n *\n *     OrderDateField(String fieldName) {\n *         this.fieldName = fieldName;\n *     }\n *\n *     @Override\n *     public String fieldName() {\n *         return fieldName;\n *     }\n * }\n * }</pre>\n *\n * <p>VO-002: Lombok 사용이 금지됩니다.\n *\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic interface DateField {\n\n    /**\n     * 날짜 필드명 반환\n     *\n     * @return 필드명 (예: \"orderDate\", \"createdAt\")\n     */\n    String fieldName();\n\n    /**\n     * enum 이름 반환 (기본 구현)\n     *\n     * @return enum 상수 이름\n     */\n    default String name() {\n        return this.toString();\n    }\n}','{Domain}DateField',NULL,'[\"lombok.*\"]','[\"DateField\"]',NULL,'[\"fieldName\"]','DateField - 날짜 필드 마커 인터페이스. BC별 날짜 필드 enum이 구현합니다.','2026-01-25 10:55:41.000000','2026-01-25 10:55:41.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (88,5,'SEARCH_FIELD_INTERFACE','/**\n * SearchField - 검색 필드 마커 인터페이스\n *\n * <p>각 Bounded Context에서 검색 가능한 필드를 enum으로 정의할 때 구현합니다.\n *\n * <p><strong>설계 원칙:</strong>\n *\n * <ul>\n *   <li>각 BC는 자신만의 SearchField enum을 정의\n *   <li>검색 가능한 필드만 enum 값으로 노출\n *   <li>DB 컬럼명은 Adapter에서 매핑 (도메인 언어 유지)\n * </ul>\n *\n * <p><strong>구현 예시:</strong>\n *\n * <pre>{@code\n * public enum OrderSearchField implements SearchField {\n *     ORDER_NUMBER(\"orderNumber\"), CUSTOMER_NAME(\"customerName\");\n *\n *     private final String fieldName;\n *\n *     OrderSearchField(String fieldName) {\n *         this.fieldName = fieldName;\n *     }\n *\n *     @Override\n *     public String fieldName() {\n *         return fieldName;\n *     }\n * }\n * }</pre>\n *\n * <p>VO-002: Lombok 사용이 금지됩니다.\n *\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic interface SearchField {\n\n    /**\n     * 검색 필드명 반환\n     *\n     * @return 필드명 (예: \"code\", \"name\")\n     */\n    String fieldName();\n\n    /**\n     * enum 이름 반환 (기본 구현)\n     *\n     * @return enum 상수 이름\n     */\n    default String name() {\n        return this.toString();\n    }\n}','{Domain}SearchField',NULL,'[\"lombok.*\"]','[\"SearchField\"]',NULL,'[\"fieldName\"]','SearchField - 검색 필드 마커 인터페이스. BC별 검색 필드 enum이 구현합니다.','2026-01-25 10:55:53.000000','2026-01-25 10:55:53.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (89,5,'ERROR_CODE_INTERFACE','/**\n * ErrorCode - 비즈니스 예외 에러 코드 인터페이스\n *\n * <p>모든 비즈니스 예외는 ErrorCode를 구현하여 일관된 에러 정보를 제공합니다.\n *\n * <p><strong>설계 원칙:</strong>\n *\n * <ul>\n *   <li>Bounded Context별 ErrorCode enum 구현\n *   <li>HTTP Status와 에러 코드 매핑\n *   <li>명확한 에러 메시지 제공\n * </ul>\n *\n * <p><strong>구현 예시:</strong>\n *\n * <pre>{@code\n * public enum OrderErrorCode implements ErrorCode {\n *     ORDER_NOT_FOUND(\"ORDER-001\", 404, \"Order not found\"),\n *     INVALID_ORDER_STATUS(\"ORDER-002\", 400, \"Invalid order status\");\n *\n *     private final String code;\n *     private final int httpStatus;\n *     private final String message;\n *\n *     OrderErrorCode(String code, int httpStatus, String message) {\n *         this.code = code;\n *         this.httpStatus = httpStatus;\n *         this.message = message;\n *     }\n *\n *     @Override public String getCode() { return code; }\n *     @Override public int getHttpStatus() { return httpStatus; }\n *     @Override public String getMessage() { return message; }\n * }\n * }</pre>\n *\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic interface ErrorCode {\n\n    /**\n     * 에러 코드 반환\n     *\n     * <p>형식: {CONTEXT}-{NUMBER} (예: ORDER-001)\n     *\n     * @return 에러 코드 문자열\n     */\n    String getCode();\n\n    /**\n     * HTTP 상태 코드 반환\n     *\n     * @return HTTP 상태 코드 (예: 404, 400, 500)\n     */\n    int getHttpStatus();\n\n    /**\n     * 에러 메시지 반환\n     *\n     * @return 에러 메시지 문자열\n     */\n    String getMessage();\n}','{Domain}ErrorCode',NULL,'[\"lombok.*\"]','[\"ErrorCode\"]',NULL,'[\"getCode\", \"getHttpStatus\", \"getMessage\"]','ErrorCode - 비즈니스 예외 에러 코드 인터페이스. BC별 ErrorCode enum이 구현합니다.','2026-01-25 10:56:07.000000','2026-01-25 10:56:07.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (90,5,'DOMAIN_EXCEPTION_CLASS','/**\n * DomainException - Domain Layer 예외의 최상위 클래스\n *\n * <p>모든 비즈니스 예외는 이 클래스를 상속해야 합니다.\n *\n * <p><strong>설계 원칙:</strong>\n *\n * <ul>\n *   <li>Spring 의존성 금지 (HttpStatus 대신 int 사용)\n *   <li>ErrorCode 객체 기반 (에러 코드, HTTP 상태, 메시지 캡슐화)\n *   <li>RuntimeException 상속 (Unchecked Exception)\n * </ul>\n *\n * <p><strong>사용 예시:</strong>\n *\n * <pre>{@code\n * public class OrderNotFoundException extends DomainException {\n *     public OrderNotFoundException(Long orderId) {\n *         super(\n *             OrderErrorCode.ORDER_NOT_FOUND,\n *             String.format(\"Order not found: %d\", orderId),\n *             Map.of(\"orderId\", orderId)\n *         );\n *     }\n * }\n * }</pre>\n *\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic class DomainException extends RuntimeException {\n\n    private final ErrorCode errorCode;\n    private final Map<String, Object> args;\n\n    protected DomainException(ErrorCode errorCode) {\n        super(errorCode.getMessage());\n        this.errorCode = errorCode;\n        this.args = Collections.emptyMap();\n    }\n\n    protected DomainException(ErrorCode errorCode, String message) {\n        super(message);\n        this.errorCode = errorCode;\n        this.args = Collections.emptyMap();\n    }\n\n    protected DomainException(ErrorCode errorCode, String message, Map<String, Object> args) {\n        super(message);\n        this.errorCode = errorCode;\n        this.args = args != null ? Map.copyOf(args) : Collections.emptyMap();\n    }\n\n    public ErrorCode getErrorCode() { return errorCode; }\n    public String code() { return errorCode.getCode(); }\n    public int httpStatus() { return errorCode.getHttpStatus(); }\n    public Map<String, Object> args() { return args; }\n}','{Domain}Exception',NULL,'[\"lombok.*\", \"org.springframework.*\"]',NULL,'[\"RuntimeException\"]','[\"getErrorCode\", \"code\", \"httpStatus\", \"args\"]','DomainException - Domain Layer 예외의 최상위 클래스. 모든 비즈니스 예외가 상속합니다.','2026-01-25 10:56:21.000000','2026-01-25 10:56:21.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (91,5,'DOMAIN_EVENT_INTERFACE','/**\n * DomainEvent - 도메인 이벤트 인터페이스\n *\n * <p>모든 도메인 이벤트는 이 인터페이스를 구현해야 합니다.\n *\n * <p><strong>구현 규칙</strong>:\n *\n * <ul>\n *   <li>Record 타입으로 구현 (불변성 보장)\n *   <li>occurredAt 필드 필수 (Instant 타입)\n *   <li>모든 필드는 Value Object 타입 사용\n *   <li>from(Aggregate, Instant) 정적 팩토리 메서드 제공\n * </ul>\n *\n * <p><strong>구현 예시</strong>:\n *\n * <pre>{@code\n * public record OrderCreatedEvent(\n *     OrderId orderId,\n *     MemberId memberId,\n *     Money totalAmount,\n *     Instant occurredAt\n * ) implements DomainEvent {\n *\n *     public static OrderCreatedEvent from(Order order, Instant occurredAt) {\n *         return new OrderCreatedEvent(\n *             order.id(),\n *             order.memberId(),\n *             order.totalAmount(),\n *             occurredAt\n *         );\n *     }\n * }\n * }</pre>\n *\n * @author ryu-qqq\n * @since 1.0.0\n */\npublic interface DomainEvent {\n\n    /**\n     * 이벤트 발생 시각\n     *\n     * @return 이벤트가 생성된 시각\n     */\n    Instant occurredAt();\n\n    /**\n     * 이벤트 타입 식별자\n     *\n     * @return 이벤트 타입 문자열\n     */\n    default String eventType() {\n        return this.getClass().getSimpleName();\n    }\n}','{Domain}Event',NULL,'[\"lombok.*\"]','[\"DomainEvent\"]',NULL,'[\"occurredAt\"]','DomainEvent - 도메인 이벤트 인터페이스. Record로 구현하며 occurredAt 필수입니다.','2026-01-25 10:56:35.000000','2026-01-25 10:56:35.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (92,64,'COMMON_CONFIG','/**\n * ApplicationJsonConfig - Application 레이어 JSON 설정\n *\n * <p>Application 레이어에서 사용하는 ObjectMapper 빈을 등록합니다.\n *\n * @author ryu-qqq\n */\n@Configuration\npublic class ApplicationJsonConfig {\n\n    @Bean\n    @Primary\n    public ObjectMapper applicationObjectMapper() {\n        ObjectMapper objectMapper = new ObjectMapper();\n        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n        return objectMapper;\n    }\n}','*Config','[\"org.springframework.context.annotation.Configuration\"]','[\"lombok.*\"]',NULL,NULL,NULL,'ApplicationJsonConfig - Application 레이어 공통 설정 클래스.','2026-01-25 15:55:17.000000','2026-01-25 15:55:17.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (93,65,'COMMON_CACHE_PORT','/**\n * Cache Port (출력 포트)\n *\n * <p>캐시 저장/조회/무효화를 위한 포트입니다.\n *\n * <p><strong>Cache-Aside 패턴:</strong>\n *\n * <ol>\n *   <li>Cache 조회 (CachePort.get)\n *   <li>Cache Miss → DB 조회 (QueryPort)\n *   <li>Cache 저장 (CachePort.set)\n * </ol>\n *\n * @param <T> 캐시 대상 타입\n * @author Development Team\n * @since 1.0.0\n * @see CacheKey\n */\npublic interface CachePort<T> {\n\n    /**\n     * 캐시 저장 (기본 TTL)\n     */\n    void set(CacheKey key, T value);\n\n    /**\n     * 캐시 저장 (TTL 지정)\n     */\n    void set(CacheKey key, T value, Duration ttl);\n\n    /**\n     * 캐시 조회\n     */\n    Optional<T> get(CacheKey key);\n\n    /**\n     * 캐시 무효화\n     */\n    void evict(CacheKey key);\n}','CachePort',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"set\", \"get\", \"evict\"]','CachePort - 캐시 저장/조회/무효화를 위한 공통 출력 포트.','2026-01-25 15:55:28.000000','2026-01-25 15:55:28.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (94,65,'COMMON_DISTRIBUTED_LOCK_PORT','/**\n * 분산락 포트 (출력 포트)\n *\n * <p>Redisson 기반 분산락 추상화입니다.\n *\n * <p><strong>사용 예시:</strong>\n *\n * <pre>{@code\n * OrderLockKey lockKey = new OrderLockKey(orderId);\n * boolean acquired = lockPort.tryLock(lockKey, 10, 30, TimeUnit.SECONDS);\n *\n * if (!acquired) {\n *     throw new LockAcquisitionException(\"Lock 획득 실패\");\n * }\n *\n * try {\n *     // 비즈니스 로직\n * } finally {\n *     lockPort.unlock(lockKey);\n * }\n * }</pre>\n *\n * @author Development Team\n * @since 1.0.0\n * @see LockKey\n */\npublic interface DistributedLockPort {\n\n    /**\n     * 분산락 획득 시도\n     */\n    boolean tryLock(LockKey key, long waitTime, long leaseTime, TimeUnit unit);\n\n    /**\n     * 분산락 해제\n     */\n    void unlock(LockKey key);\n}','DistributedLockPort',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"tryLock\", \"unlock\"]','DistributedLockPort - Redisson 기반 분산락 공통 출력 포트.','2026-01-25 15:55:44.000000','2026-01-25 15:55:44.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (95,65,'COMMON_ID_GENERATOR_PORT','/**\n * ID 생성 Port (Outbound)\n *\n * <p>도메인 Aggregate ID 생성을 위한 Port입니다. \n * UUIDv7 기반의 시간 순서가 보장되는 고유 ID를 생성합니다.\n *\n * <p>구현체는 Adapter Layer에서 제공합니다.\n *\n * @author development-team\n * @since 1.0.0\n */\npublic interface IdGeneratorPort {\n\n    /**\n     * 새 ID 생성\n     *\n     * <p>UUIDv7 형식의 시간 순서가 보장되는 고유 ID를 생성합니다.\n     *\n     * @return 생성된 ID 문자열\n     */\n    String generate();\n}','IdGeneratorPort',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"generate\"]','IdGeneratorPort - UUIDv7 기반 ID 생성 공통 출력 포트.','2026-01-25 15:55:44.000000','2026-01-25 15:55:44.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (96,66,'COMMON_TIME_PROVIDER','/**\n * 시간 제공자\n *\n * <p>시스템 시간을 제공하는 공통 컴포넌트입니다. \n * Clock을 캡슐화하여 테스트 용이성을 보장합니다.\n *\n * <p><strong>책임:</strong>\n *\n * <ul>\n *   <li>현재 시간(Instant) 제공\n *   <li>Clock 의존성 캡슐화\n * </ul>\n *\n * <p><strong>사용 예시:</strong>\n *\n * <pre>{@code\n * @Service\n * public class UpdateService {\n *     private final TimeProvider timeProvider;\n *\n *     public void execute(Command command) {\n *         aggregate.update(data, timeProvider.now());\n *     }\n * }\n * }</pre>\n *\n * @author development-team\n * @since 1.0.0\n */\n@Component\npublic class TimeProvider {\n\n    private final Clock clock;\n\n    public TimeProvider(Clock clock) {\n        this.clock = clock;\n    }\n\n    /**\n     * 현재 시간 반환\n     *\n     * @return 현재 Instant\n     */\n    public Instant now() {\n        return clock.instant();\n    }\n}','TimeProvider','[\"org.springframework.stereotype.Component\"]','[\"lombok.*\"]',NULL,NULL,'[\"now\"]','TimeProvider - Clock 기반 시간 제공 공통 컴포넌트.','2026-01-25 15:55:54.000000','2026-01-25 15:55:54.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (97,31,'COMMON_CURSOR_PARAMS','/**\n * 공통 커서 기반 페이징 파라미터\n *\n * <p>모든 Cursor Query에서 공통으로 사용하는 파라미터입니다. \n * Composition 방식으로 사용되며, SearchParams DTO는 delegate 메서드를 통해\n * 이 파라미터들을 노출해야 합니다.\n *\n * <p><strong>사용 규칙:</strong>\n *\n * <ul>\n *   <li>SearchParams는 이 record를 필드로 포함해야 함\n *   <li>SearchParams는 delegate 메서드를 제공하여 직접 접근 허용\n *   <li>중첩 접근(params.cursorParams().cursor()) 금지 - delegate 사용\n * </ul>\n *\n * <p><strong>기본값:</strong>\n *\n * <ul>\n *   <li>cursor: null (첫 페이지)\n *   <li>size: 20\n * </ul>\n *\n * @param cursor 커서 값 (null이면 첫 페이지)\n * @param size 페이지 크기 (기본: 20)\n * @author development-team\n * @since 1.0.0\n */\npublic record CommonCursorParams(String cursor, Integer size) {\n\n    private static final Integer DEFAULT_SIZE = 20;\n    private static final int MAX_SIZE = 100;\n\n    public CommonCursorParams {\n        if (size == null) {\n            size = DEFAULT_SIZE;\n        }\n        if (size <= 0) {\n            size = DEFAULT_SIZE;\n        }\n        if (size > MAX_SIZE) {\n            size = MAX_SIZE;\n        }\n    }\n\n    public boolean isFirstPage() {\n        return cursor == null || cursor.isBlank();\n    }\n}','CommonCursorParams',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"cursor\", \"size\", \"isFirstPage\"]','CommonCursorParams - 공통 커서 기반 페이징 파라미터 DTO.','2026-01-25 15:56:16.000000','2026-01-25 15:56:16.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (98,31,'COMMON_SEARCH_PARAMS','/**\n * 공통 검색 파라미터\n *\n * <p>모든 Search Query에서 공통으로 사용하는 파라미터입니다. \n * Composition 방식으로 사용되며, Query DTO는 delegate 메서드를 통해 이\n * 파라미터들을 노출해야 합니다.\n *\n * <p><strong>사용 규칙:</strong>\n *\n * <ul>\n *   <li>SearchQuery는 이 record를 필드로 포함해야 함\n *   <li>SearchQuery는 delegate 메서드를 제공하여 직접 접근 허용\n *   <li>중첩 접근(query.searchParams().page()) 금지 - delegate 사용\n * </ul>\n *\n * <p><strong>기본값:</strong>\n *\n * <ul>\n *   <li>includeDeleted: false\n *   <li>sortKey: \"createdAt\"\n *   <li>sortDirection: \"DESC\"\n *   <li>page: 0\n *   <li>size: 20\n * </ul>\n *\n * @param includeDeleted 삭제된 항목 포함 여부\n * @param startDate 조회 시작일\n * @param endDate 조회 종료일\n * @param sortKey 정렬 기준\n * @param sortDirection 정렬 방향\n * @param page 페이지 번호\n * @param size 페이지 크기\n * @author development-team\n * @since 1.0.0\n */\npublic record CommonSearchParams(\n        Boolean includeDeleted,\n        LocalDate startDate,\n        LocalDate endDate,\n        String sortKey,\n        String sortDirection,\n        Integer page,\n        Integer size) {\n\n    private static final Boolean DEFAULT_INCLUDE_DELETED = false;\n    private static final String DEFAULT_SORT_KEY = \"createdAt\";\n    private static final String DEFAULT_SORT_DIRECTION = \"DESC\";\n    private static final Integer DEFAULT_PAGE = 0;\n    private static final Integer DEFAULT_SIZE = 20;\n\n    public CommonSearchParams {\n        if (includeDeleted == null) includeDeleted = DEFAULT_INCLUDE_DELETED;\n        if (sortKey == null || sortKey.isBlank()) sortKey = DEFAULT_SORT_KEY;\n        if (sortDirection == null || sortDirection.isBlank()) sortDirection = DEFAULT_SORT_DIRECTION;\n        if (page == null || page < 0) page = DEFAULT_PAGE;\n        if (size == null || size <= 0) size = DEFAULT_SIZE;\n    }\n}','CommonSearchParams',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"includeDeleted\", \"startDate\", \"endDate\", \"sortKey\", \"sortDirection\", \"page\", \"size\"]','CommonSearchParams - 공통 검색 파라미터 DTO.','2026-01-25 15:56:16.000000','2026-01-25 15:56:16.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (99,67,'COMMON_API_PATHS','/**\n * ApiPaths - 서비스 공통 API 경로 상수\n *\n * <p>모든 API 경로의 기본이 되는 상수들을 정의합니다.\n *\n * @author ryu-qqq\n */\npublic final class ApiPaths {\n\n    private ApiPaths() {\n        // Utility class\n    }\n\n    /** API 버전 */\n    public static final String API_VERSION = \"/api/v1\";\n\n    /** 서비스 기본 경로 */\n    public static final String SERVICE_BASE = API_VERSION + \"/standards\";\n\n    /** MCP 경로 */\n    public static final String MCP = API_VERSION + \"/mcp\";\n\n    /** API 문서 경로 */\n    public static final String DOCS = \"/docs\";\n    public static final String DOCS_PATTERN = \"/docs/**\";\n}','ApiPaths',NULL,'[\"lombok.*\"]',NULL,NULL,NULL,'ApiPaths - REST API 공통 경로 상수 클래스.','2026-01-25 16:01:21.000000','2026-01-25 16:01:21.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (100,68,'COMMON_API_DOCS_CONTROLLER','/**\n * API 문서 컨트롤러\n *\n * <p>Spring REST Docs 기반 API 문서 리다이렉트를 처리합니다.\n *\n * @author ryu-qqq\n */\n@Controller\npublic class ApiDocsController {\n\n    @GetMapping(ApiPaths.DOCS)\n    public String redirectToDocs() {\n        return \"redirect:\" + ApiPaths.DOCS + \"/index.html\";\n    }\n}','ApiDocsController','[\"org.springframework.stereotype.Controller\"]','[\"lombok.*\"]',NULL,NULL,'[\"redirectToDocs\"]','ApiDocsController - API 문서 리다이렉트 컨트롤러.','2026-01-25 16:01:21.000000','2026-01-25 16:01:21.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (101,69,'COMMON_API_RESPONSE','/**\n * ApiResponse - 공통 API 응답 래퍼\n *\n * <p>모든 API 응답을 일관된 형식으로 래핑합니다.\n *\n * @param <T> 응답 데이터 타입\n * @author ryu-qqq\n */\npublic record ApiResponse<T>(\n    boolean success,\n    T data,\n    String message,\n    String errorCode\n) {\n\n    public static <T> ApiResponse<T> success(T data) {\n        return new ApiResponse<>(true, data, null, null);\n    }\n\n    public static <T> ApiResponse<T> success(T data, String message) {\n        return new ApiResponse<>(true, data, message, null);\n    }\n\n    public static <T> ApiResponse<T> error(String message, String errorCode) {\n        return new ApiResponse<>(false, null, message, errorCode);\n    }\n}','ApiResponse',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"success\", \"error\"]','ApiResponse - 공통 API 응답 래퍼 클래스.','2026-01-25 16:01:37.000000','2026-01-25 16:01:37.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (102,69,'COMMON_PAGE_API_RESPONSE','/**\n * PageApiResponse - 페이지 기반 API 응답\n *\n * <p>오프셋 기반 페이지네이션 결과를 담는 응답 클래스입니다.\n *\n * @param <T> 데이터 항목 타입\n * @author ryu-qqq\n */\npublic record PageApiResponse<T>(\n    List<T> content,\n    int page,\n    int size,\n    long totalElements,\n    int totalPages,\n    boolean hasNext,\n    boolean hasPrevious\n) {\n\n    public static <T> PageApiResponse<T> of(List<T> content, PageMeta meta) {\n        return new PageApiResponse<>(\n            content,\n            meta.page(),\n            meta.size(),\n            meta.totalElements(),\n            meta.totalPages(),\n            meta.hasNext(),\n            meta.hasPrevious()\n        );\n    }\n}','PageApiResponse',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"of\"]','PageApiResponse - 페이지 기반 API 응답 클래스.','2026-01-25 16:01:37.000000','2026-01-25 16:01:37.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (103,69,'COMMON_SLICE_API_RESPONSE','/**\n * SliceApiResponse - 커서 기반 API 응답\n *\n * <p>커서 기반 페이지네이션 결과를 담는 응답 클래스입니다.\n *\n * @param <T> 데이터 항목 타입\n * @author ryu-qqq\n */\npublic record SliceApiResponse<T>(\n    List<T> content,\n    int size,\n    boolean hasNext,\n    String cursor,\n    int count\n) {\n\n    public static <T> SliceApiResponse<T> of(List<T> content, SliceMeta meta) {\n        return new SliceApiResponse<>(\n            content,\n            meta.size(),\n            meta.hasNext(),\n            meta.cursor(),\n            meta.count()\n        );\n    }\n}','SliceApiResponse',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"of\"]','SliceApiResponse - 커서 기반 API 응답 클래스.','2026-01-25 16:01:37.000000','2026-01-25 16:01:37.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (104,70,'COMMON_ERROR_MAPPER_INTERFACE','/**\n * ErrorMapper - 에러 매핑 인터페이스\n *\n * <p>도메인 예외를 API 응답으로 변환하는 매퍼 인터페이스입니다.\n *\n * @author ryu-qqq\n */\npublic interface ErrorMapper {\n\n    /**\n     * 지원하는 예외 타입 반환\n     */\n    Class<? extends DomainException> supportedType();\n\n    /**\n     * 예외를 API 응답으로 변환\n     */\n    ApiResponse<?> toResponse(DomainException exception);\n}','ErrorMapper',NULL,'[\"lombok.*\"]',NULL,NULL,'[\"supportedType\", \"toResponse\"]','ErrorMapper - 도메인 예외를 API 응답으로 변환하는 인터페이스.','2026-01-25 16:01:57.000000','2026-01-25 16:01:57.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (105,70,'COMMON_ERROR_MAPPER_REGISTRY','/**\n * ErrorMapperRegistry - 에러 매퍼 레지스트리\n *\n * <p>모든 ErrorMapper를 등록하고 예외 타입에 맞는 매퍼를 찾습니다.\n *\n * @author ryu-qqq\n */\n@Component\npublic class ErrorMapperRegistry {\n\n    private final Map<Class<? extends DomainException>, ErrorMapper> mappers;\n\n    public ErrorMapperRegistry(List<ErrorMapper> errorMappers) {\n        this.mappers = errorMappers.stream()\n            .collect(Collectors.toMap(\n                ErrorMapper::supportedType,\n                Function.identity()\n            ));\n    }\n\n    public Optional<ErrorMapper> findMapper(Class<? extends DomainException> exceptionType) {\n        return Optional.ofNullable(mappers.get(exceptionType));\n    }\n}','ErrorMapperRegistry','[\"org.springframework.stereotype.Component\"]','[\"lombok.*\"]',NULL,NULL,'[\"findMapper\"]','ErrorMapperRegistry - 예외 타입별 ErrorMapper 레지스트리.','2026-01-25 16:01:57.000000','2026-01-25 16:01:57.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (106,70,'COMMON_GLOBAL_EXCEPTION_HANDLER','/**\n * GlobalExceptionHandler - 전역 예외 핸들러\n *\n * <p>모든 예외를 일관된 API 응답으로 변환합니다.\n *\n * @author ryu-qqq\n */\n@RestControllerAdvice\npublic class GlobalExceptionHandler {\n\n    private final ErrorMapperRegistry errorMapperRegistry;\n\n    public GlobalExceptionHandler(ErrorMapperRegistry errorMapperRegistry) {\n        this.errorMapperRegistry = errorMapperRegistry;\n    }\n\n    @ExceptionHandler(DomainException.class)\n    public ResponseEntity<ApiResponse<?>> handleDomainException(DomainException ex) {\n        return errorMapperRegistry.findMapper(ex.getClass())\n            .map(mapper -> ResponseEntity\n                .status(ex.httpStatus())\n                .body(mapper.toResponse(ex)))\n            .orElseGet(() -> ResponseEntity\n                .status(ex.httpStatus())\n                .body(ApiResponse.error(ex.getMessage(), ex.code())));\n    }\n}','GlobalExceptionHandler','[\"org.springframework.web.bind.annotation.RestControllerAdvice\"]','[\"lombok.*\"]',NULL,NULL,'[\"handleDomainException\"]','GlobalExceptionHandler - 전역 예외 핸들러.','2026-01-25 16:01:57.000000','2026-01-25 16:01:57.000000',NULL);
INSERT INTO `class_template` (`id`, `structure_id`, `class_type`, `template_code`, `naming_pattern`, `required_annotations`, `forbidden_annotations`, `required_interfaces`, `forbidden_inheritance`, `required_methods`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (107,71,'COMMON_DATETIME_FORMAT_UTILS','/**\n * DateTimeFormatUtils - 날짜/시간 포맷 유틸리티\n *\n * <p>API 요청/응답에서 사용하는 날짜/시간 포맷 상수를 정의합니다.\n *\n * @author ryu-qqq\n */\npublic final class DateTimeFormatUtils {\n\n    private DateTimeFormatUtils() {\n        // Utility class\n    }\n\n    /** ISO 8601 날짜 포맷 */\n    public static final String DATE_FORMAT = \"yyyy-MM-dd\";\n\n    /** ISO 8601 날짜시간 포맷 */\n    public static final String DATETIME_FORMAT = \"yyyy-MM-dd\'T\'HH:mm:ss\";\n\n    /** ISO 8601 날짜시간 + 타임존 포맷 */\n    public static final String DATETIME_WITH_ZONE_FORMAT = \"yyyy-MM-dd\'T\'HH:mm:ssXXX\";\n}','*Utils',NULL,'[\"lombok.*\"]',NULL,NULL,NULL,'DateTimeFormatUtils - 날짜/시간 포맷 유틸리티 클래스.','2026-01-25 16:01:57.000000','2026-01-25 16:01:57.000000',NULL);

INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (27,1,'DOM-AGG-004','forNew() 팩토리 메서드 필수','BLOCKER','STRUCTURE','Aggregate는 새로운 인스턴스 생성을 위한 static forNew(..., Instant now) 팩토리 메서드가 필수입니다. ID는 null(Long ID) 또는 외부 주입(String ID)합니다.','생성자를 직접 노출하지 않고 팩토리 메서드를 통해 생성 의도를 명확히 합니다. forNew는 \"새로 생성\"임을 명시합니다.',0,'Aggregate','2026-01-20 14:59:45.000000','2026-01-20 14:59:45.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (28,1,'DOM-AGG-005','reconstitute() 팩토리 메서드 필수','BLOCKER','STRUCTURE','Aggregate는 DB에서 조회한 데이터로 복원하기 위한 static reconstitute(...) 팩토리 메서드가 필수입니다. 비즈니스 검증은 수행하지 않습니다.','forNew()와 reconstitute()를 분리하여 생성과 복원의 의도를 명확히 합니다.',0,'Aggregate','2026-01-20 14:59:45.000000','2026-01-20 14:59:45.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (29,1,'DOM-AGG-006','protected 기본 생성자','CRITICAL','STRUCTURE','Aggregate는 reconstitute() 팩토리 메서드와 함께 protected 기본 생성자를 선언할 수 있습니다. 외부에서 직접 호출하지 않도록 protected로 접근을 제한합니다.','JPA는 리플렉션으로 객체를 생성하므로 기본 생성자가 필요합니다. protected로 선언하여 외부 사용을 방지합니다.',0,'Aggregate','2026-01-20 14:59:45.000000','2026-01-20 15:52:53.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (30,1,'DOM-AGG-007','Aggregate ID는 ID VO 사용','BLOCKER','STRUCTURE','Aggregate의 ID 필드는 원시 타입(Long) 대신 전용 ID VO(예: OrderId)를 사용해야 합니다. ID VO는 domain/{bc}/id 패키지에 위치합니다.','Primitive Obsession 안티패턴 방지. ID VO를 사용하면 타입 안전성이 보장됩니다.',0,'Aggregate','2026-01-20 14:59:45.000000','2026-01-20 14:59:45.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (31,1,'DOM-AGG-008','isNew() 메서드 필수','BLOCKER','STRUCTURE','Aggregate는 새로 생성된 객체인지 판단하는 isNew() 메서드가 필수입니다. Long ID의 경우 id.value() == null 또는 id.isNew()로 판단합니다.','JPA의 merge/persist 결정, Outbox 이벤트 생성 여부 등에서 신규 생성 여부 판단이 필요합니다.',0,'Aggregate','2026-01-20 14:59:45.000000','2026-01-20 14:59:45.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (32,1,'DOM-AGG-009','Aggregate 시간 필드는 Instant 타입','BLOCKER','STRUCTURE','Aggregate의 모든 시간 필드(createdAt, updatedAt, expiredAt 등)는 java.time.Instant 타입을 사용합니다. LocalDateTime, LocalDate, Date 등은 금지됩니다.','Instant는 타임존 독립적인 시점을 나타냅니다. UTC 기준 저장 후 표현 계층에서 타임존 변환합니다.',0,'Aggregate','2026-01-20 14:59:45.000000','2026-01-20 14:59:45.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (33,1,'DOM-AGG-010','Instant 파라미터 주입 (Instant.now() 금지)','BLOCKER','BEHAVIOR','Aggregate 내부에서 Instant.now() 또는 System.currentTimeMillis() 직접 호출을 금지합니다. 시간이 필요한 메서드는 Instant 파라미터로 받습니다.','테스트 가능성 확보. Instant.now()는 테스트에서 시간을 고정할 수 없습니다.',0,'Aggregate','2026-01-20 14:59:45.000000','2026-01-20 14:59:45.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (34,1,'DOM-AGG-011','상태 변경 시 updatedAt 갱신','CRITICAL','BEHAVIOR','Aggregate의 상태를 변경하는 모든 메서드는 updatedAt 필드를 갱신해야 합니다. 시간은 파라미터로 주입받습니다.','변경 이력 추적을 위해 updatedAt은 항상 최신 상태를 유지해야 합니다.',0,'Aggregate','2026-01-20 14:59:45.000000','2026-01-20 14:59:45.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (35,1,'DOM-AGG-012','Aggregate Setter 메서드 금지','BLOCKER','STRUCTURE','Aggregate에서 setXxx() 형태의 Setter 메서드 사용을 금지합니다. 상태 변경은 비즈니스 의미가 담긴 메서드(예: cancel(), approve())를 통해서만 가능합니다.','Setter는 캡슐화를 해치고 비즈니스 로직이 외부로 유출됩니다. 도메인 언어로 표현된 메서드를 사용합니다.',0,'Aggregate','2026-01-20 14:59:45.000000','2026-01-20 14:59:45.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (36,1,'DOM-AGG-013','Aggregate Getter 최소화','MAJOR','STRUCTURE','Aggregate에서 Getter는 꼭 필요한 경우에만 제공합니다. 외부에서 상태를 조회하여 판단하는 것보다 Aggregate가 직접 판단하는 메서드를 제공합니다.','Tell, Don\'t Ask 원칙. 외부에서 상태를 물어보고 판단하는 대신 Aggregate에게 판단을 요청합니다.',0,'Aggregate','2026-01-20 14:59:45.000000','2026-01-20 14:59:45.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (37,1,'DOM-AGG-014','Law of Demeter (Getter 체이닝 금지)','BLOCKER','BEHAVIOR','order.getCustomer().getAddress().getCity()와 같은 Getter 체이닝을 금지합니다. 필요한 정보는 Aggregate가 직접 제공하는 메서드를 통해 접근합니다.','결합도 감소. Getter 체이닝은 내부 구조에 대한 깊은 의존성을 만듭니다.',0,'Aggregate','2026-01-20 14:59:45.000000','2026-01-20 14:59:45.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (38,1,'DOM-AGG-015','Tell Don\'t Ask 원칙','CRITICAL','BEHAVIOR','if (order.getStatus() == PENDING) order.cancel() 대신 order.cancelIfPending()처럼 Aggregate에게 판단을 위임합니다.','비즈니스 로직이 Aggregate 내부에 캡슐화되어 일관성이 보장됩니다.',0,'Aggregate','2026-01-20 14:59:45.000000','2026-01-20 14:59:45.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (39,1,'DOM-AGG-016','복잡한 비즈니스 규칙은 VO로 위임','CRITICAL','BEHAVIOR','복잡한 비즈니스 규칙이나 계산 로직은 Value Object로 추출하여 위임합니다. Aggregate는 조율 역할만 수행합니다.','단일 책임 원칙. Aggregate가 비대해지는 것을 방지하고 테스트 용이성을 높입니다.',0,'Aggregate','2026-01-20 14:59:45.000000','2026-01-20 14:59:45.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (40,1,'DOM-AGG-017','상태 변경 시 도메인 이벤트 발행','CRITICAL','BEHAVIOR','Aggregate의 중요한 상태 변경은 도메인 이벤트를 발행해야 합니다. registerEvent() 메서드를 통해 이벤트를 등록합니다.','도메인 이벤트를 통해 다른 Bounded Context나 외부 시스템에 변경 사실을 알릴 수 있습니다.',0,'Aggregate','2026-01-20 14:59:46.000000','2026-01-20 14:59:46.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (41,1,'DOM-AGG-018','registerEvent() protected 메서드','CRITICAL','STRUCTURE','Aggregate는 도메인 이벤트를 등록하는 protected registerEvent(DomainEvent event) 메서드를 가져야 합니다.','이벤트 등록은 Aggregate 내부에서만 가능하도록 protected로 선언합니다.',0,'Aggregate','2026-01-20 14:59:46.000000','2026-01-20 14:59:46.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (42,1,'DOM-AGG-019','pollEvents() 메서드 (이벤트 수확)','CRITICAL','STRUCTURE','Aggregate는 등록된 이벤트를 수확하는 public List<DomainEvent> pollEvents() 메서드를 가져야 합니다. 호출 후 내부 이벤트 목록은 비워집니다.','Application Layer에서 영속화 후 이벤트를 수확하여 발행합니다.',0,'Aggregate','2026-01-20 14:59:46.000000','2026-01-20 14:59:46.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (43,1,'DOM-AGG-020','Command 메서드는 동사로 시작','MAJOR','NAMING','상태를 변경하는 Command 메서드는 동사로 시작합니다. 예: cancel(), approve(), updateStatus(), changeAddress().','메서드 이름만으로 상태 변경 여부를 파악할 수 있습니다.',0,'Aggregate','2026-01-20 14:59:46.000000','2026-01-20 14:59:46.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (44,1,'DOM-AGG-021','Query 메서드는 get/is/has/can으로 시작','MAJOR','NAMING','상태를 조회하는 Query 메서드는 get, is, has, can으로 시작합니다. 예: getStatus(), isActive(), hasItems(), canCancel().','메서드 이름만으로 조회 메서드임을 파악할 수 있습니다.',0,'Aggregate','2026-01-20 14:59:46.000000','2026-01-20 14:59:46.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (45,1,'DOM-AGG-022','판단 메서드는 boolean 반환','MAJOR','BEHAVIOR','is, has, can으로 시작하는 판단 메서드는 반드시 boolean 타입을 반환합니다.','메서드 시그니처의 일관성을 유지합니다.',0,'Aggregate','2026-01-20 14:59:46.000000','2026-01-20 14:59:46.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (48,1,'DOM-AGG-025','불변식(Invariant) 검증','CRITICAL','BEHAVIOR','Aggregate는 항상 유효한 상태를 유지해야 합니다. 생성 시점과 상태 변경 시점에 불변식을 검증합니다.','비즈니스 규칙 위반을 방지하고 데이터 정합성을 보장합니다.',0,'Aggregate','2026-01-20 14:59:46.000000','2026-01-20 14:59:46.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (49,1,'DOM-AGG-026','equals/hashCode는 ID 기반','MAJOR','STRUCTURE','Aggregate의 equals()와 hashCode()는 ID 필드만을 기반으로 구현합니다.','Entity 동등성은 ID로 판단합니다. 다른 필드 변경 시에도 동일한 객체로 인식되어야 합니다.',0,'Aggregate','2026-01-20 14:59:46.000000','2026-01-20 14:59:46.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (50,1,'DOM-AGG-027','불변 필드는 final 선언','MINOR','STRUCTURE','생성 이후 변경되지 않는 필드는 final로 선언합니다. 예: id, createdAt.','의도를 명확히 하고 실수로 인한 변경을 방지합니다.',0,'Aggregate','2026-01-20 14:59:46.000000','2026-01-20 14:59:46.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (51,1,'DOM-VO-001','VO Record 타입 필수','BLOCKER','STRUCTURE','Value Object는 Java Record로 정의합니다. Record는 불변성, equals/hashCode, toString을 자동으로 보장합니다.','VO의 핵심 특성인 불변성을 언어 수준에서 보장합니다.',0,'ValueObject','2026-01-20 14:59:46.000000','2026-01-20 14:59:46.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (52,1,'DOM-VO-002','VO of() 정적 팩토리 메서드 필수','BLOCKER','STRUCTURE','Value Object는 of() 정적 팩토리 메서드를 제공합니다. 예: Money.of(1000, Currency.KRW).','생성 의도를 명확히 하고 검증 로직을 캡슐화합니다.',0,'ValueObject','2026-01-20 14:59:46.000000','2026-01-20 14:59:46.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (53,1,'DOM-VO-003','VO Compact Constructor 검증 필수','BLOCKER','BEHAVIOR','Record의 Compact Constructor에서 필수 검증을 수행합니다. null 체크, 범위 검증 등을 통해 유효하지 않은 VO 생성을 방지합니다.','VO는 생성 시점부터 항상 유효한 상태여야 합니다.',0,'ValueObject','2026-01-20 14:59:46.000000','2026-01-20 14:59:46.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (54,1,'DOM-VO-004','Enum VO displayName() 필수','CRITICAL','STRUCTURE','Enum 타입의 VO는 사용자 표시용 displayName() 메서드를 제공합니다.','UI에 표시할 때 코드 대신 의미 있는 이름을 사용할 수 있습니다.',0,'ValueObject,Enum','2026-01-20 14:59:46.000000','2026-01-20 14:59:46.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (55,1,'DOM-VO-005','LockKey 인터페이스 구현 (선택적)','CRITICAL','STRUCTURE','분산락이 필요한 VO는 LockKey 인터페이스를 구현하여 getLockKey() 메서드를 제공합니다.','분산 환경에서 동시성 제어를 위한 표준화된 락 키를 제공합니다.',0,'ValueObject','2026-01-20 14:59:46.000000','2026-01-20 14:59:46.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (56,1,'DOM-VO-006','CacheKey 인터페이스 구현 (선택적)','CRITICAL','STRUCTURE','캐싱이 필요한 VO는 CacheKey 인터페이스를 구현하여 getCacheKey() 메서드를 제공합니다.','캐시 키 생성 로직을 표준화하고 캡슐화합니다.',0,'ValueObject','2026-01-20 14:59:46.000000','2026-01-20 14:59:46.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (60,1,'DOM-ID-001','ID VO *Id 네이밍 필수','BLOCKER','NAMING','ID Value Object는 {Domain}Id 형태로 네이밍합니다. 예: OrderId, CustomerId, ProductId.','일관된 네이밍으로 ID VO임을 명확히 구분합니다.',0,'IdValueObject','2026-01-20 14:59:46.000000','2026-01-20 14:59:46.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (61,1,'DOM-ID-002','ID VO Record 타입 필수','BLOCKER','STRUCTURE','ID Value Object는 Java Record로 정의합니다. 예: public record OrderId(Long value) {}.','불변성과 값 동등성을 언어 수준에서 보장합니다.',0,'IdValueObject','2026-01-20 14:59:46.000000','2026-01-20 14:59:46.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (62,1,'DOM-ID-003','ID VO of() 정적 팩토리 메서드 필수','BLOCKER','STRUCTURE','ID VO는 of() 정적 팩토리 메서드를 제공합니다. 예: OrderId.of(1L).','생성 의도를 명확히 하고 검증 로직을 캡슐화합니다.',0,'IdValueObject','2026-01-20 14:59:47.000000','2026-01-20 14:59:47.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (63,1,'DOM-ID-004','Long ID forNew() 필수','BLOCKER','STRUCTURE','Long 타입 ID VO는 forNew() 정적 팩토리 메서드를 제공합니다. 새로 생성되는 Aggregate용입니다.','forNew()는 아직 영속화되지 않은 새 Aggregate를 위한 ID 생성임을 명시합니다.',0,'IdValueObject','2026-01-20 14:59:47.000000','2026-01-20 14:59:47.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (64,1,'DOM-ID-005','Long ID forNew()는 null 반환','BLOCKER','BEHAVIOR','Long 타입 ID VO의 forNew()는 value가 null인 ID를 반환합니다. 예: return new OrderId(null).','null ID는 아직 영속화되지 않았음을 의미합니다. DB에서 auto-increment로 할당됩니다.',0,'IdValueObject','2026-01-20 14:59:47.000000','2026-01-20 14:59:47.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (65,1,'DOM-ID-006','Long ID isNew() 필수','BLOCKER','STRUCTURE','Long 타입 ID VO는 isNew() 메서드를 제공합니다. return value == null;로 구현합니다.','신규 생성 여부를 판단할 때 사용합니다.',0,'IdValueObject','2026-01-20 14:59:47.000000','2026-01-20 14:59:47.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (66,1,'DOM-ID-007','String ID isNew() 금지','BLOCKER','BEHAVIOR','String 타입 ID VO는 isNew() 메서드를 제공하지 않습니다. String ID는 항상 외부에서 주입받아 생성됩니다.','String ID는 UUID 등 외부에서 생성하여 주입하므로 null 상태가 없습니다.',0,'IdValueObject','2026-01-20 14:59:47.000000','2026-01-20 14:59:47.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (67,1,'DOM-ID-008','String ID는 외부에서 주입','BLOCKER','BEHAVIOR','String 타입 ID는 Application Layer(Factory)에서 생성하여 Aggregate에 주입합니다. Domain에서 UUID.randomUUID() 호출 금지.','테스트 가능성 확보. ID 생성 로직을 외부로 분리하여 테스트에서 고정된 ID를 주입할 수 있습니다.',0,'IdValueObject','2026-01-20 14:59:47.000000','2026-01-20 14:59:47.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (70,1,'DOM-EVT-001','DomainEvent 인터페이스 구현 필수','BLOCKER','STRUCTURE','모든 도메인 이벤트는 DomainEvent 인터페이스를 구현해야 합니다.','이벤트 기반 아키텍처에서 일관된 이벤트 처리와 추적을 보장합니다.',0,'DomainEvent','2026-01-20 14:59:47.000000','2026-01-20 14:59:47.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (71,1,'DOM-EVT-002','Event Record 타입 필수','BLOCKER','STRUCTURE','도메인 이벤트는 Java Record로 정의합니다. 이벤트는 반드시 불변이어야 합니다.','이벤트의 불변성을 통해 이벤트 소싱, 감사 로그, 디버깅의 신뢰성을 보장합니다.',0,'DomainEvent','2026-01-20 14:59:47.000000','2026-01-20 14:59:47.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (72,1,'DOM-EVT-003','Event occurredAt 필드 필수','BLOCKER','STRUCTURE','도메인 이벤트는 occurredAt(Instant) 필드를 필수로 포함합니다. 이벤트 발생 시점을 기록합니다.','이벤트 발생 시점 추적과 이벤트 순서 보장에 필요합니다.',0,'DomainEvent','2026-01-20 14:59:47.000000','2026-01-20 14:59:47.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (73,1,'DOM-EVT-004','Event from() 팩토리 메서드 필수','BLOCKER','STRUCTURE','도메인 이벤트는 from(Aggregate, Instant) 정적 팩토리 메서드를 제공합니다. Aggregate에서 필요한 정보를 추출하여 이벤트를 생성합니다.','이벤트 생성 로직을 캡슐화하고 Aggregate의 내부 상태 노출을 최소화합니다.',0,'DomainEvent','2026-01-20 14:59:47.000000','2026-01-20 14:59:47.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (74,1,'DOM-EVT-005','Event 과거형 네이밍 필수','BLOCKER','NAMING','도메인 이벤트는 과거형으로 네이밍합니다. 예: OrderCreatedEvent, PaymentCompletedEvent.','이벤트는 이미 발생한 사실을 나타내므로 과거형을 사용합니다.',0,'DomainEvent','2026-01-20 14:59:47.000000','2026-01-20 14:59:47.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (75,1,'DOM-EVT-006','Event 패키지 위치','BLOCKER','LOCATION','도메인 이벤트는 domain.{bc}.event 패키지에 위치합니다.','이벤트를 별도 패키지로 분리하여 관리합니다.',0,'DomainEvent','2026-01-20 14:59:47.000000','2026-01-20 14:59:47.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (81,1,'DOM-EXC-001','ErrorCode 인터페이스 구현 필수','BLOCKER','STRUCTURE','모든 도메인별 ErrorCode enum은 ErrorCode 인터페이스를 구현해야 합니다.','일관된 에러 코드 체계를 통해 API 응답의 일관성을 보장합니다.',0,'ErrorCode','2026-01-20 14:59:47.000000','2026-01-20 14:59:47.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (82,1,'DOM-EXC-002','ErrorCode 패키지 위치','BLOCKER','LOCATION','ErrorCode enum은 domain.{bc}.exception 패키지에 위치합니다.','예외 관련 코드를 별도 패키지로 분리하여 관리합니다.',0,'ErrorCode','2026-01-20 14:59:47.000000','2026-01-20 14:59:47.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (84,1,'DOM-EXC-004','ErrorCode public 접근 제어자','BLOCKER','STRUCTURE','ErrorCode enum은 public 접근 제어자를 사용합니다.','다른 레이어에서 에러 코드를 참조할 수 있어야 합니다.',0,'ErrorCode','2026-01-20 14:59:47.000000','2026-01-20 14:59:47.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (85,1,'DOM-EXC-005','ErrorCode getCode() 메서드 필수','BLOCKER','STRUCTURE','ErrorCode는 getCode() 메서드를 제공합니다. 형식: {DOMAIN}-{NUMBER} (예: ORD-001).','에러 코드를 통해 문제를 식별하고 문서화할 수 있습니다.',0,'ErrorCode','2026-01-20 14:59:48.000000','2026-01-20 14:59:48.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (86,1,'DOM-EXC-006','ErrorCode getHttpStatus() int 반환','BLOCKER','STRUCTURE','ErrorCode의 getHttpStatus()는 int 타입을 반환합니다. Spring의 HttpStatus를 사용하지 않습니다.','Domain Layer는 Spring에 의존하면 안 됩니다. 원시 타입을 사용합니다.',0,'ErrorCode','2026-01-20 14:59:48.000000','2026-01-20 14:59:48.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (87,1,'DOM-EXC-007','ErrorCode getMessage() 메서드 필수','BLOCKER','STRUCTURE','ErrorCode는 getMessage() 메서드를 제공합니다. 사용자에게 표시할 에러 메시지를 반환합니다.','에러 발생 시 사용자에게 의미 있는 메시지를 제공합니다.',0,'ErrorCode','2026-01-20 14:59:48.000000','2026-01-20 14:59:48.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (89,1,'DOM-EXC-009','DomainException 상속 필수','BLOCKER','STRUCTURE','도메인 레이어의 모든 예외 클래스는 DomainException을 상속받아야 합니다.','공통 예외 처리 로직을 적용하고 ErrorCode 기반의 구조화된 에러 응답을 보장합니다.',0,'Exception','2026-01-20 14:59:48.000000','2026-01-20 14:59:48.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (90,1,'DOM-EXC-010','Exception 패키지 위치','BLOCKER','LOCATION','도메인 예외 클래스는 domain.{bc}.exception 패키지에 위치합니다.','예외를 별도 패키지로 분리하여 관리합니다.',0,'Exception','2026-01-20 14:59:48.000000','2026-01-20 14:59:48.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (94,1,'DOM-EXC-014','Exception public 클래스','BLOCKER','STRUCTURE','도메인 예외는 public 클래스로 선언합니다.','다른 레이어에서 예외를 catch하고 처리할 수 있어야 합니다.',0,'Exception','2026-01-20 14:59:48.000000','2026-01-20 14:59:48.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (95,1,'DOM-EXC-015','Exception RuntimeException 계층','BLOCKER','STRUCTURE','도메인 예외는 RuntimeException 계층입니다. Checked Exception을 사용하지 않습니다.','Unchecked Exception을 사용하여 불필요한 try-catch 블록을 방지합니다.',0,'Exception','2026-01-20 14:59:48.000000','2026-01-20 14:59:48.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (98,1,'DOM-EXC-018','Exception 비즈니스 네이밍','CRITICAL','NAMING','도메인 예외는 비즈니스 의미가 명확한 이름을 사용합니다. 예: OrderNotFoundException, InsufficientBalanceException.','예외 이름만으로 어떤 비즈니스 상황인지 파악할 수 있어야 합니다.',0,'Exception','2026-01-20 14:59:48.000000','2026-01-20 14:59:48.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (99,1,'DOM-EXC-019','DomainException common 패키지','BLOCKER','LOCATION','DomainException 추상 클래스는 domain.common.exception 패키지에 위치합니다.','공통으로 사용되는 기본 예외 클래스는 common 패키지에 위치합니다.',0,'DomainException','2026-01-20 14:59:48.000000','2026-01-20 14:59:48.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (100,1,'DOM-EXC-020','ErrorCode 인터페이스 common 패키지','BLOCKER','LOCATION','ErrorCode 인터페이스는 domain.common.exception 패키지에 위치합니다.','공통으로 사용되는 인터페이스는 common 패키지에 위치합니다.',0,'ErrorCode','2026-01-20 14:59:48.000000','2026-01-20 14:59:48.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (101,1,'DOM-CRI-001','Criteria 패키지 위치','BLOCKER','LOCATION','Criteria는 domain.{bc}.query.criteria 패키지에 위치합니다.','조회 조건을 별도 패키지로 분리하여 관리합니다.',0,'Criteria','2026-01-20 14:59:48.000000','2026-01-20 14:59:48.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (102,1,'DOM-CRI-002','Criteria 네이밍 규칙','BLOCKER','NAMING','Criteria는 {Domain}SliceCriteria 또는 {Domain}SearchCriteria 형태로 네이밍합니다.','일관된 네이밍으로 Criteria 객체임을 명확히 구분합니다.',0,'Criteria','2026-01-20 14:59:48.000000','2026-01-20 14:59:48.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (103,1,'DOM-CRI-003','Criteria public 접근 제어자','BLOCKER','STRUCTURE','Criteria는 public 접근 제어자를 사용합니다.','다른 레이어에서 Criteria를 사용할 수 있어야 합니다.',0,'Criteria','2026-01-20 14:59:48.000000','2026-01-20 14:59:48.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (104,1,'DOM-CRI-004','Criteria Record 타입 필수','BLOCKER','STRUCTURE','Criteria는 Java Record로 정의합니다. 불변성을 보장합니다.','조회 조건은 불변이어야 하며 Record가 이를 보장합니다.',0,'Criteria','2026-01-20 14:59:48.000000','2026-01-20 14:59:48.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (105,1,'DOM-CRI-005','Criteria of() 팩토리 메서드 필수','BLOCKER','STRUCTURE','Criteria는 of() 정적 팩토리 메서드를 제공합니다.','생성 의도를 명확히 하고 기본값 적용 로직을 캡슐화합니다.',0,'Criteria','2026-01-20 14:59:48.000000','2026-01-20 14:59:48.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (110,1,'DOM-CRI-010','Criteria 공통 VO 사용 권장','MINOR','BEHAVIOR','Criteria는 DateRange, CursorQueryContext 등 공통 VO를 사용하여 조회 조건을 구성합니다.','공통 VO를 재사용하여 일관된 조회 패턴을 유지합니다.',0,'Criteria','2026-01-20 14:59:49.000000','2026-01-20 14:59:49.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (111,1,'DOM-CMN-001','순수 자바 객체 원칙 (POJO)','BLOCKER','ANNOTATION','도메인 객체는 순수 자바 객체(POJO)여야 합니다. Lombok(@Data, @Getter, @Setter, @Builder 등), JPA(@Entity, @Table, @Column 등), Spring(@Component, @Service, @Autowired 등) 등 모든 프레임워크/라이브러리 어노테이션 사용을 금지합니다. 도메인 레이어는 인프라스트럭처를 알지 못해야 합니다.','헥사고날 아키텍처에서 도메인 레이어는 가장 안쪽에 위치하며, 외부 프레임워크에 의존하지 않아야 합니다. 이를 통해 도메인 로직의 순수성을 유지하고, 테스트 용이성을 확보하며, 프레임워크 변경에 대한 유연성을 갖출 수 있습니다.',0,'Aggregate, ValueObject, DomainEvent, DomainException, IdValueObject, Criteria','2026-01-20 15:53:15.000000','2026-01-20 15:53:15.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (112,1,'DOM-CMN-002','외부 레이어 의존 금지','BLOCKER','DEPENDENCY','도메인 객체는 Application, Persistence, REST API 레이어를 의존하면 안 됩니다. Repository, Port, Service, Controller, Entity, DTO 등 외부 레이어 클래스를 import하거나 참조할 수 없습니다. 도메인은 오직 자신보다 안쪽에 있는 것만 의존할 수 있습니다.','의존성 역전 원칙(DIP)에 따라 도메인 레이어는 외부 레이어에 의존하지 않습니다. 이를 통해 도메인 로직을 외부 변경으로부터 보호하고, 독립적인 테스트와 재사용이 가능해집니다.',0,'Aggregate, ValueObject, DomainEvent, DomainException, IdValueObject, Criteria','2026-01-20 15:53:34.000000','2026-01-20 15:53:34.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (113,1,'DOM-AGG-028','Collection 불변성 (방어적 복사)','MAJOR','','Aggregate의 Collection 필드를 외부에 노출할 때는 방어적 복사를 사용합니다. List.copyOf(), Set.copyOf(), Collections.unmodifiableList() 등을 사용하여 내부 상태가 외부에서 변경되지 않도록 보호합니다.','Aggregate의 불변식을 보호하기 위해 내부 Collection이 외부에서 직접 수정되는 것을 방지해야 합니다. getter를 통해 원본 Collection을 반환하면 외부에서 add/remove가 가능해져 캡슐화가 깨집니다.',0,'Aggregate','2026-01-21 01:16:57.000000','2026-01-21 01:16:57.000000','2026-01-21 03:08:56.000000');
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (114,1,'DOM-AGG-029','Optional 필드 금지, 반환 타입만 허용','MAJOR','','Aggregate의 필드에 Optional을 사용하지 않습니다. Optional은 메서드 반환 타입으로만 사용하며, null이 될 수 있는 필드는 nullable로 선언하고 getter에서 Optional로 감싸서 반환합니다.','Optional은 반환 타입을 위해 설계되었습니다. 필드로 사용하면 직렬화 문제, 메모리 오버헤드, null 체크의 이중화 등 문제가 발생합니다. Brian Goetz(Java 아키텍트)도 필드 사용을 권장하지 않습니다.',0,'Aggregate, ValueObject','2026-01-21 01:16:57.000000','2026-01-21 01:16:57.000000','2026-01-21 03:08:56.000000');
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (115,2,'APP-TRX-001','Service @Transactional 금지','BLOCKER','STRUCTURE','Service는 조율만 담당하며 @Transactional을 직접 선언하지 않습니다. 트랜잭션은 Manager/Facade에서 관리합니다.',NULL,0,NULL,'2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (116,2,'APP-TRX-002','Manager @Transactional 필수','BLOCKER','STRUCTURE','CommandManager/QueryManager는 @Transactional 필수입니다. QueryManager는 readOnly=true 사용.',NULL,0,NULL,'2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (117,2,'APP-TRX-003','ClientManager @Transactional 금지','BLOCKER','STRUCTURE','ClientManager는 외부 호출이므로 트랜잭션 밖에서 실행해야 합니다. @Transactional 금지.',NULL,0,NULL,'2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (118,2,'APP-TRX-004','CommandFacade @Transactional 선택','MAJOR','STRUCTURE','CommandFacade는 DB 원자성 필요 시에만 @Transactional 사용. 불필요한 트랜잭션 범위 확대 금지.',NULL,0,NULL,'2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (119,2,'APP-TRX-005','QueryFacade @Transactional(readOnly=true)','MAJOR','STRUCTURE','QueryFacade는 복합 조회용이므로 @Transactional(readOnly=true) 사용.',NULL,0,NULL,'2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (120,2,'APP-DEP-001','Service → Facade/Manager 의존','CRITICAL','BEHAVIOR','Service는 Facade 또는 Manager에 의존합니다. Manager 1개면 직접, 2개 이상이면 Facade 사용.',NULL,0,NULL,'2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (121,2,'APP-DEP-002','Facade → Manager 의존 (같은 CQRS)','CRITICAL','BEHAVIOR','Facade는 같은 CQRS 범위의 Manager만 의존합니다. CommandFacade → CommandManager만 허용.',NULL,0,NULL,'2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (122,2,'APP-DEP-003','CommandFacade → QueryManager 금지 (CQRS)','BLOCKER','BEHAVIOR','CQRS 원칙에 따라 CommandFacade에서 QueryManager 의존이 금지됩니다. 조회가 필요하면 Service에서 분리.',NULL,0,NULL,'2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (123,2,'APP-DEP-004','Validator → 단일 도메인 ReadManager만','CRITICAL','BEHAVIOR','Validator는 자기 도메인의 ReadManager(QueryManager)만 의존합니다. 복합 Validator 금지.',NULL,0,NULL,'2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (124,2,'APP-DEP-005','Internal → Manager 의존 (Port 직접 금지)','CRITICAL','BEHAVIOR','Calculator, Resolver 등 Internal 컴포넌트는 Manager를 통해 데이터 접근. Port 직접 의존 금지.',NULL,0,NULL,'2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (125,2,'APP-DTO-001','Command/Query Record 필수','BLOCKER','STRUCTURE','Command, Query DTO는 반드시 Record로 정의합니다. Lombok 금지.',NULL,0,NULL,'2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (126,2,'APP-DTO-002','Command/Query 인스턴스 메서드 금지','BLOCKER','STRUCTURE','Command/Query DTO는 순수 데이터 컨테이너입니다. 인스턴스 메서드, Compact Constructor 로직, 기본값 처리 모두 금지.',NULL,0,NULL,'2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (127,2,'APP-DTO-003','SearchParams CommonSearchParams 포함 필수','CRITICAL','STRUCTURE','*SearchParams는 CommonSearchParams를 필수로 포함합니다.',NULL,0,NULL,'2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (128,2,'APP-DTO-004','CursorParams CommonCursorParams 포함 필수','CRITICAL','STRUCTURE','*CursorParams는 CommonCursorParams를 필수로 포함합니다.',NULL,0,NULL,'2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (129,2,'APP-DTO-005','Bundle withId() 패턴','MAJOR','STRUCTURE','Bundle DTO는 withId() 메서드로 상위-하위 ID 연결 로직을 캡슐화합니다.',NULL,0,NULL,'2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (130,2,'APP-PRT-001','CommandPort persist/persistAll만','CRITICAL','STRUCTURE','CommandPort는 persist, persistAll 메서드만 허용됩니다. update 메서드 금지 (JPA Dirty Checking 사용).',NULL,0,NULL,'2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (131,2,'APP-PRT-002','QueryPort findAll 금지 (OOM)','BLOCKER','STRUCTURE','QueryPort에서 findAll 금지. 전체 데이터 로딩은 OOM 위험. 반드시 findBySliceCriteria 사용.',NULL,0,NULL,'2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (132,2,'APP-PRT-003','QueryPort 네이밍 규칙','MAJOR','NAMING','QueryPort 메서드는 findById, findBy*, findBySliceCriteria, existsBy*, countBy* 패턴을 사용합니다.',NULL,0,NULL,'2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (133,2,'APP-EVT-001','ApplicationEventPublisher 직접 주입 금지','BLOCKER','BEHAVIOR','Service에서 ApplicationEventPublisher 직접 주입이 금지됩니다. 트랜잭션 안전성 보장 불가.',NULL,0,NULL,'2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (134,2,'APP-EVT-002','TransactionEventRegistry 사용 필수','BLOCKER','BEHAVIOR','도메인 이벤트 발행 시 TransactionEventRegistry 사용 필수. 트랜잭션 커밋 후 이벤트 발행 보장.',NULL,0,NULL,'2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (135,2,'APP-TIM-001','TimeProvider Factory에서만','BLOCKER','BEHAVIOR','TimeProvider.now()는 Factory에서만 호출합니다. Service에서 직접 사용 금지. Factory가 생성한 Context로 시간 전달.',NULL,0,NULL,'2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (136,2,'APP-FAC-001','Factory 사용 기준','MAJOR','STRUCTURE','복잡한 생성(Bundle), 업데이트(UpdateContext), 상태변경(StatusChangeContext)은 Factory 사용. 단순 조회(ID만)는 Service에서 직접.',NULL,0,NULL,'2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (137,2,'APP-VAL-001','Validator Domain 반환','CRITICAL','BEHAVIOR','Validator의 validate*Exists 메서드는 검증 성공 시 조회한 Domain 객체를 반환합니다.',NULL,0,NULL,'2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (138,2,'APP-VAL-002','Validator 도메인 전용 예외','CRITICAL','BEHAVIOR','Validator는 도메인 전용 예외(OrderNotFoundException 등)를 발생시킵니다. 범용 예외 클래스 사용 금지.',NULL,0,NULL,'2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (139,2,'APP-ASM-001','도메인별 구체 Result 클래스','CRITICAL','STRUCTURE','Assembler는 도메인별 구체 Result 클래스(OrderSliceResult 등)를 반환합니다. 제네릭 래퍼(SliceResult<T>) 금지.',NULL,0,NULL,'2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (140,2,'APP-ASM-002','생성 응답 원시타입 ID','MAJOR','BEHAVIOR','생성(Create) UseCase는 원시타입(Long)만 반환합니다. Assembler 불필요.',NULL,0,NULL,'2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (141,2,'APP-SVC-001','UseCase 1:1 Service 구현','CRITICAL','STRUCTURE','1 UseCase = 1 Service. UseCase 인터페이스명에서 UseCase → Service로 변경.',NULL,0,NULL,'2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (142,2,'APP-SVC-002','UseCase 네이밍 규칙','MAJOR','NAMING','Command: Create*, Update*, Delete*, Cancel*, Approve*, Reject*. Query: Get*, Get*s, Get*By*, Check*Exists, Count*.',NULL,0,NULL,'2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (143,2,'APP-EXC-001','도메인 전용 예외 클래스 사용','CRITICAL','BEHAVIOR','범용 예외 클래스(EntityNotFoundException) 금지. 도메인별 전용 예외(OrderNotFoundException) 사용 필수.',NULL,0,NULL,'2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (144,2,'APP-EXC-002','DomainException 직접 사용 금지','CRITICAL','BEHAVIOR','DomainException을 직접 throw하지 않습니다. 도메인별 전용 예외 클래스를 상속하여 사용.',NULL,0,NULL,'2026-01-21 05:26:56.000000','2026-01-21 05:26:56.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (145,2,'APP-LSN-001','EventListener @Async 권장','MAJOR','BEHAVIOR','EventListener는 비동기 처리를 권장합니다. 동기 처리 시 트랜잭션 문제 발생 가능.',NULL,0,NULL,'2026-01-21 05:39:51.000000','2026-01-21 05:39:51.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (146,2,'APP-LSN-002','EventListener Manager 의존','CRITICAL','DEPENDENCY','EventListener는 Manager에 의존하여 비즈니스 로직을 처리합니다. Port 직접 의존 금지.',NULL,0,NULL,'2026-01-21 05:39:51.000000','2026-01-21 05:39:51.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (147,3,'PER-REP-001','JpaRepository save/saveAll만 사용','BLOCKER','STRUCTURE','JpaRepository는 save, saveAll 메서드만 사용합니다. 다른 조회/삭제 메서드는 QueryDslRepository에서 처리합니다.','CQRS 패턴 준수. Command와 Query 분리를 통해 확장성과 유지보수성 향상.',0,'JPA_REPOSITORY','2026-01-21 07:49:21.000000','2026-01-21 07:49:21.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (148,3,'PER-REP-002','JpaRepository 커스텀 메서드 금지','BLOCKER','STRUCTURE','JpaRepository에 커스텀 쿼리 메서드(@Query, findBy* 등)를 추가하지 않습니다.','모든 조회 로직은 QueryDslRepository로 일원화하여 쿼리 관리 일관성 유지.',0,'JPA_REPOSITORY','2026-01-21 07:49:21.000000','2026-01-21 07:49:21.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (149,3,'PER-REP-003','모든 조회는 QueryDslRepository','BLOCKER','STRUCTURE','모든 조회 쿼리는 QueryDslRepository에서 QueryDSL을 사용하여 구현합니다. JPQL, Native Query 금지.','타입 안전한 쿼리 작성, 컴파일 타임 오류 검출, 동적 쿼리 구성 용이.',0,'QUERYDSL_REPOSITORY','2026-01-21 07:49:21.000000','2026-01-21 07:49:21.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (150,3,'PER-ADP-001','CommandAdapter는 JpaRepository만 의존','BLOCKER','DEPENDENCY','CommandAdapter는 오직 JpaRepository만 의존합니다. QueryDslRepository를 주입받지 않습니다.','CQRS 원칙 준수. Command 경로에서 조회 로직 혼입 방지.',0,'COMMAND_ADAPTER','2026-01-21 07:49:21.000000','2026-01-21 07:49:21.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (151,3,'PER-ADP-002','QueryAdapter는 QueryDslRepository만 의존','BLOCKER','DEPENDENCY','QueryAdapter는 오직 QueryDslRepository만 의존합니다. JpaRepository를 주입받지 않습니다.','CQRS 원칙 준수. Query 경로에서 변경 로직 혼입 방지.',0,'QUERY_ADAPTER','2026-01-21 07:49:21.000000','2026-01-21 07:49:21.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (152,3,'PER-ENT-001','JPA 관계 어노테이션 금지','BLOCKER','ANNOTATION','@OneToMany, @ManyToOne, @OneToOne, @ManyToMany 관계 어노테이션을 사용하지 않습니다. Long FK 전략 사용.','N+1 문제 원천 차단, 명시적 조인으로 성능 제어, 도메인 경계 명확화.',0,'JPA_ENTITY','2026-01-21 07:49:21.000000','2026-01-21 07:49:21.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (153,3,'PER-ENT-002','Entity는 BaseAuditEntity 상속','MAJOR','STRUCTURE','모든 JpaEntity는 BaseAuditEntity(audit만) 또는 SoftDeletableEntity(audit+soft delete)를 상속합니다.','Audit 필드 일관성, 코드 중복 제거, 감사 추적 표준화.',0,'JPA_ENTITY','2026-01-21 07:49:21.000000','2026-01-21 07:49:21.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (154,3,'PER-CFG-001','OSIV 비활성화 필수','BLOCKER','STRUCTURE','Open Session In View를 반드시 비활성화합니다. spring.jpa.open-in-view=false','커넥션 점유 시간 최소화, Lazy Loading은 Transaction 내에서만 수행.',0,'JPA_CONFIG','2026-01-21 07:49:21.000000','2026-01-21 07:49:21.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (155,3,'PER-CFG-002','DDL-AUTO는 validate만 허용','BLOCKER','STRUCTURE','Hibernate ddl-auto는 validate만 사용합니다. 스키마 변경은 Flyway로 관리.','운영 환경 스키마 안정성, 마이그레이션 이력 관리, 롤백 가능성 확보.',0,'JPA_CONFIG','2026-01-21 07:49:21.000000','2026-01-21 07:49:21.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (156,3,'PER-CND-001','BooleanExpression은 ConditionBuilder로 분리','MAJOR','STRUCTURE','QueryDslRepository의 where절 조건은 별도 ConditionBuilder 클래스에서 BooleanExpression 메서드로 분리합니다.','조건 로직 재사용, Repository 가독성 향상, 테스트 용이성.',0,'CONDITION_BUILDER','2026-01-21 07:49:21.000000','2026-01-21 07:49:21.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (157,3,'PER-CND-002','deletedAt null 조건 필수','BLOCKER','BEHAVIOR','Soft Delete 테이블 조회 시 반드시 deletedAt IS NULL 조건을 포함합니다.','삭제된 데이터 조회 방지, 데이터 무결성 보장.',0,'CONDITION_BUILDER,QUERYDSL_REPOSITORY','2026-01-21 07:49:21.000000','2026-01-21 07:49:21.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (158,3,'PER-MAP-001','EntityMapper 양방향 변환','MAJOR','STRUCTURE','EntityMapper는 toDomain(Entity)과 toEntity(Domain) 양방향 변환 메서드를 제공합니다.','도메인-영속성 변환 표준화, 의존성 방향 준수.',0,'ENTITY_MAPPER','2026-01-21 07:49:21.000000','2026-01-21 07:49:21.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (159,3,'PER-FTS-001','FullText는 FunctionContributor 등록','MAJOR','STRUCTURE','MySQL MATCH AGAINST 사용 시 Hibernate FunctionContributor를 META-INF/services에 등록합니다.','Native Query 의존 제거, QueryDSL 통합, 타입 안전성 확보.',0,'FUNCTION_CONTRIBUTOR','2026-01-21 07:49:21.000000','2026-01-21 07:49:21.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (160,3,'PER-ADM-001','Admin 복잡 쿼리는 persistence-mysql-admin 모듈','BLOCKER','LOCATION','조인, 서브쿼리 등 복잡한 쿼리는 persistence-mysql-admin 모듈에서만 허용됩니다. 도메인용 persistence-mysql에서는 단일 테이블 쿼리만 허용.','도메인 모듈의 순수성 유지, OLTP/OLAP 분리, 정책 명확화.',0,'ADMIN_QUERYDSL_REPOSITORY','2026-01-21 07:59:04.000000','2026-01-21 07:59:04.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (161,3,'PER-ADM-002','Admin 모듈은 조인 허용','INFO','STRUCTURE','persistence-mysql-admin 모듈에서는 leftJoin, innerJoin 등 조인이 허용됩니다. 단, DTO Projection 필수.','Admin/통계용 복잡 쿼리 지원, OLAP 최적화.',0,'ADMIN_QUERYDSL_REPOSITORY','2026-01-21 07:59:04.000000','2026-01-21 07:59:04.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (165,4,'API-CTR-001','@RestController 어노테이션 필수','CRITICAL','ANNOTATION','Controller 클래스는 반드시 @RestController 어노테이션을 사용해야 합니다.','@Controller + @ResponseBody 조합 대신 @RestController로 명시적으로 REST API임을 선언합니다.',1,'Controller','2026-01-21 13:25:01.000000','2026-01-21 13:25:01.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (166,4,'API-CTR-002','DELETE 메서드 금지','BLOCKER','BEHAVIOR','HTTP DELETE 메서드 사용을 금지합니다. 대신 PATCH /{id}/delete로 soft delete를 구현해야 합니다.','데이터 복구 가능성과 감사 추적을 위해 물리 삭제 대신 논리 삭제(soft delete)를 사용합니다.',0,'Controller','2026-01-21 13:25:01.000000','2026-01-21 13:25:01.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (167,4,'API-CTR-003','UseCase 인터페이스 의존','CRITICAL','DEPENDENCY','Controller는 Application Layer의 UseCase(Port-In) 인터페이스에만 의존해야 합니다. 구체 Service 클래스 직접 의존 금지.','헥사고날 아키텍처의 포트-어댑터 패턴을 준수하여 계층 간 결합도를 낮춥니다.',0,'Controller','2026-01-21 13:25:01.000000','2026-01-21 13:25:01.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (168,4,'API-CTR-004','ResponseEntity + ApiResponse 래핑','CRITICAL','STRUCTURE','모든 응답은 ResponseEntity<ApiResponse<T>> 형태로 래핑해야 합니다.','일관된 API 응답 형식을 제공하고, timestamp, requestId 등 공통 메타데이터를 포함합니다.',0,'Controller','2026-01-21 13:25:01.000000','2026-01-21 13:25:01.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (169,4,'API-CTR-005','Controller @Transactional 금지','BLOCKER','ANNOTATION','Controller에서 @Transactional 어노테이션 사용을 금지합니다. 트랜잭션은 Application Layer에서 관리합니다.','Controller는 HTTP 요청/응답만 담당하며, 비즈니스 로직과 트랜잭션 경계는 Application Layer의 책임입니다.',1,'Controller','2026-01-21 13:25:01.000000','2026-01-21 13:25:01.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (170,4,'API-CTR-006','OpenAPI 어노테이션 필수','MAJOR','ANNOTATION','@Tag, @Operation, @ApiResponses 어노테이션을 반드시 사용해야 합니다.','Swagger/OpenAPI 문서 자동 생성을 위해 API 메타데이터를 어노테이션으로 선언합니다.',0,'Controller','2026-01-21 13:25:01.000000','2026-01-21 13:25:01.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (171,4,'API-CTR-007','Controller 비즈니스 로직 금지','MAJOR','BEHAVIOR','Controller에 비즈니스 로직을 작성하지 않습니다. 변환 로직은 Mapper에 위임합니다.','Controller는 얇은(thin) 레이어로 유지하고, 요청 수신과 응답 반환만 담당합니다.',0,'Controller','2026-01-21 13:25:20.000000','2026-01-21 13:25:20.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (172,4,'API-CTR-008','Endpoints 상수 사용','MAJOR','STRUCTURE','경로를 하드코딩하지 않고 *ApiEndpoints 상수 클래스를 사용해야 합니다.','경로 관리의 일관성과 오타 방지, IDE 자동완성 지원을 위해 상수로 관리합니다.',0,'Controller','2026-01-21 13:25:20.000000','2026-01-21 13:25:20.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (173,4,'API-CTR-009','@Valid 어노테이션 필수','MAJOR','ANNOTATION','Request DTO 파라미터에 @Valid 어노테이션을 반드시 사용해야 합니다.','Jakarta Validation을 통한 입력값 검증을 활성화하여 비즈니스 로직 진입 전 유효성을 검사합니다.',1,'Controller','2026-01-21 13:25:20.000000','2026-01-21 13:25:20.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (174,4,'API-CTR-010','CQRS Controller 분리','MAJOR','STRUCTURE','Command(CUD)와 Query(R) Controller를 별도 클래스로 분리해야 합니다.','CQRS 패턴에 따라 명령과 조회의 책임을 분리하여 코드 복잡도를 낮춥니다.',0,'Controller','2026-01-21 13:25:20.000000','2026-01-21 13:25:20.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (175,4,'API-CTR-011','List 직접 반환 금지','BLOCKER','STRUCTURE','목록 조회 시 List를 직접 반환하지 않습니다. SliceApiResponse 또는 PageApiResponse를 사용해야 합니다.','페이지네이션 메타 정보(hasNext, cursor, totalPages 등)를 함께 제공하여 클라이언트의 페이징 처리를 지원합니다.',0,'Controller','2026-01-21 13:25:20.000000','2026-01-21 13:25:20.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (176,4,'API-CTR-012','URL 경로 규칙','MINOR','NAMING','URL 경로는 소문자 + 복수형을 사용합니다. 예: /conventions, /modules','RESTful API 네이밍 컨벤션을 준수하여 일관된 API 설계를 유지합니다.',0,'Controller','2026-01-21 13:25:20.000000','2026-01-21 13:25:20.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (177,4,'API-DTO-001','Record 타입 필수','CRITICAL','STRUCTURE','Request/Response DTO는 Java Record를 사용해야 합니다.','Record는 불변성을 보장하고 boilerplate 코드를 줄여줍니다.',0,'DTO','2026-01-21 13:25:41.000000','2026-01-21 13:25:41.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (178,4,'API-DTO-002','DTO 불변성 보장','CRITICAL','STRUCTURE','DTO는 불변 객체로 설계해야 합니다. Setter 금지.','불변 객체는 스레드 안전하고 부수효과가 없어 예측 가능한 동작을 보장합니다.',0,'DTO','2026-01-21 13:25:41.000000','2026-01-21 13:25:41.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (179,4,'API-DTO-003','Validation 어노테이션','MAJOR','ANNOTATION','Request DTO에 Jakarta Validation 어노테이션(@NotNull, @NotBlank 등)을 사용해야 합니다.','입력값 검증을 선언적으로 수행하여 컨트롤러 코드를 간결하게 유지합니다.',0,'Request DTO','2026-01-21 13:25:41.000000','2026-01-21 13:25:41.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (180,4,'API-DTO-004','createdAt/updatedAt 필수','CRITICAL','STRUCTURE','Response DTO에는 createdAt, updatedAt 필드가 반드시 포함되어야 합니다.','생성/수정 시각 정보는 클라이언트의 캐싱, 정렬, 표시에 필수적인 메타데이터입니다.',0,'Response DTO','2026-01-21 13:25:41.000000','2026-01-21 13:25:41.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (181,4,'API-DTO-005','날짜 String 변환 필수','CRITICAL','STRUCTURE','Instant 타입은 DateTimeFormatUtils.formatIso8601()로 String 변환하여 반환해야 합니다.','ISO 8601 형식의 문자열로 제공하여 클라이언트의 타임존 처리를 용이하게 합니다.',0,'Response DTO','2026-01-21 13:25:41.000000','2026-01-21 13:25:41.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (182,4,'API-DTO-006','Nested Record 허용','MINOR','STRUCTURE','복잡한 구조는 중첩 Record로 표현할 수 있습니다.','관련 필드를 그룹화하여 API 응답의 구조를 명확하게 표현합니다.',0,'DTO','2026-01-21 13:25:41.000000','2026-01-21 13:25:41.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (183,4,'API-DTO-007','@Schema 어노테이션 권장','MINOR','ANNOTATION','OpenAPI 문서화를 위해 @Schema 어노테이션 사용을 권장합니다.','API 문서에 필드 설명, 예시값, 제약조건을 명시하여 개발자 경험을 향상시킵니다.',0,'DTO','2026-01-21 13:25:41.000000','2026-01-21 13:25:41.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (184,4,'API-DTO-008','Optional 대신 Nullable','MAJOR','STRUCTURE','Optional 대신 @Nullable 또는 기본값을 사용합니다.','DTO에서 Optional은 직렬화 이슈가 있고, null 허용을 명시적으로 표현하는 것이 더 명확합니다.',0,'DTO','2026-01-21 13:25:41.000000','2026-01-21 13:25:41.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (185,4,'API-DTO-009','List 필드 불변 복사','MAJOR','STRUCTURE','List 필드는 생성자에서 List.copyOf()로 방어적 복사해야 합니다.','외부에서 전달받은 컬렉션의 변경으로부터 DTO 내부 상태를 보호합니다.',0,'DTO','2026-01-21 13:25:41.000000','2026-01-21 13:25:41.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (186,4,'API-MAP-001','@Component 필수','CRITICAL','ANNOTATION','Mapper 클래스는 @Component 어노테이션으로 Spring Bean 등록해야 합니다.','DI를 통한 테스트 용이성과 일관된 관리를 위해 Spring Bean으로 등록합니다.',1,'Mapper','2026-01-21 13:25:56.000000','2026-01-21 13:25:56.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (187,4,'API-MAP-002','양방향 변환 지원','CRITICAL','BEHAVIOR','Mapper는 Request→Application Query/Command, Application Result→Response 양방향 변환을 지원해야 합니다.','API 경계의 모든 변환 로직을 Mapper에 집중하여 Controller를 얇게 유지합니다.',0,'Mapper','2026-01-21 13:25:56.000000','2026-01-21 13:25:56.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (188,4,'API-MAP-003','날짜 포맷팅 담당','CRITICAL','BEHAVIOR','Response 생성 시 DateTimeFormatUtils.formatIso8601()로 날짜를 포맷팅해야 합니다.','Instant→String 변환 로직을 Mapper에 일원화하여 일관된 날짜 형식을 보장합니다.',0,'Mapper','2026-01-21 13:25:56.000000','2026-01-21 13:25:56.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (189,4,'API-MAP-004','Slice/Page 변환 지원','MAJOR','BEHAVIOR','SliceResult/PageResult를 SliceApiResponse/PageApiResponse로 변환하는 메서드를 제공해야 합니다.','페이지네이션 결과의 변환 로직을 Mapper에 캡슐화합니다.',0,'Mapper','2026-01-21 13:25:56.000000','2026-01-21 13:25:56.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (190,4,'API-MAP-005','순수 변환 로직만','MAJOR','BEHAVIOR','Mapper는 순수 변환 로직만 담당합니다. 비즈니스 로직 금지.','Mapper의 단일 책임을 유지하여 테스트와 유지보수를 용이하게 합니다.',0,'Mapper','2026-01-21 13:25:56.000000','2026-01-21 13:25:56.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (191,4,'API-MAP-006','기본값 처리 담당','MAJOR','BEHAVIOR','Request에서 null인 필드의 기본값 처리는 Mapper에서 수행합니다.','Request DTO는 기본값 없이 원시 입력을 받고, Mapper에서 정책에 따라 기본값을 설정합니다.',0,'Mapper','2026-01-21 13:25:56.000000','2026-01-21 13:25:56.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (192,4,'API-ERR-001','ErrorMapper 패턴','CRITICAL','STRUCTURE','도메인별 ErrorMapper를 구현하여 DomainException을 HTTP 응답으로 매핑해야 합니다.','예외 처리 로직을 ErrorMapper에 캡슐화하여 GlobalExceptionHandler를 얇게 유지합니다.',0,'ErrorMapper','2026-01-21 13:26:09.000000','2026-01-21 13:26:09.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (193,4,'API-ERR-002','ProblemDetail 응답','CRITICAL','STRUCTURE','에러 응답은 RFC 7807 ProblemDetail 형식을 사용해야 합니다.','표준화된 에러 응답 형식으로 클라이언트의 에러 처리를 일관되게 합니다.',0,'ErrorMapper','2026-01-21 13:26:09.000000','2026-01-21 13:26:09.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (194,4,'API-ERR-003','x-error-code 헤더','MAJOR','STRUCTURE','ProblemDetail에 x-error-code 확장 헤더를 추가해야 합니다.','에러 코드를 헤더로 제공하여 클라이언트의 조건부 에러 처리를 지원합니다.',0,'ErrorMapper','2026-01-21 13:26:09.000000','2026-01-21 13:26:09.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (195,4,'API-ERR-004','GlobalExceptionHandler 사용','CRITICAL','STRUCTURE','전역 예외 처리기(GlobalExceptionHandler)를 사용해야 합니다.','Controller별 예외 처리 중복을 제거하고 일관된 에러 응답을 보장합니다.',0,'ErrorHandler','2026-01-21 13:26:09.000000','2026-01-21 13:26:09.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (196,4,'API-ERR-005','application/problem+json','MAJOR','STRUCTURE','에러 응답의 Content-Type은 application/problem+json이어야 합니다.','RFC 7807 표준에 따른 Content-Type으로 클라이언트가 에러 응답임을 인식할 수 있게 합니다.',0,'ErrorHandler','2026-01-21 13:26:09.000000','2026-01-21 13:26:09.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (197,4,'API-CFG-001','JacksonConfig 설정','MAJOR','STRUCTURE','ObjectMapper 설정을 JacksonConfig에서 중앙 관리한다. PropertyNamingStrategies.SNAKE_CASE, JavaTimeModule 등록 필수.','JSON 직렬화/역직렬화 일관성 보장 및 Java 8+ 시간 타입 지원',0,'JacksonConfig','2026-01-21 13:27:27.000000','2026-01-21 13:27:27.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (198,4,'API-CFG-002','OpenApiConfig 설정','MINOR','STRUCTURE','Swagger/OpenAPI 문서화 설정을 OpenApiConfig에서 관리한다. GroupedOpenApi로 API 그룹핑.','API 문서 자동 생성 및 버전 관리',0,'OpenApiConfig','2026-01-21 13:27:27.000000','2026-01-21 13:27:27.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (199,4,'API-CFG-003','WebMvcConfig 설정','MAJOR','STRUCTURE','CORS, Interceptor, ArgumentResolver 설정을 WebMvcConfig에서 관리한다.','MVC 설정 중앙 집중화',0,'WebMvcConfig','2026-01-21 13:27:27.000000','2026-01-21 13:27:27.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (200,4,'API-CFG-004','서버 프리픽스 경로','MAJOR','NAMING','server.servlet.context-path=/api/v1/mcp 설정으로 모든 API 경로에 프리픽스 적용.','버전 관리 및 API Gateway 라우팅 지원',0,'application.yml','2026-01-21 13:27:27.000000','2026-01-21 13:27:27.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (201,4,'API-END-001','Endpoints final class','MAJOR','STRUCTURE','API 엔드포인트 상수 클래스는 final class로 선언하고 private 생성자를 가진다.','상속 방지 및 인스턴스화 방지로 유틸리티 클래스 패턴 준수',1,'*ApiEndpoints','2026-01-21 13:27:44.000000','2026-01-21 13:27:44.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (202,4,'API-END-002','static final 상수','MAJOR','NAMING','모든 경로 상수는 public static final String으로 선언한다. 예: public static final String CONVENTIONS = \"/conventions\";','컴파일 타임 상수 보장 및 경로 중앙 관리',1,'*ApiEndpoints','2026-01-21 13:27:44.000000','2026-01-21 13:27:44.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (203,4,'API-END-003','Path Variable 상수','MINOR','NAMING','PathVariable 이름도 상수로 관리한다. 예: public static final String PATH_ID = \"conventionId\";','오타 방지 및 일관된 경로 변수명 사용',1,'*ApiEndpoints','2026-01-21 13:27:44.000000','2026-01-21 13:27:44.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (204,4,'API-END-004','도메인별 Endpoints 분리','MAJOR','STRUCTURE','각 도메인(Convention, Module 등)별로 별도의 *ApiEndpoints 클래스를 생성한다.','관심사 분리 및 유지보수성 향상',0,'*ApiEndpoints','2026-01-21 13:27:44.000000','2026-01-21 13:27:44.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (205,4,'API-TST-001','MockMvc 금지','CRITICAL','TESTING','❌ MockMvc 사용 금지. 실제 HTTP 요청/응답 검증을 위해 TestRestTemplate 사용 필수.','MockMvc는 서블릿 컨테이너 없이 테스트하므로 실제 HTTP 동작과 차이 발생',0,'*ControllerTest','2026-01-21 13:27:59.000000','2026-01-21 13:27:59.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (206,4,'API-TST-002','TestRestTemplate 사용','CRITICAL','TESTING','✅ @SpringBootTest(webEnvironment = RANDOM_PORT) + TestRestTemplate으로 통합 테스트 작성.','실제 서블릿 컨테이너에서 HTTP 요청/응답 검증',0,'*ControllerTest','2026-01-21 13:27:59.000000','2026-01-21 13:27:59.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (207,4,'API-TST-003','ParameterizedTypeReference 사용','MAJOR','TESTING','ApiResponse<T> 제네릭 응답 역직렬화 시 ParameterizedTypeReference 사용 필수.','제네릭 타입 정보 보존을 위한 Type Token 패턴',0,'*ControllerTest','2026-01-21 13:27:59.000000','2026-01-21 13:27:59.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (208,4,'API-TST-004','Fixture 패턴','MAJOR','TESTING','테스트 데이터 생성은 *Fixture 클래스에서 static factory 메서드로 제공. 예: CreateOrderApiRequestFixture.valid()','테스트 데이터 중앙 관리 및 재사용성 향상',0,'*Fixture','2026-01-21 13:27:59.000000','2026-01-21 13:27:59.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (209,4,'API-TST-005','ErrorMapper 단위 테스트','MAJOR','TESTING','ErrorMapper는 supports() + map() 메서드 단위 테스트 필수. 도메인 예외별 HTTP 상태 코드 검증.','예외 처리 로직 안정성 보장',0,'*ErrorMapperTest','2026-01-21 13:27:59.000000','2026-01-21 13:27:59.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (210,2,'APP-PRT-004','Port 파라미터 Domain VO 사용 원칙','MAJOR','STRUCTURE','Port/UseCase 인터페이스의 파라미터는 원시타입 대신 Domain VO(Value Object)를 사용합니다.\n\n✅ 올바른 예:\nOptional<Order> findById(OrderId id);\nboolean existsByCustomerId(CustomerId customerId);\n\n⚠️ 예외 허용 (nullable 파라미터):\nList<Order> search(@Nullable Long customerId, OrderStatus status);\n\n❌ 잘못된 예:\nOptional<Order> findById(Long id);  // 원시타입 사용\nboolean exists(Long customerId);    // VO 없이 원시타입','Domain VO 사용의 이점:\n1. 타입 안전성: 컴파일 타임에 파라미터 혼동 방지 (Long customerId vs Long orderId)\n2. 도메인 언어 일관성: 유비쿼터스 언어를 인터페이스에 반영\n3. 검증 보장: VO 생성 시 유효성 검증이 이미 완료됨\n4. 의도 명확화: 파라미터의 비즈니스 의미가 타입으로 표현됨\n\nnullable 파라미터 예외 이유:\n- 검색 조건 등에서 null 허용이 필요한 경우 VO로 감싸면 불필요한 복잡성 증가\n- Optional.ofNullable(vo).map(Vo::value) 패턴의 반복을 피함',0,'*Port,*UseCase','2026-01-22 00:42:12.000000','2026-01-22 00:42:12.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (211,4,'API-CTR-013','Controller 조회 메서드명 규칙','MAJOR','NAMING','복합 조건 + 페이징/커서 조회: search{Bc}(Offset), search{Bc}ByCursor(커서). 단순 목록 조회: list{Bc}(필터 없음)','조회 API의 일관된 네이밍으로 클라이언트가 페이징 방식을 명확히 인지할 수 있음',0,'Controller','2026-01-22 02:11:08.000000','2026-01-22 02:11:08.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (212,4,'API-DTO-010','Request DTO 조회 네이밍 규칙','MAJOR','NAMING','Offset 페이징: Search{Bc}ApiRequest. 커서 기반: Search{Bc}CursorApiRequest. 단순 목록: List{Bc}ApiRequest','Request DTO 네이밍으로 페이징 방식을 명확히 구분하여 API 문서화와 클라이언트 사용성 향상',0,'ApiRequest','2026-01-22 02:11:26.000000','2026-01-22 02:11:26.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (213,2,'APP-UC-001','UseCase 조회 네이밍 규칙','MAJOR','NAMING','커서 기반 조회: Search{Domain}ByCursorUseCase. Offset 페이징: Search{Domain}UseCase. GetAll 네이밍 금지','UseCase 네이밍에 조회 방식을 명시하여 CQRS 분리와 조회 전략을 명확히 표현',0,'UseCase','2026-01-22 02:11:27.000000','2026-01-22 02:11:27.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (214,2,'APP-UC-002','Delete 네이밍 금지','CRITICAL','NAMING','UseCase, Service, Manager 등에서 Delete 네이밍 금지. Soft Delete는 Archive/Deactivate/Disable 사용. 예: ArchiveTechStackUseCase, DeactivateOrderService','Soft Delete와 Hard Delete 혼동 방지. Delete는 물리 삭제로 오해할 수 있어 명시적 네이밍 필수',0,'UseCase,Service,Manager','2026-01-22 02:23:03.000000','2026-01-22 02:23:03.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (215,2,'FAC-002','Factory 메서드에 DTO 통째로 전달','CRITICAL','BEHAVIOR','Factory 메서드 호출 시 DTO를 풀어서 개별 파라미터로 전달하지 말고, DTO 자체를 전달합니다.','개별 파라미터를 풀어서 전달하면 DTO 필드 변경 시 호출하는 모든 곳을 수정해야 하므로 변경에 취약합니다. DTO를 통째로 전달하면 Factory 내부에서만 필드 접근을 처리하므로 응집도가 높아지고 변경에 강해집니다.',0,'Factory','2026-01-22 02:32:57.000000','2026-01-22 02:32:57.000000',NULL);
INSERT INTO `coding_rule` (`id`, `convention_id`, `code`, `name`, `severity`, `category`, `description`, `rationale`, `auto_fixable`, `applies_to`, `created_at`, `updated_at`, `deleted_at`) VALUES (216,2,'FAC-008','Factory에서 UpdateContext로 ID, UpdateData, changedAt 한 번에 생성','MAJOR','STRUCTURE','Update Command에서 ID, UpdateData, 변경 시간을 생성할 때 Factory를 여러 번 호출하지 않고, createUpdateContext() 메서드를 통해 UpdateContext<ID, UPDATE_DATA>(id, updateData, changedAt)를 한 번에 생성합니다. changedAt은 C-006에 따라 Factory에서 TimeProvider.now()로 생성합니다. Service에서는 context.changedAt()을 Domain.update()에 전달합니다.','Factory 호출 단순화 및 시간 생성 책임 일원화. Service에서 toId(), toUpdateData(), now()를 각각 호출하지 않고, createUpdateContext() 한 번 호출로 모든 업데이트 컨텍스트를 받습니다. C-006(시간 생성은 Factory에서만)과 일관성을 유지합니다.',0,NULL,'2026-01-22 03:17:03.000000','2026-01-22 03:17:03.000000',NULL);

INSERT INTO `config_file_template` (`id`, `tech_stack_id`, `architecture_id`, `tool_type`, `file_path`, `file_name`, `content`, `category`, `description`, `variables`, `display_order`, `is_required`, `created_at`, `updated_at`, `deleted_at`) VALUES (1,1,1,'CLAUDE','.claude/CLAUDE.md','CLAUDE.md','# {{project_name}} - Claude Code Configuration\n\n이 프로젝트는 **{{tech_stack.framework_type}} {{tech_stack.framework_version}} + {{tech_stack.language_type}} {{tech_stack.language_version}}** 기반의 **{{architecture.name}}** 프로젝트입니다.\n\n---\n\n## 🏗️ 아키텍처 개요\n\n{{layers_diagram}}\n\n---\n\n## 🧰 MCP 도구 사용법\n\n이 프로젝트의 코딩 컨벤션은 **Convention Hub DB**에서 관리됩니다.\n코드 작성 시 반드시 MCP 도구를 사용하여 규칙을 조회하세요.\n\n### 3-Phase 워크플로우\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│  1️⃣ PLANNING PHASE                                          │\n│     planning_context(layers=[...])                          │\n│     → 레이어는 list_tech_stacks()로 먼저 조회                 │\n├─────────────────────────────────────────────────────────────┤\n│  2️⃣ EXECUTION PHASE                                         │\n│     module_context(module_id=N, class_type=\"...\")           │\n│     → 템플릿 + 규칙 기반 코드 생성                            │\n├─────────────────────────────────────────────────────────────┤\n│  3️⃣ VALIDATION PHASE                                        │\n│     validation_context(layers=[...])                        │\n│     → Zero-Tolerance + Checklist 검증                       │\n└─────────────────────────────────────────────────────────────┘\n```\n\n### 사용 예시\n\n```python\n# 0. 먼저 레이어 목록 조회 (하드코딩 금지!)\nlist_tech_stacks()\n# → layers: [\"DOMAIN\", \"APPLICATION\", \"ADAPTER_OUT\", \"ADAPTER_IN\", \"BOOTSTRAP\"]\n\n# 1. 개발 계획 수립\nplanning_context(layers=[\"DOMAIN\", \"APPLICATION\"])\n\n# 2. 코드 생성\nmodule_context(module_id=1, class_type=\"AGGREGATE\")\n\n# 3. 코드 검증\nvalidation_context(layers=[\"DOMAIN\"])\n```\n\n---\n\n## 🚨 Zero-Tolerance 규칙\n\n> ⚠️ **중요**: 규칙은 DB에서 조회하세요.\n\n```python\n# Zero-Tolerance 규칙 조회 (레이어는 동적으로!)\nvalidation_context(layers={{layers}})\n```\n\n### 주요 규칙 (요약)\n\n> 상세 규칙은 MCP `validation_context()` 또는 `get_rule()` 로 조회\n\nMCP를 통해 최신 규칙을 동적으로 조회하세요.\n하드코딩된 규칙은 DB 변경 시 outdated 될 수 있습니다.\n\n---\n\n## 📚 MCP Tools 목록\n\n| 분류 | Tool | 용도 |\n|------|------|------|\n| **워크플로우** | planning_context | 개발 계획 수립 |\n| | module_context | 코드 생성 (템플릿 + 규칙) |\n| | validation_context | 코드 검증 (Zero-Tolerance) |\n| **컨텍스트** | get_context | 빠른 컨텍스트 조회 |\n| | get_rule | 규칙 상세 + 예시 |\n| **계층** | list_tech_stacks | 기술 스택 + 레이어 목록 |\n| | get_architecture | 아키텍처 상세 |\n| | get_layer_detail | 레이어 상세 |\n\n---\n\n## 🔧 설계 원칙\n\nMCP 서버는 **순수 정보 브릿지**로 설계되었습니다:\n- MCP = 규칙/템플릿 전달 (Spring API → LLM)\n- **LLM은 규칙을 반드시 준수**하며 코드 생성\n- 규칙을 \"판단\"하지 않고 **100% 준수**\n\n---\n\n## ⚡ 빠른 시작\n\n```python\n# 1. 레이어 목록 조회\nlayers = list_tech_stacks()  # → [\"DOMAIN\", \"APPLICATION\", ...]\n\n# 2. Aggregate 생성 시\nplanning_context(layers=[\"DOMAIN\"])\nmodule_context(module_id=1, class_type=\"AGGREGATE\")\nvalidation_context(layers=[\"DOMAIN\"])\n\n# 3. UseCase 생성 시\nmodule_context(module_id=2, class_type=\"USE_CASE\")\n```\n','MAIN_CONFIG','Claude Code 메인 설정 파일. MCP 사용법과 아키텍처 개요 포함.','{\"tech_stack\": \"DYNAMIC - tech_stack 테이블에서 조회\", \"architecture\": \"DYNAMIC - architecture 테이블에서 조회\", \"project_name\": \"프로젝트명 (init 시 치환)\", \"layers_diagram\": \"DYNAMIC - layer 테이블에서 조회하여 다이어그램 생성\"}',1,1,'2026-01-24 07:44:23.000000','2026-01-25 06:38:38.000000',NULL);
INSERT INTO `config_file_template` (`id`, `tech_stack_id`, `architecture_id`, `tool_type`, `file_path`, `file_name`, `content`, `category`, `description`, `variables`, `display_order`, `is_required`, `created_at`, `updated_at`, `deleted_at`) VALUES (2,1,1,'CLAUDE','.claude/settings.local.json','settings.local.json','{\n  \"hooks\": {}\n}','MAIN_CONFIG','Claude Code 로컬 설정 (hooks 비활성화)',NULL,2,0,'2026-01-24 07:44:39.000000','2026-01-25 06:42:55.000000',NULL);
INSERT INTO `config_file_template` (`id`, `tech_stack_id`, `architecture_id`, `tool_type`, `file_path`, `file_name`, `content`, `category`, `description`, `variables`, `display_order`, `is_required`, `created_at`, `updated_at`, `deleted_at`) VALUES (3,1,1,'CLAUDE','.claude/agents/','implementer.md','# Implementer Agent\n\n모든 레이어 구현 전문가. Convention Hub의 규칙을 100% 준수하며 코드 생성.\n\n## 🎯 핵심 원칙\n\n> **MCP 기반 동적 규칙 조회 + Serena Lazy Caching**\n\n모든 컨벤션은 DB에서 관리됩니다. 하드코딩된 규칙이 아닌 MCP를 통해 동적으로 조회하세요.\n\n---\n\n## 📋 작업 워크플로우\n\n### Phase 1: 컨텍스트 확인\n\n```python\n# 1. Serena 캐시 확인\nserena.list_memories()\n# → \"convention-{layer}-{class_type}\" 존재 여부 확인\n\n# 2. 캐시 없으면 MCP로 조회\nplanning_context(layers=[\"요청된_레이어\"])\n# → 현재 TechStack/Architecture의 모듈 구조 파악\n```\n\n### Phase 2: 템플릿/규칙 조회 (Lazy Loading)\n\n```python\n# Serena에 캐시 없을 때만 호출\nresult = module_context(module_id=N, class_type=\"AGGREGATE\")\n\n# 결과를 Serena에 저장 (Lazy Caching)\nserena.write_memory(\n    memory_file_name=\"convention-domain-aggregate\",\n    content=result\n)\n```\n\n### Phase 3: 코드 생성\n\n1. 조회된 **템플릿 구조** 그대로 따르기\n2. 조회된 **규칙 100% 준수**\n3. BLOCKER 등급 규칙 위반 시 즉시 수정\n\n### Phase 4: 검증\n\n```python\nvalidation_context(layers=[\"작업한_레이어\"])\n# → Zero-Tolerance 규칙 체크\n```\n\n---\n\n## 🗂️ Serena 캐싱 전략\n\n### Memory Naming Convention\n```\nconvention-{layer_code}-{class_type}\n\n예시:\n- convention-domain-aggregate\n- convention-domain-vo\n- convention-application-usecase\n- convention-application-service\n- convention-persistence-entity\n- convention-restapi-controller\n```\n\n### 캐시 정책\n| 상황 | 동작 |\n|------|------|\n| 첫 요청 | MCP 호출 → Serena 저장 |\n| 재요청 | Serena에서 읽기 (API 호출 X) |\n| `--refresh` | 강제 재조회 |\n\n---\n\n## ⚠️ 필수 준수 사항\n\n1. **MCP 먼저**: 코드 작성 전 반드시 `module_context()` 호출\n2. **Serena 활용**: 동일 작업 반복 시 캐시 활용\n3. **Zero-Tolerance**: `validation_context()`로 검증 필수\n','AGENT','구현 전문가 Agent. MCP 동적 조회 + Serena Lazy Caching 워크플로우.',NULL,1,1,'2026-01-24 16:39:06.000000','2026-01-24 16:39:06.000000',NULL);
INSERT INTO `config_file_template` (`id`, `tech_stack_id`, `architecture_id`, `tool_type`, `file_path`, `file_name`, `content`, `category`, `description`, `variables`, `display_order`, `is_required`, `created_at`, `updated_at`, `deleted_at`) VALUES (4,1,1,'CLAUDE','.claude/agents/','planner.md','# Planner Agent\n\nEpic 기획 및 Task 분해 전문가. 요구사항을 분석하고 구현 전략을 수립.\n\n## 🎯 핵심 원칙\n\n> **MCP로 프로젝트 구조 파악 → 영향도 분석 → Task 분해**\n\n---\n\n## 📋 작업 워크플로우\n\n### Phase 1: 프로젝트 구조 파악\n\n```python\n# 먼저 레이어 목록 조회\nlist_tech_stacks()\n# → layers: [\"DOMAIN\", \"APPLICATION\", \"ADAPTER_OUT\", \"ADAPTER_IN\", \"BOOTSTRAP\"]\n\n# 현재 TechStack/Architecture 확인\nplanning_context(layers=[...])  # 조회된 레이어 사용\n# → 모듈 목록, 패키지 구조, 레이어 관계 파악\n```\n\n### Phase 2: 영향도 분석\n\n```python\n# Serena로 기존 코드 검색\nserena.search_for_pattern(pattern=\"관련_키워드\")\nserena.find_symbol(name_path=\"관련_클래스\")\n# → 변경 영향 범위 파악\n```\n\n### Phase 3: Task 분해\n\n1. **컨텍스트 크기 기준**: ~15K tokens per Task\n2. **레이어별 분리**: 하위 레이어 → 상위 레이어 순서\n3. **의존성 순서**: Domain → Application → Adapter 순\n\n### Phase 4: Epic 문서 작성\n\n```python\n# Serena Memory에 Epic 저장\nserena.write_memory(\n    memory_file_name=\"epic-{feature_name}\",\n    content=epic_document\n)\n```\n\n---\n\n## 📊 Task 분해 기준\n\n| 작업 유형 | Task 단위 |\n|----------|----------|\n| 🆕 신규 기능 | 레이어별 1 Task |\n| ➕ 기능 확장 | 변경 파일 그룹별 |\n| 🔄 리팩토링 | 패턴별 |\n| 🐛 버그 수정 | 원인별 |\n','AGENT','기획 전문가 Agent. 요구사항 분석 및 Task 분해.',NULL,2,1,'2026-01-24 16:39:06.000000','2026-01-25 06:38:38.000000',NULL);
INSERT INTO `config_file_template` (`id`, `tech_stack_id`, `architecture_id`, `tool_type`, `file_path`, `file_name`, `content`, `category`, `description`, `variables`, `display_order`, `is_required`, `created_at`, `updated_at`, `deleted_at`) VALUES (5,1,1,'CLAUDE','.claude/agents/','reviewer.md','# Reviewer Agent\n\n코드 리뷰 전문가. Convention Hub 규칙 기반 검증.\n\n## 🎯 핵심 원칙\n\n> **MCP로 규칙 조회 → 코드 대조 → 위반 사항 리포트**\n\n---\n\n## 📋 리뷰 워크플로우\n\n### Phase 1: 레이어 및 규칙 로드\n\n```python\n# 먼저 레이어 목록 조회\nlist_tech_stacks()\n\n# 변경된 레이어의 규칙 조회\nvalidation_context(layers=[...])  # 동적으로 레이어 지정\n# → Zero-Tolerance 규칙 + 체크리스트 획득\n\n# Serena에 캐싱\nserena.write_memory(\"review-rules\", rules)\n```\n\n### Phase 2: 코드 분석\n\n```python\n# 변경 파일 분류\ngit diff --name-only\n\n# 레이어별 파일 그룹핑 (경로 패턴으로 판별)\n# /domain/     → DOMAIN\n# /application/ → APPLICATION\n# /adapter-out/ or /persistence/ → ADAPTER_OUT\n# /adapter-in/ or /rest-api/     → ADAPTER_IN\n```\n\n### Phase 3: 규칙 대조\n\n각 파일에 대해:\n1. 해당 레이어/클래스타입의 규칙 조회\n2. 코드와 규칙 대조\n3. 위반 사항 기록\n\n### Phase 4: 리포트 생성\n\n```markdown\n## 리뷰 결과\n\n### 🔴 필수 수정 (Zero-Tolerance 위반)\n- [ ] 규칙코드: 설명 → 파일:라인\n\n### 🟡 권장 수정\n- [ ] ...\n\n### 🟢 통과\n- ✅ 규칙 준수 항목들\n```\n\n---\n\n## ⚠️ Zero-Tolerance 우선 체크\n\nMCP `validation_context()` 로 최신 규칙 조회 후 체크:\n- Lombok 사용 여부\n- Getter 체이닝 (Law of Demeter)\n- @Transactional 내 외부 API 호출\n- JPA 관계 어노테이션\n','AGENT','리뷰 전문가 Agent. Convention Hub 규칙 기반 코드 검증.',NULL,3,1,'2026-01-24 16:39:06.000000','2026-01-25 06:38:39.000000',NULL);
INSERT INTO `config_file_template` (`id`, `tech_stack_id`, `architecture_id`, `tool_type`, `file_path`, `file_name`, `content`, `category`, `description`, `variables`, `display_order`, `is_required`, `created_at`, `updated_at`, `deleted_at`) VALUES (6,1,1,'CLAUDE','.claude/agents/','shipper.md','# Shipper Agent\n\n배포 전문가. Git 커밋, 푸시, PR 생성, Jira 상태 업데이트.\n\n## 🎯 핵심 원칙\n\n> **Epic 단위 배포: 1 Epic = 1 Branch = 1 PR**\n\n---\n\n## 📋 배포 워크플로우\n\n### Phase 1: 상태 확인\n\n```bash\ngit status\ngit log --oneline -10\n```\n\n### Phase 2: 커밋 정리\n\n```bash\n# WIP 커밋들 Squash\ngit rebase -i main\n\n# 커밋 메시지 형식\nfeat(domain): Order Aggregate 구현\n\n- OrderId, OrderStatus VO 추가\n- OrderCreatedEvent 이벤트 정의\n- Zero-Tolerance 규칙 준수 확인\n\nEPIC-123\n```\n\n### Phase 3: PR 생성\n\n```bash\ngh pr create --title \"feat: 주문 기능 구현\" --body \"...\"\n```\n\n### Phase 4: Jira 업데이트\n\n```python\n# Jira MCP 사용\njira.transition_issue(issue_key=\"EPIC-123\", status=\"In Review\")\n```\n\n---\n\n## 📝 PR 템플릿\n\n```markdown\n## Summary\n- 주문 도메인 Aggregate 구현\n- CQRS 패턴 적용\n\n## Changes\n- Domain: Order Aggregate, VO, Event\n- Application: CreateOrderUseCase\n- Persistence: OrderJpaEntity, Repository\n- REST API: OrderController\n\n## Test Plan\n- [ ] 단위 테스트 통과\n- [ ] ArchUnit 테스트 통과\n- [ ] 정적 분석 통과\n```\n','AGENT','배포 전문가 Agent. Git, PR, Jira 관리.',NULL,4,1,'2026-01-24 16:39:06.000000','2026-01-24 16:39:06.000000',NULL);
INSERT INTO `config_file_template` (`id`, `tech_stack_id`, `architecture_id`, `tool_type`, `file_path`, `file_name`, `content`, `category`, `description`, `variables`, `display_order`, `is_required`, `created_at`, `updated_at`, `deleted_at`) VALUES (7,1,1,'CLAUDE','.claude/agents/','tester.md','# Tester Agent\n\n테스트 전문가. ArchUnit, 단위 테스트, 통합 테스트 작성 및 실행.\n\n## 🎯 핵심 원칙\n\n> **MCP로 테스트 규칙 조회 → 테스트 작성 → 실행 검증**\n\n---\n\n## 📋 테스트 워크플로우\n\n### Phase 1: 테스트 규칙 조회\n\n```python\n# 해당 레이어의 테스트 규칙 조회\nmodule_context(module_id=N, class_type=\"TEST\")\n# → 테스트 패턴, Mock 규칙, 네이밍 컨벤션\n```\n\n### Phase 2: 테스트 작성\n\n#### 단위 테스트\n```java\n@ExtendWith(MockitoExtension.class)\n@Tag(\"unit\")\nclass CreateOrderServiceTest {\n    @Mock private OrderCommandPort orderCommandPort;\n    // BDDMockito 스타일\n}\n```\n\n#### 통합 테스트\n```java\n@SpringBootTest(webEnvironment = RANDOM_PORT)\n@Tag(\"integration\")\nclass OrderApiIntegrationTest {\n    @Autowired private TestRestTemplate restTemplate;\n    // MockMvc 금지 → TestRestTemplate 사용\n}\n```\n\n### Phase 3: 실행 및 검증\n\n```bash\n# 단위 테스트\n./gradlew test --tests \"*Test\"\n\n# ArchUnit 테스트\n./gradlew test --tests \"*ArchTest\"\n\n# 정적 분석\n./gradlew check\n```\n\n---\n\n## ⚠️ 테스트 규칙\n\n| 항목 | 규칙 |\n|------|------|\n| Mock 프레임워크 | Mockito + BDDMockito |\n| 단위 테스트 | @ExtendWith(MockitoExtension.class) |\n| 통합 테스트 | TestRestTemplate (MockMvc 금지) |\n| Assertion | AssertJ |\n| 태그 | @Tag(\"unit\"), @Tag(\"integration\") |\n','AGENT','테스트 전문가 Agent. 테스트 작성 및 실행.',NULL,5,1,'2026-01-24 16:39:06.000000','2026-01-24 16:39:06.000000',NULL);
INSERT INTO `config_file_template` (`id`, `tech_stack_id`, `architecture_id`, `tool_type`, `file_path`, `file_name`, `content`, `category`, `description`, `variables`, `display_order`, `is_required`, `created_at`, `updated_at`, `deleted_at`) VALUES (8,1,1,'CLAUDE','.claude/skills/implementer/','SKILL.md','# /implementer Skill\n\n코드 구현 스킬. MCP + Serena Lazy Caching 기반.\n\n## 사용법\n\n```\n/implementer \"Order Aggregate 생성\"\n/implementer --layer domain --type aggregate\n```\n\n## 실행 흐름\n\n1. **캐시 확인**: `serena.read_memory(\"convention-{layer}-{type}\")`\n2. **캐시 미스**: `module_context()` 호출 → Serena 저장\n3. **코드 생성**: 템플릿 + 규칙 기반\n4. **검증**: `validation_context()` 호출\n\n## Lazy Caching 로직\n\n```python\ncache_key = f\"convention-{layer}-{class_type}\"\n\n# 1. Serena 캐시 확인\ncached = serena.read_memory(cache_key)\n\nif cached:\n    # 캐시 히트 → API 호출 스킵\n    rules = cached\nelse:\n    # 캐시 미스 → MCP 호출\n    rules = module_context(module_id, class_type)\n    # Serena에 저장\n    serena.write_memory(cache_key, rules)\n\n# 규칙 기반 코드 생성\ngenerate_code(rules)\n```\n','SKILL','구현 스킬. Lazy Caching 기반 코드 생성.',NULL,1,1,'2026-01-24 16:39:06.000000','2026-01-24 16:39:06.000000',NULL);
INSERT INTO `config_file_template` (`id`, `tech_stack_id`, `architecture_id`, `tool_type`, `file_path`, `file_name`, `content`, `category`, `description`, `variables`, `display_order`, `is_required`, `created_at`, `updated_at`, `deleted_at`) VALUES (9,1,1,'CLAUDE','.claude/skills/planner/','SKILL.md','# /planner Skill\n\n기획 및 Task 분해 스킬.\n\n## 사용법\n\n```\n/planner \"결제 기능 구현\"\n/planner --analyze \"영향도 분석\"\n```\n\n## 실행 흐름\n\n1. `planning_context()` → 프로젝트 구조 파악\n2. `serena.search_for_pattern()` → 영향도 분석\n3. Task 분해 (컨텍스트 크기 ~15K 기준)\n4. `serena.write_memory(\"epic-{name}\")` → Epic 저장\n','SKILL','기획 스킬. Task 분해 및 Epic 관리.',NULL,2,1,'2026-01-24 16:39:06.000000','2026-01-24 16:39:06.000000',NULL);
INSERT INTO `config_file_template` (`id`, `tech_stack_id`, `architecture_id`, `tool_type`, `file_path`, `file_name`, `content`, `category`, `description`, `variables`, `display_order`, `is_required`, `created_at`, `updated_at`, `deleted_at`) VALUES (10,1,1,'CLAUDE','.claude/skills/reviewer/','SKILL.md','# /reviewer Skill\n\n코드 리뷰 스킬. Convention Hub 규칙 기반.\n\n## 사용법\n\n```\n/reviewer\n/reviewer --staged\n/reviewer --fix\n```\n\n## 실행 흐름\n\n1. `validation_context()` → Zero-Tolerance 규칙 로드\n2. 변경 파일 분석\n3. 규칙 대조 및 위반 사항 리포트\n4. `--fix` 옵션 시 자동 수정\n','SKILL','리뷰 스킬. 규칙 기반 코드 검증.',NULL,3,1,'2026-01-24 16:39:06.000000','2026-01-24 16:39:06.000000',NULL);
INSERT INTO `config_file_template` (`id`, `tech_stack_id`, `architecture_id`, `tool_type`, `file_path`, `file_name`, `content`, `category`, `description`, `variables`, `display_order`, `is_required`, `created_at`, `updated_at`, `deleted_at`) VALUES (11,1,1,'CLAUDE','.claude/skills/shipper/','SKILL.md','# /shipper Skill\n\n배포 스킬. Git + PR + Jira 통합.\n\n## 사용법\n\n```\n/shipper\n/shipper --draft\n/shipper --no-squash\n```\n\n## 실행 흐름\n\n1. Git 상태 확인\n2. WIP 커밋 Squash\n3. PR 생성\n4. Jira 상태 업데이트\n','SKILL','배포 스킬. Epic 단위 PR 생성.',NULL,4,1,'2026-01-24 16:39:06.000000','2026-01-24 16:39:06.000000',NULL);
INSERT INTO `config_file_template` (`id`, `tech_stack_id`, `architecture_id`, `tool_type`, `file_path`, `file_name`, `content`, `category`, `description`, `variables`, `display_order`, `is_required`, `created_at`, `updated_at`, `deleted_at`) VALUES (12,1,1,'CLAUDE','.claude/skills/tester/','SKILL.md','# /tester Skill\n\n테스트 스킬. 테스트 작성 및 실행.\n\n## 사용법\n\n```\n/tester\n/tester --unit\n/tester --arch\n```\n\n## 실행 흐름\n\n1. `module_context(class_type=\"TEST\")` → 테스트 규칙 조회\n2. 테스트 코드 작성\n3. `./gradlew test` 실행\n4. 결과 리포트\n','SKILL','테스트 스킬. 테스트 작성 및 실행.',NULL,5,1,'2026-01-24 16:39:06.000000','2026-01-24 16:39:06.000000',NULL);
INSERT INTO `config_file_template` (`id`, `tech_stack_id`, `architecture_id`, `tool_type`, `file_path`, `file_name`, `content`, `category`, `description`, `variables`, `display_order`, `is_required`, `created_at`, `updated_at`, `deleted_at`) VALUES (13,1,1,'CLAUDE','.claude/rules/','convention-guide.md','# Convention Guide\n\n> ⚠️ **규칙은 하드코딩되지 않습니다. MCP를 통해 동적으로 조회하세요.**\n\n## 규칙 조회 방법\n\n### 1. 레이어 목록 확인\n```python\n# 먼저 사용 가능한 레이어 목록 조회\nlist_tech_stacks()\n# 또는\nget_architecture(architecture_id=1)\n```\n\n### 2. 전체 규칙 개요\n```python\n# 조회된 레이어 코드로 validation_context 호출\nvalidation_context(layers={{layers}})\n```\n\n### 3. 레이어별 상세 규칙\n```python\nget_layer_detail(layer_code=\"조회된_레이어_코드\")\n```\n\n### 4. 특정 규칙 상세\n```python\nget_rule(rule_code=\"규칙_코드\")\n```\n\n### 5. 클래스별 템플릿 + 규칙\n```python\nmodule_context(module_id=N, class_type=\"클래스_타입\")\n```\n\n## Serena 캐싱\n\n조회된 규칙은 Serena Memory에 캐싱하여 재사용:\n\n```python\n# 캐시 키: convention-{layer}-{class_type}\nserena.write_memory(\"convention-domain-aggregate\", rules)\nserena.read_memory(\"convention-domain-aggregate\")\n```\n\n## Zero-Tolerance 빠른 참조\n\n> 상세 규칙은 `validation_context()` 또는 `get_rule()` 로 조회\n\nMCP를 통해 최신 규칙을 동적으로 조회하세요.\n하드코딩된 규칙은 DB 변경 시 outdated 될 수 있습니다.\n','RULE','Convention 가이드. MCP 동적 조회 안내.','{\"layers\": \"DYNAMIC - layer 테이블에서 조회\"}',1,1,'2026-01-24 16:39:06.000000','2026-01-25 06:35:23.000000',NULL);
INSERT INTO `config_file_template` (`id`, `tech_stack_id`, `architecture_id`, `tool_type`, `file_path`, `file_name`, `content`, `category`, `description`, `variables`, `display_order`, `is_required`, `created_at`, `updated_at`, `deleted_at`) VALUES (16,1,NULL,'CLAUDE','.claude/agents/','implementer.md','# Implementer Agent\n\n모든 레이어 구현 전문가. Convention Hub의 규칙을 100% 준수하며 코드 생성.\n\n## 🎯 핵심 원칙\n\n> **MCP 기반 동적 규칙 조회 + Serena Lazy Caching**\n\n모든 컨벤션은 DB에서 관리됩니다. 하드코딩된 규칙이 아닌 MCP를 통해 동적으로 조회하세요.\n\n---\n\n## 📋 작업 워크플로우\n\n### Phase 1: 컨텍스트 확인\n\n```python\n# 1. Serena 캐시 확인\nserena.list_memories()\n# → \"convention-{layer}-{class_type}\" 존재 여부 확인\n\n# 2. 캐시 없으면 MCP로 조회 (레이어는 list_tech_stacks()로 먼저 조회!)\nplanning_context(layers=[...])  # 동적 레이어 사용\n# → 현재 TechStack/Architecture의 모듈 구조 파악\n```\n\n### Phase 2: 템플릿/규칙 조회 (Lazy Loading)\n\n```python\n# Serena에 캐시 없을 때만 호출\nresult = module_context(module_id=N, class_type=\"AGGREGATE\")\n\n# 결과를 Serena에 저장 (Lazy Caching)\nserena.write_memory(\n    memory_file_name=\"convention-domain-aggregate\",\n    content=result\n)\n```\n\n### Phase 3: 코드 생성\n\n1. 조회된 **템플릿 구조** 그대로 따르기\n2. 조회된 **규칙 100% 준수**\n3. BLOCKER 등급 규칙 위반 시 즉시 수정\n\n### Phase 4: 검증\n\n```python\nvalidation_context(layers=[...])  # 동적 레이어 사용\n# → Zero-Tolerance 규칙 체크\n```\n\n---\n\n## 🗂️ Serena 캐싱 전략\n\n### Memory Naming Convention\n```\nconvention-{layer_code}-{class_type}\n\n예시:\n- convention-domain-aggregate\n- convention-domain-vo\n- convention-application-usecase\n- convention-application-service\n- convention-adapter_out-entity\n- convention-adapter_in-controller\n```\n\n### 캐시 정책\n| 상황 | 동작 |\n|------|------|\n| 첫 요청 | MCP 호출 → Serena 저장 |\n| 재요청 | Serena에서 읽기 (API 호출 X) |\n| `--refresh` | 강제 재조회 |\n\n---\n\n## ⚠️ 필수 준수 사항\n\n1. **MCP 먼저**: 코드 작성 전 반드시 `module_context()` 호출\n2. **Serena 활용**: 동일 작업 반복 시 캐시 활용\n3. **Zero-Tolerance**: `validation_context()`로 검증 필수\n','AGENT','구현 전문가 Agent. MCP 동적 조회 + Serena Lazy Caching 워크플로우.',NULL,1,1,'2026-01-25 07:46:59.000000','2026-01-25 07:46:59.000000',NULL);
INSERT INTO `config_file_template` (`id`, `tech_stack_id`, `architecture_id`, `tool_type`, `file_path`, `file_name`, `content`, `category`, `description`, `variables`, `display_order`, `is_required`, `created_at`, `updated_at`, `deleted_at`) VALUES (17,1,NULL,'CLAUDE','.claude/agents/','planner.md','# Planner Agent\n\nEpic 기획 및 Task 분해 전문가. 요구사항을 분석하고 구현 전략을 수립.\n\n## 🎯 핵심 원칙\n\n> **MCP로 프로젝트 구조 파악 → 영향도 분석 → Task 분해**\n\n---\n\n## 📋 작업 워크플로우\n\n### Phase 1: 프로젝트 구조 파악\n\n```python\n# 먼저 레이어 목록 조회\nlist_tech_stacks()\n# → layers: [\"DOMAIN\", \"APPLICATION\", \"ADAPTER_OUT\", \"ADAPTER_IN\", \"BOOTSTRAP\"]\n\n# 현재 TechStack/Architecture 확인\nplanning_context(layers=[...])  # 조회된 레이어 사용\n# → 모듈 목록, 패키지 구조, 레이어 관계 파악\n```\n\n### Phase 2: 영향도 분석\n\n```python\n# Serena로 기존 코드 검색\nserena.search_for_pattern(pattern=\"관련_키워드\")\nserena.find_symbol(name_path=\"관련_클래스\")\n# → 변경 영향 범위 파악\n```\n\n### Phase 3: Task 분해\n\n1. **컨텍스트 크기 기준**: ~15K tokens per Task\n2. **레이어별 분리**: 하위 레이어 → 상위 레이어 순서\n3. **의존성 순서**: Domain → Application → Adapter 순\n\n### Phase 4: Epic 문서 작성\n\n```python\n# Serena Memory에 Epic 저장\nserena.write_memory(\n    memory_file_name=\"epic-{feature_name}\",\n    content=epic_document\n)\n```\n\n---\n\n## 📊 Task 분해 기준\n\n| 작업 유형 | Task 단위 |\n|----------|----------|\n| 🆕 신규 기능 | 레이어별 1 Task |\n| ➕ 기능 확장 | 변경 파일 그룹별 |\n| 🔄 리팩토링 | 패턴별 |\n| 🐛 버그 수정 | 원인별 |\n','AGENT','기획 전문가 Agent. 요구사항 분석 및 Task 분해.',NULL,2,1,'2026-01-25 07:46:59.000000','2026-01-25 07:46:59.000000',NULL);
INSERT INTO `config_file_template` (`id`, `tech_stack_id`, `architecture_id`, `tool_type`, `file_path`, `file_name`, `content`, `category`, `description`, `variables`, `display_order`, `is_required`, `created_at`, `updated_at`, `deleted_at`) VALUES (18,1,NULL,'CLAUDE','.claude/agents/','reviewer.md','# Reviewer Agent\n\n코드 리뷰 전문가. Convention Hub 규칙 기반 검증.\n\n## 🎯 핵심 원칙\n\n> **MCP로 규칙 조회 → 코드 대조 → 위반 사항 리포트**\n\n---\n\n## 📋 리뷰 워크플로우\n\n### Phase 1: 레이어 및 규칙 로드\n\n```python\n# 먼저 레이어 목록 조회\nlist_tech_stacks()\n\n# 변경된 레이어의 규칙 조회\nvalidation_context(layers=[...])  # 동적으로 레이어 지정\n# → Zero-Tolerance 규칙 + 체크리스트 획득\n\n# Serena에 캐싱\nserena.write_memory(\"review-rules\", rules)\n```\n\n### Phase 2: 코드 분석\n\n```python\n# 변경 파일 분류\ngit diff --name-only\n\n# 레이어별 파일 그룹핑 (경로 패턴으로 판별)\n# /domain/     → DOMAIN\n# /application/ → APPLICATION\n# /adapter-out/ or /persistence/ → ADAPTER_OUT\n# /adapter-in/ or /rest-api/     → ADAPTER_IN\n```\n\n### Phase 3: 규칙 대조\n\n각 파일에 대해:\n1. 해당 레이어/클래스타입의 규칙 조회\n2. 코드와 규칙 대조\n3. 위반 사항 기록\n\n### Phase 4: 리포트 생성\n\n```markdown\n## 리뷰 결과\n\n### 🔴 필수 수정 (Zero-Tolerance 위반)\n- [ ] 규칙코드: 설명 → 파일:라인\n\n### 🟡 권장 수정\n- [ ] ...\n\n### 🟢 통과\n- ✅ 규칙 준수 항목들\n```\n\n---\n\n## ⚠️ Zero-Tolerance 우선 체크\n\nMCP `validation_context()` 로 최신 규칙 조회 후 체크:\n- Lombok 사용 여부\n- Getter 체이닝 (Law of Demeter)\n- @Transactional 내 외부 API 호출\n- JPA 관계 어노테이션\n','AGENT','리뷰 전문가 Agent. Convention Hub 규칙 기반 코드 검증.',NULL,3,1,'2026-01-25 07:46:59.000000','2026-01-25 07:46:59.000000',NULL);
INSERT INTO `config_file_template` (`id`, `tech_stack_id`, `architecture_id`, `tool_type`, `file_path`, `file_name`, `content`, `category`, `description`, `variables`, `display_order`, `is_required`, `created_at`, `updated_at`, `deleted_at`) VALUES (19,1,NULL,'CLAUDE','.claude/agents/','shipper.md','# Shipper Agent\n\n배포 전문가. Git 커밋, 푸시, PR 생성, Jira 상태 업데이트.\n\n## 🎯 핵심 원칙\n\n> **Epic 단위 배포: 1 Epic = 1 Branch = 1 PR**\n\n---\n\n## 📋 배포 워크플로우\n\n### Phase 1: 상태 확인\n\n```bash\ngit status\ngit log --oneline -10\n```\n\n### Phase 2: 커밋 정리\n\n```bash\n# WIP 커밋들 Squash\ngit rebase -i main\n\n# 커밋 메시지 형식\nfeat(domain): Order Aggregate 구현\n\n- OrderId, OrderStatus VO 추가\n- OrderCreatedEvent 이벤트 정의\n- Zero-Tolerance 규칙 준수 확인\n\nEPIC-123\n```\n\n### Phase 3: PR 생성\n\n```bash\ngh pr create --title \"feat: 주문 기능 구현\" --body \"...\"\n```\n\n### Phase 4: Jira 업데이트\n\n```python\n# Jira MCP 사용\njira.transition_issue(issue_key=\"EPIC-123\", status=\"In Review\")\n```\n\n---\n\n## 📝 PR 템플릿\n\n```markdown\n## Summary\n- 주문 도메인 Aggregate 구현\n- CQRS 패턴 적용\n\n## Changes\n- Domain: Order Aggregate, VO, Event\n- Application: CreateOrderUseCase\n- Adapter-Out: OrderJpaEntity, Repository\n- Adapter-In: OrderController\n\n## Test Plan\n- [ ] 단위 테스트 통과\n- [ ] ArchUnit 테스트 통과\n- [ ] 정적 분석 통과\n```\n','AGENT','배포 전문가 Agent. Git, PR, Jira 관리.',NULL,4,1,'2026-01-25 07:46:59.000000','2026-01-25 07:46:59.000000',NULL);
INSERT INTO `config_file_template` (`id`, `tech_stack_id`, `architecture_id`, `tool_type`, `file_path`, `file_name`, `content`, `category`, `description`, `variables`, `display_order`, `is_required`, `created_at`, `updated_at`, `deleted_at`) VALUES (20,1,NULL,'CLAUDE','.claude/agents/','tester.md','# Tester Agent\n\n테스트 전문가. ArchUnit, 단위 테스트, 통합 테스트 작성 및 실행.\n\n## 🎯 핵심 원칙\n\n> **MCP로 테스트 규칙 조회 → 테스트 작성 → 실행 검증**\n\n---\n\n## 📋 테스트 워크플로우\n\n### Phase 1: 테스트 규칙 조회\n\n```python\n# 해당 레이어의 테스트 규칙 조회\nmodule_context(module_id=N, class_type=\"TEST\")\n# → 테스트 패턴, Mock 규칙, 네이밍 컨벤션\n```\n\n### Phase 2: 테스트 작성\n\n#### 단위 테스트\n```java\n@ExtendWith(MockitoExtension.class)\n@Tag(\"unit\")\nclass CreateOrderServiceTest {\n    @Mock private OrderCommandPort orderCommandPort;\n    // BDDMockito 스타일\n}\n```\n\n#### 통합 테스트\n```java\n@SpringBootTest(webEnvironment = RANDOM_PORT)\n@Tag(\"integration\")\nclass OrderApiIntegrationTest {\n    @Autowired private TestRestTemplate restTemplate;\n    // MockMvc 금지 → TestRestTemplate 사용\n}\n```\n\n### Phase 3: 실행 및 검증\n\n```bash\n# 단위 테스트\n./gradlew test --tests \"*Test\"\n\n# ArchUnit 테스트\n./gradlew test --tests \"*ArchTest\"\n\n# 정적 분석\n./gradlew check\n```\n\n---\n\n## ⚠️ 테스트 규칙\n\n| 항목 | 규칙 |\n|------|------|\n| Mock 프레임워크 | Mockito + BDDMockito |\n| 단위 테스트 | @ExtendWith(MockitoExtension.class) |\n| 통합 테스트 | TestRestTemplate (MockMvc 금지) |\n| Assertion | AssertJ |\n| 태그 | @Tag(\"unit\"), @Tag(\"integration\") |\n','AGENT','테스트 전문가 Agent. 테스트 작성 및 실행.',NULL,5,1,'2026-01-25 07:46:59.000000','2026-01-25 07:46:59.000000',NULL);
INSERT INTO `config_file_template` (`id`, `tech_stack_id`, `architecture_id`, `tool_type`, `file_path`, `file_name`, `content`, `category`, `description`, `variables`, `display_order`, `is_required`, `created_at`, `updated_at`, `deleted_at`) VALUES (21,1,NULL,'CLAUDE','.claude/skills/implementer/','SKILL.md','# /implementer Skill\n\n코드 구현 스킬. MCP + Serena Lazy Caching 기반.\n\n## 사용법\n\n```\n/implementer \"Order Aggregate 생성\"\n/implementer --layer domain --type aggregate\n```\n\n## 실행 흐름\n\n1. **캐시 확인**: `serena.read_memory(\"convention-{layer}-{type}\")`\n2. **캐시 미스**: `module_context()` 호출 → Serena 저장\n3. **코드 생성**: 템플릿 + 규칙 기반\n4. **검증**: `validation_context()` 호출\n\n## Lazy Caching 로직\n\n```python\ncache_key = f\"convention-{layer}-{class_type}\"\n\n# 1. Serena 캐시 확인\ncached = serena.read_memory(cache_key)\n\nif cached:\n    # 캐시 히트 → API 호출 스킵\n    rules = cached\nelse:\n    # 캐시 미스 → MCP 호출\n    rules = module_context(module_id, class_type)\n    # Serena에 저장\n    serena.write_memory(cache_key, rules)\n\n# 규칙 기반 코드 생성\ngenerate_code(rules)\n```\n','SKILL','구현 스킬. Lazy Caching 기반 코드 생성.',NULL,1,1,'2026-01-25 07:46:59.000000','2026-01-25 07:46:59.000000',NULL);
INSERT INTO `config_file_template` (`id`, `tech_stack_id`, `architecture_id`, `tool_type`, `file_path`, `file_name`, `content`, `category`, `description`, `variables`, `display_order`, `is_required`, `created_at`, `updated_at`, `deleted_at`) VALUES (22,1,NULL,'CLAUDE','.claude/skills/planner/','SKILL.md','# /planner Skill\n\n기획 및 Task 분해 스킬.\n\n## 사용법\n\n```\n/planner \"결제 기능 구현\"\n/planner --analyze \"영향도 분석\"\n```\n\n## 실행 흐름\n\n1. `planning_context()` → 프로젝트 구조 파악\n2. `serena.search_for_pattern()` → 영향도 분석\n3. Task 분해 (컨텍스트 크기 ~15K 기준)\n4. `serena.write_memory(\"epic-{name}\")` → Epic 저장\n','SKILL','기획 스킬. Task 분해 및 Epic 관리.',NULL,2,1,'2026-01-25 07:46:59.000000','2026-01-25 07:46:59.000000',NULL);
INSERT INTO `config_file_template` (`id`, `tech_stack_id`, `architecture_id`, `tool_type`, `file_path`, `file_name`, `content`, `category`, `description`, `variables`, `display_order`, `is_required`, `created_at`, `updated_at`, `deleted_at`) VALUES (23,1,NULL,'CLAUDE','.claude/skills/reviewer/','SKILL.md','# /reviewer Skill\n\n코드 리뷰 스킬. Convention Hub 규칙 기반.\n\n## 사용법\n\n```\n/reviewer\n/reviewer --staged\n/reviewer --fix\n```\n\n## 실행 흐름\n\n1. `validation_context()` → Zero-Tolerance 규칙 로드\n2. 변경 파일 분석\n3. 규칙 대조 및 위반 사항 리포트\n4. `--fix` 옵션 시 자동 수정\n','SKILL','리뷰 스킬. 규칙 기반 코드 검증.',NULL,3,1,'2026-01-25 07:46:59.000000','2026-01-25 07:46:59.000000',NULL);
INSERT INTO `config_file_template` (`id`, `tech_stack_id`, `architecture_id`, `tool_type`, `file_path`, `file_name`, `content`, `category`, `description`, `variables`, `display_order`, `is_required`, `created_at`, `updated_at`, `deleted_at`) VALUES (24,1,NULL,'CLAUDE','.claude/skills/shipper/','SKILL.md','# /shipper Skill\n\n배포 스킬. Git + PR + Jira 통합.\n\n## 사용법\n\n```\n/shipper\n/shipper --draft\n/shipper --no-squash\n```\n\n## 실행 흐름\n\n1. Git 상태 확인\n2. WIP 커밋 Squash\n3. PR 생성\n4. Jira 상태 업데이트\n','SKILL','배포 스킬. Epic 단위 PR 생성.',NULL,4,1,'2026-01-25 07:46:59.000000','2026-01-25 07:46:59.000000',NULL);
INSERT INTO `config_file_template` (`id`, `tech_stack_id`, `architecture_id`, `tool_type`, `file_path`, `file_name`, `content`, `category`, `description`, `variables`, `display_order`, `is_required`, `created_at`, `updated_at`, `deleted_at`) VALUES (25,1,NULL,'CLAUDE','.claude/skills/tester/','SKILL.md','# /tester Skill\n\n테스트 스킬. 테스트 작성 및 실행.\n\n## 사용법\n\n```\n/tester\n/tester --unit\n/tester --arch\n```\n\n## 실행 흐름\n\n1. `module_context(class_type=\"TEST\")` → 테스트 규칙 조회\n2. 테스트 코드 작성\n3. `./gradlew test` 실행\n4. 결과 리포트\n','SKILL','테스트 스킬. 테스트 작성 및 실행.',NULL,5,1,'2026-01-25 07:46:59.000000','2026-01-25 07:46:59.000000',NULL);
INSERT INTO `config_file_template` (`id`, `tech_stack_id`, `architecture_id`, `tool_type`, `file_path`, `file_name`, `content`, `category`, `description`, `variables`, `display_order`, `is_required`, `created_at`, `updated_at`, `deleted_at`) VALUES (26,1,NULL,'CLAUDE','.claude/rules/','convention-guide.md','# Convention Guide\n\n> ⚠️ **규칙은 하드코딩되지 않습니다. MCP를 통해 동적으로 조회하세요.**\n\n## 규칙 조회 방법\n\n### 1. 레이어 목록 먼저 조회\n```python\nlist_tech_stacks()\n# → layers: [\"DOMAIN\", \"APPLICATION\", \"ADAPTER_OUT\", \"ADAPTER_IN\", \"BOOTSTRAP\"]\n```\n\n### 2. 전체 규칙 개요\n```python\nvalidation_context(layers=[...])  # 조회된 레이어 사용\n```\n\n### 3. 레이어별 상세 규칙\n```python\nget_layer_detail(layer_code=\"DOMAIN\")\n```\n\n### 4. 특정 규칙 상세\n```python\nget_rule(rule_code=\"DOM-AGG-001\")\n```\n\n### 5. 클래스별 템플릿 + 규칙\n```python\nmodule_context(module_id=1, class_type=\"AGGREGATE\")\n```\n\n## Serena 캐싱\n\n조회된 규칙은 Serena Memory에 캐싱하여 재사용:\n\n```python\n# 캐시 키: convention-{layer}-{class_type}\nserena.write_memory(\"convention-domain-aggregate\", rules)\nserena.read_memory(\"convention-domain-aggregate\")\n```\n\n## Zero-Tolerance 빠른 참조\n\n> 상세 규칙은 `validation_context()`로 조회\n\n| Layer | 핵심 규칙 |\n|-------|----------|\n| DOMAIN | Lombok 금지, Getter 체이닝 금지 |\n| APPLICATION | @Transactional 내 외부 API 금지 |\n| ADAPTER_OUT | JPA 관계 어노테이션 금지 |\n| ADAPTER_IN | MockMvc 금지 |\n','RULE','Convention 가이드. MCP 동적 조회 안내.',NULL,1,1,'2026-01-25 07:46:59.000000','2026-01-25 07:46:59.000000',NULL);

INSERT INTO `convention` (`id`, `module_id`, `version`, `description`, `is_active`, `created_at`, `updated_at`, `deleted_at`) VALUES (1,1,'1.0.0','Domain Layer 코딩 컨벤션',1,'2026-01-20 02:11:20.000000','2026-01-20 02:11:20.000000',NULL);
INSERT INTO `convention` (`id`, `module_id`, `version`, `description`, `is_active`, `created_at`, `updated_at`, `deleted_at`) VALUES (2,2,'1.0.0','Application Layer 코딩 컨벤션',1,'2026-01-20 02:11:20.000000','2026-01-20 02:11:20.000000',NULL);
INSERT INTO `convention` (`id`, `module_id`, `version`, `description`, `is_active`, `created_at`, `updated_at`, `deleted_at`) VALUES (3,4,'1.0.0','Persistence Layer 코딩 컨벤션',1,'2026-01-20 02:11:20.000000','2026-01-20 02:11:20.000000',NULL);
INSERT INTO `convention` (`id`, `module_id`, `version`, `description`, `is_active`, `created_at`, `updated_at`, `deleted_at`) VALUES (4,6,'1.0.0','REST API Layer 코딩 컨벤션',1,'2026-01-20 02:11:20.000000','2026-01-20 02:11:20.000000',NULL);
INSERT INTO `convention` (`id`, `module_id`, `version`, `description`, `is_active`, `created_at`, `updated_at`, `deleted_at`) VALUES (5,7,'1.0.0','Bootstrap Layer 코딩 컨벤션',1,'2026-01-20 05:59:01.000000','2026-01-20 05:59:01.000000',NULL);

INSERT INTO `layer` (`id`, `architecture_id`, `code`, `name`, `description`, `order_index`, `created_at`, `updated_at`, `deleted_at`) VALUES (1,1,'DOMAIN','Domain Layer','비즈니스 로직과 도메인 모델을 포함하는 핵심 레이어. Aggregate, Value Object, Domain Event, Domain Exception을 정의합니다.',1,'2026-01-20 02:11:20.000000','2026-01-20 02:11:20.000000',NULL);
INSERT INTO `layer` (`id`, `architecture_id`, `code`, `name`, `description`, `order_index`, `created_at`, `updated_at`, `deleted_at`) VALUES (2,1,'APPLICATION','Application Layer','애플리케이션 비즈니스 로직을 조율하는 레이어. UseCase(Port-In), Service, Manager, Port-Out을 정의합니다.',2,'2026-01-20 02:11:20.000000','2026-01-20 02:11:20.000000',NULL);
INSERT INTO `layer` (`id`, `architecture_id`, `code`, `name`, `description`, `order_index`, `created_at`, `updated_at`, `deleted_at`) VALUES (3,1,'ADAPTER_OUT','Adapter-Out Layer','아웃바운드 어댑터 레이어. 외부 시스템(DB, 외부 API, 메시지 큐 등)과의 통신을 담당합니다. Port-Out 인터페이스의 구현체가 위치합니다.',3,'2026-01-20 02:11:20.000000','2026-01-20 05:59:01.000000',NULL);
INSERT INTO `layer` (`id`, `architecture_id`, `code`, `name`, `description`, `order_index`, `created_at`, `updated_at`, `deleted_at`) VALUES (4,1,'ADAPTER_IN','Adapter-In Layer','인바운드 어댑터 레이어. 외부 요청(REST API, gRPC, CLI 등)을 받아 애플리케이션으로 전달합니다. Controller, API DTO, Mapper를 포함합니다.',4,'2026-01-20 02:11:20.000000','2026-01-20 05:59:01.000000',NULL);
INSERT INTO `layer` (`id`, `architecture_id`, `code`, `name`, `description`, `order_index`, `created_at`, `updated_at`, `deleted_at`) VALUES (5,1,'BOOTSTRAP','Bootstrap Layer','애플리케이션 실행 진입점 레이어. main() 메서드, Spring Boot Application 클래스, 설정 파일이 위치합니다. 모든 모듈을 조립하여 실행 가능한 애플리케이션을 구성합니다.',5,'2026-01-20 05:59:01.000000','2026-01-20 05:59:01.000000',NULL);

INSERT INTO `layer_dependency_rule` (`id`, `architecture_id`, `from_layer`, `to_layer`, `dependency_type`, `condition_description`, `created_at`, `updated_at`, `deleted_at`) VALUES (1,1,'APPLICATION','DOMAIN','ALLOWED','Application 레이어는 Domain 레이어에 의존할 수 있습니다.','2026-01-20 02:11:20.000000','2026-01-20 02:11:20.000000',NULL);
INSERT INTO `layer_dependency_rule` (`id`, `architecture_id`, `from_layer`, `to_layer`, `dependency_type`, `condition_description`, `created_at`, `updated_at`, `deleted_at`) VALUES (2,1,'ADAPTER_OUT','DOMAIN','ALLOWED','Adapter-Out 레이어는 Domain 레이어에 의존할 수 있습니다.','2026-01-20 02:11:20.000000','2026-01-20 05:59:01.000000',NULL);
INSERT INTO `layer_dependency_rule` (`id`, `architecture_id`, `from_layer`, `to_layer`, `dependency_type`, `condition_description`, `created_at`, `updated_at`, `deleted_at`) VALUES (3,1,'ADAPTER_IN','APPLICATION','ALLOWED','Adapter-In 레이어는 Application 레이어에 의존할 수 있습니다.','2026-01-20 02:11:20.000000','2026-01-20 05:59:01.000000',NULL);
INSERT INTO `layer_dependency_rule` (`id`, `architecture_id`, `from_layer`, `to_layer`, `dependency_type`, `condition_description`, `created_at`, `updated_at`, `deleted_at`) VALUES (4,1,'DOMAIN','APPLICATION','FORBIDDEN','Domain 레이어는 Application 레이어에 의존할 수 없습니다.','2026-01-20 02:11:20.000000','2026-01-20 02:11:20.000000',NULL);
INSERT INTO `layer_dependency_rule` (`id`, `architecture_id`, `from_layer`, `to_layer`, `dependency_type`, `condition_description`, `created_at`, `updated_at`, `deleted_at`) VALUES (5,1,'DOMAIN','ADAPTER_OUT','FORBIDDEN','Domain 레이어는 Adapter-Out 레이어에 의존할 수 없습니다.','2026-01-20 02:11:20.000000','2026-01-20 05:59:01.000000',NULL);
INSERT INTO `layer_dependency_rule` (`id`, `architecture_id`, `from_layer`, `to_layer`, `dependency_type`, `condition_description`, `created_at`, `updated_at`, `deleted_at`) VALUES (6,1,'DOMAIN','ADAPTER_IN','FORBIDDEN','Domain 레이어는 Adapter-In 레이어에 의존할 수 없습니다.','2026-01-20 02:11:20.000000','2026-01-20 05:59:01.000000',NULL);
INSERT INTO `layer_dependency_rule` (`id`, `architecture_id`, `from_layer`, `to_layer`, `dependency_type`, `condition_description`, `created_at`, `updated_at`, `deleted_at`) VALUES (7,1,'BOOTSTRAP','ADAPTER_IN','ALLOWED','Bootstrap 레이어는 Adapter-In 레이어에 의존할 수 있습니다.','2026-01-20 05:59:01.000000','2026-01-20 05:59:01.000000',NULL);
INSERT INTO `layer_dependency_rule` (`id`, `architecture_id`, `from_layer`, `to_layer`, `dependency_type`, `condition_description`, `created_at`, `updated_at`, `deleted_at`) VALUES (8,1,'BOOTSTRAP','ADAPTER_OUT','ALLOWED','Bootstrap 레이어는 Adapter-Out 레이어에 의존할 수 있습니다.','2026-01-20 05:59:01.000000','2026-01-20 05:59:01.000000',NULL);
INSERT INTO `layer_dependency_rule` (`id`, `architecture_id`, `from_layer`, `to_layer`, `dependency_type`, `condition_description`, `created_at`, `updated_at`, `deleted_at`) VALUES (9,1,'BOOTSTRAP','APPLICATION','ALLOWED','Bootstrap 레이어는 Application 레이어에 의존할 수 있습니다.','2026-01-20 05:59:01.000000','2026-01-20 05:59:01.000000',NULL);
INSERT INTO `layer_dependency_rule` (`id`, `architecture_id`, `from_layer`, `to_layer`, `dependency_type`, `condition_description`, `created_at`, `updated_at`, `deleted_at`) VALUES (10,1,'BOOTSTRAP','DOMAIN','ALLOWED','Bootstrap 레이어는 Domain 레이어에 의존할 수 있습니다.','2026-01-20 05:59:01.000000','2026-01-20 05:59:01.000000',NULL);
INSERT INTO `layer_dependency_rule` (`id`, `architecture_id`, `from_layer`, `to_layer`, `dependency_type`, `condition_description`, `created_at`, `updated_at`, `deleted_at`) VALUES (11,1,'DOMAIN','BOOTSTRAP','FORBIDDEN','Domain 레이어는 Bootstrap 레이어에 의존할 수 없습니다.','2026-01-20 05:59:01.000000','2026-01-20 05:59:01.000000',NULL);
INSERT INTO `layer_dependency_rule` (`id`, `architecture_id`, `from_layer`, `to_layer`, `dependency_type`, `condition_description`, `created_at`, `updated_at`, `deleted_at`) VALUES (12,1,'APPLICATION','BOOTSTRAP','FORBIDDEN','Application 레이어는 Bootstrap 레이어에 의존할 수 없습니다.','2026-01-20 05:59:01.000000','2026-01-20 05:59:01.000000',NULL);
INSERT INTO `layer_dependency_rule` (`id`, `architecture_id`, `from_layer`, `to_layer`, `dependency_type`, `condition_description`, `created_at`, `updated_at`, `deleted_at`) VALUES (13,1,'ADAPTER_IN','BOOTSTRAP','FORBIDDEN','Adapter-In 레이어는 Bootstrap 레이어에 의존할 수 없습니다.','2026-01-20 05:59:01.000000','2026-01-20 05:59:01.000000',NULL);
INSERT INTO `layer_dependency_rule` (`id`, `architecture_id`, `from_layer`, `to_layer`, `dependency_type`, `condition_description`, `created_at`, `updated_at`, `deleted_at`) VALUES (14,1,'ADAPTER_OUT','BOOTSTRAP','FORBIDDEN','Adapter-Out 레이어는 Bootstrap 레이어에 의존할 수 없습니다.','2026-01-20 05:59:01.000000','2026-01-20 05:59:01.000000',NULL);

INSERT INTO `module` (`id`, `layer_id`, `parent_module_id`, `name`, `description`, `module_path`, `build_identifier`, `created_at`, `updated_at`, `deleted_at`) VALUES (1,1,NULL,'domain','Domain 핵심 모듈','domain',':domain','2026-01-20 02:11:20.000000','2026-01-20 02:11:20.000000',NULL);
INSERT INTO `module` (`id`, `layer_id`, `parent_module_id`, `name`, `description`, `module_path`, `build_identifier`, `created_at`, `updated_at`, `deleted_at`) VALUES (2,2,NULL,'application','Application 서비스 모듈','application',':application','2026-01-20 02:11:20.000000','2026-01-20 02:11:20.000000',NULL);
INSERT INTO `module` (`id`, `layer_id`, `parent_module_id`, `name`, `description`, `module_path`, `build_identifier`, `created_at`, `updated_at`, `deleted_at`) VALUES (3,3,NULL,'adapter-out','Outbound Adapter 부모 모듈','adapter-out',':adapter-out','2026-01-20 02:11:20.000000','2026-01-20 02:11:20.000000',NULL);
INSERT INTO `module` (`id`, `layer_id`, `parent_module_id`, `name`, `description`, `module_path`, `build_identifier`, `created_at`, `updated_at`, `deleted_at`) VALUES (4,3,3,'persistence-mysql','MySQL Persistence 어댑터','adapter-out/persistence-mysql',':adapter-out:persistence-mysql','2026-01-20 02:11:20.000000','2026-01-20 02:11:20.000000',NULL);
INSERT INTO `module` (`id`, `layer_id`, `parent_module_id`, `name`, `description`, `module_path`, `build_identifier`, `created_at`, `updated_at`, `deleted_at`) VALUES (5,4,NULL,'adapter-in','Inbound Adapter 부모 모듈','adapter-in',':adapter-in','2026-01-20 02:11:20.000000','2026-01-20 02:11:20.000000',NULL);
INSERT INTO `module` (`id`, `layer_id`, `parent_module_id`, `name`, `description`, `module_path`, `build_identifier`, `created_at`, `updated_at`, `deleted_at`) VALUES (6,4,5,'rest-api','REST API 어댑터','adapter-in/rest-api',':adapter-in:rest-api','2026-01-20 02:11:20.000000','2026-01-20 02:11:20.000000',NULL);
INSERT INTO `module` (`id`, `layer_id`, `parent_module_id`, `name`, `description`, `module_path`, `build_identifier`, `created_at`, `updated_at`, `deleted_at`) VALUES (7,5,NULL,'bootstrap','Bootstrap 부모 모듈','bootstrap',':bootstrap','2026-01-20 05:59:01.000000','2026-01-20 05:59:01.000000',NULL);
INSERT INTO `module` (`id`, `layer_id`, `parent_module_id`, `name`, `description`, `module_path`, `build_identifier`, `created_at`, `updated_at`, `deleted_at`) VALUES (8,5,7,'bootstrap-web-api','Web API 실행 모듈','bootstrap/bootstrap-web-api',':bootstrap:bootstrap-web-api','2026-01-20 05:59:01.000000','2026-01-20 05:59:01.000000',NULL);
INSERT INTO `module` (`id`, `layer_id`, `parent_module_id`, `name`, `description`, `module_path`, `build_identifier`, `created_at`, `updated_at`, `deleted_at`) VALUES (9,5,7,'bootstrap-scheduler','Scheduler 실행 모듈','bootstrap/bootstrap-scheduler',':bootstrap:bootstrap-scheduler','2026-01-20 05:59:01.000000','2026-01-20 05:59:01.000000',NULL);
INSERT INTO `module` (`id`, `layer_id`, `parent_module_id`, `name`, `description`, `module_path`, `build_identifier`, `created_at`, `updated_at`, `deleted_at`) VALUES (10,3,3,'persistence-redis','Redis 캐시 어댑터','adapter-out/persistence-redis',':adapter-out:persistence-redis','2026-01-20 05:59:01.000000','2026-01-20 05:59:01.000000',NULL);
INSERT INTO `module` (`id`, `layer_id`, `parent_module_id`, `name`, `description`, `module_path`, `build_identifier`, `created_at`, `updated_at`, `deleted_at`) VALUES (11,3,3,'sqs-publisher','AWS SQS 메시지 발행 어댑터','adapter-out/sqs-publisher',':adapter-out:sqs-publisher','2026-01-20 05:59:01.000000','2026-01-20 05:59:01.000000',NULL);
INSERT INTO `module` (`id`, `layer_id`, `parent_module_id`, `name`, `description`, `module_path`, `build_identifier`, `created_at`, `updated_at`, `deleted_at`) VALUES (12,4,5,'sqs-consumer','AWS SQS 메시지 소비 어댑터','adapter-in/sqs-consumer',':adapter-in:sqs-consumer','2026-01-20 05:59:01.000000','2026-01-20 05:59:01.000000',NULL);
INSERT INTO `module` (`id`, `layer_id`, `parent_module_id`, `name`, `description`, `module_path`, `build_identifier`, `created_at`, `updated_at`, `deleted_at`) VALUES (13,4,5,'scheduler','스케줄 작업 어댑터','adapter-in/scheduler',':adapter-in:scheduler','2026-01-20 05:59:01.000000','2026-01-20 05:59:01.000000',NULL);
INSERT INTO `module` (`id`, `layer_id`, `parent_module_id`, `name`, `description`, `module_path`, `build_identifier`, `created_at`, `updated_at`, `deleted_at`) VALUES (14,3,3,'client','외부 클라이언트 부모 모듈','adapter-out/client',':adapter-out:client','2026-01-20 05:59:01.000000','2026-01-20 05:59:01.000000',NULL);
INSERT INTO `module` (`id`, `layer_id`, `parent_module_id`, `name`, `description`, `module_path`, `build_identifier`, `created_at`, `updated_at`, `deleted_at`) VALUES (15,3,14,'distributed-lock-redis','Redis 기반 분산락 클라이언트','adapter-out/client/distributed-lock-redis',':adapter-out:client:distributed-lock-redis','2026-01-20 05:59:01.000000','2026-01-20 05:59:01.000000',NULL);
INSERT INTO `module` (`id`, `layer_id`, `parent_module_id`, `name`, `description`, `module_path`, `build_identifier`, `created_at`, `updated_at`, `deleted_at`) VALUES (16,5,7,'bootstrap-worker','메시지 리스너 및 백그라운드 작업 실행 모듈','bootstrap/bootstrap-worker',':bootstrap:bootstrap-worker','2026-01-20 05:59:01.000000','2026-01-20 05:59:01.000000',NULL);
INSERT INTO `module` (`id`, `layer_id`, `parent_module_id`, `name`, `description`, `module_path`, `build_identifier`, `created_at`, `updated_at`, `deleted_at`) VALUES (17,3,3,'persistence-mysql-admin','Admin/통계용 MySQL Persistence 어댑터. 조인 허용, 복잡 쿼리 허용. OLAP 최적화.','adapter-out/persistence-mysql-admin',':adapter-out:persistence-mysql-admin','2026-01-21 07:57:35.000000','2026-01-21 07:57:35.000000',NULL);

INSERT INTO `onboarding_context` (`id`, `tech_stack_id`, `architecture_id`, `context_type`, `title`, `content`, `priority`, `created_at`, `updated_at`, `deleted_at`) VALUES (1,1,1,'SUMMARY','프로젝트 개요','## 기술 스택\n- **Language**: Java 21 (Virtual Thread, Record, Pattern Matching)\n- **Framework**: Spring Boot 3.5.x\n- **Build**: Gradle (Kotlin DSL)\n\n## 아키텍처\n- **Pattern**: Hexagonal Architecture (Ports & Adapters)\n- **Principles**: DIP, SRP, OCP, ISP, CQRS, DDD\n\n## 모듈 구조\n```\ndomain                  → 비즈니스 로직 (Aggregate, VO, Event)\napplication             → 유스케이스 (Service, Port)\nadapter-out/persistence → 영속성 (Entity, Repository)\nadapter-in/rest-api     → REST API (Controller, DTO)\n```',1,'2026-01-24 07:51:10.000000','2026-01-24 07:51:10.000000',NULL);
INSERT INTO `onboarding_context` (`id`, `tech_stack_id`, `architecture_id`, `context_type`, `title`, `content`, `priority`, `created_at`, `updated_at`, `deleted_at`) VALUES (2,1,1,'MCP_USAGE','MCP 사용법','## 3-Phase 워크플로우\n\n| Phase | Tool | 용도 |\n|-------|------|------|\n| 1. Planning | `planning_context()` | 어떤 컴포넌트를 어디에 만들지 결정 |\n| 2. Execution | `module_context()` | 템플릿 + 규칙 기반 코드 생성 |\n| 3. Validation | `validation_context()` | Zero-Tolerance 검증 |\n\n## 핵심 사용 패턴\n\n```python\n# Aggregate 생성 시\nplanning_context(layers=[\"DOMAIN\"])\nmodule_context(module_id=1, class_type=\"AGGREGATE\")\nvalidation_context(layers=[\"DOMAIN\"])\n\n# UseCase 생성 시\nmodule_context(module_id=2, class_type=\"USE_CASE\")\n```\n\n## 주요 도구\n\n| Tool | 용도 |\n|------|------|\n| `get_context()` | 빠른 컨텍스트 조회 |\n| `get_rule()` | 규칙 상세 + 예시 |\n| `get_layer_detail()` | 레이어 상세 |',2,'2026-01-24 07:51:23.000000','2026-01-24 07:51:23.000000',NULL);
INSERT INTO `onboarding_context` (`id`, `tech_stack_id`, `architecture_id`, `context_type`, `title`, `content`, `priority`, `created_at`, `updated_at`, `deleted_at`) VALUES (3,1,1,'ZERO_TOLERANCE','Zero-Tolerance 규칙','## 절대 위반 금지 규칙\n\n> 상세 규칙은 `validation_context()`로 조회하세요.\n\n### Domain Layer\n- ❌ Lombok 금지 (@Data, @Getter, @Builder 등)\n- ❌ Getter 체이닝 금지 (Law of Demeter)\n- ❌ Setter 금지\n- ✅ Tell, Don\'t Ask 원칙\n\n### Application Layer\n- ❌ @Transactional 내 외부 API 호출 금지\n- ✅ DTO는 Record 필수\n- ✅ CQRS 분리\n\n### Persistence Layer\n- ❌ JPA 관계 어노테이션 금지 (@OneToMany 등)\n- ✅ Long FK 전략\n- ✅ QueryDSL DTO Projection\n\n### REST API Layer\n- ❌ MockMvc 금지\n- ✅ TestRestTemplate 사용\n- ✅ @Valid 필수\n\n## 검증 방법\n```python\nvalidation_context(layers=[\"DOMAIN\", \"APPLICATION\", \"PERSISTENCE\", \"REST_API\"])\n```',3,'2026-01-24 07:51:37.000000','2026-01-24 07:51:37.000000',NULL);
INSERT INTO `onboarding_context` (`id`, `tech_stack_id`, `architecture_id`, `context_type`, `title`, `content`, `priority`, `created_at`, `updated_at`, `deleted_at`) VALUES (4,1,1,'RULES_INDEX','규칙 인덱스','## 레이어별 규칙 현황\n\n| Layer | Module | Rules | BLOCKER | Examples |\n|-------|--------|-------|---------|----------|\n| DOMAIN | domain | 63 | 44 | 15 |\n| APPLICATION | application | 37 | 10 | 68 |\n| PERSISTENCE | persistence-mysql | 15 | 10 | 29 |\n| REST_API | rest-api | 47 | 3 | 20 |\n| **합계** | - | **162** | **67** | **134** |\n\n## 클래스 템플릿 현황\n\n| Layer | Templates |\n|-------|-----------|\n| DOMAIN | 25개 (Aggregate, VO, Event, Exception) |\n| APPLICATION | 22개 (UseCase, Service, Manager, Port) |\n| PERSISTENCE | 15개 (Entity, Repository, Mapper) |\n| REST_API | 7개 (Controller, DTO, Mapper) |\n\n## 규칙 조회 방법\n\n```python\n# 레이어별 규칙 조회\nget_layer_detail(layer_code=\"DOMAIN\")\n\n# 특정 규칙 상세\nget_rule(rule_code=\"DOM-AGG-001\")\n\n# 클래스 템플릿 조회\nmodule_context(module_id=1, class_type=\"AGGREGATE\")\n```',4,'2026-01-24 07:51:50.000000','2026-01-24 07:51:50.000000',NULL);

INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (1,1,'AGGREGATE','Aggregate 패키지','Domain Aggregate Root와 내부 Entity가 위치하는 패키지입니다. Aggregate Root는 비즈니스 불변식을 보장하고, 트랜잭션 일관성 경계를 정의합니다.','[\"AGGREGATE_ROOT\", \"ENTITY\"]',NULL,NULL,'2026-01-20 08:21:55.000000','2026-01-20 08:21:55.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (2,2,'VALUE_OBJECT','Value Object 패키지','도메인별 Value Object가 위치하는 패키지입니다. 불변 객체로 동등성은 값으로 판단합니다. Money, Address, DateRange 등이 해당됩니다.','[\"VALUE_OBJECT\", \"RECORD\"]',NULL,NULL,'2026-01-20 08:21:55.000000','2026-01-20 08:21:55.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (3,3,'ID_VALUE_OBJECT','ID Value Object 패키지','Aggregate Root의 식별자 Value Object가 위치하는 패키지입니다. record로 정의하며, Long value 필드를 가집니다.','[\"RECORD\"]','{Domain}Id','Id','2026-01-20 08:21:55.000000','2026-01-20 08:21:55.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (4,4,'DOMAIN_EXCEPTION','Domain Exception 패키지','도메인별 예외 클래스와 ErrorCode enum이 위치하는 패키지입니다. DomainException을 상속받고, 도메인별 ErrorCode를 정의합니다.','[\"EXCEPTION\", \"ENUM\"]','{Domain}*Exception|{Domain}ErrorCode','Exception','2026-01-20 08:21:55.000000','2026-01-20 08:21:55.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (16,5,'COMMON_VO','공통 Value Object 패키지','여러 도메인에서 공통으로 사용되는 불변 Value Object를 정의합니다.','[\"VALUE_OBJECT\", \"RECORD\", \"INTERFACE\", \"ENUM\"]',NULL,NULL,'2026-01-20 07:36:20.000000','2026-01-20 07:36:20.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (17,6,'COMMON_EXCEPTION','공통 Exception 패키지','도메인 예외의 기본 구조를 정의합니다. ErrorCode 인터페이스와 DomainException 추상 클래스를 제공합니다.','[\"EXCEPTION\", \"INTERFACE\", \"ENUM\"]','*Exception','Exception','2026-01-20 07:36:20.000000','2026-01-20 07:36:20.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (18,7,'COMMON_EVENT','공통 Event 패키지','도메인 이벤트의 기본 구조를 정의합니다. DomainEvent 마커 인터페이스를 제공합니다.','[\"INTERFACE\", \"RECORD\"]','*Event','Event','2026-01-20 07:36:20.000000','2026-01-20 07:36:20.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (19,8,'DOMAIN_QUERY','도메인 Query 패키지','도메인별 조회 조건(Criteria)을 정의합니다. 페이지 기반은 *PageCriteria, 커서 기반은 *CursorCriteria 네이밍을 따릅니다. QueryContext 또는 CursorQueryContext를 필수로 포함하며, DateRange 등 공통 VO를 활용할 수 있습니다.','[\"RECORD\", \"CLASS\"]','*Criteria','Criteria','2026-01-20 07:57:26.000000','2026-01-20 07:57:26.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (20,9,'PORT_IN_COMMAND','Command UseCase 인터페이스','Command UseCase 인터페이스가 위치합니다. execute() 단일 메서드를 가지며, 1 UseCase = 1 Service로 구현됩니다.',NULL,NULL,NULL,'2026-01-21 05:26:15.000000','2026-01-21 05:26:15.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (21,10,'PORT_IN_QUERY','Query UseCase 인터페이스','Query UseCase 인터페이스가 위치합니다. Get*, Count*, Check*Exists 패턴의 조회 UseCase가 위치합니다.',NULL,NULL,NULL,'2026-01-21 05:26:15.000000','2026-01-21 05:26:15.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (22,11,'PORT_OUT_COMMAND','Command Port 인터페이스','DB 쓰기용 CommandPort가 위치합니다. persist(), persistAll() 메서드만 허용됩니다. update 메서드는 JPA Dirty Checking으로 대체.',NULL,NULL,NULL,'2026-01-21 05:26:15.000000','2026-01-21 05:26:15.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (23,12,'PORT_OUT_QUERY','Query Port 인터페이스','DB 읽기용 QueryPort가 위치합니다. findById, findBy*, findBySliceCriteria, existsBy*, countBy* 패턴을 사용합니다. findAll 금지 (OOM 위험).',NULL,NULL,NULL,'2026-01-21 05:26:15.000000','2026-01-21 05:26:15.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (24,13,'PORT_OUT_CLIENT','Client Port 인터페이스','외부 HTTP API, 메시징 큐 연동용 ClientPort가 위치합니다. PaymentClientPort, NotificationClientPort 등.',NULL,NULL,NULL,'2026-01-21 05:26:15.000000','2026-01-21 05:26:15.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (25,14,'SERVICE_COMMAND','Command Service 구현체','Command UseCase 1:1 구현체가 위치합니다. @Transactional 금지. Factory → Validator → Facade/Manager → Assembler 흐름으로 조율합니다.',NULL,NULL,NULL,'2026-01-21 05:26:15.000000','2026-01-21 05:26:15.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (26,15,'SERVICE_QUERY','Query Service 구현체','Query UseCase 1:1 구현체가 위치합니다. QueryFacade/QueryManager를 통해 조회합니다.',NULL,NULL,NULL,'2026-01-21 05:26:15.000000','2026-01-21 05:26:15.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (27,16,'FACADE_COMMAND','Command Facade','Manager 2개 이상 조합 시 사용합니다. DB 원자성 필요 시 @Transactional 사용. CommandFacade → QueryManager 의존 금지 (CQRS).',NULL,NULL,NULL,'2026-01-21 05:26:15.000000','2026-01-21 05:26:15.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (28,17,'FACADE_QUERY','Query Facade','어드민 복합 조회 등 Manager 2개 이상 조합 시 사용합니다. @Transactional(readOnly=true) 사용.',NULL,NULL,NULL,'2026-01-21 05:26:15.000000','2026-01-21 05:26:15.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (29,18,'MANAGER_COMMAND','Command Manager','CommandPort 1:1 래핑. @Transactional 필수. 트랜잭션 관리 주체입니다.',NULL,NULL,NULL,'2026-01-21 05:26:15.000000','2026-01-21 05:26:15.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (30,19,'MANAGER_QUERY','Query Manager (ReadManager)','QueryPort 1:1 래핑. @Transactional(readOnly=true) 필수. NOT_FOUND 예외 처리 통일.',NULL,NULL,NULL,'2026-01-21 05:26:15.000000','2026-01-21 05:26:15.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (31,20,'MANAGER_CLIENT','Client Manager','ClientPort 래핑. @Transactional 금지. 외부 호출은 트랜잭션 밖에서 실행. Service에서 직접 의존 가능.',NULL,NULL,NULL,'2026-01-21 05:26:15.000000','2026-01-21 05:26:15.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (32,21,'FACTORY_COMMAND','Command Factory','Command → Domain/Bundle 생성. TimeProvider 사용하여 Instant 전달. UpdateContext, StatusChangeContext 생성.',NULL,NULL,NULL,'2026-01-21 05:26:15.000000','2026-01-21 05:26:15.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (33,22,'FACTORY_QUERY','Query Factory','Query → Criteria 변환. 도메인별 기본값(sortKey, direction, dateRange) 결정. CommonVoFactory로 순수 변환 위임.',NULL,NULL,NULL,'2026-01-21 05:26:15.000000','2026-01-21 05:26:15.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (34,23,'ASSEMBLER','Assembler','Domain → Application Response 변환. 도메인별 구체 Result 클래스 반환 (제네릭 래퍼 금지).',NULL,NULL,NULL,'2026-01-21 05:26:15.000000','2026-01-21 05:26:15.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (35,24,'VALIDATOR','Validator','외부 의존성 필요한 비즈니스 검증. 자기 도메인 ReadManager만 의존. 검증 성공 시 Domain 객체 반환.',NULL,NULL,NULL,'2026-01-21 05:26:15.000000','2026-01-21 05:26:15.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (38,27,'DTO_COMMAND','Command DTO','Command DTO 패키지. Record 필수. 순수 데이터 컨테이너 (인스턴스 메서드 금지). 기본값 처리는 REST API Mapper에서.',NULL,NULL,NULL,'2026-01-21 05:26:15.000000','2026-01-21 05:26:15.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (39,28,'DTO_QUERY','Query DTO','Query DTO 패키지. *SearchParams는 CommonSearchParams 포함 필수. *CursorParams는 CommonCursorParams 포함 필수.',NULL,NULL,NULL,'2026-01-21 05:26:15.000000','2026-01-21 05:26:15.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (40,29,'DTO_RESPONSE','Response DTO','Response/Result DTO 패키지. 도메인별 구체 Result 클래스 사용. *SliceResult, *PageResult는 SliceMeta/PageMeta(Domain VO) 포함.',NULL,NULL,NULL,'2026-01-21 05:26:15.000000','2026-01-21 05:26:15.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (41,30,'DTO_BUNDLE','Bundle DTO','Facade용 복합 DTO. withId() 패턴으로 상위-하위 ID 연결. Service → Factory → Facade(Bundle) 흐름.',NULL,NULL,NULL,'2026-01-21 05:26:15.000000','2026-01-21 05:26:15.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (42,31,'DTO_COMMON_QUERY','공통 Query DTO','공통 Query DTO. CommonSearchParams(page, size, sortKey, sortDirection, includeDeleted, startDate, endDate), CommonCursorParams(cursor, size).',NULL,NULL,NULL,'2026-01-21 05:26:15.000000','2026-01-21 05:26:15.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (44,33,'FACTORY_COMMON','공통 Factory','공통 Factory. CommonVoFactory가 위치. 순수 타입 변환만 담당 (기본값 로직 없음).',NULL,NULL,NULL,'2026-01-21 05:26:15.000000','2026-01-21 05:26:15.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (45,25,'INTERNAL_HELPER','Internal Helper','Calculator, Resolver, Converter 등 내부 헬퍼 컴포넌트',NULL,NULL,NULL,'2026-01-21 05:38:47.000000','2026-01-21 05:38:47.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (46,32,'COMMON_COMMAND_DTO','Common Command DTO','StatusChangeContext 등 공통 Command DTO',NULL,NULL,'Context','2026-01-21 05:38:47.000000','2026-01-21 05:38:47.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (47,34,'COMMON_INTERNAL','Common Internal Helper','여러 도메인에서 공유하는 내부 헬퍼 컴포넌트',NULL,NULL,NULL,'2026-01-21 05:38:47.000000','2026-01-21 05:38:47.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (48,35,'COMMON_EVENT','Common Event Component','TransactionEventRegistry 등 이벤트 관련 공통 컴포넌트',NULL,NULL,'Registry','2026-01-21 05:38:47.000000','2026-01-21 05:38:47.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (49,36,'EVENT_LISTENER','Event Listener','도메인 이벤트를 처리하는 리스너',NULL,NULL,'EventListener','2026-01-21 05:38:47.000000','2026-01-21 05:38:47.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (50,37,'COMMAND_ADAPTER','Command Adapter','CommandPort 구현체. JpaRepository만 의존','[\"COMMAND_ADAPTER\"]','{Entity}CommandAdapter','CommandAdapter','2026-01-21 07:42:54.000000','2026-01-21 07:42:54.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (51,37,'QUERY_ADAPTER','Query Adapter','QueryPort 구현체. QueryDslRepository만 의존','[\"QUERY_ADAPTER\"]','{Entity}QueryAdapter','QueryAdapter','2026-01-21 07:42:54.000000','2026-01-21 07:42:54.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (52,38,'JPA_ENTITY','JPA Entity','JPA 엔티티. BaseAuditEntity 또는 SoftDeletableEntity 상속','[\"JPA_ENTITY\"]','{Entity}JpaEntity','JpaEntity','2026-01-21 07:42:54.000000','2026-01-21 07:42:54.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (53,39,'ENTITY_MAPPER','Entity Mapper','Domain ↔ Entity 변환. static 메서드로 구성','[\"ENTITY_MAPPER\"]','{Entity}EntityMapper','EntityMapper','2026-01-21 07:42:54.000000','2026-01-21 07:42:54.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (54,40,'JPA_REPOSITORY','JPA Repository','Command용. save, saveAll만 사용 (커스텀 메서드 추가 금지)','[\"JPA_REPOSITORY\"]','{Entity}JpaRepository','JpaRepository','2026-01-21 07:42:54.000000','2026-01-21 07:42:54.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (55,40,'QUERYDSL_REPOSITORY','QueryDSL Repository','Query용. 모든 조회 담당','[\"QUERYDSL_REPOSITORY\"]','{Entity}QueryDslRepository','QueryDslRepository','2026-01-21 07:42:54.000000','2026-01-21 07:42:54.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (56,41,'CONDITION_BUILDER','Condition Builder','BooleanExpression/BooleanBuilder 생성 전담','[\"CONDITION_BUILDER\"]','{Entity}ConditionBuilder','ConditionBuilder','2026-01-21 07:42:54.000000','2026-01-21 07:42:54.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (57,42,'BASE_AUDIT_ENTITY','Base Audit Entity','감사 필드 제공 (createdAt, updatedAt)','[\"BASE_AUDIT_ENTITY\"]','BaseAuditEntity',NULL,'2026-01-21 07:42:54.000000','2026-01-21 07:42:54.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (58,42,'SOFT_DELETABLE_ENTITY','Soft Deletable Entity','소프트 삭제 지원. BaseAuditEntity 상속 + deletedAt','[\"SOFT_DELETABLE_ENTITY\"]','SoftDeletableEntity',NULL,'2026-01-21 07:42:54.000000','2026-01-21 07:42:54.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (59,43,'JPA_CONFIG','JPA Config','JPA/QueryDSL/ObjectMapper Bean 설정','[\"JPA_CONFIG\"]','JpaConfig',NULL,'2026-01-21 07:42:54.000000','2026-01-21 07:42:54.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (60,43,'PERSISTENCE_OBJECT_MAPPER','Persistence ObjectMapper','JSON 파싱 래퍼. 에러 처리 중앙화','[\"PERSISTENCE_OBJECT_MAPPER\"]','PersistenceObjectMapper',NULL,'2026-01-21 07:42:54.000000','2026-01-21 07:42:54.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (61,44,'SLICE_CRITERIA','Slice Criteria','커서 기반 페이징 조건 (cursor, size)','[\"SLICE_CRITERIA\"]','SliceCriteria',NULL,'2026-01-21 07:42:54.000000','2026-01-21 07:42:54.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (62,44,'SORT_CRITERIA','Sort Criteria','정렬 조건 (field, direction)','[\"SORT_CRITERIA\"]','SortCriteria',NULL,'2026-01-21 07:42:54.000000','2026-01-21 07:42:54.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (63,44,'SEARCH_CRITERIA','Search Criteria','검색 조건 (keyword, searchType)','[\"SEARCH_CRITERIA\"]','SearchCriteria',NULL,'2026-01-21 07:42:54.000000','2026-01-21 07:42:54.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (64,45,'FUNCTION_CONTRIBUTOR','Function Contributor','Hibernate 커스텀 함수 등록 (FullText 등)','[\"FUNCTION_CONTRIBUTOR\"]','MatchAgainstFunctionContributor',NULL,'2026-01-21 07:42:54.000000','2026-01-21 07:42:54.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (65,46,'ADMIN_QUERY_ADAPTER','Admin 조회 어댑터','Admin용 QueryPort 구현체. AdminQueryDslRepository만 의존.','[\"ADMIN_QUERY_ADAPTER\"]','{Entity}AdminQueryAdapter','AdminQueryAdapter','2026-01-21 07:58:16.000000','2026-01-21 07:58:16.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (66,46,'ADMIN_QUERYDSL_REPOSITORY','Admin QueryDSL 레포지토리','Admin용 복잡 쿼리 처리. 조인 허용, 서브쿼리 허용.','[\"ADMIN_QUERYDSL_REPOSITORY\"]','{Entity}AdminQueryDslRepository','AdminQueryDslRepository','2026-01-21 07:58:16.000000','2026-01-21 07:58:16.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (67,47,'ADMIN_PROJECTION_DTO','Admin Projection DTO','여러 테이블 조인 결과를 담는 DTO. Record 권장.','[\"ADMIN_PROJECTION_DTO\"]','{Purpose}Dto','Dto','2026-01-21 07:58:16.000000','2026-01-21 07:58:16.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (68,48,'ADMIN_JPA_CONFIG','Admin JPA 설정','Read Replica 연결, 별도 DataSource 설정 등.','[\"ADMIN_JPA_CONFIG\"]','Admin{Purpose}Config','Config','2026-01-21 07:58:16.000000','2026-01-21 07:58:16.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (69,49,'API_ENDPOINTS','API Endpoints','도메인 API 엔드포인트 상수 클래스','[\"API_ENDPOINTS\"]',NULL,'ApiEndpoints','2026-01-21 08:13:08.120519','2026-01-21 08:13:08.120519',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (73,52,'API_ERROR_CODE','API Error Code','API 에러 코드 Enum','[\"API_ERROR_CODE\"]',NULL,'ErrorCode','2026-01-21 08:13:08.120519','2026-01-21 08:13:08.120519',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (74,52,'API_EXCEPTION','API Exception','API 예외 클래스','[\"API_EXCEPTION\"]',NULL,'Exception','2026-01-21 08:13:08.120519','2026-01-21 08:13:08.120519',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (75,53,'API_MAPPER','API DTO Mapper','API DTO <-> Application DTO 매퍼','[\"API_MAPPER\"]',NULL,'ApiMapper','2026-01-21 08:13:08.120519','2026-01-21 08:13:08.120519',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (76,54,'COMMON_API_PATHS','Common API Paths','공통 API 경로 상수 (ApiPaths)','[\"API_ENDPOINTS\"]',NULL,NULL,'2026-01-21 08:13:08.120519','2026-01-21 08:13:08.120519',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (77,55,'COMMON_CONTROLLER','Common Controller','공통 컨트롤러 (Health Check, Info 등)','[\"CONTROLLER\"]',NULL,'Controller','2026-01-21 08:13:08.120519','2026-01-21 08:13:08.120519',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (78,56,'COMMON_API_REQUEST','Common API Request','공통 API 요청 DTO','[\"API_REQUEST\"]',NULL,'ApiRequest','2026-01-21 08:13:08.120519','2026-01-21 08:13:08.120519',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (79,56,'COMMON_API_RESPONSE','Common API Response','공통 API 응답 DTO','[\"API_RESPONSE\"]',NULL,'ApiResponse','2026-01-21 08:13:08.120519','2026-01-21 08:13:08.120519',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (80,56,'API_PAGE_RESPONSE','API Page Response','페이징 API 응답 래퍼','[\"API_PAGE_RESPONSE\"]',NULL,'PageApiResponse','2026-01-21 08:13:08.120519','2026-01-21 08:13:08.120519',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (81,57,'GLOBAL_EXCEPTION_HANDLER','Global Exception Handler','전역 예외 처리 핸들러 (@RestControllerAdvice)','[\"GLOBAL_EXCEPTION_HANDLER\"]',NULL,'ExceptionHandler','2026-01-21 08:13:08.120519','2026-01-21 08:13:08.120519',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (82,57,'API_ERROR_RESPONSE','API Error Response','API 에러 응답 DTO','[\"API_ERROR_RESPONSE\"]',NULL,'ErrorResponse','2026-01-21 08:13:08.120519','2026-01-21 08:13:08.120519',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (83,58,'COMMON_API_MAPPER','Common API Mapper','공통 API 매퍼','[\"API_MAPPER\"]',NULL,'ApiMapper','2026-01-21 08:13:08.120519','2026-01-21 08:13:08.120519',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (84,59,'UTILITY','Utility Class','유틸리티 클래스','[\"UTILITY\"]',NULL,'Util','2026-01-21 08:13:08.120519','2026-01-21 08:13:08.120519',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (85,59,'HELPER','Helper Class','헬퍼 클래스','[\"HELPER\"]',NULL,'Helper','2026-01-21 08:13:08.120519','2026-01-21 08:13:08.120519',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (86,60,'COMMAND_CONTROLLER','Command Controller','CUD 작업을 처리하는 REST Controller','[\"CONTROLLER\"]','{Domain}CommandController','CommandController','2026-01-21 13:24:16.000000','2026-01-21 13:24:16.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (87,61,'QUERY_CONTROLLER','Query Controller','R(조회) 작업을 처리하는 REST Controller','[\"CONTROLLER\"]','{Domain}QueryController','QueryController','2026-01-21 13:24:16.000000','2026-01-21 13:24:16.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (88,62,'CREATE_REQUEST','Create Request DTO','생성 API 요청 DTO','[\"REQUEST_DTO\"]','Create{Domain}ApiRequest','ApiRequest','2026-01-21 13:24:16.000000','2026-01-21 13:24:16.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (89,62,'UPDATE_REQUEST','Update Request DTO','수정 API 요청 DTO','[\"REQUEST_DTO\"]','Update{Domain}ApiRequest','ApiRequest','2026-01-21 13:24:16.000000','2026-01-21 13:24:16.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (90,62,'FIND_REQUEST','Find Request DTO','목록 조회 API 요청 DTO (커서/페이지)','[\"REQUEST_DTO\"]','Find{Domain}sApiRequest','ApiRequest','2026-01-21 13:24:16.000000','2026-01-21 13:24:16.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (91,63,'ITEM_RESPONSE','Item Response DTO','단일 항목 API 응답 DTO','[\"RESPONSE_DTO\"]','{Domain}ApiResponse','ApiResponse','2026-01-21 13:24:16.000000','2026-01-21 13:24:16.000000',NULL);
INSERT INTO `package_purpose` (`id`, `structure_id`, `code`, `name`, `description`, `default_allowed_class_types`, `default_naming_pattern`, `default_naming_suffix`, `created_at`, `updated_at`, `deleted_at`) VALUES (92,63,'ID_RESPONSE','ID Response DTO','ID만 반환하는 API 응답 DTO','[\"RESPONSE_DTO\"]','{Domain}IdApiResponse','IdApiResponse','2026-01-21 13:24:16.000000','2026-01-21 13:24:16.000000',NULL);

INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (1,1,'{base_package}.{domain}.aggregate','[\"AGGREGATE_ROOT\", \"ENTITY\"]',NULL,NULL,'Domain Aggregate 패키지','2026-01-20 02:11:21.000000','2026-01-20 07:29:58.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (2,1,'{base_package}.{domain}.vo','[\"VALUE_OBJECT\", \"RECORD\"]',NULL,NULL,'Domain Value Object 패키지','2026-01-20 02:11:21.000000','2026-01-20 07:29:58.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (3,1,'{base_package}.{domain}.id','[\"RECORD\"]','*Id','Id','Domain ID 패키지','2026-01-20 02:11:21.000000','2026-01-20 07:29:58.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (4,1,'{base_package}.{domain}.exception','[\"EXCEPTION\"]','*Exception','Exception','Domain Exception 패키지','2026-01-20 02:11:21.000000','2026-01-20 07:29:58.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (5,1,'{base_package}.common.vo','[\"VALUE_OBJECT\", \"RECORD\", \"INTERFACE\", \"ENUM\"]',NULL,NULL,'도메인 공통 Value Object 패키지. 여러 도메인에서 재사용되는 불변 값 객체가 위치합니다.','2026-01-20 07:29:58.000000','2026-01-20 07:29:58.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (6,1,'{base_package}.common.exception','[\"EXCEPTION\", \"INTERFACE\", \"ENUM\"]','*Exception','Exception','도메인 공통 예외 패키지. DomainException, ErrorCode 인터페이스가 위치합니다.','2026-01-20 07:29:58.000000','2026-01-20 07:29:58.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (7,1,'{base_package}.common.event','[\"INTERFACE\", \"RECORD\"]','*Event','Event','도메인 공통 이벤트 패키지. DomainEvent 마커 인터페이스가 위치합니다.','2026-01-20 07:29:58.000000','2026-01-20 07:29:58.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (8,1,'{base_package}.{domain}.query','[\"RECORD\", \"CLASS\"]','*Criteria','Criteria','도메인 조회 조건 패키지. PageCriteria 또는 CursorCriteria로 끝나는 조회 조건 객체가 위치합니다.','2026-01-20 07:57:17.000000','2026-01-20 07:57:17.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (9,2,'{base_package}.{domain}.port.in.command','[\"INTERFACE\"]','{Action}{Domain}UseCase','UseCase','Command UseCase 인터페이스 패키지. 단일 execute() 메서드를 가진 UseCase 인터페이스가 위치합니다.','2026-01-21 05:25:44.000000','2026-01-21 05:25:44.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (10,2,'{base_package}.{domain}.port.in.query','[\"INTERFACE\"]','Get{Domain}*UseCase','UseCase','Query UseCase 인터페이스 패키지. 조회용 UseCase 인터페이스가 위치합니다.','2026-01-21 05:25:44.000000','2026-01-21 05:25:44.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (11,2,'{base_package}.{domain}.port.out.command','[\"INTERFACE\"]','{Domain}CommandPort','Port','Command Port 인터페이스 패키지. DB 쓰기용 CommandPort (persist, persistAll 메서드)가 위치합니다.','2026-01-21 05:25:44.000000','2026-01-21 05:25:44.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (12,2,'{base_package}.{domain}.port.out.query','[\"INTERFACE\"]','{Domain}QueryPort','Port','Query Port 인터페이스 패키지. DB 읽기용 QueryPort (findBy*, existsBy*, countBy* 메서드)가 위치합니다.','2026-01-21 05:25:44.000000','2026-01-21 05:25:44.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (13,2,'{base_package}.{domain}.port.out.client','[\"INTERFACE\"]','{Domain}*ClientPort','Port','Client Port 인터페이스 패키지. 외부 HTTP/메시징 연동용 Port가 위치합니다.','2026-01-21 05:25:44.000000','2026-01-21 05:25:44.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (14,2,'{base_package}.{domain}.service.command','[\"CLASS\"]','{Action}{Domain}Service','Service','Command Service 구현체 패키지. Command UseCase 1:1 구현체가 위치합니다. @Transactional 금지.','2026-01-21 05:25:44.000000','2026-01-21 05:25:44.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (15,2,'{base_package}.{domain}.service.query','[\"CLASS\"]','Get{Domain}*Service','Service','Query Service 구현체 패키지. Query UseCase 1:1 구현체가 위치합니다.','2026-01-21 05:25:44.000000','2026-01-21 05:25:44.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (16,2,'{base_package}.{domain}.facade.command','[\"CLASS\"]','{Action}{Domain}Facade','Facade','Command Facade 패키지. Manager 2개 이상 조합 시 사용. @Transactional 선택.','2026-01-21 05:25:44.000000','2026-01-21 05:25:44.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (17,2,'{base_package}.{domain}.facade.query','[\"CLASS\"]','Get{Domain}*Facade','Facade','Query Facade 패키지. 어드민 복합 조회 등 Manager 2개 이상 조합. @Transactional(readOnly=true).','2026-01-21 05:25:44.000000','2026-01-21 05:25:44.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (18,2,'{base_package}.{domain}.manager.command','[\"CLASS\"]','{Domain}*Manager','Manager','Command Manager 패키지. CommandPort 1:1 래핑. @Transactional 필수.','2026-01-21 05:25:44.000000','2026-01-21 05:25:44.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (19,2,'{base_package}.{domain}.manager.query','[\"CLASS\"]','{Domain}*Manager','Manager','Query Manager 패키지. QueryPort 1:1 래핑. @Transactional(readOnly=true) 필수.','2026-01-21 05:25:44.000000','2026-01-21 05:25:44.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (20,2,'{base_package}.{domain}.manager.client','[\"CLASS\"]','{Domain}*ClientManager','Manager','Client Manager 패키지. ClientPort 래핑. @Transactional 금지.','2026-01-21 05:25:44.000000','2026-01-21 05:25:44.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (21,2,'{base_package}.{domain}.factory.command','[\"CLASS\"]','{Domain}*Factory','Factory','Command Factory 패키지. Command → Domain/Bundle 생성. TimeProvider 사용.','2026-01-21 05:25:44.000000','2026-01-21 05:25:44.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (22,2,'{base_package}.{domain}.factory.query','[\"CLASS\"]','{Domain}*Factory','Factory','Query Factory 패키지. Query → Criteria 변환. 도메인별 기본값 결정.','2026-01-21 05:25:44.000000','2026-01-21 05:25:44.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (23,2,'{base_package}.{domain}.assembler','[\"CLASS\"]','{Domain}Assembler','Assembler','Assembler 패키지. Domain → Response 변환. 도메인별 구체 Result 클래스 반환.','2026-01-21 05:25:44.000000','2026-01-21 05:25:44.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (24,2,'{base_package}.{domain}.validator','[\"CLASS\"]','{Domain}*Validator','Validator','Validator 패키지. 비즈니스 검증 (외부 의존성). 자기 도메인 ReadManager만 의존.','2026-01-21 05:25:44.000000','2026-01-21 05:25:44.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (25,2,'{base_package}.{domain}.internal','[\"CLASS\"]','{Domain}*Calculator','Calculator','내부 헬퍼 컴포넌트 (Calculator, Resolver, Converter 등)','2026-01-21 05:25:44.000000','2026-01-21 05:38:06.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (27,2,'{base_package}.{domain}.dto.command','[\"RECORD\"]','{Action}{Domain}Command','Command','Command DTO 패키지. Record 필수. 인스턴스 메서드 금지.','2026-01-21 05:25:44.000000','2026-01-21 05:25:44.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (28,2,'{base_package}.{domain}.dto.query','[\"RECORD\"]','Get*Query','Query','Query DTO 패키지. *SearchParams, *CursorParams. CommonSearchParams/CommonCursorParams 필수 포함.','2026-01-21 05:25:44.000000','2026-01-21 05:25:44.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (29,2,'{base_package}.{domain}.dto.response','[\"RECORD\"]','{Domain}*Result','Result','Response DTO 패키지. *Response, *Result, *SliceResult, *PageResult.','2026-01-21 05:25:44.000000','2026-01-21 05:25:44.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (30,2,'{base_package}.{domain}.dto.bundle','[\"RECORD\"]','{Domain}*Bundle','Bundle','Bundle DTO 패키지. Facade용 복합 DTO. withId() 패턴으로 ID 전파.','2026-01-21 05:25:44.000000','2026-01-21 05:25:44.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (31,2,'{base_package}.common.dto.query','[\"RECORD\"]','*Query','Query','공통 Query DTO 패키지. CommonSearchParams, CommonCursorParams가 위치합니다.','2026-01-21 05:25:44.000000','2026-01-21 05:25:44.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (32,2,'{base_package}.common.dto.command','[\"RECORD\"]','*Context','Context','공통 Command DTO (StatusChangeContext 등)','2026-01-21 05:25:44.000000','2026-01-21 05:38:06.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (33,2,'{base_package}.common.factory','[\"CLASS\"]','*Factory','Factory','공통 Factory 패키지. CommonVoFactory가 위치합니다.','2026-01-21 05:25:44.000000','2026-01-21 05:25:44.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (34,2,'{base_package}.common.internal','[\"CALCULATOR\", \"RESOLVER\", \"CONVERTER\", \"HELPER\"]','*Helper','Helper','공통 내부 헬퍼 컴포넌트','2026-01-21 05:38:21.000000','2026-01-21 05:38:21.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (35,2,'{base_package}.common.event','[\"EVENT_REGISTRY\", \"EVENT_PUBLISHER\"]','{Domain}*Event','Event','공통 이벤트 관련 컴포넌트 (TransactionEventRegistry 등)','2026-01-21 05:38:21.000000','2026-01-21 05:38:21.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (36,2,'{base_package}.{domain}.listener','[\"EVENT_LISTENER\"]','{Domain}*Listener','Listener','도메인 이벤트 리스너','2026-01-21 05:38:21.000000','2026-01-21 05:38:21.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (37,4,'{base_package}.{domain}.adapter','[\"COMMAND_ADAPTER\", \"QUERY_ADAPTER\"]','{Domain}*Adapter','Adapter',NULL,'2026-01-21 07:42:21.000000','2026-01-21 07:42:21.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (38,4,'{base_package}.{domain}.entity','[\"JPA_ENTITY\"]','{Domain}JpaEntity','JpaEntity',NULL,'2026-01-21 07:42:21.000000','2026-01-21 07:42:21.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (39,4,'{base_package}.{domain}.mapper','[\"ENTITY_MAPPER\"]','{Domain}PersistenceMapper','PersistenceMapper',NULL,'2026-01-21 07:42:21.000000','2026-01-21 07:42:21.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (40,4,'{base_package}.{domain}.repository','[\"JPA_REPOSITORY\", \"QUERYDSL_REPOSITORY\"]','{Domain}Repository','Repository',NULL,'2026-01-21 07:42:21.000000','2026-01-21 07:42:21.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (41,4,'{base_package}.{domain}.condition','[\"CONDITION_BUILDER\"]','{Domain}*Condition','Condition',NULL,'2026-01-21 07:42:21.000000','2026-01-21 07:42:21.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (42,4,'{base_package}.common.entity','[\"BASE_AUDIT_ENTITY\", \"SOFT_DELETABLE_ENTITY\"]','*JpaEntity','JpaEntity',NULL,'2026-01-21 07:42:21.000000','2026-01-21 07:42:21.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (43,4,'{base_package}.common.config','[\"JPA_CONFIG\", \"PERSISTENCE_OBJECT_MAPPER\"]','*Config','Config',NULL,'2026-01-21 07:42:21.000000','2026-01-21 07:42:21.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (44,4,'{base_package}.common.dto.query','[\"SLICE_CRITERIA\", \"SORT_CRITERIA\", \"SEARCH_CRITERIA\"]','*QueryDto','QueryDto',NULL,'2026-01-21 07:42:21.000000','2026-01-21 07:42:21.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (45,4,'{base_package}.common.function','[\"FUNCTION_CONTRIBUTOR\"]','*Function','Function',NULL,'2026-01-21 07:42:21.000000','2026-01-21 07:42:21.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (46,17,'{base_package}.{domain}.admin','[\"ADMIN_QUERY_ADAPTER\", \"ADMIN_QUERYDSL_REPOSITORY\"]',NULL,NULL,'Admin용 조회 어댑터 및 레포지토리. 조인 허용, 복잡 쿼리 허용.','2026-01-21 07:57:48.000000','2026-01-21 07:57:48.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (47,17,'{base_package}.{domain}.admin.dto','[\"ADMIN_PROJECTION_DTO\"]',NULL,NULL,'Admin용 DTO Projection. 여러 테이블 조인 결과를 담는 DTO.','2026-01-21 07:57:48.000000','2026-01-21 07:57:48.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (48,17,'{base_package}.common.config','[\"ADMIN_JPA_CONFIG\"]',NULL,NULL,'Admin 전용 JPA 설정. Read Replica 연결 등.','2026-01-21 07:57:48.000000','2026-01-21 07:57:48.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (49,6,'{base_package}.{domain}','[\"API_ENDPOINTS\"]','{Domain}ApiEndpoints','ApiEndpoints','도메인 API 엔드포인트 상수','2026-01-21 08:12:45.943082','2026-01-21 08:12:45.943082',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (52,6,'{base_package}.{domain}.error','[\"API_ERROR_CODE\", \"API_EXCEPTION\"]','{Domain}ErrorMapper','ErrorMapper','API 에러 코드 및 예외','2026-01-21 08:12:45.943082','2026-01-21 08:12:45.943082',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (53,6,'{base_package}.{domain}.mapper','[\"API_MAPPER\"]','{Domain}*ApiMapper','ApiMapper','API DTO 매퍼','2026-01-21 08:12:45.943082','2026-01-21 08:12:45.943082',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (54,6,'{base_package}.common','[\"API_ENDPOINTS\"]','*',NULL,'공통 API 엔드포인트 상수 (ApiPaths)','2026-01-21 08:12:45.943082','2026-01-21 08:12:45.943082',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (55,6,'{base_package}.common.controller','[\"CONTROLLER\"]','*Controller','Controller','공통 컨트롤러 (Health Check 등)','2026-01-21 08:12:45.943082','2026-01-21 08:12:45.943082',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (56,6,'{base_package}.common.dto','[\"API_REQUEST\", \"API_RESPONSE\", \"API_PAGE_RESPONSE\"]','*ApiResponse','ApiResponse','공통 API DTO','2026-01-21 08:12:45.943082','2026-01-21 08:12:45.943082',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (57,6,'{base_package}.common.error','[\"GLOBAL_EXCEPTION_HANDLER\", \"API_ERROR_RESPONSE\"]','GlobalExceptionHandler','ExceptionHandler','전역 예외 처리 및 에러 응답','2026-01-21 08:12:45.943082','2026-01-21 08:12:45.943082',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (58,6,'{base_package}.common.mapper','[\"API_MAPPER\"]','*ApiMapper','ApiMapper','공통 API 매퍼','2026-01-21 08:12:45.943082','2026-01-21 08:12:45.943082',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (59,6,'{base_package}.common.util','[\"UTILITY\", \"HELPER\"]','*Util','Util','공통 유틸리티','2026-01-21 08:12:45.943082','2026-01-21 08:12:45.943082',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (60,6,'{base_package}.{domain}.controller.command','[\"CONTROLLER\"]','{Domain}CommandController','CommandController','Command 컨트롤러 (CUD 작업)','2026-01-21 13:23:46.000000','2026-01-21 13:23:46.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (61,6,'{base_package}.{domain}.controller.query','[\"CONTROLLER\"]','{Domain}QueryController','QueryController','Query 컨트롤러 (R 작업)','2026-01-21 13:23:46.000000','2026-01-21 13:23:46.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (62,6,'{base_package}.{domain}.dto.request','[\"REQUEST_DTO\"]','{Action}{Domain}ApiRequest','ApiRequest','API 요청 DTO','2026-01-21 13:23:46.000000','2026-01-21 13:23:46.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (63,6,'{base_package}.{domain}.dto.response','[\"RESPONSE_DTO\"]','{Domain}ApiResponse','ApiResponse','API 응답 DTO','2026-01-21 13:23:46.000000','2026-01-21 13:23:46.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (64,2,'{base_package}.common.config','[\"CLASS\"]','*Config','Config','공통 설정 클래스 패키지. ApplicationJsonConfig 등이 위치합니다.','2026-01-25 15:55:06.000000','2026-01-25 15:55:06.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (65,2,'{base_package}.common.port.out','[\"INTERFACE\"]','*Port','Port','공통 출력 포트 패키지. CachePort, DistributedLockPort, IdGeneratorPort 등이 위치합니다.','2026-01-25 15:55:06.000000','2026-01-25 15:55:06.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (66,2,'{base_package}.common.time','[\"CLASS\"]','*Provider','Provider','공통 시간 관련 컴포넌트 패키지. TimeProvider가 위치합니다.','2026-01-25 15:55:06.000000','2026-01-25 15:55:06.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (67,6,'{base_package}.common','[\"CLASS\"]','Api*',NULL,'REST API 공통 상수 패키지. ApiPaths 등이 위치합니다.','2026-01-25 16:01:05.000000','2026-01-25 16:01:05.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (68,6,'{base_package}.common.controller','[\"CLASS\"]','*Controller','Controller','REST API 공통 컨트롤러 패키지. ApiDocsController가 위치합니다.','2026-01-25 16:01:05.000000','2026-01-25 16:01:05.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (69,6,'{base_package}.common.dto','[\"RECORD\", \"CLASS\"]','*Response | *Request',NULL,'REST API 공통 DTO 패키지. ApiResponse, PageApiResponse, SliceApiResponse가 위치합니다.','2026-01-25 16:01:05.000000','2026-01-25 16:01:05.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (70,6,'{base_package}.common.error','[\"CLASS\", \"INTERFACE\"]','*Mapper | *Handler | *Registry',NULL,'REST API 공통 에러 처리 패키지. ErrorMapper, GlobalExceptionHandler가 위치합니다.','2026-01-25 16:01:05.000000','2026-01-25 16:01:05.000000',NULL);
INSERT INTO `package_structure` (`id`, `module_id`, `path_pattern`, `allowed_class_types`, `naming_pattern`, `naming_suffix`, `description`, `created_at`, `updated_at`, `deleted_at`) VALUES (71,6,'{base_package}.common.util','[\"CLASS\"]','*Utils','Utils','REST API 공통 유틸리티 패키지. DateTimeFormatUtils가 위치합니다.','2026-01-25 16:01:05.000000','2026-01-25 16:01:05.000000',NULL);

INSERT INTO `resource_template` (`id`, `module_id`, `category`, `file_path`, `file_type`, `description`, `template_content`, `required`, `created_at`, `updated_at`, `deleted_at`) VALUES (1,4,'CONFIG','src/main/resources/persistence.yml','YAML','Persistence Layer 공통 설정. OSIV off, Batch 설정, Flyway 설정','# ============================================================\n# Persistence Layer 공통 설정\n# ============================================================\n# 환경별 설정은 persistence-{profile}.yml 참조\n\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n\n  jpa:\n    # ⚠️ OSIV 비활성화 (필수!)\n    open-in-view: false\n    hibernate:\n      # ⚠️ Flyway가 스키마 관리, Hibernate는 검증만\n      ddl-auto: validate\n    properties:\n      hibernate:\n        jdbc:\n          batch_size: 50\n          fetch_size: 50\n        order_inserts: true\n        order_updates: true\n        batch_versioned_data: true\n        query:\n          plan_cache_max_size: 2048\n          in_clause_parameter_padding: true\n    show-sql: false\n\n  flyway:\n    enabled: true\n    locations: classpath:db/migration\n    baseline-on-migrate: true\n    validate-on-migrate: true\n    out-of-order: false\n    clean-disabled: true',1,'2026-01-21 07:45:16.000000','2026-01-21 07:45:16.000000',NULL);
INSERT INTO `resource_template` (`id`, `module_id`, `category`, `file_path`, `file_type`, `description`, `template_content`, `required`, `created_at`, `updated_at`, `deleted_at`) VALUES (2,4,'CONFIG','src/main/resources/persistence-local.yml','YAML','Persistence Layer 로컬 환경. HikariCP 최소 설정, Debug 로깅','# ============================================================\n# Persistence Layer 로컬 개발 환경 설정\n# ============================================================\n\nspring:\n  datasource:\n    url: jdbc:mysql://${DB_HOST:localhost}:${DB_PORT:3306}/${DB_NAME}?useSSL=false&allowPublicKeyRetrieval=true&serverTimezone=Asia/Seoul\n    username: ${DB_USER:root}\n    password: ${DB_PASSWORD:}\n\n    hikari:\n      maximum-pool-size: 5\n      minimum-idle: 2\n      connection-timeout: 20000\n      idle-timeout: 300000\n      max-lifetime: 600000\n      leak-detection-threshold: 0\n      pool-name: HikariPool-Local\n      data-source-properties:\n        cachePrepStmts: true\n        prepStmtCacheSize: 250\n        prepStmtCacheSqlLimit: 2048\n        useServerPrepStmts: true\n        rewriteBatchedStatements: true\n\n  jpa:\n    properties:\n      hibernate:\n        format_sql: true\n        use_sql_comments: true\n\n  flyway:\n    clean-disabled: true\n\nlogging:\n  level:\n    org.hibernate.SQL: DEBUG\n    org.hibernate.orm.jdbc.bind: TRACE',1,'2026-01-21 07:45:16.000000','2026-01-21 07:45:16.000000',NULL);
INSERT INTO `resource_template` (`id`, `module_id`, `category`, `file_path`, `file_type`, `description`, `template_content`, `required`, `created_at`, `updated_at`, `deleted_at`) VALUES (3,4,'CONFIG','src/main/resources/persistence-prod.yml','YAML','Persistence Layer 운영 환경. HikariCP 최적화, Leak Detection','# ============================================================\n# Persistence Layer 운영 환경 설정\n# ============================================================\n# ⚠️ 모든 민감 정보는 환경 변수로 관리\n\nspring:\n  datasource:\n    url: jdbc:mysql://${DB_HOST}:${DB_PORT:3306}/${DB_NAME}?useSSL=true&requireSSL=true&serverTimezone=Asia/Seoul\n    username: ${DB_USERNAME}\n    password: ${DB_PASSWORD}\n\n    hikari:\n      # Pool Size: (core_count * 2) + effective_spindle_count\n      maximum-pool-size: 20\n      minimum-idle: 10\n      connection-timeout: 30000\n      idle-timeout: 600000\n      max-lifetime: 1800000\n      leak-detection-threshold: 60000\n      pool-name: HikariPool-Prod\n      connection-init-sql: SELECT 1\n      data-source-properties:\n        cachePrepStmts: true\n        prepStmtCacheSize: 250\n        prepStmtCacheSqlLimit: 2048\n        useServerPrepStmts: true\n        rewriteBatchedStatements: true\n        cacheResultSetMetadata: true\n        cacheServerConfiguration: true\n        elideSetAutoCommits: true\n        maintainTimeStats: false\n\n  jpa:\n    hibernate:\n      ddl-auto: none\n    properties:\n      hibernate:\n        format_sql: false\n        use_sql_comments: false\n\n  flyway:\n    clean-disabled: true\n    validate-on-migrate: false\n\nlogging:\n  level:\n    org.hibernate.SQL: WARN\n    org.hibernate.orm.jdbc.bind: WARN',1,'2026-01-21 07:45:16.000000','2026-01-21 07:45:16.000000',NULL);
INSERT INTO `resource_template` (`id`, `module_id`, `category`, `file_path`, `file_type`, `description`, `template_content`, `required`, `created_at`, `updated_at`, `deleted_at`) VALUES (4,4,'SERVICE','src/main/resources/META-INF/services/org.hibernate.boot.model.FunctionContributor','TEXT','Hibernate 커스텀 함수 등록. FullText 검색 지원','{base_package}.common.function.MatchAgainstFunctionContributor',0,'2026-01-21 07:45:28.000000','2026-01-21 07:45:28.000000',NULL);
INSERT INTO `resource_template` (`id`, `module_id`, `category`, `file_path`, `file_type`, `description`, `template_content`, `required`, `created_at`, `updated_at`, `deleted_at`) VALUES (5,4,'MIGRATION','src/main/resources/db/migration/V{version}__{description}.sql','SQL','Flyway DB 마이그레이션. V숫자__설명.sql 형식','-- ============================================================\n-- V{version}__{description}.sql\n-- ============================================================\n-- 작성자: {author}\n-- 작성일: {date}\n-- 설명: {description}\n-- ============================================================\n\n-- DDL 작업\nCREATE TABLE IF NOT EXISTS {table_name} (\n    id BIGINT NOT NULL AUTO_INCREMENT,\n    -- 비즈니스 컬럼\n    {column_name} VARCHAR(100) NOT NULL,\n    -- 감사 컬럼\n    created_at DATETIME(6) NOT NULL,\n    updated_at DATETIME(6) NOT NULL,\n    deleted_at DATETIME(6) NULL,\n    PRIMARY KEY (id),\n    -- 인덱스\n    INDEX idx_{table}_deleted (deleted_at)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n-- ⚠️ 풀텍스트 인덱스 (필요시)\n-- ALTER TABLE {table_name} ADD FULLTEXT INDEX ft_{column} ({column}) WITH PARSER ngram;',0,'2026-01-21 07:45:28.000000','2026-01-21 07:45:28.000000',NULL);
INSERT INTO `resource_template` (`id`, `module_id`, `category`, `file_path`, `file_type`, `description`, `template_content`, `required`, `created_at`, `updated_at`, `deleted_at`) VALUES (6,6,'CONFIG','src/main/resources/rest-api.yml','YAML','REST API 공통 설정. Jackson, MessageSource, Springdoc, RFC 7807 에러 설정.','# ============================================================\n# REST API Adapter 공통 설정\n# ============================================================\n# 환경별 설정은 rest-api-{profile}.yml 참조\n# - rest-api-local.yml: 로컬 개발 환경\n# - rest-api-prod.yml: 운영 환경\n#\n# 인증 아키텍처: Gateway Only\n# - JWT 검증: API Gateway에서 처리\n# - OAuth2: API Gateway에서 처리\n# - CORS: API Gateway에서 처리\n# - 이 서비스: Gateway가 전달하는 헤더(X-User-Id, X-User-Roles)만 파싱\n#\n# @since 1.0.0\n# ============================================================\n\nspring:\n  # ============================================================\n  # MessageSource (i18n)\n  # ============================================================\n  messages:\n    basename: messages\n    encoding: UTF-8\n    fallback-to-system-locale: false\n\n  # ============================================================\n  # Jackson (JSON 직렬화/역직렬화)\n  # ============================================================\n  jackson:\n    date-format: yyyy-MM-dd\'T\'HH:mm:ss\n    time-zone: Asia/Seoul\n\n    serialization:\n      WRITE_DATES_AS_TIMESTAMPS: false\n      FAIL_ON_EMPTY_BEANS: false\n\n    deserialization:\n      FAIL_ON_UNKNOWN_PROPERTIES: false\n\n    default-property-inclusion: non_null\n\n  # ============================================================\n  # Web Configuration\n  # ============================================================\n  web:\n    locale: ko_KR\n    locale-resolver: fixed\n\n  # ============================================================\n  # MVC Configuration\n  # ============================================================\n  mvc:\n    contentnegotiation:\n      favor-parameter: false\n      favor-path-extension: false\n\n# ============================================================\n# Error Response Configuration (RFC 7807)\n# ============================================================\napi:\n  error:\n    base-url: about:blank\n    use-about-blank: true\n\n# ============================================================\n# API Documentation (Springdoc OpenAPI)\n# ============================================================\nspringdoc:\n  api-docs:\n    enabled: true\n    path: /api-docs\n\n  swagger-ui:\n    enabled: true\n    path: /swagger-ui.html\n    operations-sorter: method\n    tags-sorter: alpha\n    display-request-duration: true\n    try-it-out-enabled: true\n\n  packages-to-scan:\n    - ${BASE_PACKAGE:com.example}.adapter.in.rest\n\n  default-consumes-media-type: application/json\n  default-produces-media-type: application/json\n\n  cache:\n    disabled: true\n',1,'2026-01-21 13:48:13.000000','2026-01-21 13:48:13.000000',NULL);
INSERT INTO `resource_template` (`id`, `module_id`, `category`, `file_path`, `file_type`, `description`, `template_content`, `required`, `created_at`, `updated_at`, `deleted_at`) VALUES (7,6,'CONFIG','src/main/resources/rest-api-local.yml','YAML','REST API 로컬 환경 설정. Swagger 활성화, DEBUG 로깅.','# ============================================================\n# REST API Adapter 로컬 개발 환경 설정\n# ============================================================\n# 활성화: spring.profiles.active=local\n#\n# Gateway-Only 아키텍처:\n# - 로컬에서도 Gateway를 통해 접근 (docker-compose로 Gateway 실행)\n# - Gateway가 X-User-Id, X-User-Roles 헤더 전달\n# - 이 서비스는 헤더만 파싱\n# ============================================================\n\n# ============================================================\n# API Documentation (로컬: 전체 활성화)\n# ============================================================\nspringdoc:\n  api-docs:\n    enabled: true\n  swagger-ui:\n    enabled: true\n  cache:\n    disabled: true\n\n# ============================================================\n# Logging (로컬: 상세 로깅)\n# ============================================================\nlogging:\n  level:\n    ${BASE_PACKAGE:com.example}.adapter.in.rest: DEBUG\n    org.springframework.web: DEBUG\n',1,'2026-01-21 13:48:23.000000','2026-01-21 13:48:23.000000',NULL);
INSERT INTO `resource_template` (`id`, `module_id`, `category`, `file_path`, `file_type`, `description`, `template_content`, `required`, `created_at`, `updated_at`, `deleted_at`) VALUES (8,6,'CONFIG','src/main/resources/rest-api-prod.yml','YAML','REST API 운영 환경 설정. 환경변수 기반 Swagger 제어, 최소 로깅.','# ============================================================\n# REST API Adapter 운영 환경 설정\n# ============================================================\n# 활성화: spring.profiles.active=prod\n#\n# Gateway-Only 아키텍처:\n# - Gateway만 이 서비스에 접근 가능 (네트워크 정책으로 강제)\n# - JWT 검증, OAuth2, CORS 모두 Gateway에서 처리\n# - 이 서비스는 X-User-Id, X-User-Roles 헤더만 파싱\n# ============================================================\n\n# ============================================================\n# API Documentation (운영: 환경변수로 제어)\n# ============================================================\n# 기본 비활성화, 필요시 SWAGGER_ENABLED=true로 활성화\nspringdoc:\n  api-docs:\n    enabled: ${SWAGGER_ENABLED:false}\n  swagger-ui:\n    enabled: ${SWAGGER_ENABLED:false}\n  cache:\n    disabled: false\n\n# ============================================================\n# Error Response (운영: 상세 URL 제공)\n# ============================================================\napi:\n  error:\n    base-url: ${API_ERROR_DOCS_URL:https://api.example.com/problems}\n    use-about-blank: false\n\n# ============================================================\n# Logging (운영: 최소화)\n# ============================================================\nlogging:\n  level:\n    ${BASE_PACKAGE:com.example}.adapter.in.rest: INFO\n    org.springframework.web: WARN\n',1,'2026-01-21 13:48:33.000000','2026-01-21 13:48:33.000000',NULL);
INSERT INTO `resource_template` (`id`, `module_id`, `category`, `file_path`, `file_type`, `description`, `template_content`, `required`, `created_at`, `updated_at`, `deleted_at`) VALUES (9,6,'I18N','src/main/resources/messages_en.properties','PROPERTIES','영어 에러 메시지. 공통 에러 + 도메인별 에러 패턴 가이드.','# ===============================================\n# English Error Messages (messages_en.properties)\n# ===============================================\n# Used by Spring Boot MessageSource\n# UTF-8 encoding required\n#\n# Usage:\n# messageSource.getMessage(\"error.example.not_found\", args, locale)\n#\n# Parameter usage:\n# {0}, {1}, {2} format to reference args array values\n#\n# @since 1.0.0\n# ===============================================\n\n# ===============================================\n# Common Error Messages\n# ===============================================\n\n# Generic 400 Bad Request\nerror.common.bad_request=Bad request\n\n# Generic 401 Unauthorized\nerror.common.unauthorized=Authentication required\n\n# Generic 403 Forbidden\nerror.common.forbidden=Access forbidden\n\n# Generic 404 Not Found\nerror.common.not_found=Resource not found\n\n# Generic 409 Conflict\nerror.common.conflict=Resource conflict occurred\n\n# Generic 500 Internal Server Error\nerror.common.internal_server_error=Internal server error. Please try again later\n\n# ===============================================\n# Domain Error Messages Template\n# ===============================================\n# Replace {domain} with your domain name:\n#   error.order.not_found=Order not found (ID: {0})\n#   error.product.duplicate=Product already exists (code: {0})\n#\n# Common patterns:\n#   error.{domain}.not_found={Domain} not found (ID: {0})\n#   error.{domain}.duplicate={Domain} already exists ({0})\n#   error.{domain}.invalid_status=Invalid status transition (current: {0}, attempted: {1})\n# ===============================================\n',1,'2026-01-21 13:48:44.000000','2026-01-21 13:48:44.000000',NULL);
INSERT INTO `resource_template` (`id`, `module_id`, `category`, `file_path`, `file_type`, `description`, `template_content`, `required`, `created_at`, `updated_at`, `deleted_at`) VALUES (10,6,'I18N','src/main/resources/messages_ko.properties','PROPERTIES','한국어 에러 메시지. 공통 에러 + 도메인별 에러 패턴 가이드.','# ===============================================\n# 한국어 에러 메시지 (messages_ko.properties)\n# ===============================================\n# Spring Boot MessageSource에서 사용\n# UTF-8 인코딩 필수\n#\n# 사용 예시:\n# messageSource.getMessage(\"error.example.not_found\", args, locale)\n#\n# 파라미터 사용:\n# {0}, {1}, {2} 형식으로 args 배열의 값을 참조\n#\n# @since 1.0.0\n# ===============================================\n\n# ===============================================\n# 공통 에러 메시지\n# ===============================================\n\n# 일반적인 400 Bad Request\nerror.common.bad_request=잘못된 요청입니다.\n\n# 일반적인 401 Unauthorized\nerror.common.unauthorized=인증이 필요합니다.\n\n# 일반적인 403 Forbidden\nerror.common.forbidden=접근 권한이 없습니다.\n\n# 일반적인 404 Not Found\nerror.common.not_found=리소스를 찾을 수 없습니다.\n\n# 일반적인 409 Conflict\nerror.common.conflict=리소스 충돌이 발생했습니다.\n\n# 일반적인 500 Internal Server Error\nerror.common.internal_server_error=서버 오류가 발생했습니다. 잠시 후 다시 시도해주세요.\n\n# ===============================================\n# 도메인 에러 메시지 템플릿\n# ===============================================\n# {domain}을 도메인명으로 대체:\n#   error.order.not_found=주문을 찾을 수 없습니다. (ID: {0})\n#   error.product.duplicate=이미 존재하는 상품입니다. (코드: {0})\n#\n# 공통 패턴:\n#   error.{domain}.not_found={Domain}을(를) 찾을 수 없습니다. (ID: {0})\n#   error.{domain}.duplicate=이미 존재하는 {Domain}입니다. ({0})\n#   error.{domain}.invalid_status=유효하지 않은 상태 전환입니다. (현재: {0}, 시도: {1})\n# ===============================================\n',1,'2026-01-21 13:48:55.000000','2026-01-21 13:48:55.000000',NULL);
INSERT INTO `resource_template` (`id`, `module_id`, `category`, `file_path`, `file_type`, `description`, `template_content`, `required`, `created_at`, `updated_at`, `deleted_at`) VALUES (11,6,'CONFIG','persistence-local.yml','YAML','로컬 개발 환경 설정. Docker MySQL 또는 로컬 MySQL 연결. 상세 SQL 로깅, 작은 커넥션 풀.','# ============================================================\n# Persistence Module - Local Development Configuration\n# ============================================================\n\nspring:\n  # ─────────────────────────────────────────────────────────\n  # DataSource 설정 (로컬 MySQL)\n  # ─────────────────────────────────────────────────────────\n  datasource:\n    url: jdbc:mysql://localhost:3306/$${DB_NAME:app}?useSSL=false&allowPublicKeyRetrieval=true&serverTimezone=Asia/Seoul&characterEncoding=UTF-8&useUnicode=true&rewriteBatchedStatements=true&cachePrepStmts=true&useServerPrepStmts=true\n    username: $${DB_USERNAME:root}\n    password: $${DB_PASSWORD:root}\n\n    # ─────────────────────────────────────────────────────\n    # HikariCP 설정 (로컬: 최소 설정)\n    # ─────────────────────────────────────────────────────\n    hikari:\n      # 풀 크기 (로컬: 작게)\n      maximum-pool-size: 5\n      minimum-idle: 2\n\n      # 타임아웃 (로컬: 짧게)\n      connection-timeout: 5000        # 커넥션 획득 대기 최대 5초\n      idle-timeout: 300000            # 유휴 커넥션 유지 5분\n      max-lifetime: 600000            # 커넥션 최대 수명 10분\n      validation-timeout: 3000        # 커넥션 유효성 검사 3초\n\n      # 커넥션 테스트 (MySQL 전용)\n      connection-test-query: SELECT 1\n\n      # 커넥션 누수 감지 (개발 시 유용)\n      leak-detection-threshold: 30000  # 30초 이상 반환 안 되면 경고\n\n  # ─────────────────────────────────────────────────────────\n  # JPA 설정 (로컬: DDL 자동 검증)\n  # ─────────────────────────────────────────────────────────\n  jpa:\n    hibernate:\n      ddl-auto: validate    # 스키마 검증만 (Flyway로 관리)\n\n    # SQL 로깅 (개발 편의)\n    show-sql: true\n\n    properties:\n      hibernate:\n        # SQL 포맷팅\n        format_sql: true\n        use_sql_comments: true\n        highlight_sql: true\n\n        # 통계 수집 (개발 시 성능 분석)\n        generate_statistics: true\n\n        # 느린 쿼리 로깅 (100ms 이상)\n        session:\n          events:\n            log:\n              LOG_QUERIES_SLOWER_THAN_MS: 100\n\n  # ─────────────────────────────────────────────────────────\n  # Flyway 설정 (로컬)\n  # ─────────────────────────────────────────────────────────\n  flyway:\n    enabled: true\n    clean-disabled: false    # 로컬에서는 clean 허용\n    baseline-on-migrate: true\n\n# ─────────────────────────────────────────────────────────\n# 로깅 설정 (로컬: 상세 SQL 로깅)\n# ─────────────────────────────────────────────────────────\nlogging:\n  level:\n    # Hibernate SQL 로깅\n    org.hibernate.SQL: DEBUG\n    org.hibernate.type.descriptor.sql.BasicBinder: TRACE\n    org.hibernate.orm.jdbc.bind: TRACE\n\n    # HikariCP 로깅\n    com.zaxxer.hikari: DEBUG\n    com.zaxxer.hikari.HikariConfig: DEBUG\n\n    # Spring Data JPA\n    org.springframework.data.jpa: DEBUG\n\n    # QueryDSL\n    com.querydsl: DEBUG\n\n    # Flyway\n    org.flywaydb: DEBUG\n',1,'2026-01-16 06:52:08.000000','2026-01-16 06:52:08.000000',NULL);
INSERT INTO `resource_template` (`id`, `module_id`, `category`, `file_path`, `file_type`, `description`, `template_content`, `required`, `created_at`, `updated_at`, `deleted_at`) VALUES (12,6,'CONFIG','persistence-dev.yml','YAML','개발 서버 환경 설정. 팀 공유 개발 DB 연결. 적당한 커넥션 풀, SQL 로깅 활성화.','# ============================================================\n# Persistence Module - Development Server Configuration\n# ============================================================\n\nspring:\n  # ─────────────────────────────────────────────────────────\n  # DataSource 설정 (개발 서버 MySQL)\n  # ─────────────────────────────────────────────────────────\n  datasource:\n    url: jdbc:mysql://$${DB_HOST:dev-mysql.internal}:$${DB_PORT:3306}/$${DB_NAME:app}?useSSL=true&requireSSL=true&verifyServerCertificate=false&serverTimezone=Asia/Seoul&characterEncoding=UTF-8&useUnicode=true&rewriteBatchedStatements=true&cachePrepStmts=true&useServerPrepStmts=true&connectTimeout=5000&socketTimeout=30000\n    username: $${DB_USERNAME}\n    password: $${DB_PASSWORD}\n\n    # ─────────────────────────────────────────────────────\n    # HikariCP 설정 (개발 서버: 중간 설정)\n    # ─────────────────────────────────────────────────────\n    hikari:\n      # 풀 크기 (개발: 중간)\n      maximum-pool-size: 10\n      minimum-idle: 5\n\n      # 타임아웃\n      connection-timeout: 10000       # 커넥션 획득 대기 최대 10초\n      idle-timeout: 600000            # 유휴 커넥션 유지 10분\n      max-lifetime: 1800000           # 커넥션 최대 수명 30분\n      validation-timeout: 5000        # 커넥션 유효성 검사 5초\n\n      # 커넥션 테스트\n      connection-test-query: SELECT 1\n\n      # 커넥션 누수 감지\n      leak-detection-threshold: 60000  # 60초 이상 반환 안 되면 경고\n\n      # 초기화 실패 타임아웃\n      initialization-fail-timeout: 30000\n\n  # ─────────────────────────────────────────────────────────\n  # JPA 설정 (개발 서버)\n  # ─────────────────────────────────────────────────────────\n  jpa:\n    hibernate:\n      ddl-auto: validate\n\n    show-sql: false    # 파일 로깅으로 대체\n\n    properties:\n      hibernate:\n        format_sql: true\n        generate_statistics: true\n\n        session:\n          events:\n            log:\n              LOG_QUERIES_SLOWER_THAN_MS: 500\n\n  # ─────────────────────────────────────────────────────────\n  # Flyway 설정 (개발 서버)\n  # ─────────────────────────────────────────────────────────\n  flyway:\n    enabled: true\n    clean-disabled: true    # 개발 서버에서도 clean 금지\n    out-of-order: true      # 팀 협업으로 순서 외 마이그레이션 허용\n\n# ─────────────────────────────────────────────────────────\n# 로깅 설정 (개발 서버: SQL 로깅)\n# ─────────────────────────────────────────────────────────\nlogging:\n  level:\n    org.hibernate.SQL: DEBUG\n    org.hibernate.orm.jdbc.bind: DEBUG\n    com.zaxxer.hikari: INFO\n    org.flywaydb: INFO\n',1,'2026-01-16 06:52:08.000000','2026-01-16 06:52:08.000000',NULL);
INSERT INTO `resource_template` (`id`, `module_id`, `category`, `file_path`, `file_type`, `description`, `template_content`, `required`, `created_at`, `updated_at`, `deleted_at`) VALUES (13,6,'CONFIG','persistence-staging.yml','YAML','스테이징 환경 설정. 운영과 유사한 설정으로 사전 검증. SQL 로깅 최소화, 운영급 커넥션 풀.','# ============================================================\n# Persistence Module - Staging Configuration\n# ============================================================\n\nspring:\n  # ─────────────────────────────────────────────────────────\n  # DataSource 설정 (스테이징 MySQL)\n  # ─────────────────────────────────────────────────────────\n  datasource:\n    url: jdbc:mysql://$${DB_HOST}:$${DB_PORT:3306}/$${DB_NAME}?useSSL=true&requireSSL=true&verifyServerCertificate=true&serverTimezone=Asia/Seoul&characterEncoding=UTF-8&useUnicode=true&rewriteBatchedStatements=true&cachePrepStmts=true&useServerPrepStmts=true&connectTimeout=5000&socketTimeout=60000\n    username: $${DB_USERNAME}\n    password: $${DB_PASSWORD}\n\n    # ─────────────────────────────────────────────────────\n    # HikariCP 설정 (스테이징: 운영과 유사)\n    # ─────────────────────────────────────────────────────\n    hikari:\n      # 풀 크기 (운영의 절반 수준)\n      maximum-pool-size: 15\n      minimum-idle: 10\n\n      # 타임아웃 (운영과 동일)\n      connection-timeout: 30000       # 커넥션 획득 대기 최대 30초\n      idle-timeout: 600000            # 유휴 커넥션 유지 10분\n      max-lifetime: 1800000           # 커넥션 최대 수명 30분\n      validation-timeout: 5000        # 커넥션 유효성 검사 5초\n      keepalive-time: 300000          # Keep-alive 5분\n\n      # 커넥션 테스트\n      connection-test-query: SELECT 1\n\n      # 커넥션 누수 감지 (스테이징에서 검증)\n      leak-detection-threshold: 120000  # 2분\n\n      # 초기화 실패 타임아웃\n      initialization-fail-timeout: 60000\n\n  # ─────────────────────────────────────────────────────────\n  # JPA 설정 (스테이징)\n  # ─────────────────────────────────────────────────────────\n  jpa:\n    hibernate:\n      ddl-auto: validate\n\n    show-sql: false\n\n    properties:\n      hibernate:\n        format_sql: false\n        generate_statistics: false\n\n        # 느린 쿼리만 로깅 (1초 이상)\n        session:\n          events:\n            log:\n              LOG_QUERIES_SLOWER_THAN_MS: 1000\n\n  # ─────────────────────────────────────────────────────────\n  # Flyway 설정 (스테이징)\n  # ─────────────────────────────────────────────────────────\n  flyway:\n    enabled: true\n    clean-disabled: true\n    validate-on-migrate: true\n\n# ─────────────────────────────────────────────────────────\n# 로깅 설정 (스테이징: 최소 로깅)\n# ─────────────────────────────────────────────────────────\nlogging:\n  level:\n    org.hibernate.SQL: WARN\n    org.hibernate.orm.jdbc.bind: WARN\n    com.zaxxer.hikari: WARN\n    org.flywaydb: INFO\n',1,'2026-01-16 06:52:08.000000','2026-01-16 06:52:08.000000',NULL);
INSERT INTO `resource_template` (`id`, `module_id`, `category`, `file_path`, `file_type`, `description`, `template_content`, `required`, `created_at`, `updated_at`, `deleted_at`) VALUES (14,6,'CONFIG','persistence-prod.yml','YAML','운영 환경 설정. 보안 최우선, 성능 최적화, 고가용성. HikariCP 풀 최적화, SSL 필수.','# ============================================================\n# Persistence Module - Production Configuration\n# ============================================================\n\nspring:\n  # ─────────────────────────────────────────────────────────\n  # DataSource 설정 (운영 MySQL - AWS RDS/Aurora 등)\n  # ─────────────────────────────────────────────────────────\n  datasource:\n    # AWS RDS MySQL 예시 (Aurora, RDS 모두 적용 가능)\n    url: jdbc:mysql://$${DB_HOST}:$${DB_PORT:3306}/$${DB_NAME}?useSSL=true&requireSSL=true&verifyServerCertificate=true&enabledTLSProtocols=TLSv1.2,TLSv1.3&serverTimezone=Asia/Seoul&characterEncoding=UTF-8&useUnicode=true&rewriteBatchedStatements=true&cachePrepStmts=true&prepStmtCacheSize=500&prepStmtCacheSqlLimit=4096&useServerPrepStmts=true&connectTimeout=5000&socketTimeout=60000&tcpKeepAlive=true\n    username: $${DB_USERNAME}\n    password: $${DB_PASSWORD}\n\n    # ─────────────────────────────────────────────────────\n    # HikariCP 설정 (운영: 고성능 최적화)\n    # ─────────────────────────────────────────────────────\n    hikari:\n      pool-name: HikariPool-Production\n\n      # ─────────────────────────────────────────────────\n      # 풀 크기 설정\n      # 공식: connections = ((core_count * 2) + effective_spindle_count)\n      # 일반적으로 CPU 코어 수 * 2 ~ 4\n      # ─────────────────────────────────────────────────\n      maximum-pool-size: $${HIKARI_MAX_POOL_SIZE:30}\n      minimum-idle: $${HIKARI_MIN_IDLE:15}\n\n      # ─────────────────────────────────────────────────\n      # 타임아웃 설정 (운영: 안정성 중시)\n      # ─────────────────────────────────────────────────\n\n      # 커넥션 획득 대기 최대 시간 (30초)\n      # 이 시간 내에 커넥션을 얻지 못하면 SQLException 발생\n      connection-timeout: 30000\n\n      # 유휴 커넥션 유지 시간 (10분)\n      # minimum-idle보다 많은 유휴 커넥션은 이 시간 후 제거\n      idle-timeout: 600000\n\n      # 커넥션 최대 수명 (30분)\n      # DB의 wait_timeout보다 짧아야 함 (MySQL 기본 8시간)\n      # 커넥션 재활용으로 메모리 누수 방지\n      max-lifetime: 1800000\n\n      # 커넥션 유효성 검사 타임아웃 (5초)\n      validation-timeout: 5000\n\n      # Keep-Alive 간격 (5분)\n      # 유휴 커넥션이 DB에 의해 끊기지 않도록 유지\n      keepalive-time: 300000\n\n      # ─────────────────────────────────────────────────\n      # 커넥션 검증\n      # ─────────────────────────────────────────────────\n\n      # MySQL 커넥션 테스트 쿼리\n      # JDBC4 드라이버는 isValid() 사용, 설정하지 않아도 됨\n      # 하지만 명시적으로 설정하면 더 확실함\n      connection-test-query: SELECT 1\n\n      # ─────────────────────────────────────────────────\n      # 초기화 설정\n      # ─────────────────────────────────────────────────\n\n      # 초기화 실패 시 즉시 예외 발생 (fail-fast)\n      # 0보다 크면 해당 시간만큼 재시도\n      initialization-fail-timeout: 1\n\n      # ─────────────────────────────────────────────────\n      # 커넥션 누수 감지 (운영에서는 비활성화 또는 높은 값)\n      # 운영에서 오탐 방지를 위해 높은 임계값 또는 비활성화\n      # ─────────────────────────────────────────────────\n      leak-detection-threshold: 0    # 비활성화 (0)\n\n      # ─────────────────────────────────────────────────\n      # 기타 최적화 설정\n      # ─────────────────────────────────────────────────\n      auto-commit: false\n      read-only: false\n\n      # MySQL 드라이버 최적화 속성\n      data-source-properties:\n        # PreparedStatement 캐싱 (성능 향상)\n        cachePrepStmts: true\n        prepStmtCacheSize: 500\n        prepStmtCacheSqlLimit: 4096\n        useServerPrepStmts: true\n\n        # 배치 처리 최적화\n        rewriteBatchedStatements: true\n\n        # 메타데이터 캐싱\n        cacheResultSetMetadata: true\n        cacheServerConfiguration: true\n        elideSetAutoCommits: true\n\n        # 네트워크 최적화\n        tcpKeepAlive: true\n        tcpNoDelay: true\n\n        # 로깅 비활성화 (성능)\n        maintainTimeStats: false\n        enableQueryTimeouts: true\n\n  # ─────────────────────────────────────────────────────────\n  # JPA 설정 (운영)\n  # ─────────────────────────────────────────────────────────\n  jpa:\n    hibernate:\n      ddl-auto: none    # 절대 자동 DDL 금지\n\n    show-sql: false\n    open-in-view: false\n\n    properties:\n      hibernate:\n        format_sql: false\n        use_sql_comments: false\n        generate_statistics: false\n\n        # 배치 처리 (운영: 큰 배치)\n        jdbc:\n          batch_size: 100\n          fetch_size: 200\n\n        # 캐시 비활성화 (Redis로 대체)\n        cache:\n          use_second_level_cache: false\n          use_query_cache: false\n\n        # 느린 쿼리 로깅 비활성화 (APM 도구로 대체)\n        session:\n          events:\n            log:\n              LOG_QUERIES_SLOWER_THAN_MS: 0\n\n  # ─────────────────────────────────────────────────────────\n  # Flyway 설정 (운영)\n  # ─────────────────────────────────────────────────────────\n  flyway:\n    enabled: $${FLYWAY_ENABLED:true}\n    clean-disabled: true    # 절대 clean 금지\n    validate-on-migrate: true\n    out-of-order: false     # 순서 엄격 적용\n\n# ─────────────────────────────────────────────────────────\n# 로깅 설정 (운영: 에러만)\n# ─────────────────────────────────────────────────────────\nlogging:\n  level:\n    org.hibernate: WARN\n    org.hibernate.SQL: WARN\n    org.hibernate.orm.jdbc.bind: OFF\n    com.zaxxer.hikari: WARN\n    org.flywaydb: WARN\n',1,'2026-01-16 06:52:08.000000','2026-01-16 06:52:08.000000',NULL);
INSERT INTO `resource_template` (`id`, `module_id`, `category`, `file_path`, `file_type`, `description`, `template_content`, `required`, `created_at`, `updated_at`, `deleted_at`) VALUES (15,6,'CONFIG','config/JpaConfig.java','JAVA','JPA 설정 클래스. JPA Auditing, EntityManager, TransactionManager 설정.','package com.{bc}.adapter.out.persistence.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.domain.AuditorAware;\nimport org.springframework.data.jpa.repository.config.EnableJpaAuditing;\nimport org.springframework.data.jpa.repository.config.EnableJpaRepositories;\nimport org.springframework.transaction.annotation.EnableTransactionManagement;\n\nimport java.util.Optional;\n\n/**\n * JPA 설정 클래스\n *\n * <p>기능:</p>\n * <ul>\n *   <li>JPA Auditing 활성화 (@CreatedDate, @LastModifiedDate)</li>\n *   <li>JPA Repository 스캔 경로 지정</li>\n *   <li>트랜잭션 관리 활성화</li>\n * </ul>\n *\n * <p>주의사항:</p>\n * <ul>\n *   <li>auditorProvider는 보안 컨텍스트에서 사용자 ID를 가져오도록 구현</li>\n *   <li>멀티 모듈 프로젝트에서는 basePackages 명시 필수</li>\n * </ul>\n */\n@Configuration\n@EnableJpaAuditing(auditorAwareRef = \"auditorProvider\")\n@EnableJpaRepositories(\n    basePackages = \"com.{bc}.adapter.out.persistence\",\n    // EntityManager 지정 (멀티 DataSource 시)\n    entityManagerFactoryRef = \"entityManagerFactory\",\n    transactionManagerRef = \"transactionManager\"\n)\n@EnableTransactionManagement\npublic class JpaConfig {\n\n    /**\n     * Auditor Provider - 현재 사용자 ID 제공\n     *\n     * <p>@CreatedBy, @LastModifiedBy 필드에 사용자 ID 자동 주입</p>\n     *\n     * <p>구현 방법:</p>\n     * <ul>\n     *   <li>Spring Security: SecurityContextHolder에서 가져오기</li>\n     *   <li>JWT: 토큰에서 사용자 ID 추출</li>\n     *   <li>시스템 작업: \"SYSTEM\" 또는 고정값 반환</li>\n     * </ul>\n     *\n     * @return AuditorAware 구현체\n     */\n    @Bean\n    public AuditorAware<String> auditorProvider() {\n        // 기본 구현: 시스템 사용자\n        // TODO: 실제 구현 시 SecurityContext에서 사용자 ID 추출\n        return () -> Optional.of(\"SYSTEM\");\n\n        // Spring Security 사용 시 예시:\n        // return () -> Optional.ofNullable(SecurityContextHolder.getContext())\n        //     .map(SecurityContext::getAuthentication)\n        //     .filter(Authentication::isAuthenticated)\n        //     .map(Authentication::getName);\n    }\n}',1,'2026-01-16 06:52:08.000000','2026-01-16 06:52:08.000000',NULL);
INSERT INTO `resource_template` (`id`, `module_id`, `category`, `file_path`, `file_type`, `description`, `template_content`, `required`, `created_at`, `updated_at`, `deleted_at`) VALUES (16,6,'CONFIG','config/QueryDslConfig.java','JAVA','QueryDSL 설정 클래스. JPAQueryFactory Bean 등록.','package com.{bc}.adapter.out.persistence.config;\n\nimport com.querydsl.jpa.impl.JPAQueryFactory;\nimport jakarta.persistence.EntityManager;\nimport jakarta.persistence.PersistenceContext;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n/**\n * QueryDSL 설정 클래스\n *\n * <p>JPAQueryFactory Bean을 등록하여 QueryDslRepository에서 사용</p>\n *\n * <p>사용 예시:</p>\n * <pre>{@code\n * @Repository\n * public class OrderQueryDslRepository {\n *\n *     private final JPAQueryFactory queryFactory;\n *\n *     public OrderQueryDslRepository(JPAQueryFactory queryFactory) {\n *         this.queryFactory = queryFactory;\n *     }\n *\n *     public List<OrderJpaEntity> findByStatus(OrderStatus status) {\n *         return queryFactory\n *             .selectFrom(order)\n *             .where(order.status.eq(status))\n *             .fetch();\n *     }\n * }\n * }</pre>\n *\n * <p>주의사항:</p>\n * <ul>\n *   <li>EntityManager는 요청 스코프이므로 Thread-Safe</li>\n *   <li>JPAQueryFactory는 Singleton Bean으로 등록해도 안전</li>\n *   <li>멀티 DataSource 환경에서는 EntityManager 구분 필요</li>\n * </ul>\n */\n@Configuration\npublic class QueryDslConfig {\n\n    @PersistenceContext\n    private EntityManager entityManager;\n\n    /**\n     * JPAQueryFactory Bean 등록\n     *\n     * <p>QueryDSL의 타입 안전한 쿼리 빌더</p>\n     *\n     * @return JPAQueryFactory 인스턴스\n     */\n    @Bean\n    public JPAQueryFactory jpaQueryFactory() {\n        return new JPAQueryFactory(entityManager);\n    }\n}',1,'2026-01-16 06:52:08.000000','2026-01-16 06:52:08.000000',NULL);
INSERT INTO `resource_template` (`id`, `module_id`, `category`, `file_path`, `file_type`, `description`, `template_content`, `required`, `created_at`, `updated_at`, `deleted_at`) VALUES (17,6,'CONFIG','config/P6SpyConfig.java','JAVA','P6Spy SQL 로깅 설정 (선택적). 바인딩 파라미터 포함 실제 SQL 출력.','package com.{bc}.adapter.out.persistence.config;\n\nimport com.p6spy.engine.logging.Category;\nimport com.p6spy.engine.spy.P6SpyOptions;\nimport com.p6spy.engine.spy.appender.MessageFormattingStrategy;\nimport jakarta.annotation.PostConstruct;\nimport org.hibernate.engine.jdbc.internal.FormatStyle;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Profile;\n\nimport java.util.Locale;\n\n/**\n * P6Spy SQL 로깅 설정 (선택적)\n *\n * <p>실제 바인딩된 파라미터 값을 포함한 SQL 출력</p>\n *\n * <p>활성화 조건:</p>\n * <ul>\n *   <li>local, dev 프로파일에서만 활성화</li>\n *   <li>운영 환경에서는 비활성화 (성능 영향)</li>\n * </ul>\n *\n * <p>의존성 추가 필요:</p>\n * <pre>{@code\n * implementation \'com.github.gavlyukovskiy:p6spy-spring-boot-starter:1.9.0\'\n * }</pre>\n *\n * <p>application.yml 설정:</p>\n * <pre>{@code\n * decorator:\n *   datasource:\n *     p6spy:\n *       enable-logging: true\n *       multiline: true\n *       logging: slf4j\n * }</pre>\n */\n@Configuration\n@Profile({\"local\", \"dev\"})\npublic class P6SpyConfig {\n\n    @PostConstruct\n    public void setLogMessageFormat() {\n        P6SpyOptions.getActiveInstance().setLogMessageFormat(P6SpySqlFormatStrategy.class.getName());\n    }\n\n    /**\n     * SQL 포맷팅 전략\n     */\n    public static class P6SpySqlFormatStrategy implements MessageFormattingStrategy {\n\n        @Override\n        public String formatMessage(int connectionId, String now, long elapsed,\n                                    String category, String prepared, String sql, String url) {\n            if (sql == null || sql.trim().isEmpty()) {\n                return \"\";\n            }\n\n            String formattedSql = formatSql(category, sql);\n\n            return String.format(\n                \"\n============================================================\n\" +\n                \"  Connection ID: %d\n\" +\n                \"  Execution Time: %d ms\n\" +\n                \"  Category: %s\n\" +\n                \"============================================================\n\" +\n                \"%s\n\" +\n                \"============================================================\",\n                connectionId, elapsed, category, formattedSql\n            );\n        }\n\n        private String formatSql(String category, String sql) {\n            if (sql == null || sql.trim().isEmpty()) {\n                return sql;\n            }\n\n            // DDL과 DML 구분하여 포맷팅\n            if (Category.STATEMENT.getName().equals(category)) {\n                String trimmedSql = sql.trim().toLowerCase(Locale.ROOT);\n                if (trimmedSql.startsWith(\"create\") ||\n                    trimmedSql.startsWith(\"alter\") ||\n                    trimmedSql.startsWith(\"drop\") ||\n                    trimmedSql.startsWith(\"comment\")) {\n                    return FormatStyle.DDL.getFormatter().format(sql);\n                }\n                return FormatStyle.BASIC.getFormatter().format(sql);\n            }\n            return sql;\n        }\n    }\n}',0,'2026-01-16 06:52:08.000000','2026-01-16 06:52:08.000000',NULL);
INSERT INTO `resource_template` (`id`, `module_id`, `category`, `file_path`, `file_type`, `description`, `template_content`, `required`, `created_at`, `updated_at`, `deleted_at`) VALUES (18,6,'CONFIG','entity/common/BaseAuditEntity.java','JAVA','JPA Auditing 기반 추상 엔티티. createdAt, updatedAt 자동 관리.','package com.{bc}.adapter.out.persistence.entity.common;\n\nimport jakarta.persistence.Column;\nimport jakarta.persistence.EntityListeners;\nimport jakarta.persistence.MappedSuperclass;\nimport org.springframework.data.annotation.CreatedDate;\nimport org.springframework.data.annotation.LastModifiedDate;\nimport org.springframework.data.jpa.domain.support.AuditingEntityListener;\n\nimport java.time.Instant;\n\n/**\n * 감사 기반 추상 엔티티\n *\n * <p>모든 Entity가 상속받아야 하는 기본 클래스</p>\n *\n * <p>제공 기능:</p>\n * <ul>\n *   <li>createdAt: 생성 시각 (INSERT 시 자동 설정, 변경 불가)</li>\n *   <li>updatedAt: 수정 시각 (UPDATE 시 자동 갱신)</li>\n * </ul>\n *\n * <p>주의사항:</p>\n * <ul>\n *   <li>@EnableJpaAuditing 설정 필수</li>\n *   <li>Instant 타입 사용 (타임존 독립적)</li>\n *   <li>Setter 미제공 (JPA Auditing이 자동 설정)</li>\n * </ul>\n *\n * <p>사용 예시:</p>\n * <pre>{@code\n * @Entity\n * @Table(name = \"orders\")\n * public class OrderJpaEntity extends BaseAuditEntity {\n *     // Entity 필드 정의\n * }\n * }</pre>\n */\n@MappedSuperclass\n@EntityListeners(AuditingEntityListener.class)\npublic abstract class BaseAuditEntity {\n\n    @CreatedDate\n    @Column(name = \"created_at\", nullable = false, updatable = false)\n    private Instant createdAt;\n\n    @LastModifiedDate\n    @Column(name = \"updated_at\", nullable = false)\n    private Instant updatedAt;\n\n    // Getter만 제공 (Setter 금지 - Auditing이 자동 설정)\n    public Instant getCreatedAt() {\n        return createdAt;\n    }\n\n    public Instant getUpdatedAt() {\n        return updatedAt;\n    }\n}',1,'2026-01-16 06:52:08.000000','2026-01-16 06:52:08.000000',NULL);
INSERT INTO `resource_template` (`id`, `module_id`, `category`, `file_path`, `file_type`, `description`, `template_content`, `required`, `created_at`, `updated_at`, `deleted_at`) VALUES (19,6,'CONFIG','entity/common/SoftDeletableEntity.java','JAVA','소프트 삭제 기반 추상 엔티티. deleted, deletedAt 필드 제공.','package com.{bc}.adapter.out.persistence.entity.common;\n\nimport jakarta.persistence.Column;\nimport jakarta.persistence.MappedSuperclass;\n\nimport java.time.Instant;\n\n/**\n * 소프트 삭제 기반 추상 엔티티\n *\n * <p>BaseAuditEntity를 상속하고 소프트 삭제 기능 추가</p>\n *\n * <p>제공 기능:</p>\n * <ul>\n *   <li>deleted: 삭제 여부 플래그</li>\n *   <li>deletedAt: 삭제 시각</li>\n *   <li>softDelete(): 소프트 삭제 실행 메서드</li>\n *   <li>restore(): 복원 메서드</li>\n * </ul>\n *\n * <p>주의사항:</p>\n * <ul>\n *   <li>조회 시 deleted = false 조건 필수</li>\n *   <li>복원 시 deletedAt = null로 초기화</li>\n *   <li>물리적 삭제(DELETE)는 배치 작업으로 별도 처리</li>\n * </ul>\n *\n * <p>QueryDSL 조회 예시:</p>\n * <pre>{@code\n * queryFactory\n *     .selectFrom(order)\n *     .where(order.deleted.isFalse())  // 소프트 삭제되지 않은 것만\n *     .fetch();\n * }</pre>\n */\n@MappedSuperclass\npublic abstract class SoftDeletableEntity extends BaseAuditEntity {\n\n    @Column(name = \"deleted\", nullable = false)\n    private boolean deleted = false;\n\n    @Column(name = \"deleted_at\")\n    private Instant deletedAt;\n\n    // Getter\n    public boolean isDeleted() {\n        return deleted;\n    }\n\n    public Instant getDeletedAt() {\n        return deletedAt;\n    }\n\n    /**\n     * 소프트 삭제 실행\n     *\n     * <p>deleted = true, deletedAt = 현재 시각으로 설정</p>\n     *\n     * @param deletedAt 삭제 시각 (Domain에서 전달)\n     */\n    public void softDelete(Instant deletedAt) {\n        this.deleted = true;\n        this.deletedAt = deletedAt;\n    }\n\n    /**\n     * 복원 (삭제 취소)\n     *\n     * <p>deleted = false, deletedAt = null로 초기화</p>\n     */\n    public void restore() {\n        this.deleted = false;\n        this.deletedAt = null;\n    }\n}',1,'2026-01-16 06:52:08.000000','2026-01-16 06:52:08.000000',NULL);
INSERT INTO `resource_template` (`id`, `module_id`, `category`, `file_path`, `file_type`, `description`, `template_content`, `required`, `created_at`, `updated_at`, `deleted_at`) VALUES (20,6,'CONFIG','config/FlywayConfig.java','JAVA','Flyway 콜백 설정 (선택적). 마이그레이션 전후 커스텀 로직 실행.','package com.{bc}.adapter.out.persistence.config;\n\nimport org.flywaydb.core.api.callback.Callback;\nimport org.flywaydb.core.api.callback.Context;\nimport org.flywaydb.core.api.callback.Event;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n/**\n * Flyway 콜백 설정 (선택적)\n *\n * <p>마이그레이션 이벤트에 대한 커스텀 로직 실행</p>\n *\n * <p>지원 이벤트:</p>\n * <ul>\n *   <li>BEFORE_MIGRATE: 마이그레이션 시작 전</li>\n *   <li>AFTER_MIGRATE: 마이그레이션 완료 후</li>\n *   <li>AFTER_MIGRATE_ERROR: 마이그레이션 실패 시</li>\n *   <li>BEFORE_EACH_MIGRATE: 각 스크립트 실행 전</li>\n *   <li>AFTER_EACH_MIGRATE: 각 스크립트 실행 후</li>\n * </ul>\n *\n * <p>활용 예시:</p>\n * <ul>\n *   <li>마이그레이션 완료 Slack 알림</li>\n *   <li>마이그레이션 실패 시 롤백 알림</li>\n *   <li>마이그레이션 전후 캐시 초기화</li>\n * </ul>\n */\n@Configuration\npublic class FlywayConfig {\n\n    private static final Logger log = LoggerFactory.getLogger(FlywayConfig.class);\n\n    @Bean\n    public Callback flywayCallback() {\n        return new Callback() {\n\n            @Override\n            public boolean supports(Event event, Context context) {\n                return event == Event.BEFORE_MIGRATE\n                    || event == Event.AFTER_MIGRATE\n                    || event == Event.AFTER_MIGRATE_ERROR;\n            }\n\n            @Override\n            public boolean canHandleInTransaction(Event event, Context context) {\n                return true;\n            }\n\n            @Override\n            public void handle(Event event, Context context) {\n                switch (event) {\n                    case BEFORE_MIGRATE -> log.info(\n                        \"[Flyway] 마이그레이션 시작 - Schema: {}\",\n                        context.getConfiguration().getDefaultSchema()\n                    );\n                    case AFTER_MIGRATE -> log.info(\n                        \"[Flyway] 마이그레이션 완료 - Version: {}\",\n                        context.getMigrationInfo() != null\n                            ? context.getMigrationInfo().getVersion()\n                            : \"N/A\"\n                    );\n                    case AFTER_MIGRATE_ERROR -> log.error(\n                        \"[Flyway] 마이그레이션 실패! 롤백 필요\"\n                    );\n                    default -> { }\n                }\n            }\n\n            @Override\n            public String getCallbackName() {\n                return \"FlywayLoggingCallback\";\n            }\n        };\n    }\n}',0,'2026-01-16 06:52:08.000000','2026-01-16 06:52:08.000000',NULL);
INSERT INTO `resource_template` (`id`, `module_id`, `category`, `file_path`, `file_type`, `description`, `template_content`, `required`, `created_at`, `updated_at`, `deleted_at`) VALUES (21,6,'CONFIG','config/DataSourceHealthConfig.java','JAVA','DataSource 헬스체크 확장 설정 (선택적). HikariCP 풀 상태 모니터링.','package com.{bc}.adapter.out.persistence.config;\n\nimport com.zaxxer.hikari.HikariDataSource;\nimport com.zaxxer.hikari.HikariPoolMXBean;\nimport org.springframework.boot.actuate.health.Health;\nimport org.springframework.boot.actuate.health.HealthIndicator;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Profile;\n\nimport javax.sql.DataSource;\n\n/**\n * DataSource 헬스체크 확장 설정 (선택적)\n *\n * <p>HikariCP 커넥션 풀 상태를 Actuator 헬스체크에 포함</p>\n *\n * <p>모니터링 항목:</p>\n * <ul>\n *   <li>activeConnections: 현재 사용 중인 커넥션 수</li>\n *   <li>idleConnections: 유휴 커넥션 수</li>\n *   <li>totalConnections: 전체 커넥션 수</li>\n *   <li>threadsAwaitingConnection: 커넥션 대기 중인 스레드 수</li>\n * </ul>\n *\n * <p>Actuator 엔드포인트:</p>\n * <pre>\n * GET /actuator/health/hikariPool\n * </pre>\n */\n@Configuration\n@Profile({\"!test\"})  // 테스트 환경 제외\npublic class DataSourceHealthConfig {\n\n    @Bean\n    public HealthIndicator hikariPoolHealthIndicator(DataSource dataSource) {\n        return () -> {\n            if (!(dataSource instanceof HikariDataSource hikariDataSource)) {\n                return Health.unknown()\n                    .withDetail(\"message\", \"DataSource is not HikariDataSource\")\n                    .build();\n            }\n\n            HikariPoolMXBean poolMXBean = hikariDataSource.getHikariPoolMXBean();\n            if (poolMXBean == null) {\n                return Health.down()\n                    .withDetail(\"message\", \"HikariPool not initialized\")\n                    .build();\n            }\n\n            int activeConnections = poolMXBean.getActiveConnections();\n            int idleConnections = poolMXBean.getIdleConnections();\n            int totalConnections = poolMXBean.getTotalConnections();\n            int threadsAwaiting = poolMXBean.getThreadsAwaitingConnection();\n            int maxPoolSize = hikariDataSource.getMaximumPoolSize();\n\n            // 풀 사용률 계산\n            double poolUsage = (double) activeConnections / maxPoolSize * 100;\n\n            Health.Builder builder;\n            if (poolUsage >= 90) {\n                builder = Health.down()\n                    .withDetail(\"warning\", \"Connection pool usage over 90%\");\n            } else if (poolUsage >= 70) {\n                builder = Health.up()\n                    .withDetail(\"warning\", \"Connection pool usage over 70%\");\n            } else {\n                builder = Health.up();\n            }\n\n            return builder\n                .withDetail(\"poolName\", hikariDataSource.getPoolName())\n                .withDetail(\"activeConnections\", activeConnections)\n                .withDetail(\"idleConnections\", idleConnections)\n                .withDetail(\"totalConnections\", totalConnections)\n                .withDetail(\"maxPoolSize\", maxPoolSize)\n                .withDetail(\"poolUsagePercent\", String.format(\"%.1f%%\", poolUsage))\n                .withDetail(\"threadsAwaitingConnection\", threadsAwaiting)\n                .build();\n        };\n    }\n}',0,'2026-01-16 06:52:08.000000','2026-01-16 06:52:08.000000',NULL);

INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (5,24,'BAD','// ❌ BAD: Lombok 사용\n@Data\n@Builder\n@AllArgsConstructor\npublic class Order {\n    private Long id;\n    private String status;\n    private Instant createdAt;\n}','java','Lombok 어노테이션은 컴파일 타임 코드 생성으로 디버깅이 어렵고, Domain Layer의 순수성을 해칩니다.','[2, 3, 4]','MANUAL',NULL,'2026-01-20 15:04:52.000000','2026-01-20 15:04:52.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (6,24,'GOOD','// ✅ GOOD: 명시적 구현\npublic class Order {\n    private final OrderId id;\n    private OrderStatus status;\n    private final Instant createdAt;\n\n    private Order(OrderId id, OrderStatus status, Instant createdAt) {\n        this.id = id;\n        this.status = status;\n        this.createdAt = createdAt;\n    }\n\n    public OrderId id() { return id; }\n    public OrderStatus status() { return status; }\n    public Instant createdAt() { return createdAt; }\n}','java','모든 필드와 메서드를 명시적으로 작성하여 코드 가독성과 디버깅 용이성을 확보합니다.','[7, 8, 9, 10]','MANUAL',NULL,'2026-01-20 15:04:52.000000','2026-01-20 15:04:52.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (7,27,'BAD','// ❌ BAD: 생성자 직접 노출\npublic class Order {\n    private OrderId id;\n    private OrderStatus status;\n\n    // public 생성자 직접 노출\n    public Order(Long customerId, List<OrderLine> lines) {\n        this.id = OrderId.forNew();\n        this.status = OrderStatus.PENDING;\n    }\n}\n\n// 사용 시\nOrder order = new Order(customerId, lines);','java','생성자를 직접 노출하면 생성 의도가 불명확하고, 비즈니스 규칙 검증이 분산됩니다.','[7, 8, 9, 10, 14]','MANUAL',NULL,'2026-01-20 15:04:52.000000','2026-01-20 15:04:52.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (8,27,'GOOD','// ✅ GOOD: forNew() 정적 팩토리 메서드\npublic class Order {\n    private final OrderId id;\n    private OrderStatus status;\n\n    private Order(OrderId id, OrderStatus status) {\n        this.id = id;\n        this.status = status;\n    }\n\n    // 새 Aggregate 생성 - ID는 null\n    public static Order forNew(Long customerId, List<OrderLine> lines, Instant now) {\n        validateNewOrder(customerId, lines);\n        return new Order(OrderId.forNew(), OrderStatus.PENDING);\n    }\n\n    // DB에서 복원 - ID 존재\n    public static Order reconstitute(OrderId id, OrderStatus status) {\n        return new Order(id, status);\n    }\n}\n\n// 사용 시\nOrder order = Order.forNew(customerId, lines, now);','java','forNew()는 새 Aggregate 생성 의도를 명확히 하고, reconstitute()는 영속성 복원을 표현합니다.','[12, 13, 14, 15, 18, 19, 20, 24]','MANUAL',NULL,'2026-01-20 15:04:52.000000','2026-01-20 15:04:52.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (9,35,'BAD','// ❌ BAD: Setter 메서드 사용\npublic class Order {\n    private OrderStatus status;\n\n    public void setStatus(OrderStatus status) {\n        this.status = status;\n    }\n}\n\n// 사용 시 - 비즈니스 의도 불명확\norder.setStatus(OrderStatus.SHIPPED);','java','Setter는 상태 변경 의도가 불명확하고, 비즈니스 불변식 검증이 누락됩니다.','[5, 6, 7, 11]','MANUAL',NULL,'2026-01-20 15:04:52.000000','2026-01-20 15:04:52.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (10,35,'GOOD','// ✅ GOOD: 도메인 메서드로 상태 변경\npublic class Order {\n    private OrderStatus status;\n\n    public void ship(Instant shippedAt) {\n        if (this.status != OrderStatus.PAID) {\n            throw new OrderNotPaidException(this.id);\n        }\n        this.status = OrderStatus.SHIPPED;\n        this.shippedAt = shippedAt;\n    }\n\n    public void cancel(String reason, Instant cancelledAt) {\n        if (this.status == OrderStatus.SHIPPED) {\n            throw new OrderAlreadyShippedException(this.id);\n        }\n        this.status = OrderStatus.CANCELLED;\n        this.cancelReason = reason;\n    }\n}\n\n// 사용 시 - 비즈니스 의도 명확\norder.ship(now);\norder.cancel(\"고객 요청\", now);','java','도메인 메서드는 비즈니스 의도를 명확히 하고, 불변식 검증을 캡슐화합니다.','[5, 6, 7, 8, 9, 10, 11, 13, 14, 15, 16, 17, 18, 19, 23, 24]','MANUAL',NULL,'2026-01-20 15:04:52.000000','2026-01-20 15:04:52.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (11,37,'BAD','// ❌ BAD: Getter 체이닝 (Law of Demeter 위반)\npublic class OrderService {\n    public void processOrder(Order order) {\n        // 내부 구조 노출\n        BigDecimal amount = order.getTotalPrice().getValue();\n        String city = order.getShippingAddress().getCity();\n\n        // 구조 변경 시 모든 호출부 수정 필요\n        if (order.getCustomer().getMembership().getLevel().equals(\"VIP\")) {\n            applyDiscount();\n        }\n    }\n}','java','Getter 체이닝은 내부 구조를 노출하고, 구조 변경 시 모든 호출부를 수정해야 합니다.','[5, 6, 9]','MANUAL',NULL,'2026-01-20 15:04:52.000000','2026-01-20 15:04:52.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (12,37,'GOOD','// ✅ GOOD: 편의 메서드로 캡슐화\npublic class Order {\n    private final Money totalPrice;\n    private final Address shippingAddress;\n    private final Customer customer;\n\n    // VO 원시값 접근 편의 메서드\n    public BigDecimal totalPriceValue() {\n        return totalPrice.value();\n    }\n\n    public String shippingCity() {\n        return shippingAddress.city();\n    }\n\n    // 비즈니스 로직 캡슐화\n    public boolean isVipCustomer() {\n        return customer.isVip();\n    }\n}\n\n// 사용 시 - 체이닝 없음\npublic class OrderService {\n    public void processOrder(Order order) {\n        BigDecimal amount = order.totalPriceValue();\n        if (order.isVipCustomer()) {\n            applyDiscount();\n        }\n    }\n}','java','편의 메서드로 내부 구조를 캡슐화하면, 구조 변경 시 Aggregate만 수정합니다.','[8, 9, 12, 13, 17, 18, 19, 25, 26, 27]','MANUAL',NULL,'2026-01-20 15:04:52.000000','2026-01-20 15:04:52.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (13,51,'BAD','// ❌ BAD: class로 VO 정의\npublic class Money {\n    private final BigDecimal value;\n    private final String currency;\n\n    public Money(BigDecimal value, String currency) {\n        this.value = value;\n        this.currency = currency;\n    }\n\n    public BigDecimal getValue() { return value; }\n    public String getCurrency() { return currency; }\n\n    // equals, hashCode 직접 구현 필요\n    @Override\n    public boolean equals(Object o) { ... }\n    @Override\n    public int hashCode() { ... }\n}','java','class로 VO를 정의하면 equals/hashCode를 직접 구현해야 하고, 불변성 보장이 어렵습니다.','[2, 6, 7, 8, 14, 15, 16, 17]','MANUAL',NULL,'2026-01-20 15:04:52.000000','2026-01-20 15:04:52.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (14,51,'GOOD','// ✅ GOOD: Record로 VO 정의\npublic record Money(BigDecimal value, String currency) {\n\n    // Compact Constructor로 검증\n    public Money {\n        if (value == null || value.compareTo(BigDecimal.ZERO) < 0) {\n            throw new IllegalArgumentException(\"금액은 0 이상이어야 합니다\");\n        }\n        if (currency == null || currency.isBlank()) {\n            throw new IllegalArgumentException(\"통화 코드는 필수입니다\");\n        }\n    }\n\n    // 정적 팩토리 메서드\n    public static Money of(BigDecimal value, String currency) {\n        return new Money(value, currency);\n    }\n\n    public static Money krw(BigDecimal value) {\n        return new Money(value, \"KRW\");\n    }\n}','java','Record는 자동으로 불변성, equals/hashCode, toString을 제공하고, Compact Constructor로 검증합니다.','[2, 5, 6, 7, 8, 9, 10, 11, 15, 16, 19, 20]','MANUAL',NULL,'2026-01-20 15:04:52.000000','2026-01-20 15:04:52.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (15,52,'GOOD','// ✅ GOOD: of() 정적 팩토리 메서드\npublic record Email(String value) {\n\n    private static final Pattern EMAIL_PATTERN =\n        Pattern.compile(\"^[A-Za-z0-9+_.-]+@(.+)$\");\n\n    public Email {\n        if (value == null || !EMAIL_PATTERN.matcher(value).matches()) {\n            throw new IllegalArgumentException(\"유효하지 않은 이메일: \" + value);\n        }\n    }\n\n    // 생성을 위한 유일한 진입점\n    public static Email of(String value) {\n        return new Email(value);\n    }\n}\n\n// 사용 시\nEmail email = Email.of(\"user@example.com\");','java','of() 정적 팩토리로 생성을 통제하고, 명명된 생성자 패턴으로 가독성을 높입니다.','[13, 14, 15, 19]','MANUAL',NULL,'2026-01-20 15:04:52.000000','2026-01-20 15:04:52.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (16,61,'GOOD','// ✅ GOOD: Long ID VO\npublic record OrderId(Long value) {\n\n    // 새 Aggregate용 - ID null\n    public static OrderId forNew() {\n        return new OrderId(null);\n    }\n\n    // DB 복원용 - ID 필수\n    public static OrderId of(Long value) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"OrderId는 null일 수 없습니다\");\n        }\n        return new OrderId(value);\n    }\n\n    public boolean isNew() {\n        return value == null;\n    }\n}','java','Long ID는 forNew()에서 null을 반환하고, of()에서는 null 검증을 수행합니다.','[2, 5, 6, 9, 10, 11, 12, 13, 16, 17]','MANUAL',NULL,'2026-01-20 15:04:52.000000','2026-01-20 15:04:52.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (17,62,'GOOD','// ✅ GOOD: String ID VO (UUID 등)\npublic record ProductId(String value) {\n\n    public ProductId {\n        if (value == null || value.isBlank()) {\n            throw new IllegalArgumentException(\"ProductId는 필수입니다\");\n        }\n    }\n\n    // String ID는 외부에서 주입 (forNew 없음)\n    public static ProductId of(String value) {\n        return new ProductId(value);\n    }\n\n    // String ID는 항상 값이 있으므로 isNew() 제공하지 않음\n}\n\n// 사용 시 - UUID는 외부에서 생성\nProductId productId = ProductId.of(UUID.randomUUID().toString());','java','String ID는 외부에서 값을 주입받아야 하므로 forNew()가 없고, isNew()도 불필요합니다.','[2, 4, 5, 6, 7, 10, 11, 12, 18]','MANUAL',NULL,'2026-01-20 15:04:52.000000','2026-01-20 15:04:52.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (18,81,'BAD','// ❌ BAD: RuntimeException 직접 상속\npublic class OrderNotFoundException extends RuntimeException {\n    public OrderNotFoundException(Long orderId) {\n        super(\"주문을 찾을 수 없습니다: \" + orderId);\n    }\n}\n\n// 사용 시 - ErrorCode 없음\nthrow new OrderNotFoundException(orderId);','java','RuntimeException을 직접 상속하면 공통 에러 처리 로직 적용이 어렵습니다.','[2]','MANUAL',NULL,'2026-01-20 15:04:52.000000','2026-01-20 15:04:52.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (19,81,'GOOD','// ✅ GOOD: ErrorCode + DomainException 구조\npublic enum OrderErrorCode implements ErrorCode {\n    NOT_FOUND(\"ORD-001\", 404, \"주문을 찾을 수 없습니다\"),\n    ALREADY_SHIPPED(\"ORD-002\", 400, \"이미 배송된 주문입니다\");\n\n    private final String code;\n    private final int httpStatus;\n    private final String message;\n\n    // constructor, getters...\n}\n\npublic class OrderNotFoundException extends DomainException {\n    public OrderNotFoundException(OrderId orderId) {\n        super(OrderErrorCode.NOT_FOUND,\n              String.format(\"주문 ID: %s\", orderId.value()),\n              Map.of(\"orderId\", orderId.value()));\n    }\n}\n\n// 사용 시\nthrow new OrderNotFoundException(orderId);','java','ErrorCode enum으로 에러 코드를 체계화하고, DomainException으로 공통 처리가 가능합니다.','[2, 3, 4, 13, 14, 15, 16, 17]','MANUAL',NULL,'2026-01-20 15:04:52.000000','2026-01-20 15:04:52.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (20,70,'GOOD','// ✅ GOOD: DomainEvent 구현 (Record)\npublic record OrderCreatedEvent(\n    OrderId orderId,\n    Long customerId,\n    BigDecimal totalAmount,\n    Instant occurredAt\n) implements DomainEvent {\n\n    // 정적 팩토리 메서드 - Application 레이어에서 시간 주입\n    public static OrderCreatedEvent from(Order order, Instant occurredAt) {\n        return new OrderCreatedEvent(\n            order.id(),\n            order.customerId(),\n            order.totalAmount(),\n            occurredAt\n        );\n    }\n}\n\n// Application 레이어에서 이벤트 생성\n@Service\n@Transactional\npublic class OrderCommandManager {\n    private final TimeProvider timeProvider;\n    \n    public void place(Order order) {\n        order.place();\n        OrderCreatedEvent event = OrderCreatedEvent.from(order, timeProvider.now());\n        eventRegistry.register(event);\n    }\n}','java','DomainEvent는 Record로 불변성을 보장하고, occurredAt으로 이벤트 발생 시각을 기록합니다.','[2, 3, 4, 5, 6, 7, 11, 12, 13, 22, 23, 24]','MANUAL',NULL,'2026-01-20 15:04:52.000000','2026-01-21 14:57:52.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (21,101,'GOOD','// ✅ GOOD: Cursor 기반 Criteria\npublic record OrderSliceCriteria(\n    Long customerId,\n    OrderStatus status,\n    DateRange orderDateRange,\n    CursorQueryContext<OrderSortKey, Long> queryContext  // 필수!\n) implements CursorSliceCriteria<OrderSortKey, Long> {\n\n    // 빌더 스타일 정적 팩토리\n    public static OrderSliceCriteria of(\n            Long customerId,\n            OrderStatus status,\n            CursorQueryContext<OrderSortKey, Long> queryContext) {\n        return new OrderSliceCriteria(customerId, status, null, queryContext);\n    }\n}\n\n// SortKey enum\npublic enum OrderSortKey implements SortKey {\n    ORDER_DATE(\"orderDate\"),\n    TOTAL_AMOUNT(\"totalAmount\");\n\n    private final String fieldName;\n\n    OrderSortKey(String fieldName) { this.fieldName = fieldName; }\n\n    @Override\n    public String fieldName() { return fieldName; }\n}','java','Criteria는 반드시 CursorQueryContext를 포함하고, SortKey enum으로 정렬 필드를 정의합니다.','[2, 3, 4, 5, 6, 7, 20, 21, 22, 27, 28]','MANUAL',NULL,'2026-01-20 15:04:53.000000','2026-01-20 15:04:53.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (24,115,'GOOD','@Service\npublic class CreateOrderService implements CreateOrderUseCase {\n    private final OrderCommandFacade orderCommandFacade;\n    \n    @Override\n    public Long execute(CreateOrderCommand command) {\n        return orderCommandFacade.createOrder(command);\n    }\n}','java','Service는 @Transactional 없이 Facade에 위임',NULL,NULL,NULL,'2026-01-21 05:31:07.000000','2026-01-21 05:31:07.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (25,115,'BAD','@Service\n@Transactional\npublic class CreateOrderService implements CreateOrderUseCase {\n    @Override\n    public Long execute(CreateOrderCommand command) {\n        // Service에 @Transactional 직접 선언\n    }\n}','java','Service에 @Transactional 직접 선언 - Manager에서 관리해야 함',NULL,NULL,NULL,'2026-01-21 05:31:07.000000','2026-01-21 05:31:07.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (26,116,'GOOD','@Service\n@Transactional\npublic class OrderCommandManager {\n    private final OrderCommandPort orderCommandPort;\n    \n    public Long create(Order order) {\n        return orderCommandPort.persist(order);\n    }\n}','java','Manager는 @Transactional 필수',NULL,NULL,NULL,'2026-01-21 05:31:07.000000','2026-01-21 05:31:07.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (27,116,'BAD','@Service\npublic class OrderCommandManager {\n    // @Transactional 누락\n    public Long create(Order order) {\n        return orderCommandPort.persist(order);\n    }\n}','java','Manager에 @Transactional 누락 - 트랜잭션 경계 미정의',NULL,NULL,NULL,'2026-01-21 05:31:07.000000','2026-01-21 05:31:07.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (28,117,'GOOD','@Service\npublic class PaymentClientManager {\n    private final PaymentClientPort paymentClientPort;\n    \n    public PaymentResult process(PaymentRequest request) {\n        return paymentClientPort.execute(request);\n    }\n}','java','ClientManager는 @Transactional 없이 외부 호출만',NULL,NULL,NULL,'2026-01-21 05:31:19.000000','2026-01-21 05:31:19.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (29,117,'BAD','@Service\n@Transactional\npublic class PaymentClientManager {\n    public PaymentResult process(PaymentRequest request) {\n        return paymentClientPort.execute(request);\n    }\n}','java','ClientManager에 @Transactional - 외부 호출 시 트랜잭션 문제 발생 가능',NULL,NULL,NULL,'2026-01-21 05:31:19.000000','2026-01-21 05:31:19.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (30,118,'GOOD','@Service\n@Transactional\npublic class OrderCommandFacade {\n    private final OrderCommandManager orderCommandManager;\n    private final InventoryCommandManager inventoryCommandManager;\n    \n    public Long createOrder(CreateOrderCommand command) {\n        Long orderId = orderCommandManager.create(command);\n        inventoryCommandManager.decrease(command.items());\n        return orderId;\n    }\n}','java','CommandFacade는 여러 Manager 조합 시 @Transactional 권장',NULL,NULL,NULL,'2026-01-21 05:31:19.000000','2026-01-21 05:31:19.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (31,118,'BAD','@Service\n@Transactional(readOnly = true)\npublic class OrderCommandFacade {\n    public Long createOrder(CreateOrderCommand command) {\n        // readOnly는 Command에 부적합\n    }\n}','java','CommandFacade에 readOnly=true 사용 - 쓰기 작업에 부적합',NULL,NULL,NULL,'2026-01-21 05:31:19.000000','2026-01-21 05:31:19.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (32,119,'GOOD','@Service\n@Transactional(readOnly = true)\npublic class OrderQueryFacade {\n    private final OrderQueryManager orderQueryManager;\n    \n    public OrderDetailBundle getOrderDetail(Long orderId) {\n        return orderQueryManager.findWithDetails(orderId);\n    }\n}','java','QueryFacade는 @Transactional(readOnly=true) 필수',NULL,NULL,NULL,'2026-01-21 05:31:19.000000','2026-01-21 05:31:19.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (33,119,'BAD','@Service\n@Transactional\npublic class OrderQueryFacade {\n    public OrderDetailBundle getOrderDetail(Long orderId) {\n        // readOnly 누락 - 성능 최적화 못함\n    }\n}','java','QueryFacade에 readOnly 누락 - DB 읽기 최적화 불가',NULL,NULL,NULL,'2026-01-21 05:31:19.000000','2026-01-21 05:31:19.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (34,120,'GOOD','@Service\npublic class CreateOrderService implements CreateOrderUseCase {\n    private final OrderCommandFacade orderCommandFacade;\n    \n    public Long execute(CreateOrderCommand command) {\n        return orderCommandFacade.createOrder(command);\n    }\n}','java','Service는 Facade 또는 Manager에 위임',NULL,NULL,NULL,'2026-01-21 05:31:35.000000','2026-01-21 05:31:35.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (35,120,'BAD','@Service\npublic class CreateOrderService implements CreateOrderUseCase {\n    private final OrderCommandPort orderCommandPort; // Port 직접 의존\n    \n    public Long execute(CreateOrderCommand command) {\n        return orderCommandPort.persist(order);\n    }\n}','java','Service에서 Port 직접 의존 금지 - Manager/Facade 통해 접근',NULL,NULL,NULL,'2026-01-21 05:31:35.000000','2026-01-21 05:31:35.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (36,121,'GOOD','@Service\npublic class OrderCommandFacade {\n    private final OrderCommandManager orderCommandManager;\n    private final InventoryCommandManager inventoryCommandManager;\n}','java','CommandFacade는 CommandManager들에 의존',NULL,NULL,NULL,'2026-01-21 05:31:35.000000','2026-01-21 05:31:35.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (37,121,'BAD','@Service\npublic class OrderCommandFacade {\n    private final OrderCommandPort orderCommandPort; // Port 직접 의존\n}','java','Facade에서 Port 직접 의존 금지 - Manager 통해 접근',NULL,NULL,NULL,'2026-01-21 05:31:35.000000','2026-01-21 05:31:35.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (38,122,'GOOD','@Service\npublic class OrderCommandFacade {\n    private final OrderCommandManager orderCommandManager;\n    // QueryManager 의존 없음 - CQRS 준수\n}','java','CommandFacade는 QueryManager에 의존하지 않음 - CQRS 준수',NULL,NULL,NULL,'2026-01-21 05:31:35.000000','2026-01-21 05:31:35.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (39,122,'BAD','@Service\npublic class OrderCommandFacade {\n    private final OrderCommandManager orderCommandManager;\n    private final OrderQueryManager orderQueryManager; // CQRS 위반\n    \n    public Long createOrder(CreateOrderCommand command) {\n        Order existing = orderQueryManager.findById(id); // 조회 혼합\n        return orderCommandManager.create(order);\n    }\n}','java','CommandFacade에서 QueryManager 의존 - CQRS 원칙 위반',NULL,NULL,NULL,'2026-01-21 05:31:35.000000','2026-01-21 05:31:35.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (40,123,'GOOD','@Component\npublic class OrderValidator {\n    private final OrderQueryManager orderQueryManager; // 같은 도메인만\n    \n    public void validateExists(OrderId orderId) {\n        if (!orderQueryManager.existsById(orderId)) {\n            throw new DomainException(OrderErrorCode.NOT_FOUND);\n        }\n    }\n}','java','Validator는 같은 도메인의 QueryManager만 의존',NULL,NULL,NULL,'2026-01-21 05:31:35.000000','2026-01-21 05:31:35.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (41,123,'BAD','@Component\npublic class OrderValidator {\n    private final OrderQueryManager orderQueryManager;\n    private final CustomerQueryManager customerQueryManager; // 다른 도메인\n}','java','Validator에서 다른 도메인 Manager 의존 - 단일 도메인 원칙 위반',NULL,NULL,NULL,'2026-01-21 05:31:35.000000','2026-01-21 05:31:35.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (42,124,'GOOD','@Component\nclass PriceCalculator { // internal 패키지\n    private final ProductQueryManager productQueryManager;\n    \n    BigDecimal calculate(List<Long> productIds) {\n        return productQueryManager.findPrices(productIds)\n            .stream()\n            .reduce(BigDecimal.ZERO, BigDecimal::add);\n    }\n}','java','Internal 컴포넌트는 Manager를 통해 데이터 접근',NULL,NULL,NULL,'2026-01-21 05:31:51.000000','2026-01-21 05:31:51.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (43,124,'BAD','@Component\nclass PriceCalculator {\n    private final ProductQueryPort productQueryPort; // Port 직접 의존\n}','java','Internal 컴포넌트에서 Port 직접 의존 금지',NULL,NULL,NULL,'2026-01-21 05:31:51.000000','2026-01-21 05:31:51.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (44,125,'GOOD','public record CreateOrderCommand(\n    Long customerId,\n    List<OrderLineCommand> lines,\n    String memo\n) {}','java','Command/Query DTO는 record로 정의',NULL,NULL,NULL,'2026-01-21 05:31:51.000000','2026-01-21 05:31:51.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (45,125,'BAD','@Data\npublic class CreateOrderCommand {\n    private Long customerId;\n    private List<OrderLineCommand> lines;\n}','java','Command/Query에 클래스 + Lombok 사용 금지 - record 필수',NULL,NULL,NULL,'2026-01-21 05:31:51.000000','2026-01-21 05:31:51.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (46,126,'GOOD','public record CreateOrderCommand(\n    Long customerId,\n    List<OrderLineCommand> lines\n) {\n    // 정적 팩토리만 허용\n    public static CreateOrderCommand of(Long customerId) {\n        return new CreateOrderCommand(customerId, List.of());\n    }\n}','java','Command/Query에는 정적 팩토리만 허용',NULL,NULL,NULL,'2026-01-21 05:31:51.000000','2026-01-21 05:31:51.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (47,126,'BAD','public record CreateOrderCommand(\n    Long customerId,\n    List<OrderLineCommand> lines\n) {\n    public int getTotalLineCount() { // 인스턴스 메서드 금지\n        return lines.size();\n    }\n}','java','Command/Query에 인스턴스 메서드 금지 - 행위 없는 데이터 전달자',NULL,NULL,NULL,'2026-01-21 05:31:51.000000','2026-01-21 05:31:51.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (48,127,'GOOD','public record OrderSearchQuery(\n    String keyword,\n    OrderStatus status,\n    CommonSearchParams searchParams\n) {}','java','검색 Query는 CommonSearchParams 포함',NULL,NULL,NULL,'2026-01-21 05:31:51.000000','2026-01-21 05:31:51.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (49,127,'BAD','public record OrderSearchQuery(\n    String keyword,\n    OrderStatus status,\n    int page,     // 직접 정의 금지\n    int size\n) {}','java','페이징 파라미터 직접 정의 금지 - CommonSearchParams 사용',NULL,NULL,NULL,'2026-01-21 05:31:51.000000','2026-01-21 05:31:51.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (50,128,'GOOD','public record OrderListQuery(\n    OrderStatus status,\n    CommonCursorParams cursorParams\n) {}','java','커서 기반 조회는 CommonCursorParams 포함',NULL,NULL,NULL,'2026-01-21 05:31:51.000000','2026-01-21 05:31:51.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (51,128,'BAD','public record OrderListQuery(\n    OrderStatus status,\n    Long cursor,  // 직접 정의 금지\n    int size\n) {}','java','커서 파라미터 직접 정의 금지 - CommonCursorParams 사용',NULL,NULL,NULL,'2026-01-21 05:31:51.000000','2026-01-21 05:31:51.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (52,129,'GOOD','public record OrderBundle(\n    Order order,\n    List<OrderLine> lines,\n    Customer customer\n) {\n    public OrderBundle withId(Long orderId) {\n        return new OrderBundle(\n            order.withId(orderId),\n            lines,\n            customer\n        );\n    }\n}','java','Bundle은 withId() 패턴으로 ID 설정',NULL,NULL,NULL,'2026-01-21 05:32:07.000000','2026-01-21 05:32:07.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (53,129,'BAD','public record OrderBundle(\n    Order order,\n    List<OrderLine> lines\n) {\n    public void setOrderId(Long id) { // setter 금지\n        // record는 immutable\n    }\n}','java','Bundle에 setter 패턴 금지 - withId() 사용',NULL,NULL,NULL,'2026-01-21 05:32:07.000000','2026-01-21 05:32:07.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (54,130,'GOOD','public interface OrderCommandPort {\n    Long persist(Order order);\n    List<Long> persistAll(List<Order> orders);\n}','java','CommandPort는 persist/persistAll 메서드만 제공',NULL,NULL,NULL,'2026-01-21 05:32:07.000000','2026-01-21 05:32:07.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (55,130,'BAD','public interface OrderCommandPort {\n    Long save(Order order);      // persist 사용\n    void update(Order order);    // persist가 처리\n    void delete(Long id);        // persist가 처리 (soft delete)\n}','java','save/update/delete 개별 메서드 금지 - persist로 통합',NULL,NULL,NULL,'2026-01-21 05:32:07.000000','2026-01-21 05:32:07.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (56,131,'GOOD','public interface OrderQueryPort {\n    Optional<Order> findById(OrderId id);\n    List<Order> findBySliceCriteria(OrderSliceCriteria criteria);\n    boolean existsById(OrderId id);\n}','java','QueryPort는 조건 기반 조회만 제공, findAll 금지',NULL,NULL,NULL,'2026-01-21 05:32:07.000000','2026-01-21 05:32:07.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (57,131,'BAD','public interface OrderQueryPort {\n    List<Order> findAll(); // OOM 위험\n}','java','findAll 금지 - 대량 데이터로 OOM 발생 가능',NULL,NULL,NULL,'2026-01-21 05:32:07.000000','2026-01-21 05:32:07.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (58,132,'GOOD','public interface OrderQueryPort {\n    Optional<Order> findById(OrderId id);\n    List<Order> findByCustomerId(CustomerId customerId);\n    boolean existsByOrderNumber(String orderNumber);\n    long countByStatus(OrderStatus status);\n}','java','QueryPort 메서드명: findBy*, existsBy*, countBy*',NULL,NULL,NULL,'2026-01-21 05:32:07.000000','2026-01-21 05:32:07.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (59,132,'BAD','public interface OrderQueryPort {\n    Order getById(Long id);           // get 대신 find 사용\n    List<Order> selectByCustomer(Long customerId); // select 금지\n    boolean hasOrder(Long id);        // exists 패턴 사용\n}','java','get/select/has 대신 find/exists/count 패턴 사용',NULL,NULL,NULL,'2026-01-21 05:32:07.000000','2026-01-21 05:32:07.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (60,133,'GOOD','@Service\n@Transactional\npublic class OrderCommandManager {\n    private final TransactionEventRegistry eventRegistry;\n    \n    public Long create(Order order) {\n        Long id = orderCommandPort.persist(order);\n        eventRegistry.register(new OrderCreatedEvent(id));\n        return id;\n    }\n}','java','TransactionEventRegistry를 통해 이벤트 등록',NULL,NULL,NULL,'2026-01-21 05:32:25.000000','2026-01-21 05:32:25.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (61,133,'BAD','@Service\npublic class OrderCommandManager {\n    private final ApplicationEventPublisher eventPublisher; // 직접 주입 금지\n    \n    public Long create(Order order) {\n        Long id = orderCommandPort.persist(order);\n        eventPublisher.publishEvent(new OrderCreatedEvent(id));\n        return id;\n    }\n}','java','ApplicationEventPublisher 직접 주입 금지 - 트랜잭션 타이밍 문제',NULL,NULL,NULL,'2026-01-21 05:32:25.000000','2026-01-21 05:32:25.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (62,134,'GOOD','@Service\n@Transactional\npublic class PaymentCommandManager {\n    private final TransactionEventRegistry eventRegistry;\n    \n    public void complete(Payment payment) {\n        paymentCommandPort.persist(payment);\n        eventRegistry.register(new PaymentCompletedEvent(\n            payment.getId(),\n            payment.getAmount()\n        ));\n    }\n}','java','TransactionEventRegistry로 커밋 후 이벤트 발행 보장',NULL,NULL,NULL,'2026-01-21 05:32:25.000000','2026-01-21 05:32:25.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (63,134,'BAD','@Service\npublic class PaymentCommandManager {\n    public void complete(Payment payment) {\n        paymentCommandPort.persist(payment);\n        // 이벤트 발행 누락 또는 잘못된 시점\n    }\n}','java','이벤트 발행 누락 - TransactionEventRegistry 사용 필수',NULL,NULL,NULL,'2026-01-21 05:32:25.000000','2026-01-21 05:32:25.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (64,135,'GOOD','@Component\npublic class OrderFactory {\n    private final TimeProvider timeProvider;\n    \n    public Order create(CreateOrderCommand command) {\n        return Order.create(\n            command.customerId(),\n            command.lines(),\n            timeProvider.now()\n        );\n    }\n}','java','TimeProvider는 Factory에서만 사용',NULL,NULL,NULL,'2026-01-21 05:32:25.000000','2026-01-21 05:32:25.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (65,135,'BAD','@Service\n@Transactional\npublic class OrderCommandManager {\n    private final TimeProvider timeProvider; // Manager에서 사용 금지\n    \n    public Long create(CreateOrderCommand command) {\n        Instant now = timeProvider.now();\n        Order order = Order.create(command, now);\n        return orderCommandPort.persist(order);\n    }\n}','java','Manager에서 TimeProvider 직접 사용 금지 - Factory에 위임',NULL,NULL,NULL,'2026-01-21 05:32:25.000000','2026-01-21 05:32:25.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (66,136,'GOOD','@Component\npublic class OrderFactory {\n    private final TimeProvider timeProvider;\n    private final IdGenerator idGenerator;\n    \n    public Order create(CreateOrderCommand command) {\n        return Order.builder()\n            .id(idGenerator.generate())\n            .customerId(command.customerId())\n            .createdAt(timeProvider.now())\n            .build();\n    }\n}','java','Factory는 외부 의존성 주입이 필요한 생성 로직에 사용',NULL,NULL,NULL,'2026-01-21 05:32:25.000000','2026-01-21 05:32:25.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (67,136,'BAD','@Component\npublic class OrderFactory {\n    // 단순 매핑만 하는 Factory는 불필요\n    public Order create(CreateOrderCommand command) {\n        return new Order(command.customerId());\n    }\n}','java','단순 매핑만 하는 Factory는 불필요 - 도메인 생성자 직접 사용',NULL,NULL,NULL,'2026-01-21 05:32:25.000000','2026-01-21 05:32:25.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (68,137,'GOOD','@Component\npublic class OrderValidator {\n    private final OrderQueryManager orderQueryManager;\n    \n    public Order validateAndGet(OrderId orderId) {\n        return orderQueryManager.findById(orderId)\n            .orElseThrow(() -> new DomainException(\n                OrderErrorCode.NOT_FOUND, orderId));\n    }\n}','java','Validator는 검증 후 도메인 객체 반환',NULL,NULL,NULL,'2026-01-21 05:32:43.000000','2026-01-21 05:32:43.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (69,137,'BAD','@Component\npublic class OrderValidator {\n    public void validate(OrderId orderId) {\n        // void 반환 - 조회 중복 발생\n        if (!orderQueryManager.existsById(orderId)) {\n            throw new DomainException(OrderErrorCode.NOT_FOUND);\n        }\n    }\n    // 호출 측에서 다시 조회해야 함\n}','java','void 반환 시 조회 중복 - 검증 후 도메인 반환 권장',NULL,NULL,NULL,'2026-01-21 05:32:43.000000','2026-01-21 05:32:43.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (70,138,'GOOD','@Component\npublic class OrderValidator {\n    public Order validateAndGet(OrderId orderId) {\n        return orderQueryManager.findById(orderId)\n            .orElseThrow(() -> new DomainException(\n                OrderErrorCode.NOT_FOUND, orderId));\n    }\n}','java','Validator는 DomainException(ErrorCode, id) 형태로 예외 발생',NULL,NULL,NULL,'2026-01-21 05:32:43.000000','2026-01-21 05:32:43.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (71,138,'BAD','@Component\npublic class OrderValidator {\n    public Order validateAndGet(OrderId orderId) {\n        return orderQueryManager.findById(orderId)\n            .orElseThrow(() -> new IllegalArgumentException(\n                \"Order not found: \" + orderId)); // 범용 예외 금지\n    }\n}','java','범용 예외 금지 - DomainException + ErrorCode 사용',NULL,NULL,NULL,'2026-01-21 05:32:43.000000','2026-01-21 05:32:43.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (72,139,'GOOD','@Component\npublic class OrderAssembler {\n    public OrderResponse toResponse(Order order) {\n        return new OrderResponse(\n            order.getId().value(),\n            order.getStatus().name(),\n            order.getTotalAmount()\n        );\n    }\n}','java','Assembler는 도메인별 구체적인 Response 클래스 반환',NULL,NULL,NULL,'2026-01-21 05:32:43.000000','2026-01-21 05:32:43.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (73,139,'BAD','@Component\npublic class OrderAssembler {\n    public Map<String, Object> toResponse(Order order) {\n        // Map 반환 금지 - 타입 안정성 없음\n        return Map.of(\n            \"id\", order.getId(),\n            \"status\", order.getStatus()\n        );\n    }\n}','java','Map 반환 금지 - 구체적인 Response 클래스 사용',NULL,NULL,NULL,'2026-01-21 05:32:43.000000','2026-01-21 05:32:43.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (74,140,'GOOD','@Service\npublic class CreateOrderService implements CreateOrderUseCase {\n    @Override\n    public Long execute(CreateOrderCommand command) {\n        // 생성 결과는 원시타입 ID 반환\n        return orderCommandFacade.createOrder(command);\n    }\n}','java','생성 UseCase는 원시타입 ID(Long) 반환',NULL,NULL,NULL,'2026-01-21 05:32:43.000000','2026-01-21 05:32:43.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (75,140,'BAD','@Service\npublic class CreateOrderService implements CreateOrderUseCase {\n    @Override\n    public OrderResponse execute(CreateOrderCommand command) {\n        // 생성 시 Response 반환 불필요\n        Long id = orderCommandFacade.createOrder(command);\n        return orderQueryFacade.getOrder(id); // 불필요한 조회\n    }\n}','java','생성 후 Response 반환 불필요 - ID만 반환',NULL,NULL,NULL,'2026-01-21 05:32:43.000000','2026-01-21 05:32:43.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (76,141,'GOOD','public interface CreateOrderUseCase {\n    Long execute(CreateOrderCommand command);\n}\n\n@Service\npublic class CreateOrderService implements CreateOrderUseCase {\n    @Override\n    public Long execute(CreateOrderCommand command) {\n        return orderCommandFacade.createOrder(command);\n    }\n}','java','UseCase 인터페이스당 하나의 Service 구현체',NULL,NULL,NULL,'2026-01-21 05:33:00.000000','2026-01-21 05:33:00.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (77,141,'BAD','@Service\npublic class OrderService implements CreateOrderUseCase, UpdateOrderUseCase, DeleteOrderUseCase {\n    // 여러 UseCase를 하나의 Service에서 구현 금지\n    @Override\n    public Long execute(CreateOrderCommand command) { ... }\n    \n    @Override\n    public void execute(UpdateOrderCommand command) { ... }\n}','java','하나의 Service에서 여러 UseCase 구현 금지',NULL,NULL,NULL,'2026-01-21 05:33:00.000000','2026-01-21 05:33:00.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (78,142,'GOOD','// Command UseCase\npublic interface CreateOrderUseCase { }\npublic interface UpdateOrderStatusUseCase { }\npublic interface CancelOrderUseCase { }\n\n// Query UseCase\npublic interface GetOrderUseCase { }\npublic interface SearchOrdersUseCase { }\npublic interface ListOrdersByCustomerUseCase { }','java','Command: Create/Update/Delete/Cancel, Query: Get/Search/List',NULL,NULL,NULL,'2026-01-21 05:33:00.000000','2026-01-21 05:33:00.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (79,142,'BAD','public interface OrderCreationUseCase { }  // Create 동사형 사용\npublic interface FetchOrderUseCase { }      // Get 사용\npublic interface FindOrdersUseCase { }      // Search/List 사용','java','네이밍 규칙 위반 - 동사형 + 도메인 + UseCase',NULL,NULL,NULL,'2026-01-21 05:33:00.000000','2026-01-21 05:33:00.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (80,143,'GOOD','@Service\n@Transactional\npublic class OrderCommandManager {\n    public void cancel(Order order) {\n        if (!order.isCancellable()) {\n            throw new DomainException(\n                OrderErrorCode.CANNOT_CANCEL,\n                order.getId()\n            );\n        }\n        order.cancel();\n    }\n}','java','DomainException + 도메인별 ErrorCode 사용',NULL,NULL,NULL,'2026-01-21 05:33:00.000000','2026-01-21 05:33:00.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (81,143,'BAD','@Service\npublic class OrderCommandManager {\n    public void cancel(Order order) {\n        if (!order.isCancellable()) {\n            throw new IllegalStateException(\"Cannot cancel order\");\n            // 또는\n            throw new RuntimeException(\"Order cancellation failed\");\n        }\n    }\n}','java','범용 예외 사용 금지 - DomainException 사용',NULL,NULL,NULL,'2026-01-21 05:33:00.000000','2026-01-21 05:33:00.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (82,144,'GOOD','// Order 도메인의 ErrorCode\npublic enum OrderErrorCode implements ErrorCode {\n    NOT_FOUND(\"ORDER_001\", \"주문을 찾을 수 없습니다\"),\n    CANNOT_CANCEL(\"ORDER_002\", \"취소할 수 없는 주문입니다\");\n}\n\n// 사용\nthrow new DomainException(OrderErrorCode.NOT_FOUND, orderId);','java','도메인별 ErrorCode enum 정의 후 DomainException에 전달',NULL,NULL,NULL,'2026-01-21 05:33:00.000000','2026-01-21 05:33:00.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (83,144,'BAD','throw new DomainException(\"ORDER_001\", \"주문을 찾을 수 없습니다\");\n// 또는\nthrow new DomainException(\"Order not found: \" + orderId);','java','문자열 직접 전달 금지 - ErrorCode enum 사용',NULL,NULL,NULL,'2026-01-21 05:33:00.000000','2026-01-21 05:33:00.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (84,145,'GOOD','@Component\npublic class OrderCreatedEventListener {\n\n    @Async\n    @EventListener\n    public void handle(OrderCreatedEvent event) {\n        // 비동기 처리\n        notificationManager.sendOrderConfirmation(event.getOrderId());\n    }\n}','java','EventListener는 @Async로 비동기 처리 권장',NULL,NULL,NULL,'2026-01-21 05:40:00.000000','2026-01-21 05:40:00.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (85,145,'BAD','@Component\npublic class OrderCreatedEventListener {\n\n    @EventListener\n    public void handle(OrderCreatedEvent event) {\n        // 동기 처리 - 발행자 트랜잭션에 영향\n        notificationManager.sendOrderConfirmation(event.getOrderId());\n    }\n}','java','동기 처리 시 이벤트 발행자의 트랜잭션에 영향을 줄 수 있음',NULL,NULL,NULL,'2026-01-21 05:40:00.000000','2026-01-21 05:40:00.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (86,146,'GOOD','@Component\npublic class OrderCreatedEventListener {\n    private final NotificationCommandManager notificationManager;\n    \n    @Async\n    @EventListener\n    public void handle(OrderCreatedEvent event) {\n        notificationManager.sendOrderConfirmation(event.getOrderId());\n    }\n}','java','EventListener는 Manager에 의존',NULL,NULL,NULL,'2026-01-21 05:40:00.000000','2026-01-21 05:40:00.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (87,146,'BAD','@Component\npublic class OrderCreatedEventListener {\n    private final NotificationCommandPort notificationPort; // Port 직접 의존 금지\n    \n    @EventListener\n    public void handle(OrderCreatedEvent event) {\n        notificationPort.persist(notification);\n    }\n}','java','EventListener에서 Port 직접 의존 금지 - Manager 통해 접근',NULL,NULL,NULL,'2026-01-21 05:40:00.000000','2026-01-21 05:40:00.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (88,147,'BAD','public interface OrderJpaRepository extends JpaRepository<OrderJpaEntity, Long> {\n    List<OrderJpaEntity> findByCustomerId(Long customerId);\n    Optional<OrderJpaEntity> findByOrderNumber(String orderNumber);\n    void deleteByOrderId(Long orderId);\n}','java','JpaRepository에서 조회/삭제 메서드를 정의하면 CQRS 원칙을 위반합니다.',NULL,NULL,NULL,'2026-01-21 07:49:46.000000','2026-01-21 07:49:46.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (89,147,'GOOD','public interface OrderJpaRepository extends JpaRepository<OrderJpaEntity, Long> {\n    // save, saveAll만 사용 - JpaRepository 기본 제공 메서드만 활용\n    // 조회는 QueryDslRepository에서, 삭제는 soft delete로\n}','java','JpaRepository는 저장만 담당하고, 조회는 QueryDslRepository로 분리합니다.',NULL,NULL,NULL,'2026-01-21 07:49:46.000000','2026-01-21 07:49:46.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (90,148,'BAD','@Repository\npublic interface UserJpaRepository extends JpaRepository<UserJpaEntity, Long> {\n    \n    @Query(\"SELECT u FROM UserJpaEntity u WHERE u.email = :email\")\n    Optional<UserJpaEntity> findByEmail(@Param(\"email\") String email);\n    \n    boolean existsByEmail(String email);\n    \n    @Modifying\n    @Query(\"DELETE FROM UserJpaEntity u WHERE u.id = :id\")\n    void deleteById(@Param(\"id\") Long id);\n}','java','@Query, 쿼리 메서드 정의 등 커스텀 메서드를 추가하면 안됩니다.',NULL,NULL,NULL,'2026-01-21 07:49:46.000000','2026-01-21 07:49:46.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (91,148,'GOOD','@Repository\npublic interface UserJpaRepository extends JpaRepository<UserJpaEntity, Long> {\n    // 커스텀 메서드 추가 금지\n    // JpaRepository 기본 제공: save, saveAll, findById, existsById 등만 사용\n}\n\n// 모든 조회 로직은 QueryDslRepository에서\n@Repository\npublic class UserQueryDslRepository {\n    public Optional<UserJpaEntity> findByEmail(String email) { ... }\n    public boolean existsByEmail(String email) { ... }\n}','java','커스텀 조회 로직은 QueryDslRepository로 일원화합니다.',NULL,NULL,NULL,'2026-01-21 07:49:46.000000','2026-01-21 07:49:46.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (92,149,'BAD','@Query(\"SELECT o FROM OrderJpaEntity o WHERE o.status = :status\")\nList<OrderJpaEntity> findByStatus(@Param(\"status\") String status);\n\n@Query(value = \"SELECT * FROM orders WHERE created_at > :date\", nativeQuery = true)\nList<OrderJpaEntity> findRecentOrders(@Param(\"date\") LocalDateTime date);','java','JPQL이나 Native Query 대신 QueryDSL을 사용합니다.',NULL,NULL,NULL,'2026-01-21 07:49:46.000000','2026-01-21 07:49:46.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (93,149,'GOOD','@Repository\npublic class OrderQueryDslRepository {\n    private final JPAQueryFactory queryFactory;\n    \n    public OrderQueryDslRepository(JPAQueryFactory queryFactory) {\n        this.queryFactory = queryFactory;\n    }\n    \n    public List<OrderJpaEntity> findByStatus(OrderStatus status) {\n        return queryFactory\n            .selectFrom(orderJpaEntity)\n            .where(OrderConditionBuilder.statusEq(status))\n            .fetch();\n    }\n    \n    public List<OrderJpaEntity> findRecentOrders(Instant fromDate) {\n        return queryFactory\n            .selectFrom(orderJpaEntity)\n            .where(orderJpaEntity.createdAt.after(fromDate))\n            .fetch();\n    }\n}','java','QueryDSL로 타입 안전한 쿼리를 작성합니다.',NULL,NULL,NULL,'2026-01-21 07:49:46.000000','2026-01-21 14:55:26.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (94,150,'BAD','@Component\npublic class OrderCommandAdapter implements OrderCommandPort {\n    private final OrderJpaRepository jpaRepository;\n    private final OrderQueryDslRepository queryDslRepository; // 금지!\n    \n    @Override\n    public Long persist(Order order) {\n        // QueryDslRepository 사용 금지!\n        if (queryDslRepository.existsByOrderNumber(order.getNumber())) {\n            throw new DomainException(...);\n        }\n        return jpaRepository.save(mapper.toEntity(order)).getId();\n    }\n}','java','CommandAdapter에서 QueryDslRepository를 의존하면 CQRS 원칙을 위반합니다.',NULL,NULL,NULL,'2026-01-21 07:50:06.000000','2026-01-21 07:50:06.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (95,150,'GOOD','@Component\npublic class OrderCommandAdapter implements OrderCommandPort {\n    private final OrderJpaRepository jpaRepository;\n    private final OrderEntityMapper mapper;\n    \n    @Override\n    public Long persist(Order order) {\n        OrderJpaEntity entity = mapper.toEntity(order);\n        return jpaRepository.save(entity).getId();\n    }\n}','java','CommandAdapter는 JpaRepository만 의존하여 저장 로직만 수행합니다.',NULL,NULL,NULL,'2026-01-21 07:50:06.000000','2026-01-21 07:50:06.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (96,151,'BAD','@Component\npublic class OrderQueryAdapter implements OrderQueryPort {\n    private final OrderJpaRepository jpaRepository; // 금지!\n    private final OrderQueryDslRepository queryDslRepository;\n    \n    @Override\n    public Optional<Order> findById(OrderId id) {\n        return jpaRepository.findById(id.value()) // JpaRepository 사용 금지!\n            .map(mapper::toDomain);\n    }\n}','java','QueryAdapter에서 JpaRepository를 의존하면 CQRS 원칙을 위반합니다.',NULL,NULL,NULL,'2026-01-21 07:50:06.000000','2026-01-21 07:50:06.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (97,151,'GOOD','@Component\npublic class OrderQueryAdapter implements OrderQueryPort {\n    private final OrderQueryDslRepository queryDslRepository;\n    private final OrderEntityMapper mapper;\n    \n    @Override\n    public Optional<Order> findById(OrderId id) {\n        return queryDslRepository.findById(id.value())\n            .map(mapper::toDomain);\n    }\n    \n    @Override\n    public List<Order> findByCustomerId(CustomerId customerId) {\n        return queryDslRepository.findByCustomerId(customerId.value())\n            .stream()\n            .map(mapper::toDomain)\n            .toList();\n    }\n}','java','QueryAdapter는 QueryDslRepository만 의존하여 조회 로직만 수행합니다.',NULL,NULL,NULL,'2026-01-21 07:50:06.000000','2026-01-21 07:50:06.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (98,152,'BAD','@Entity\n@Table(name = \"orders\")\npublic class OrderJpaEntity {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = \"customer_id\")\n    private CustomerJpaEntity customer; // 관계 어노테이션 금지!\n    \n    @OneToMany(mappedBy = \"order\", cascade = CascadeType.ALL)\n    private List<OrderLineJpaEntity> orderLines; // 관계 어노테이션 금지!\n}','java','JPA 관계 어노테이션은 N+1 문제와 도메인 결합을 유발합니다.',NULL,NULL,NULL,'2026-01-21 07:50:06.000000','2026-01-21 07:50:06.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (99,152,'GOOD','@Entity\n@Table(name = \"orders\")\npublic class OrderJpaEntity extends SoftDeletableEntity {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    @Column(name = \"customer_id\", nullable = false)\n    private Long customerId;  // Long FK 전략\n    \n    // OrderLine은 별도 Repository에서 customerId로 조회\n    // 필요시 QueryDSL join으로 명시적 조회\n}','java','Long FK 전략으로 관계를 관리하고, 필요시 QueryDSL join을 사용합니다.',NULL,NULL,NULL,'2026-01-21 07:50:06.000000','2026-01-21 07:50:06.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (100,153,'BAD','@Entity\n@Table(name = \"orders\")\npublic class OrderJpaEntity {\n    @Id\n    private Long id;\n    \n    @Column(name = \"created_at\")\n    private Instant createdAt; // 직접 정의 금지\n    \n    @Column(name = \"updated_at\")\n    private Instant updatedAt; // 직접 정의 금지\n}','java','Audit 필드를 직접 정의하면 코드 중복과 불일치가 발생합니다.',NULL,NULL,NULL,'2026-01-21 07:50:06.000000','2026-01-21 07:50:06.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (101,153,'GOOD','@Entity\n@Table(name = \"orders\")\npublic class OrderJpaEntity extends SoftDeletableEntity {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    @Column(name = \"customer_id\", nullable = false)\n    private Long customerId;\n    \n    // createdAt, updatedAt, deletedAt은 SoftDeletableEntity에서 상속\n}','java','BaseAuditEntity나 SoftDeletableEntity를 상속하여 Audit 필드를 표준화합니다.',NULL,NULL,NULL,'2026-01-21 07:50:06.000000','2026-01-21 07:50:06.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (102,154,'BAD','spring:\n  jpa:\n    open-in-view: true  # 기본값이지만 명시적 활성화도 금지','yaml','OSIV 활성화는 커넥션 점유 시간을 늘리고 예측 불가능한 지연 로딩을 유발합니다.',NULL,NULL,NULL,'2026-01-21 07:50:28.000000','2026-01-21 07:50:28.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (103,154,'GOOD','spring:\n  jpa:\n    open-in-view: false\n    \n# Lazy Loading은 반드시 @Transactional 범위 내에서만 수행\n# View 렌더링 시점의 지연 로딩은 LazyInitializationException 발생','yaml','OSIV를 비활성화하여 트랜잭션 범위를 명확히 합니다.',NULL,NULL,NULL,'2026-01-21 07:50:28.000000','2026-01-21 07:50:28.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (104,155,'BAD','spring:\n  jpa:\n    hibernate:\n      ddl-auto: update  # 운영 장애 원인!\n      # 또는 create, create-drop','yaml','ddl-auto가 update/create면 운영 환경에서 예기치 않은 스키마 변경이 발생합니다.',NULL,NULL,NULL,'2026-01-21 07:50:28.000000','2026-01-21 07:50:28.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (105,155,'GOOD','spring:\n  jpa:\n    hibernate:\n      ddl-auto: validate  # 스키마 검증만\n      \n  flyway:\n    enabled: true\n    locations: classpath:db/migration\n    baseline-on-migrate: true','yaml','Hibernate는 검증만, 스키마 변경은 Flyway로 관리합니다.',NULL,NULL,NULL,'2026-01-21 07:50:28.000000','2026-01-21 07:50:28.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (106,156,'BAD','@Repository\npublic class OrderQueryDslRepository {\n    \n    // Repository 내부에 조건 메서드 정의 - 금지!\n    private BooleanExpression statusEq(OrderStatus status) {\n        return status != null ? order.status.eq(status) : null;\n    }\n    \n    private BooleanExpression customerIdEq(Long customerId) {\n        return customerId != null ? order.customerId.eq(customerId) : null;\n    }\n    \n    public List<OrderJpaEntity> findByCondition(OrderStatus status, Long customerId) {\n        return queryFactory.selectFrom(order)\n            .where(statusEq(status), customerIdEq(customerId))\n            .fetch();\n    }\n}','java','Repository 내부에 조건 메서드를 정의하면 재사용이 어렵고 코드가 비대해집니다.',NULL,NULL,NULL,'2026-01-21 07:50:28.000000','2026-01-21 07:50:28.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (107,156,'GOOD','// ConditionBuilder로 분리\npublic class OrderConditionBuilder {\n    private static final QOrderJpaEntity order = QOrderJpaEntity.orderJpaEntity;\n    \n    public static BooleanExpression notDeleted() {\n        return order.deletedAt.isNull();\n    }\n    \n    public static BooleanExpression statusEq(OrderStatus status) {\n        return status != null ? order.status.eq(status) : null;\n    }\n    \n    public static BooleanExpression customerIdEq(Long customerId) {\n        return customerId != null ? order.customerId.eq(customerId) : null;\n    }\n}\n\n// Repository에서 사용\npublic List<OrderJpaEntity> findByCondition(OrderStatus status, Long customerId) {\n    return queryFactory.selectFrom(order)\n        .where(\n            OrderConditionBuilder.notDeleted(),\n            OrderConditionBuilder.statusEq(status),\n            OrderConditionBuilder.customerIdEq(customerId)\n        )\n        .fetch();\n}','java','ConditionBuilder로 분리하여 조건 로직을 재사용하고 가독성을 높입니다.',NULL,NULL,NULL,'2026-01-21 07:50:28.000000','2026-01-21 07:50:28.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (108,157,'BAD','public List<OrderJpaEntity> findByCustomerId(Long customerId) {\n    return queryFactory\n        .selectFrom(order)\n        .where(order.customerId.eq(customerId))\n        .fetch();  // deletedAt 조건 누락 - 삭제된 데이터도 조회됨!\n}','java','deletedAt 조건이 누락되면 soft delete된 데이터가 조회됩니다.',NULL,NULL,NULL,'2026-01-21 07:50:28.000000','2026-01-21 07:50:28.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (109,157,'GOOD','public List<OrderJpaEntity> findByCustomerId(Long customerId) {\n    return queryFactory\n        .selectFrom(order)\n        .where(\n            OrderConditionBuilder.notDeleted(),  // deletedAt IS NULL 필수!\n            OrderConditionBuilder.customerIdEq(customerId)\n        )\n        .fetch();\n}','java','Soft Delete 테이블은 반드시 notDeleted() 조건을 포함합니다.',NULL,NULL,NULL,'2026-01-21 07:50:28.000000','2026-01-21 07:50:28.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (110,158,'BAD','@Component\npublic class OrderEntityMapper {\n    \n    public Order toDomain(OrderJpaEntity entity) {\n        return Order.reconstitute(\n            new OrderId(entity.getId()),\n            new CustomerId(entity.getCustomerId()),\n            OrderStatus.valueOf(entity.getStatus())\n        );\n    }\n    \n    // toEntity 메서드 누락!\n}','java','단방향 매핑만 있으면 저장 시 변환이 불가능합니다.',NULL,NULL,NULL,'2026-01-21 07:50:44.000000','2026-01-21 07:50:44.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (111,158,'GOOD','@Component\npublic class OrderEntityMapper {\n    \n    public Order toDomain(OrderJpaEntity entity) {\n        return Order.reconstitute(\n            new OrderId(entity.getId()),\n            new CustomerId(entity.getCustomerId()),\n            OrderStatus.valueOf(entity.getStatus()),\n            entity.getCreatedAt()\n        );\n    }\n    \n    public OrderJpaEntity toEntity(Order domain) {\n        OrderJpaEntity entity = new OrderJpaEntity();\n        if (domain.getId() != null) {\n            entity.setId(domain.getId().value());\n        }\n        entity.setCustomerId(domain.getCustomerId().value());\n        entity.setStatus(domain.getStatus().name());\n        return entity;\n    }\n}','java','양방향 변환 메서드를 모두 제공하여 Command/Query 모두 지원합니다.',NULL,NULL,NULL,'2026-01-21 07:50:44.000000','2026-01-21 07:50:44.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (112,159,'BAD','// Native Query로 FullText 검색 - 금지!\n@Query(value = \"SELECT * FROM products WHERE MATCH(name, description) AGAINST(:keyword IN BOOLEAN MODE)\", nativeQuery = true)\nList<ProductJpaEntity> fullTextSearch(@Param(\"keyword\") String keyword);','java','Native Query는 타입 안전성이 없고 QueryDSL과 통합되지 않습니다.',NULL,NULL,NULL,'2026-01-21 07:50:44.000000','2026-01-21 07:50:44.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (113,159,'GOOD','// 1. FunctionContributor 구현\npublic class MatchAgainstFunctionContributor implements FunctionContributor {\n    @Override\n    public void contributeFunctions(FunctionContributions contributions) {\n        contributions.getFunctionRegistry().registerPattern(\n            \"match_against\",\n            \"MATCH(?1) AGAINST(?2 IN BOOLEAN MODE)\",\n            contributions.getTypeConfiguration()\n                .getBasicTypeForJavaType(Double.class)\n        );\n    }\n}\n\n// 2. META-INF/services/org.hibernate.boot.model.FunctionContributor 파일 생성\n// 내용: com.example.persistence.common.function.MatchAgainstFunctionContributor\n\n// 3. QueryDSL에서 사용\npublic List<ProductJpaEntity> fullTextSearch(String keyword) {\n    NumberExpression<Double> score = Expressions.numberTemplate(\n        Double.class,\n        \"match_against({0}, {1})\",\n        product.name,\n        keyword\n    );\n    \n    return queryFactory\n        .selectFrom(product)\n        .where(score.gt(0))\n        .orderBy(score.desc())\n        .fetch();\n}','java','FunctionContributor를 등록하여 QueryDSL에서 타입 안전하게 FullText 검색을 사용합니다.',NULL,NULL,NULL,'2026-01-21 07:50:44.000000','2026-01-21 07:50:44.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (114,160,'BAD','// persistence-mysql 모듈에서 조인 사용 - 금지!\n@Repository\npublic class OrderQueryDslRepository {\n    \n    public List<OrderWithCustomerDto> findOrdersWithCustomer(Long customerId) {\n        return queryFactory\n            .select(Projections.constructor(OrderWithCustomerDto.class,\n                order.id,\n                customer.name  // 조인!\n            ))\n            .from(order)\n            .leftJoin(customer).on(order.customerId.eq(customer.id))  // 금지!\n            .fetch();\n    }\n}','java','도메인용 persistence-mysql에서 조인을 사용하면 안됩니다.',NULL,NULL,NULL,'2026-01-21 07:59:31.000000','2026-01-21 07:59:31.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (115,160,'GOOD','// persistence-mysql-admin 모듈에서 조인 사용 - 허용\n@Repository\npublic class OrderAdminQueryDslRepository {\n    \n    public List<OrderWithCustomerDto> findOrdersWithCustomer(Long customerId) {\n        return queryFactory\n            .select(Projections.constructor(OrderWithCustomerDto.class,\n                order.id,\n                order.orderNumber,\n                customer.name,\n                customer.email\n            ))\n            .from(order)\n            .leftJoin(customer).on(order.customerId.eq(customer.id))  // Admin 모듈에서 허용\n            .where(order.customerId.eq(customerId))\n            .fetch();\n    }\n}','java','Admin 모듈에서는 조인이 허용됩니다.',NULL,NULL,NULL,'2026-01-21 07:59:31.000000','2026-01-21 07:59:31.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (116,161,'GOOD','@Repository\npublic class OrderAdminQueryDslRepository {\n    \n    // leftJoin 허용\n    public List<OrderSummaryDto> findOrderSummary() {\n        return queryFactory\n            .select(Projections.constructor(OrderSummaryDto.class,\n                order.id,\n                order.totalAmount,\n                customer.name,\n                orderLine.count()\n            ))\n            .from(order)\n            .leftJoin(customer).on(order.customerId.eq(customer.id))\n            .leftJoin(orderLine).on(orderLine.orderId.eq(order.id))\n            .groupBy(order.id, customer.name)\n            .fetch();\n    }\n    \n    // innerJoin 허용\n    public List<ActiveOrderDto> findActiveOrdersWithPayment() {\n        return queryFactory\n            .select(Projections.constructor(ActiveOrderDto.class,\n                order.id,\n                payment.status\n            ))\n            .from(order)\n            .innerJoin(payment).on(payment.orderId.eq(order.id))\n            .where(order.status.eq(OrderStatus.ACTIVE))\n            .fetch();\n    }\n}','java','Admin 모듈에서는 다양한 조인 타입이 허용됩니다.',NULL,NULL,NULL,'2026-01-21 07:59:31.000000','2026-01-21 07:59:31.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (123,165,'GOOD','@Tag(name = \"Convention\", description = \"코딩 컨벤션 관리 API\")\n@RestController\n@RequestMapping(ConventionApiEndpoints.CONVENTIONS)\npublic class ConventionCommandController {\n    private final CreateConventionUseCase createConventionUseCase;\n    // ...\n}','java','Controller는 @RestController로 선언, @Tag로 OpenAPI 문서화',NULL,'ConventionCommandController.java',NULL,'2026-01-21 14:19:44.000000','2026-01-21 14:19:44.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (124,165,'BAD','@Controller\n@RequestMapping(\"/api/v1/conventions\")\npublic class ConventionController {\n    // @RestController 대신 @Controller 사용 - 금지\n}','java','@Controller 사용 금지 - @RestController 필수',NULL,NULL,NULL,'2026-01-21 14:19:44.000000','2026-01-21 14:19:44.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (125,166,'GOOD','@PatchMapping(ConventionApiEndpoints.ID_DELETE)\npublic ResponseEntity<ApiResponse<Void>> delete(\n        @Parameter(description = \"Convention ID\", required = true)\n        @PathVariable(ConventionApiEndpoints.PATH_CONVENTION_ID) Long conventionId) {\n    deleteConventionUseCase.execute(conventionId);\n    return ResponseEntity.ok(ApiResponse.of());\n}','java','Soft Delete는 PATCH 메서드 사용 - /resource/{id}/delete 경로',NULL,'ConventionCommandController.java',NULL,'2026-01-21 14:19:53.000000','2026-01-21 14:19:53.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (126,166,'BAD','@DeleteMapping(\"/{conventionId}\")\npublic ResponseEntity<Void> delete(@PathVariable Long conventionId) {\n    // DELETE 메서드 금지 - PATCH 사용 필수\n    deleteConventionUseCase.execute(conventionId);\n    return ResponseEntity.noContent().build();\n}','java','DELETE 메서드 사용 금지 - PATCH /delete 패턴 사용',NULL,NULL,NULL,'2026-01-21 14:19:53.000000','2026-01-21 14:19:53.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (127,167,'GOOD','public class ConventionCommandController {\n    private final CreateConventionUseCase createConventionUseCase;\n    private final UpdateConventionUseCase updateConventionUseCase;\n    private final DeleteConventionUseCase deleteConventionUseCase;\n    private final ConventionCommandApiMapper mapper;\n    \n    public ConventionCommandController(\n            CreateConventionUseCase createConventionUseCase,\n            UpdateConventionUseCase updateConventionUseCase,\n            DeleteConventionUseCase deleteConventionUseCase,\n            ConventionCommandApiMapper mapper) {\n        // UseCase 인터페이스만 주입\n    }\n}','java','Controller는 UseCase(Port-In) 인터페이스만 의존 - 구현체 직접 의존 금지',NULL,'ConventionCommandController.java',NULL,'2026-01-21 14:20:05.000000','2026-01-21 14:20:05.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (128,167,'BAD','public class ConventionCommandController {\n    private final ConventionCommandManager manager;  // 금지: Service/Manager 직접 의존\n    private final ConventionRepository repository;   // 금지: Repository 직접 의존\n    \n    public ConventionCommandController(\n            ConventionCommandManager manager,\n            ConventionRepository repository) {\n        // UseCase 인터페이스가 아닌 구현체 직접 의존 - 금지\n    }\n}','java','Service/Manager/Repository 직접 의존 금지 - UseCase 인터페이스만 사용',NULL,NULL,NULL,'2026-01-21 14:20:05.000000','2026-01-21 14:20:05.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (129,168,'GOOD','@PostMapping\npublic ResponseEntity<ApiResponse<ConventionIdApiResponse>> create(\n        @Valid @RequestBody CreateConventionApiRequest request) {\n    CreateConventionCommand command = mapper.toCommand(request);\n    Long id = createConventionUseCase.execute(command);\n    ConventionIdApiResponse response = ConventionIdApiResponse.of(id);\n    return ResponseEntity.status(HttpStatus.CREATED).body(ApiResponse.of(response));\n}','java','ResponseEntity<ApiResponse<T>> 형식 필수 - 일관된 응답 포맷',NULL,'ConventionCommandController.java',NULL,'2026-01-21 14:20:15.000000','2026-01-21 14:20:15.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (130,168,'BAD','@PostMapping\npublic ConventionIdApiResponse create(@RequestBody CreateConventionApiRequest request) {\n    // ResponseEntity 누락 - HTTP 상태 코드 제어 불가\n    // ApiResponse 래핑 누락 - 응답 포맷 불일치\n    Long id = createConventionUseCase.execute(mapper.toCommand(request));\n    return ConventionIdApiResponse.of(id);\n}','java','ResponseEntity와 ApiResponse 래핑 필수 - 직접 DTO 반환 금지',NULL,NULL,NULL,'2026-01-21 14:20:15.000000','2026-01-21 14:20:15.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (131,169,'GOOD','@RestController\n@RequestMapping(ConventionApiEndpoints.CONVENTIONS)\npublic class ConventionCommandController {\n    private final CreateConventionUseCase createConventionUseCase;\n    \n    public ConventionCommandController(CreateConventionUseCase createConventionUseCase) {\n        this.createConventionUseCase = createConventionUseCase;\n    }\n    \n    // @Transactional 없음 - Controller는 트랜잭션 관리 금지\n    // 트랜잭션은 Application Layer(Manager)에서 관리\n    @PostMapping\n    public ResponseEntity<ApiResponse<ConventionIdApiResponse>> create(\n            @Valid @RequestBody CreateConventionApiRequest request) {\n        CreateConventionCommand command = mapper.toCommand(request);\n        Long conventionId = createConventionUseCase.execute(command);\n        ConventionIdApiResponse response = new ConventionIdApiResponse(conventionId);\n        return ResponseEntity.status(HttpStatus.CREATED).body(ApiResponse.of(response));\n    }\n}','java','Controller에 @Transactional 선언 금지 - 트랜잭션은 Manager에서 관리',NULL,'ConventionCommandController.java',NULL,'2026-01-21 14:20:25.000000','2026-01-21 14:59:10.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (132,169,'BAD','@RestController\n@Transactional  // 금지: Controller에 @Transactional\npublic class ConventionController {\n    @PostMapping\n    @Transactional(readOnly = true)  // 금지: 메서드에도 @Transactional 선언 금지\n    public ResponseEntity<ApiResponse<ConventionResponse>> create(...) {\n        // ...\n    }\n}','java','Controller에 @Transactional 선언 금지 - 트랜잭션 경계는 Application Layer',NULL,NULL,NULL,'2026-01-21 14:20:25.000000','2026-01-21 14:20:25.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (133,177,'GOOD','public record CreateConventionApiRequest(\n    @NotNull @Schema(description = \"모듈 ID\") Long moduleId,\n    @NotBlank @Schema(description = \"버전\") String version,\n    @Schema(description = \"설명\") String description\n) {}','java','API Request/Response DTO는 반드시 record로 정의 - 불변성 보장',NULL,'CreateConventionApiRequest.java',NULL,'2026-01-21 14:20:34.000000','2026-01-21 14:20:34.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (134,177,'BAD','public class CreateConventionApiRequest {\n    private Long moduleId;\n    private String version;\n    \n    // Getter/Setter - 금지\n    public Long getModuleId() { return moduleId; }\n    public void setModuleId(Long moduleId) { this.moduleId = moduleId; }\n}','java','class 타입 금지 - record 필수 사용',NULL,NULL,NULL,'2026-01-21 14:20:34.000000','2026-01-21 14:20:34.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (135,175,'GOOD','@GetMapping\npublic ResponseEntity<ApiResponse<SliceApiResponse<ConventionApiResponse>>> getAll(\n        @Valid GetAllConventionsApiRequest request) {\n    GetAllConventionsQuery query = mapper.toQuery(request);\n    ConventionSliceResult sliceResult = getAllConventionsUseCase.execute(query);\n    SliceApiResponse<ConventionApiResponse> response = mapper.toSliceResponse(sliceResult);\n    return ResponseEntity.ok(ApiResponse.of(response));\n}','java','List 반환 시 SliceApiResponse로 래핑 - hasNext, cursor 등 페이징 정보 포함',NULL,'ConventionQueryController.java',NULL,'2026-01-21 14:20:44.000000','2026-01-21 14:20:44.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (136,175,'BAD','@GetMapping\npublic ResponseEntity<ApiResponse<List<ConventionApiResponse>>> getAll() {\n    // List 직접 반환 금지 - 페이징 정보 누락\n    List<Convention> conventions = conventionRepository.findAll();\n    return ResponseEntity.ok(ApiResponse.of(conventions));\n}','java','List 직접 반환 금지 - SliceApiResponse 필수 사용',NULL,NULL,NULL,'2026-01-21 14:20:44.000000','2026-01-21 14:20:44.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (137,192,'GOOD','@Component\npublic class ConventionErrorMapper implements ErrorMapper {\n    \n    @Override\n    public boolean supports(DomainException ex) {\n        return ex instanceof ConventionNotFoundException\n                || ex instanceof ConventionDuplicateException;\n    }\n\n    @Override\n    public MappedError map(DomainException ex, Locale locale) {\n        return switch (ex) {\n            case ConventionNotFoundException e ->\n                new MappedError(HttpStatus.NOT_FOUND, \"Convention Not Found\", \n                    e.getMessage(), URI.create(\"/errors/convention/not-found\"));\n            // ...\n        };\n    }\n}','java','ErrorMapper 인터페이스 구현 - supports()로 지원 예외 판단, map()으로 MappedError 변환',NULL,'ConventionErrorMapper.java',NULL,'2026-01-21 14:20:59.000000','2026-01-21 14:20:59.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (138,192,'BAD','@ControllerAdvice\npublic class GlobalExceptionHandler {\n    @ExceptionHandler(ConventionNotFoundException.class)\n    public ResponseEntity<ErrorResponse> handleNotFound(ConventionNotFoundException ex) {\n        // 도메인별 ErrorMapper 분리 필요 - GlobalExceptionHandler에 직접 처리 금지\n        return ResponseEntity.status(404).body(new ErrorResponse(ex.getMessage()));\n    }\n}','java','GlobalExceptionHandler에 도메인별 예외 직접 처리 금지 - ErrorMapper로 분리',NULL,NULL,NULL,'2026-01-21 14:20:59.000000','2026-01-21 14:20:59.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (139,201,'GOOD','public final class ConventionApiEndpoints {\n\n    private ConventionApiEndpoints() {\n        // Utility class - prevent instantiation\n    }\n\n    public static final String CONVENTIONS = ApiPaths.SERVICE_BASE + \"/conventions\";\n    public static final String ID = \"/{conventionId}\";\n    public static final String ID_DELETE = \"/{conventionId}/delete\";\n    \n    public static final String PATH_CONVENTION_ID = \"conventionId\";\n}','java','Endpoints 클래스는 final class로 선언, private 생성자로 인스턴스화 방지',NULL,'ConventionApiEndpoints.java',NULL,'2026-01-21 14:21:14.000000','2026-01-21 14:21:14.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (140,201,'BAD','public class ConventionApiEndpoints {\n    // final 누락 - 상속 가능\n    // private 생성자 누락 - 인스턴스화 가능\n    \n    public String conventions = \"/conventions\";  // static final 아님 - 금지\n}','java','final class 필수, private 생성자 필수, static final 상수 필수',NULL,NULL,NULL,'2026-01-21 14:21:14.000000','2026-01-21 14:21:14.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (141,173,'GOOD','@PostMapping\npublic ResponseEntity<ApiResponse<ConventionIdApiResponse>> create(\n        @Valid @RequestBody CreateConventionApiRequest request) {\n    // @Valid로 Request DTO 검증 필수\n    CreateConventionCommand command = mapper.toCommand(request);\n    Long id = createConventionUseCase.execute(command);\n    return ResponseEntity.status(HttpStatus.CREATED).body(ApiResponse.of(response));\n}','java','@Valid 어노테이션으로 Request DTO Bean Validation 자동 적용',NULL,'ConventionCommandController.java',NULL,'2026-01-21 14:21:24.000000','2026-01-21 14:21:24.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (142,173,'BAD','@PostMapping\npublic ResponseEntity<ApiResponse<ConventionIdApiResponse>> create(\n        @RequestBody CreateConventionApiRequest request) {\n    // @Valid 누락 - 검증 수행 안됨\n    // 유효하지 않은 데이터가 Application Layer로 전달될 수 있음\n    return ResponseEntity.ok(ApiResponse.of(response));\n}','java','@Valid 누락 시 Bean Validation 미적용 - 유효성 검사 우회됨',NULL,NULL,NULL,'2026-01-21 14:21:24.000000','2026-01-21 14:21:24.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (143,210,'GOOD','public interface OrderQueryPort {\n    \n    // ✅ Domain VO 사용 - 타입 안전성 보장\n    Optional<Order> findById(OrderId orderId);\n    \n    // ✅ Domain VO 사용 - 비즈니스 의도 명확\n    boolean existsByCustomerId(CustomerId customerId);\n    \n    // ✅ 복합 VO 파라미터\n    List<Order> findByCustomerIdAndStatus(CustomerId customerId, OrderStatus status);\n    \n    // ⚠️ nullable 파라미터는 원시타입 허용 (예외)\n    List<Order> search(@Nullable Long customerId, \n                       @Nullable OrderStatus status, \n                       SearchParams params);\n}','java','Port 인터페이스에서 Domain VO를 사용하면 타입 안전성이 보장되고, 파라미터의 비즈니스 의미가 명확해집니다. 다만 검색 조건 등에서 null 허용이 필요한 파라미터는 예외적으로 원시타입 사용이 가능합니다.','[4, 7, 10]',NULL,NULL,'2026-01-22 00:42:46.000000','2026-01-22 00:42:46.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (144,210,'BAD','public interface OrderQueryPort {\n    \n    // ❌ 원시타입 사용 - 타입 혼동 위험\n    Optional<Order> findById(Long id);\n    \n    // ❌ 원시타입 사용 - 비즈니스 의도 불명확\n    boolean exists(Long customerId);\n    \n    // ❌ 모든 파라미터가 원시타입\n    List<Order> findByCustomerIdAndStatus(Long customerId, String status);\n    \n    // ❌ 필수 파라미터도 원시타입 사용\n    Order getByIdAndVersion(Long orderId, Long version);\n}','java','원시타입을 사용하면 Long customerId와 Long orderId를 혼동할 위험이 있고, 파라미터의 비즈니스 의미를 알기 어렵습니다. 또한 VO 생성 시 수행되는 유효성 검증 이점을 활용할 수 없습니다.','[4, 7, 10, 13]',NULL,NULL,'2026-01-22 00:42:46.000000','2026-01-22 00:42:46.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (145,216,'GOOD','// CommandFactory\npublic UpdateContext<TechStackId, TechStackUpdateData> createUpdateContext(\n        UpdateTechStackCommand command) {\n    TechStackId id = TechStackId.of(command.id());\n    TechStackUpdateData updateData = createUpdateData(command);\n    Instant changedAt = timeProvider.now();  // C-006: Factory에서 시간 생성\n    return new UpdateContext<>(id, updateData, changedAt);\n}\n\n// Service\n@Override\npublic void execute(UpdateTechStackCommand command) {\n    UpdateContext<TechStackId, TechStackUpdateData> context =\n            techStackCommandFactory.createUpdateContext(command);\n    \n    techStackValidator.validateNameNotDuplicateExcluding(\n        TechStackName.of(command.name()), context.id());\n    \n    TechStack techStack = techStackValidator.findExistingOrThrow(context.id());\n    techStack.update(context.updateData(), context.changedAt());\n    techStackPersistenceManager.persist(techStack);\n}','java','Factory의 createUpdateContext()로 ID, UpdateData, changedAt을 한 번에 생성합니다. Service는 UpdateContext에서 필요한 값을 꺼내 사용합니다.',NULL,NULL,NULL,'2026-01-22 03:17:27.000000','2026-01-22 03:17:27.000000',NULL);
INSERT INTO `rule_example` (`id`, `rule_id`, `example_type`, `code`, `language`, `explanation`, `highlight_lines`, `source`, `feedback_id`, `created_at`, `updated_at`, `deleted_at`) VALUES (146,216,'BAD','// ❌ BAD: Factory를 여러 번 호출\n@Override\npublic void execute(UpdateTechStackCommand command) {\n    // Factory 여러 번 호출\n    TechStackId id = techStackCommandFactory.createId(command.id());\n    TechStackUpdateData updateData = techStackCommandFactory.createUpdateData(command);\n    Instant changedAt = techStackCommandFactory.now();  // 시간도 따로 호출\n    \n    techStackValidator.validateNameNotDuplicateExcluding(updateData.name(), id);\n    \n    TechStack techStack = techStackValidator.findExistingOrThrow(id);\n    techStack.update(updateData, changedAt);\n    techStackPersistenceManager.persist(techStack);\n}\n\n// ❌ BAD: Service에서 직접 TimeProvider 사용 (C-006 위반)\n@Override\npublic void execute(UpdateTechStackCommand command) {\n    UpdateContext<TechStackId, TechStackUpdateData> context =\n            techStackCommandFactory.createUpdateContext(command);\n    \n    // C-006 위반: Service에서 직접 시간 생성\n    Instant changedAt = timeProvider.now();\n    \n    TechStack techStack = techStackValidator.findExistingOrThrow(context.id());\n    techStack.update(context.updateData(), changedAt);\n    techStackPersistenceManager.persist(techStack);\n}','java','Factory를 여러 번 호출하거나, Service에서 직접 TimeProvider를 사용하면 안 됩니다. createUpdateContext()로 한 번에 생성하고, context.changedAt()을 사용합니다.',NULL,NULL,NULL,'2026-01-22 03:17:38.000000','2026-01-22 03:17:38.000000',NULL);

INSERT INTO `tech_stack` (`id`, `name`, `status`, `language_type`, `language_version`, `language_features`, `framework_type`, `framework_version`, `framework_modules`, `platform_type`, `runtime_environment`, `build_tool_type`, `build_config_file`, `reference_links`, `created_at`, `updated_at`, `deleted_at`) VALUES (1,'java21-springboot35-backend','ACTIVE','JAVA','21','[\"VIRTUAL_THREAD\", \"RECORD\", \"SEALED_CLASS\", \"PATTERN_MATCHING\", \"SEQUENCED_COLLECTION\"]','SPRING_BOOT','3.5.x','[\"WEB\", \"JPA\", \"VALIDATION\", \"SECURITY\", \"ACTUATOR\"]','BACKEND','JVM','GRADLE','build.gradle.kts',NULL,'2026-01-20 02:11:19.000000','2026-01-20 02:11:19.000000',NULL);

INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (3,24,'LOMBOK_USAGE','@(Data|Getter|Setter|Builder|AllArgsConstructor|NoArgsConstructor|RequiredArgsConstructor|Value|With|ToString|EqualsAndHashCode)','REGEX',1,'[DOM-AGG-001] Lombok 어노테이션 사용 금지. Aggregate에서는 모든 Lombok 어노테이션을 사용할 수 없습니다.','2026-01-20 15:02:43.000000','2026-01-20 15:02:43.000000',NULL);
INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (4,25,'JPA_IN_DOMAIN','@(Entity|Table|Column|Id|GeneratedValue|ManyToOne|OneToMany|ManyToMany|JoinColumn|Embedded|Embeddable)','REGEX',1,'[DOM-AGG-002] JPA 어노테이션 사용 금지. Domain Layer는 인프라에 독립적이어야 합니다.','2026-01-20 15:02:43.000000','2026-01-20 15:02:43.000000',NULL);
INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (5,26,'SPRING_IN_DOMAIN','@(Component|Service|Repository|Controller|Autowired|Value|Configuration|Bean|Transactional)','REGEX',1,'[DOM-AGG-003] Spring 어노테이션 사용 금지. Domain Layer는 프레임워크에 독립적이어야 합니다.','2026-01-20 15:02:43.000000','2026-01-20 15:02:43.000000',NULL);
INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (6,32,'WRONG_TIME_TYPE','(LocalDateTime|LocalDate|Date|Calendar|ZonedDateTime)\\s+(created|updated|deleted|modified|registered)','REGEX',1,'[DOM-AGG-009] 시간 필드는 Instant 타입만 허용. LocalDateTime, Date 등은 사용할 수 없습니다.','2026-01-20 15:02:43.000000','2026-01-20 15:02:43.000000',NULL);
INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (7,33,'INSTANT_NOW_CALL','Instant\\.now\\(\\)','REGEX',1,'[DOM-AGG-010] Instant.now() 직접 호출 금지. 시간은 반드시 파라미터로 주입받아야 합니다.','2026-01-20 15:02:43.000000','2026-01-20 15:02:43.000000',NULL);
INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (8,35,'SETTER_METHOD','public\\s+void\\s+set[A-Z]\\w*\\s*\\(','REGEX',1,'[DOM-AGG-012] Setter 메서드 금지. 도메인 메서드를 통해 상태를 변경해야 합니다.','2026-01-20 15:02:43.000000','2026-01-20 15:02:43.000000',NULL);
INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (9,37,'GETTER_CHAINING','\\.get[A-Z]\\w*\\(\\)\\.get[A-Z]\\w*\\(\\)','REGEX',1,'[DOM-AGG-014] Getter 체이닝 감지. Law of Demeter를 위반합니다. Tell, Don\'t Ask 원칙을 따르세요.','2026-01-20 15:02:43.000000','2026-01-20 15:02:43.000000',NULL);
INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (10,46,'LAYER_DEPENDENCY','import\\s+com\\.ryuqq\\.(application|adapter|bootstrap)','REGEX',1,'[DOM-AGG-023] Domain Layer 외부 의존 금지. Application, Adapter 레이어를 참조할 수 없습니다.','2026-01-20 15:02:43.000000','2026-01-20 15:02:43.000000',NULL);
INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (11,47,'REPOSITORY_IN_AGGREGATE','(Repository|Port)\\s+\\w+','REGEX',1,'[DOM-AGG-024] Aggregate에서 Repository 참조 금지. DDD 원칙에 따라 Aggregate는 Repository를 알지 못해야 합니다.','2026-01-20 15:02:43.000000','2026-01-20 15:02:43.000000',NULL);
INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (12,51,'VO_NOT_RECORD','public\\s+class\\s+\\w+(?!.*record)','REGEX',0,'[DOM-VO-001] Value Object는 반드시 Record 타입이어야 합니다. class 대신 record를 사용하세요.','2026-01-20 15:02:43.000000','2026-01-20 15:02:43.000000',NULL);
INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (13,57,'LOMBOK_IN_VO','@(Data|Getter|Setter|Builder|Value)','REGEX',1,'[DOM-VO-007] Value Object에서 Lombok 사용 금지. Record는 기본적으로 Lombok이 불필요합니다.','2026-01-20 15:02:43.000000','2026-01-20 15:02:43.000000',NULL);
INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (14,58,'JPA_IN_VO','@(Embeddable|Embedded|Column)','REGEX',1,'[DOM-VO-008] Value Object에서 JPA 어노테이션 사용 금지. Domain은 인프라에 독립적이어야 합니다.','2026-01-20 15:02:43.000000','2026-01-20 15:02:43.000000',NULL);
INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (15,59,'SPRING_IN_VO','@(Component|Service|Value|Autowired)','REGEX',1,'[DOM-VO-009] Value Object에서 Spring 어노테이션 사용 금지.','2026-01-20 15:02:43.000000','2026-01-20 15:02:43.000000',NULL);
INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (16,61,'ID_NOT_RECORD','public\\s+class\\s+\\w+Id\\b','REGEX',1,'[DOM-ID-002] ID VO는 반드시 Record 타입이어야 합니다. public class XxxId → public record XxxId','2026-01-20 15:02:43.000000','2026-01-20 15:02:43.000000',NULL);
INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (17,68,'LOMBOK_IN_ID','@(Data|Getter|Setter|Builder|Value)','REGEX',1,'[DOM-ID-009] ID VO에서 Lombok 사용 금지. Record는 Lombok이 불필요합니다.','2026-01-20 15:02:43.000000','2026-01-20 15:02:43.000000',NULL);
INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (18,69,'JPA_SPRING_IN_ID','@(Entity|Embeddable|Column|Component|Value)','REGEX',1,'[DOM-ID-010] ID VO에서 JPA/Spring 어노테이션 사용 금지.','2026-01-20 15:02:43.000000','2026-01-20 15:02:43.000000',NULL);
INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (19,81,'WRONG_EXCEPTION_PARENT','extends\\s+(RuntimeException|Exception|Throwable)(?!.*DomainException)','REGEX',1,'[DOM-EXC-001] 도메인 예외는 반드시 DomainException을 상속해야 합니다.','2026-01-20 15:02:43.000000','2026-01-20 15:02:43.000000',NULL);
INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (20,84,'LOMBOK_IN_EXCEPTION','@(Data|Getter|Setter|Builder)','REGEX',1,'[DOM-EXC-004] Exception에서 Lombok 사용 금지.','2026-01-20 15:02:43.000000','2026-01-20 15:02:43.000000',NULL);
INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (21,91,'THROW_RUNTIME_EXCEPTION','throw\\s+new\\s+(RuntimeException|Exception|IllegalArgumentException|IllegalStateException)\\s*\\(','REGEX',1,'[DOM-EXC-011] 일반 예외 직접 throw 금지. 반드시 도메인 예외를 사용하세요.','2026-01-20 15:02:43.000000','2026-01-20 15:02:43.000000',NULL);
INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (22,70,'EVENT_NOT_RECORD','public\\s+class\\s+\\w+Event\\b(?!.*record)','REGEX',1,'[DOM-EVT-001] 도메인 이벤트는 반드시 Record 타입이어야 합니다.','2026-01-20 15:02:44.000000','2026-01-20 15:02:44.000000',NULL);
INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (23,79,'LOMBOK_IN_EVENT','@(Data|Getter|Setter|Builder|Value)','REGEX',1,'[DOM-EVT-010] Event에서 Lombok 사용 금지. Record를 사용하세요.','2026-01-20 15:02:44.000000','2026-01-20 15:02:44.000000',NULL);
INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (24,80,'JPA_SPRING_IN_EVENT','@(Entity|Component|Service|EventListener)','REGEX',1,'[DOM-EVT-011] Event에서 JPA/Spring 어노테이션 사용 금지.','2026-01-20 15:02:44.000000','2026-01-20 15:02:44.000000',NULL);
INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (25,101,'CRITERIA_NOT_RECORD','public\\s+class\\s+\\w+Criteria\\b','REGEX',1,'[DOM-CRI-001] Criteria는 반드시 Record 타입이어야 합니다.','2026-01-20 15:02:44.000000','2026-01-20 15:02:44.000000',NULL);
INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (26,109,'LOMBOK_IN_CRITERIA','@(Data|Getter|Setter|Builder)','REGEX',1,'[DOM-CRI-009] Criteria에서 Lombok 사용 금지.','2026-01-20 15:02:44.000000','2026-01-20 15:02:44.000000',NULL);
INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (27,110,'JPA_SPRING_IN_CRITERIA','@(Entity|Component|Service)','REGEX',1,'[DOM-CRI-010] Criteria에서 JPA/Spring 어노테이션 사용 금지.','2026-01-20 15:02:44.000000','2026-01-20 15:02:44.000000',NULL);
INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (28,115,'SERVICE_TRANSACTIONAL','classs+w+Service.*@Transactional','REGEX',1,'Service 클래스에 @Transactional을 사용할 수 없습니다. Manager에서만 사용하세요.','2026-01-24 08:28:08.000000','2026-01-24 08:28:08.000000',NULL);
INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (29,116,'MANAGER_NO_TRANSACTIONAL','classs+w+Manager(?!.*@Transactional)','REGEX',1,'Manager 클래스에는 @Transactional이 필수입니다.','2026-01-24 08:28:08.000000','2026-01-24 08:28:08.000000',NULL);
INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (30,117,'CLIENT_MANAGER_TRANSACTIONAL','classs+w+ClientManager.*@Transactional','REGEX',1,'ClientManager에 @Transactional을 사용할 수 없습니다. 외부 API 호출 클래스입니다.','2026-01-24 08:28:08.000000','2026-01-24 08:28:08.000000',NULL);
INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (31,122,'CQRS_VIOLATION','CommandFacade.*QueryManager|CommandFacade.*ReadManager','REGEX',1,'CommandFacade에서 QueryManager/ReadManager를 의존할 수 없습니다. CQRS 위반입니다.','2026-01-24 08:28:08.000000','2026-01-24 08:28:08.000000',NULL);
INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (32,125,'DTO_NOT_RECORD','classs+(w+Command|w+Query)s','REGEX',1,'Command/Query DTO는 반드시 record 타입이어야 합니다.','2026-01-24 08:28:08.000000','2026-01-24 08:28:08.000000',NULL);
INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (33,126,'DTO_INSTANCE_METHOD','records+w+(Command|Query).*{[^}]*(?:public|private)s+w+s+w+(','REGEX',1,'Command/Query record에 인스턴스 메서드를 정의할 수 없습니다.','2026-01-24 08:28:08.000000','2026-01-24 08:28:08.000000',NULL);
INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (34,131,'QUERY_PORT_FIND_ALL','interfaces+w+QueryPort.*findAll()','REGEX',1,'QueryPort에 findAll() 메서드를 정의할 수 없습니다. OOM 위험이 있습니다.','2026-01-24 08:28:08.000000','2026-01-24 08:28:08.000000',NULL);
INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (35,133,'DIRECT_EVENT_PUBLISHER','ApplicationEventPublishers+w+','REGEX',1,'ApplicationEventPublisher를 직접 주입할 수 없습니다. TransactionEventRegistry를 사용하세요.','2026-01-24 08:28:08.000000','2026-01-24 08:28:08.000000',NULL);
INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (36,134,'NO_EVENT_REGISTRY','publishEvent((?!.*TransactionEventRegistry)','REGEX',1,'이벤트 발행 시 TransactionEventRegistry를 사용해야 합니다.','2026-01-24 08:28:08.000000','2026-01-24 08:28:08.000000',NULL);
INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (37,135,'TIME_PROVIDER_OUTSIDE_FACTORY','(?<!Factory.*)TimeProvider','REGEX',1,'TimeProvider는 Factory 클래스에서만 사용할 수 있습니다.','2026-01-24 08:28:08.000000','2026-01-24 08:28:08.000000',NULL);
INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (38,147,'JPA_REPO_INVALID_METHOD','JpaRepository.*(?:find|delete|exists|count)','REGEX',1,'JpaRepository에서는 save/saveAll만 사용할 수 있습니다. 조회는 QueryDslRepository를 사용하세요.','2026-01-24 08:28:36.000000','2026-01-24 08:28:36.000000',NULL);
INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (39,148,'JPA_REPO_CUSTOM_METHOD','interfaces+w+JpaRepository.*{[^}]*(?:find|delete|exists|count)w+(','REGEX',1,'JpaRepository에 커스텀 메서드를 정의할 수 없습니다.','2026-01-24 08:28:36.000000','2026-01-24 08:28:36.000000',NULL);
INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (40,149,'JPA_REPO_QUERY','JpaRepository.*@Query','REGEX',1,'JpaRepository에 @Query를 사용할 수 없습니다. QueryDslRepository를 사용하세요.','2026-01-24 08:28:36.000000','2026-01-24 08:28:36.000000',NULL);
INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (41,150,'COMMAND_ADAPTER_WRONG_DEP','CommandAdapter.*QueryDslRepository','REGEX',1,'CommandAdapter는 JpaRepository만 의존해야 합니다. QueryDslRepository 사용 금지.','2026-01-24 08:28:36.000000','2026-01-24 08:28:36.000000',NULL);
INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (42,151,'QUERY_ADAPTER_WRONG_DEP','QueryAdapter.*JpaRepository','REGEX',1,'QueryAdapter는 QueryDslRepository만 의존해야 합니다. JpaRepository 사용 금지.','2026-01-24 08:28:36.000000','2026-01-24 08:28:36.000000',NULL);
INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (43,152,'JPA_RELATION_ANNOTATION','@(OneToOne|OneToMany|ManyToOne|ManyToMany|JoinColumn|JoinTable)','REGEX',1,'JPA 관계 어노테이션을 사용할 수 없습니다. Long FK 전략을 사용하세요.','2026-01-24 08:28:36.000000','2026-01-24 08:28:36.000000',NULL);
INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (44,154,'OSIV_ENABLED','open-in-view:s*true','REGEX',1,'OSIV는 반드시 비활성화해야 합니다. open-in-view: false로 설정하세요.','2026-01-24 08:28:36.000000','2026-01-24 08:28:36.000000',NULL);
INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (45,155,'DDL_AUTO_NOT_VALIDATE','ddl-auto:s*(?!validate)(create|update|create-drop|none)','REGEX',1,'ddl-auto는 validate만 허용됩니다.','2026-01-24 08:28:36.000000','2026-01-24 08:28:36.000000',NULL);
INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (46,157,'NO_DELETED_AT_CONDITION','from(Qw+.w+)(?!.*deletedAt)','REGEX',1,'QueryDSL 조회 시 deletedAt IS NULL 조건이 필수입니다.','2026-01-24 08:28:36.000000','2026-01-24 08:28:36.000000',NULL);
INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (47,160,'ADMIN_QUERY_WRONG_MODULE','persistence-mysql/.*admin.*Query','REGEX',1,'Admin용 복잡 쿼리는 persistence-mysql-admin 모듈에 작성해야 합니다.','2026-01-24 08:28:36.000000','2026-01-24 08:28:36.000000',NULL);
INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (48,166,'DELETE_METHOD','@DeleteMapping|@RequestMapping.*DELETE|methods*=s*RequestMethod.DELETE','REGEX',1,'DELETE 메서드를 사용할 수 없습니다. PATCH로 soft delete를 구현하세요.','2026-01-24 08:28:57.000000','2026-01-24 08:28:57.000000',NULL);
INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (49,169,'CONTROLLER_TRANSACTIONAL','@RestController[sS]*@Transactional|@Controller[sS]*@Transactional','REGEX',1,'Controller에 @Transactional을 사용할 수 없습니다. 트랜잭션은 Service/Manager 레이어에서 처리하세요.','2026-01-24 08:28:57.000000','2026-01-24 08:28:57.000000',NULL);
INSERT INTO `zero_tolerance_rule` (`id`, `rule_id`, `type`, `detection_pattern`, `detection_type`, `auto_reject_pr`, `error_message`, `created_at`, `updated_at`, `deleted_at`) VALUES (50,175,'LIST_DIRECT_RETURN','ResponseEntity<List<|List<w+>s+w+(','REGEX',1,'List를 직접 반환할 수 없습니다. SliceResult 또는 PageResult로 래핑하세요.','2026-01-24 08:28:57.000000','2026-01-24 08:28:57.000000',NULL);
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

